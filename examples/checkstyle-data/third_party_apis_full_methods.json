{
  "fullMethodsPaths" : [ {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.xpath.AbstractNode.iterateAxis",
    "thirdPartyMethod" : "net.sf.saxon.tree.util.Navigator.AxisFilter.<init>",
    "thirdPartyPackage" : "net.sf.saxon.tree.util.Navigator",
    "path" : [ "com.puppycrawl.tools.checkstyle.xpath.AbstractNode.iterateAxis" ],
    "fullMethods" : [ "/**\n * Determines axis iteration algorithm.\n *\n * @param axisNumber\n * \t\telement from {@code AxisInfo}\n * @param nodeTest\n * \t\tfilter for iterator\n * @return {@code AxisIterator} object\n */\n@Override\npublic AxisIterator iterateAxis(int axisNumber, NodePredicate nodeTest) {\n    AxisIterator axisIterator = iterateAxis(axisNumber);\n    if (nodeTest != null) {\n        axisIterator = new Navigator.AxisFilter(axisIterator, nodeTest);\n    }\n    return axisIterator;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.xpath.AbstractRootNode.iterateAxis",
    "thirdPartyMethod" : "net.sf.saxon.tree.iter.ArrayIterator.OfNodes.<init>",
    "thirdPartyPackage" : "net.sf.saxon.tree.iter.ArrayIterator",
    "path" : [ "com.puppycrawl.tools.checkstyle.xpath.AbstractRootNode.iterateAxis" ],
    "fullMethods" : [ "/**\n * Determines axis iteration algorithm. Throws {@code UnsupportedOperationException} in case,\n * when there is no axis iterator for given axisNumber.\n *\n * @param axisNumber\n * \t\telement from {@code AxisInfo}\n * @return {@code AxisIterator} object\n */\n@Override\npublic AxisIterator iterateAxis(int axisNumber) {\n    return switch (axisNumber) {\n        case AxisInfo.ANCESTOR, AxisInfo.PARENT, AxisInfo.FOLLOWING, AxisInfo.FOLLOWING_SIBLING, AxisInfo.PRECEDING, AxisInfo.PRECEDING_SIBLING ->\n            EmptyIterator.ofNodes();\n        case AxisInfo.ANCESTOR_OR_SELF, AxisInfo.SELF ->\n            SingleNodeIterator.makeIterator(this);\n        case AxisInfo.CHILD ->\n            {\n                if (hasChildNodes()) {\n                    yield new ArrayIterator.OfNodes<>(getChildren().toArray(EMPTY_ABSTRACT_NODE_ARRAY));\n                }\n                yield EmptyIterator.ofNodes();\n            }\n        case AxisInfo.DESCENDANT ->\n            {\n                if (hasChildNodes()) {\n                    yield new DescendantIterator(this, DescendantIterator.StartWith.CHILDREN);\n                }\n                yield EmptyIterator.ofNodes();\n            }\n        case AxisInfo.DESCENDANT_OR_SELF ->\n            new DescendantIterator(this, DescendantIterator.StartWith.CURRENT_NODE);\n        default ->\n            throw throwUnsupportedOperationException();\n    };\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.xpath.AbstractElementNode.iterateAxis",
    "thirdPartyMethod" : "net.sf.saxon.tree.iter.ArrayIterator.OfNodes.<init>",
    "thirdPartyPackage" : "net.sf.saxon.tree.iter.ArrayIterator",
    "path" : [ "com.puppycrawl.tools.checkstyle.xpath.AbstractElementNode.iterateAxis" ],
    "fullMethods" : [ "/**\n * Determines axis iteration algorithm. Throws {@code UnsupportedOperationException} in case,\n * when there is no axis iterator for given axisNumber.\n *\n * <p>Reason of suppression for resource, IOResourceOpenedButNotSafelyClosed:\n * {@link AxisIterator} implements {@link java.io.Closeable} interface,\n * but none of the subclasses of the {@link AxisIterator}\n * class has non-empty {@code close()} method.\n *\n * @param axisNumber\n * \t\telement from {@code AxisInfo}\n * @return {@code AxisIterator} object\n */\n@Override\npublic AxisIterator iterateAxis(int axisNumber) {\n    return switch (axisNumber) {\n        case AxisInfo.ANCESTOR ->\n            new Navigator.AncestorEnumeration(this, false);\n        case AxisInfo.ANCESTOR_OR_SELF ->\n            new Navigator.AncestorEnumeration(this, true);\n        case AxisInfo.ATTRIBUTE ->\n            SingleNodeIterator.makeIterator(getAttributeNode());\n        case AxisInfo.CHILD ->\n            {\n                if (hasChildNodes()) {\n                    yield new ArrayIterator.OfNodes<>(getChildren().toArray(EMPTY_ABSTRACT_NODE_ARRAY));\n                }\n                yield EmptyIterator.ofNodes();\n            }\n        case AxisInfo.DESCENDANT ->\n            {\n                if (hasChildNodes()) {\n                    yield new DescendantIterator(this, DescendantIterator.StartWith.CHILDREN);\n                }\n                yield EmptyIterator.ofNodes();\n            }\n        case AxisInfo.DESCENDANT_OR_SELF ->\n            new DescendantIterator(this, DescendantIterator.StartWith.CURRENT_NODE);\n        case AxisInfo.PARENT ->\n            SingleNodeIterator.makeIterator(parent);\n        case AxisInfo.SELF ->\n            SingleNodeIterator.makeIterator(this);\n        case AxisInfo.FOLLOWING_SIBLING ->\n            getFollowingSiblingsIterator();\n        case AxisInfo.PRECEDING_SIBLING ->\n            getPrecedingSiblingsIterator();\n        case AxisInfo.FOLLOWING ->\n            new FollowingIterator(this);\n        case AxisInfo.PRECEDING ->\n            new PrecedingIterator(this);\n        default ->\n            throw throwUnsupportedOperationException();\n    };\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.xpath.AbstractElementNode.iterateAxis",
    "thirdPartyMethod" : "net.sf.saxon.tree.util.Navigator.AncestorEnumeration.<init>",
    "thirdPartyPackage" : "net.sf.saxon.tree.util.Navigator",
    "path" : [ "com.puppycrawl.tools.checkstyle.xpath.AbstractElementNode.iterateAxis" ],
    "fullMethods" : [ "/**\n * Determines axis iteration algorithm. Throws {@code UnsupportedOperationException} in case,\n * when there is no axis iterator for given axisNumber.\n *\n * <p>Reason of suppression for resource, IOResourceOpenedButNotSafelyClosed:\n * {@link AxisIterator} implements {@link java.io.Closeable} interface,\n * but none of the subclasses of the {@link AxisIterator}\n * class has non-empty {@code close()} method.\n *\n * @param axisNumber\n * \t\telement from {@code AxisInfo}\n * @return {@code AxisIterator} object\n */\n@Override\npublic AxisIterator iterateAxis(int axisNumber) {\n    return switch (axisNumber) {\n        case AxisInfo.ANCESTOR ->\n            new Navigator.AncestorEnumeration(this, false);\n        case AxisInfo.ANCESTOR_OR_SELF ->\n            new Navigator.AncestorEnumeration(this, true);\n        case AxisInfo.ATTRIBUTE ->\n            SingleNodeIterator.makeIterator(getAttributeNode());\n        case AxisInfo.CHILD ->\n            {\n                if (hasChildNodes()) {\n                    yield new ArrayIterator.OfNodes<>(getChildren().toArray(EMPTY_ABSTRACT_NODE_ARRAY));\n                }\n                yield EmptyIterator.ofNodes();\n            }\n        case AxisInfo.DESCENDANT ->\n            {\n                if (hasChildNodes()) {\n                    yield new DescendantIterator(this, DescendantIterator.StartWith.CHILDREN);\n                }\n                yield EmptyIterator.ofNodes();\n            }\n        case AxisInfo.DESCENDANT_OR_SELF ->\n            new DescendantIterator(this, DescendantIterator.StartWith.CURRENT_NODE);\n        case AxisInfo.PARENT ->\n            SingleNodeIterator.makeIterator(parent);\n        case AxisInfo.SELF ->\n            SingleNodeIterator.makeIterator(this);\n        case AxisInfo.FOLLOWING_SIBLING ->\n            getFollowingSiblingsIterator();\n        case AxisInfo.PRECEDING_SIBLING ->\n            getPrecedingSiblingsIterator();\n        case AxisInfo.FOLLOWING ->\n            new FollowingIterator(this);\n        case AxisInfo.PRECEDING ->\n            new PrecedingIterator(this);\n        default ->\n            throw throwUnsupportedOperationException();\n    };\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.Main.main",
    "thirdPartyMethod" : "picocli.CommandLine.ParseResult.hasMatchedOption",
    "thirdPartyPackage" : "picocli.CommandLine",
    "path" : [ "com.puppycrawl.tools.checkstyle.Main.main", "com.puppycrawl.tools.checkstyle.Main.execute", "com.puppycrawl.tools.checkstyle.Main.CliOptions.validateCli" ],
    "fullMethods" : [ "/**\n * Loops over the files specified checking them for errors. The exit code\n * is the number of errors found in all the files.\n *\n * @param args\n * \t\tthe command line arguments.\n * @throws IOException\n * \t\tif there is a problem with files access\n * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace, CallToSystemExit\n * @noinspectionreason UseOfSystemOutOrSystemErr - driver class for Checkstyle requires\nusage of System.out and System.err\n * @noinspectionreason CallToPrintStackTrace - driver class for Checkstyle must be able to\nshow all details in case of failure\n * @noinspectionreason CallToSystemExit - driver class must call exit\n */\npublic static void main(String... args) throws IOException {\n    final CliOptions cliOptions = new CliOptions();\n    final CommandLine commandLine = new CommandLine(cliOptions);\n    commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n    commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n    // provide proper exit code based on results.\n    int exitStatus = 0;\n    int errorCounter = 0;\n    try {\n        final ParseResult parseResult = commandLine.parseArgs(args);\n        if (parseResult.isVersionHelpRequested()) {\n            printVersionToSystemOutput();\n        } else if (parseResult.isUsageHelpRequested()) {\n            commandLine.usage(System.out);\n        } else {\n            exitStatus = execute(parseResult, cliOptions);\n            errorCounter = exitStatus;\n        }\n    } catch (ParameterException exc) {\n        exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n        System.err.println(exc.getMessage());\n        System.err.println(\"Usage: checkstyle [OPTIONS]... file(s) or folder(s) ...\");\n        System.err.println(\"Try 'checkstyle --help' for more information.\");\n    } catch (CheckstyleException exc) {\n        exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n        errorCounter = 1;\n        exc.printStackTrace();\n    } finally {\n        // return exit code base on validation of Checker\n        if (errorCounter > 0) {\n            final LocalizedMessage errorCounterViolation = new LocalizedMessage(Definitions.CHECKSTYLE_BUNDLE, Main.class, ERROR_COUNTER, String.valueOf(errorCounter));\n            // print error count statistic to error output stream,\n            // output stream might be used by validation report content\n            System.err.println(errorCounterViolation.getMessage());\n        }\n    }\n    Runtime.getRuntime().exit(exitStatus);\n}", "/**\n * Validates the user input and returns {@value #EXIT_WITH_INVALID_USER_INPUT_CODE} if\n * invalid, otherwise executes CheckStyle and returns the number of violations.\n *\n * @param parseResult\n * \t\tgeneric access to options and parameters found on the command line\n * @param options\n * \t\tencapsulates options and parameters specified on the command line\n * @return number of violations\n * @throws IOException\n * \t\tif a file could not be read.\n * @throws CheckstyleException\n * \t\tif something happens processing the files.\n * @noinspection UseOfSystemOutOrSystemErr\n * @noinspectionreason UseOfSystemOutOrSystemErr - driver class for Checkstyle requires\nusage of System.out and System.err\n */\nprivate static int execute(ParseResult parseResult, CliOptions options) throws IOException, CheckstyleException {\n    final int exitStatus;\n    // return error if something is wrong in arguments\n    final List<File> filesToProcess = getFilesToProcess(options);\n    final List<String> messages = options.validateCli(parseResult, filesToProcess);\n    final boolean hasMessages = !messages.isEmpty();\n    if (hasMessages) {\n        messages.forEach(System.out::println);\n        exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n    } else {\n        exitStatus = runCli(options, filesToProcess);\n    }\n    return exitStatus;\n}", "/**\n * Validates the user-specified command line options.\n *\n * @param parseResult\n * \t\tused to verify if the format option was specified on the command line\n * @param filesToProcess\n * \t\tthe list of files whose style to check\n * @return list of violations\n */\n// -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation\nprivate List<String> validateCli(ParseResult parseResult, List<File> filesToProcess) {\n    final List<String> result = new ArrayList<>();\n    final boolean hasConfigurationFile = configurationFile != null;\n    final boolean hasSuppressionLineColumnNumber = suppressionLineColumnNumber != null;\n    if (filesToProcess.isEmpty()) {\n        result.add(\"Files to process must be specified, found 0.\");\n    } else if ((((printAst || printAstWithComments) || printJavadocTree) || printTreeWithJavadoc) || (xpath != null)) {\n        if (((((suppressionLineColumnNumber != null) || (configurationFile != null)) || (propertiesFile != null)) || (outputPath != null)) || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n            result.add(\"Option '-t' cannot be used with other options.\");\n        } else if (filesToProcess.size() > 1) {\n            result.add(\"Printing AST is allowed for only one file.\");\n        }\n    } else if (hasSuppressionLineColumnNumber) {\n        if ((((configurationFile != null) || (propertiesFile != null)) || (outputPath != null)) || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n            result.add(\"Option '-s' cannot be used with other options.\");\n        } else if (filesToProcess.size() > 1) {\n            result.add(\"Printing xpath suppressions is allowed for only one file.\");\n        }\n    } else if (hasConfigurationFile) {\n        try {\n            // test location only\n            CommonUtil.getUriByFilename(configurationFile);\n        } catch (CheckstyleException ignored) {\n            final String msg = \"Could not find config XML file '%s'.\";\n            result.add(String.format(Locale.ROOT, msg, configurationFile));\n        }\n        result.addAll(validateOptionalCliParametersIfConfigDefined());\n    } else {\n        result.add(\"Must specify a config XML file.\");\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForControlContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForControlContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(ForControlContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyDeclarationContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyDeclarationContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(ClassBodyDeclarationContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsOrDiamondContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsOrDiamondContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(TypeArgumentsOrDiamondContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(CreatedNameContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImportDeclarationContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImportDeclarationContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(ImportDeclarationContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsOrDiamondContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsOrDiamondContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(NonWildcardTypeArgumentsOrDiamondContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(SwitchBlockContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LambdaParametersContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LambdaParametersContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(LambdaParametersContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(SuperSuffixContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabelContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabelContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(SwitchLabelContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(PrimaryContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryPatternContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryPatternContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(PrimaryPatternContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExprContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExprContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(ExprContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExplicitConstructorInvocationContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExplicitConstructorInvocationContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(ExplicitConstructorInvocationContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.StatementContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.StatementContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(StatementContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypePatternContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypePatternContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(TypePatternContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockStatementContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockStatementContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(BlockStatementContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementRestContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementRestContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(AnnotationTypeElementRestContext ctx) {\n    super.copyFrom(ctx);\n    this.mods = ctx.mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentContext.copyFrom",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.copyFrom",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentContext.copyFrom" ],
    "fullMethods" : [ "public void copyFrom(TypeArgumentContext ctx) {\n    super.copyFrom(ctx);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.syntaxError",
    "thirdPartyMethod" : "org.antlr.v4.runtime.RecognitionException.getCtx",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.syntaxError" ],
    "fullMethods" : [ "/**\n * Logs parser errors in Checkstyle manner. Parser can generate error\n * messages. There is special error that parser can generate. It is\n * missed close HTML tag. This case is special because parser prints\n * error like {@code \"no viable alternative at input 'b \\n *\\n'\"} and it\n * is not clear that error is about missed close HTML tag. Other error\n * messages are not special and logged simply as \"Parse Error...\".\n *\n * <p>{@inheritDoc }\n */\n@Override\npublic void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException ex) {\n    final int lineNumber = offset + line;\n    final String target;\n    if (recognizer instanceof JavadocCommentsLexer lexer) {\n        target = lexer.getPreviousToken().getText();\n    } else {\n        final int ruleIndex = ex.getCtx().getRuleIndex();\n        final String ruleName = recognizer.getRuleNames()[ruleIndex];\n        target = convertUpperCamelToUpperUnderscore(ruleName);\n    }\n    errorMessage = new ParseErrorMessage(lineNumber, MSG_JAVADOC_PARSE_RULE_ERROR, charPositionInLine, msg, target);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.voidElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.FailedPredicateException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.voidElement" ],
    "fullMethods" : [ "public final VoidElementContext voidElement() throws RecognitionException {\n    VoidElementContext _localctx = new VoidElementContext(_ctx, getState());\n    enterRule(_localctx, 88, RULE_voidElement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(420);\n            if (!isVoidTag())\n                throw new FailedPredicateException(this, \" isVoidTag() \");\n\n            setState(421);\n            htmlTagStart();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.FailedPredicateException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final FieldAccessNoIdentContext fieldAccessNoIdent() throws RecognitionException {\n    FieldAccessNoIdentContext _localctx = new FieldAccessNoIdentContext(_ctx, getState());\n    enterRule(_localctx, 194, RULE_fieldAccessNoIdent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1225);\n            expr(0);\n            setState(1226);\n            match(DOT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.FailedPredicateException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExpressionContext expression() throws RecognitionException {\n    ExpressionContext _localctx = new ExpressionContext(_ctx, getState());\n    enterRule(_localctx, 216, RULE_expression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1315);\n            expr(0);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.tightElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.FailedPredicateException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.tightElement" ],
    "fullMethods" : [ "public final TightElementContext tightElement() throws RecognitionException {\n    TightElementContext _localctx = new TightElementContext(_ctx, getState());\n    enterRule(_localctx, 90, RULE_tightElement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(423);\n            if (!(!JavadocCommentsParserUtil.isNonTightTag(_input, unclosedTagNameTokens)))\n                throw new FailedPredicateException(this, \" !JavadocCommentsParserUtil.isNonTightTag(_input, unclosedTagNameTokens) \");\n\n            setState(424);\n            htmlTagStart();\n            setState(426);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 57, _ctx)) {\n                case 1 :\n                    {\n                        setState(425);\n                        htmlContent();\n                    }\n                    break;\n            }\n            setState(428);\n            htmlTagEnd();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.FailedPredicateException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement" ],
    "fullMethods" : [ "public final BlockStatementContext blockStatement() throws RecognitionException {\n    BlockStatementContext _localctx = new BlockStatementContext(_ctx, getState());\n    enterRule(_localctx, 154, RULE_blockStatement);\n    try {\n        setState(991);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 109, _ctx)) {\n            case 1 :\n                _localctx = new LocalVarContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(985);\n                    if (!(!isYieldStatement()))\n                        throw new FailedPredicateException(this, \"!isYieldStatement()\");\n\n                    setState(986);\n                    localVariableDeclaration();\n                    setState(987);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new StatContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(989);\n                    statement();\n                }\n                break;\n            case 3 :\n                _localctx = new LocalTypeContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(990);\n                    localTypeDeclaration();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.FailedPredicateException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final PrimaryContext primary() throws RecognitionException {\n    PrimaryContext _localctx = new PrimaryContext(_ctx, getState());\n    enterRule(_localctx, 226, RULE_primary);\n    int _la;\n    try {\n        setState(1533);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 176, _ctx)) {\n            case 1 :\n                _localctx = new SwitchPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1504);\n                    switchExpressionOrStatement();\n                }\n                break;\n            case 2 :\n                _localctx = new ParenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1505);\n                    match(LPAREN);\n                    setState(1506);\n                    expr(0);\n                    setState(1507);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1509);\n                    match(LITERAL_THIS);\n                }\n                break;\n            case 4 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(1510);\n                    match(LITERAL_SUPER);\n                }\n                break;\n            case 5 :\n                _localctx = new LiteralPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(1511);\n                    literal();\n                }\n                break;\n            case 6 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(1512);\n                    id();\n                }\n                break;\n            case 7 :\n                _localctx = new ClassRefPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(1513);\n                    ((ClassRefPrimaryContext) (_localctx)).type = classOrInterfaceType(false);\n                    setState(1517);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1514);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1519);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1520);\n                    match(DOT);\n                    setState(1521);\n                    match(LITERAL_CLASS);\n                }\n                break;\n            case 8 :\n                _localctx = new PrimitivePrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(1523);\n                    ((PrimitivePrimaryContext) (_localctx)).type = primitiveType();\n                    setState(1527);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1524);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1529);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1530);\n                    match(DOT);\n                    setState(1531);\n                    match(LITERAL_CLASS);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr",
    "thirdPartyMethod" : "org.antlr.v4.runtime.FailedPredicateException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExprContext expr() throws RecognitionException {\n    return expr(0);\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation",
    "thirdPartyMethod" : "org.antlr.v4.runtime.FailedPredicateException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExplicitConstructorInvocationContext explicitConstructorInvocation() throws RecognitionException {\n    ExplicitConstructorInvocationContext _localctx = new ExplicitConstructorInvocationContext(_ctx, getState());\n    enterRule(_localctx, 150, RULE_explicitConstructorInvocation);\n    int _la;\n    try {\n        setState(974);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 107, _ctx)) {\n            case 1 :\n                _localctx = new ExplicitCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(959);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(958);\n                            typeArguments();\n                        }\n                    }\n                    setState(961);\n                    _la = _input.LA(1);\n                    if (!((_la == LITERAL_THIS) || (_la == LITERAL_SUPER))) {\n                        _errHandler.recoverInline(this);\n                    } else {\n                        if (_input.LA(1) == Token.EOF)\n                            matchedEOF = true;\n\n                        _errHandler.reportMatch(this);\n                        consume();\n                    }\n                    setState(962);\n                    arguments();\n                    setState(963);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new PrimaryCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(965);\n                    expr(0);\n                    setState(966);\n                    match(DOT);\n                    setState(968);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(967);\n                            typeArguments();\n                        }\n                    }\n                    setState(970);\n                    match(LITERAL_SUPER);\n                    setState(971);\n                    arguments();\n                    setState(972);\n                    match(SEMI);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.LexerATNSimulator.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>" ],
    "fullMethods" : [ "public JavadocCommentsLexer(CharStream input) {\n    super(input);\n    _interp = new LexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.LexerATNSimulator.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>" ],
    "fullMethods" : [ "public JavaLanguageLexer(CharStream input) {\n    super(input);\n    _interp = new LexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.CrAwareLexerSimulator.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.LexerATNSimulator.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.CrAwareLexerSimulator.<init>" ],
    "fullMethods" : [ "/**\n * Constructs a CrAwareLexerSimulator to interpret the input\n * from the lexer.\n *\n * @param lexer\n * \t\tthe current lexer\n * @param augmented\n * \t\tthe augmented transition network\n * @param decisionToDfa\n * \t\tthe DFA to store our states in\n * @param sharedContextCache\n * \t\tcache of PredictionContext objects\n */\npublic CrAwareLexerSimulator(Lexer lexer, ATN augmented, DFA[] decisionToDfa, PredictionContextCache sharedContextCache) {\n    super(lexer, augmented, decisionToDfa, sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavaParser.parse",
    "thirdPartyMethod" : "org.antlr.v4.runtime.BaseErrorListener.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavaParser.parse", "com.puppycrawl.tools.checkstyle.JavaParser.CheckstyleErrorListener.<init>" ],
    "fullMethods" : [ "/**\n * Static helper method to parses a Java source file.\n *\n * @param contents\n * \t\tcontains the contents of the file\n * @return the root of the AST\n * @throws CheckstyleException\n * \t\tif the contents is not a valid Java source\n */\npublic static DetailAST parse(FileContents contents) throws CheckstyleException {\n    final String fullText = contents.getText().getFullText().toString();\n    final CharStream codePointCharStream = CharStreams.fromString(fullText);\n    final JavaLanguageLexer lexer = new JavaLanguageLexer(codePointCharStream, true);\n    lexer.setCommentListener(contents);\n    final CommonTokenStream tokenStream = new CommonTokenStream(lexer);\n    final JavaLanguageParser parser = new JavaLanguageParser(tokenStream, JavaLanguageParser.CLEAR_DFA_LIMIT);\n    parser.setErrorHandler(new CheckstyleParserErrorStrategy());\n    parser.removeErrorListeners();\n    parser.addErrorListener(new CheckstyleErrorListener());\n    final JavaLanguageParser.CompilationUnitContext compilationUnit;\n    try {\n        compilationUnit = parser.compilationUnit();\n    } catch (IllegalStateException exc) {\n        final String exceptionMsg = String.format(Locale.ROOT, \"%s occurred while parsing file %s.\", exc.getClass().getSimpleName(), contents.getFileName());\n        throw new CheckstyleException(exceptionMsg, exc);\n    }\n    return new JavaAstVisitor(tokenStream).visit(compilationUnit);\n}", "CheckstyleErrorListener() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.parseJavadocComment",
    "thirdPartyMethod" : "org.antlr.v4.runtime.BaseErrorListener.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.parseJavadocComment", "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.<init>" ],
    "fullMethods" : [ "/**\n * Parses the given Javadoc comment AST into a {@link ParseStatus} object.\n *\n * <p>\n * This method extracts the raw Javadoc comment text from the supplied\n * {@link DetailAST}, creates a new lexer and parser for the Javadoc grammar,\n * and attempts to parse it into an AST of {@link DetailNode}s.\n * The parser uses {@link PredictionMode#SLL} for\n * faster performance and stops parsing on the first error encountered by\n * using {@link CheckstyleParserErrorStrategy}.\n * </p>\n *\n * @param javadocCommentAst\n * \t\tthe {@link DetailAST} node representing the Javadoc comment in the\n * \t\tsource file\n * @return a {@link ParseStatus} containing the root of the parsed Javadoc\ntree (if successful), the first non-tight HTML tag (if any), and\nthe error message (if parsing failed)\n */\npublic ParseStatus parseJavadocComment(DetailAST javadocCommentAst) {\n    final int blockCommentLineNumber = javadocCommentAst.getLineNo();\n    final String javadocComment = JavadocUtil.getJavadocCommentContent(javadocCommentAst);\n    final ParseStatus result = new ParseStatus();\n    // Use a new error listener each time to be able to use\n    // one check instance for multiple files to be checked\n    // without getting side effects.\n    final DescriptiveErrorListener errorListener = new DescriptiveErrorListener();\n    // Log messages should have line number in scope of file,\n    // not in scope of Javadoc comment.\n    // Offset is line number of beginning of Javadoc comment.\n    errorListener.setOffset(javadocCommentAst.getLineNo() - 1);\n    final JavadocCommentsLexer lexer = new JavadocCommentsLexer(CharStreams.fromString(javadocComment), true);\n    lexer.removeErrorListeners();\n    lexer.addErrorListener(errorListener);\n    final CommonTokenStream tokens = new CommonTokenStream(lexer);\n    tokens.fill();\n    final Set<SimpleToken> unclosedTags = lexer.getUnclosedTagNameTokens();\n    final JavadocCommentsParser parser = new JavadocCommentsParser(tokens, unclosedTags);\n    // set prediction mode to SLL to speed up parsing\n    parser.getInterpreter().setPredictionMode(PredictionMode.SLL);\n    // remove default error listeners\n    parser.removeErrorListeners();\n    parser.addErrorListener(errorListener);\n    // JavadocParserErrorStrategy stops parsing on first parse error encountered unlike the\n    // DefaultErrorStrategy used by ANTLR which rather attempts error recovery.\n    parser.setErrorHandler(new CheckstyleParserErrorStrategy());\n    try {\n        final JavadocCommentsParser.JavadocContext javadoc = parser.javadoc();\n        final int javadocColumnNumber = javadocCommentAst.getColumnNo() + JAVADOC_START.length();\n        final JavadocCommentsAstVisitor visitor = new JavadocCommentsAstVisitor(tokens, blockCommentLineNumber, javadocColumnNumber);\n        final DetailNode tree = visitor.visit(javadoc);\n        result.setTree(tree);\n        result.firstNonTightHtmlTag = visitor.getFirstNonTightHtmlTag();\n        result.setParseErrorMessage(errorListener.getErrorMessage());\n    } catch (ParseCancellationException | IllegalArgumentException exc) {\n        result.setParseErrorMessage(errorListener.getErrorMessage());\n    }\n    return result;\n}", "DescriptiveErrorListener() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.ant.CheckstyleAntTask.createClasspath",
    "thirdPartyMethod" : "org.apache.tools.ant.types.Path.<init>",
    "thirdPartyPackage" : "org.apache.tools.ant.types",
    "path" : [ "com.puppycrawl.tools.checkstyle.ant.CheckstyleAntTask.createClasspath" ],
    "fullMethods" : [ "/**\n * Creates classpath.\n *\n * @return a created path for locating classes\n * @deprecated left in implementation until #12556 only to allow users to migrate to new gradle\nplugins. This method will be removed in Checkstyle 11.x.x .\n * @noinspection DeprecatedIsStillUsed\n * @noinspectionreason DeprecatedIsStillUsed - until #12556\n */\n@Deprecated(since = \"10.7.0\")\npublic Path createClasspath() {\n    return new org.apache.tools.ant.types.Path(getProject());\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.syntaxError",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Recognizer.getRuleNames",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.syntaxError" ],
    "fullMethods" : [ "/**\n * Logs parser errors in Checkstyle manner. Parser can generate error\n * messages. There is special error that parser can generate. It is\n * missed close HTML tag. This case is special because parser prints\n * error like {@code \"no viable alternative at input 'b \\n *\\n'\"} and it\n * is not clear that error is about missed close HTML tag. Other error\n * messages are not special and logged simply as \"Parse Error...\".\n *\n * <p>{@inheritDoc }\n */\n@Override\npublic void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException ex) {\n    final int lineNumber = offset + line;\n    final String target;\n    if (recognizer instanceof JavadocCommentsLexer lexer) {\n        target = lexer.getPreviousToken().getText();\n    } else {\n        final int ruleIndex = ex.getCtx().getRuleIndex();\n        final String ruleName = recognizer.getRuleNames()[ruleIndex];\n        target = convertUpperCamelToUpperUnderscore(ruleName);\n    }\n    errorMessage = new ParseErrorMessage(lineNumber, MSG_JAVADOC_PARSE_RULE_ERROR, charPositionInLine, msg, target);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Parser.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<init>" ],
    "fullMethods" : [ "/**\n * We create a custom constructor so that we can clear the DFA\n * states upon instantiation of JavaLanguageParser.\n *\n * @param input\n * \t\tthe token stream to parse\n * @param clearDfaLimit\n * \t\tthis is the number of files to parse before clearing\n * \t\tthe parser's DFA states. This number can have a significant impact\n * \t\ton performance; more frequent clearing of DFA states can lead to\n * \t\tslower parsing but lower memory usage. Conversely, not clearing the\n * \t\tDFA states at all can lead to enormous memory usage, but may also\n * \t\thave a negative effect on memory usage from higher garbage collector\n * \t\tactivity.\n */\npublic JavaLanguageParser(TokenStream input, int clearDfaLimit) {\n    super(input);\n    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n    fileCounter++;\n    if (fileCounter > clearDfaLimit) {\n        _interp.clearDFA();\n        fileCounter = 0;\n    }\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Parser.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<init>" ],
    "fullMethods" : [ "public JavadocCommentsParser(CommonTokenStream tokens, Set<SimpleToken> unclosed) {\n    super(tokens);\n    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n    this.unclosedTagNameTokens = unclosed;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Parser.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<init>" ],
    "fullMethods" : [ "public JavaLanguageParser(TokenStream input) {\n    super(input);\n    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Parser.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<init>" ],
    "fullMethods" : [ "public JavadocCommentsParser(TokenStream input) {\n    super(input);\n    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.SimpleToken.from",
    "thirdPartyMethod" : "org.antlr.v4.runtime.CommonToken.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.SimpleToken.from", "com.puppycrawl.tools.checkstyle.grammar.SimpleToken.<init>" ],
    "fullMethods" : [ "/**\n * Creates a new instance from an existing ANTLR {@link Token}.\n *\n * @param token\n * \t\tthe ANTLR token to wrap\n * @return a new instance of SimpleToken wrapping the provided token\n */\npublic static SimpleToken from(Token token) {\n    return new SimpleToken(token);\n}", "/**\n * Constructs a new instance from an existing ANTLR {@link Token}.\n *\n * @param token\n * \t\tthe ANTLR token to wrap\n */\nprivate SimpleToken(Token token) {\n    super(token);\n    setTokenIndex(token.getTokenIndex());\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.getVocabulary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.getVocabulary", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Vocabulary getVocabulary() {\n    return VOCABULARY;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getVocabulary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getVocabulary", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Vocabulary getVocabulary() {\n    return VOCABULARY;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.isVoidTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.isVoidTag", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<clinit>" ],
    "fullMethods" : [ "public boolean isVoidTag() {\n    String tagName = _input.LT(2).getText();\n    return VOID_TAGS.contains(tagName.toLowerCase());\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavaParser.parse",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavaParser.parse", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "/**\n * Static helper method to parses a Java source file.\n *\n * @param contents\n * \t\tcontains the contents of the file\n * @return the root of the AST\n * @throws CheckstyleException\n * \t\tif the contents is not a valid Java source\n */\npublic static DetailAST parse(FileContents contents) throws CheckstyleException {\n    final String fullText = contents.getText().getFullText().toString();\n    final CharStream codePointCharStream = CharStreams.fromString(fullText);\n    final JavaLanguageLexer lexer = new JavaLanguageLexer(codePointCharStream, true);\n    lexer.setCommentListener(contents);\n    final CommonTokenStream tokenStream = new CommonTokenStream(lexer);\n    final JavaLanguageParser parser = new JavaLanguageParser(tokenStream, JavaLanguageParser.CLEAR_DFA_LIMIT);\n    parser.setErrorHandler(new CheckstyleParserErrorStrategy());\n    parser.removeErrorListeners();\n    parser.addErrorListener(new CheckstyleErrorListener());\n    final JavaLanguageParser.CompilationUnitContext compilationUnit;\n    try {\n        compilationUnit = parser.compilationUnit();\n    } catch (IllegalStateException exc) {\n        final String exceptionMsg = String.format(Locale.ROOT, \"%s occurred while parsing file %s.\", exc.getClass().getSimpleName(), contents.getFileName());\n        throw new CheckstyleException(exceptionMsg, exc);\n    }\n    return new JavaAstVisitor(tokenStream).visit(compilationUnit);\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "/**\n * We need to create a different constructor in order to use our\n * own implementation of the LexerATNSimulator. This is the\n * reason for the unused 'crAwareConstructor' argument.\n *\n * @param input\n * \t\tthe character stream to tokenize\n * @param crAwareConstructor\n * \t\tdummy parameter\n */\npublic JavaLanguageLexer(CharStream input, boolean crAwareConstructor) {\n    super(input);\n    _interp = new CrAwareLexerSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.getRuleNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.getRuleNames", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String[] getRuleNames() {\n    return ruleNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "public JavadocCommentsLexer(CharStream input) {\n    super(input);\n    _interp = new LexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<init>", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<clinit>" ],
    "fullMethods" : [ "/**\n * We create a custom constructor so that we can clear the DFA\n * states upon instantiation of JavaLanguageParser.\n *\n * @param input\n * \t\tthe token stream to parse\n * @param clearDfaLimit\n * \t\tthis is the number of files to parse before clearing\n * \t\tthe parser's DFA states. This number can have a significant impact\n * \t\ton performance; more frequent clearing of DFA states can lead to\n * \t\tslower parsing but lower memory usage. Conversely, not clearing the\n * \t\tDFA states at all can lead to enormous memory usage, but may also\n * \t\thave a negative effect on memory usage from higher garbage collector\n * \t\tactivity.\n */\npublic JavaLanguageParser(TokenStream input, int clearDfaLimit) {\n    super(input);\n    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n    fileCounter++;\n    if (fileCounter > clearDfaLimit) {\n        _interp.clearDFA();\n        fileCounter = 0;\n    }\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<init>", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<clinit>" ],
    "fullMethods" : [ "public JavaLanguageParser(TokenStream input) {\n    super(input);\n    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.getATN",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.getATN", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic ATN getATN() {\n    return _ATN;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<init>", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<clinit>" ],
    "fullMethods" : [ "public JavadocCommentsParser(CommonTokenStream tokens, Set<SimpleToken> unclosed) {\n    super(tokens);\n    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n    this.unclosedTagNameTokens = unclosed;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "/**\n * We need to create a different constructor in order to use our\n * own implementation of the LexerATNSimulator. This is the reason\n * for the unused 'crAwareConstructor' argument.\n *\n * @param input\n * \t\tthe character stream to tokenize\n * @param crAwareConstructor\n * \t\tdummy parameter\n */\npublic JavadocCommentsLexer(CharStream input, boolean crAwareConstructor) {\n    super(input);\n    _interp = new CrAwareLexerSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getTokenNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getTokenNames", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "@Override\n@Deprecated\npublic String[] getTokenNames() {\n    return tokenNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getModeNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getModeNames", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String[] getModeNames() {\n    return modeNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.parseJavadocComment",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.parseJavadocComment", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "/**\n * Parses the given Javadoc comment AST into a {@link ParseStatus} object.\n *\n * <p>\n * This method extracts the raw Javadoc comment text from the supplied\n * {@link DetailAST}, creates a new lexer and parser for the Javadoc grammar,\n * and attempts to parse it into an AST of {@link DetailNode}s.\n * The parser uses {@link PredictionMode#SLL} for\n * faster performance and stops parsing on the first error encountered by\n * using {@link CheckstyleParserErrorStrategy}.\n * </p>\n *\n * @param javadocCommentAst\n * \t\tthe {@link DetailAST} node representing the Javadoc comment in the\n * \t\tsource file\n * @return a {@link ParseStatus} containing the root of the parsed Javadoc\ntree (if successful), the first non-tight HTML tag (if any), and\nthe error message (if parsing failed)\n */\npublic ParseStatus parseJavadocComment(DetailAST javadocCommentAst) {\n    final int blockCommentLineNumber = javadocCommentAst.getLineNo();\n    final String javadocComment = JavadocUtil.getJavadocCommentContent(javadocCommentAst);\n    final ParseStatus result = new ParseStatus();\n    // Use a new error listener each time to be able to use\n    // one check instance for multiple files to be checked\n    // without getting side effects.\n    final DescriptiveErrorListener errorListener = new DescriptiveErrorListener();\n    // Log messages should have line number in scope of file,\n    // not in scope of Javadoc comment.\n    // Offset is line number of beginning of Javadoc comment.\n    errorListener.setOffset(javadocCommentAst.getLineNo() - 1);\n    final JavadocCommentsLexer lexer = new JavadocCommentsLexer(CharStreams.fromString(javadocComment), true);\n    lexer.removeErrorListeners();\n    lexer.addErrorListener(errorListener);\n    final CommonTokenStream tokens = new CommonTokenStream(lexer);\n    tokens.fill();\n    final Set<SimpleToken> unclosedTags = lexer.getUnclosedTagNameTokens();\n    final JavadocCommentsParser parser = new JavadocCommentsParser(tokens, unclosedTags);\n    // set prediction mode to SLL to speed up parsing\n    parser.getInterpreter().setPredictionMode(PredictionMode.SLL);\n    // remove default error listeners\n    parser.removeErrorListeners();\n    parser.addErrorListener(errorListener);\n    // JavadocParserErrorStrategy stops parsing on first parse error encountered unlike the\n    // DefaultErrorStrategy used by ANTLR which rather attempts error recovery.\n    parser.setErrorHandler(new CheckstyleParserErrorStrategy());\n    try {\n        final JavadocCommentsParser.JavadocContext javadoc = parser.javadoc();\n        final int javadocColumnNumber = javadocCommentAst.getColumnNo() + JAVADOC_START.length();\n        final JavadocCommentsAstVisitor visitor = new JavadocCommentsAstVisitor(tokens, blockCommentLineNumber, javadocColumnNumber);\n        final DetailNode tree = visitor.visit(javadoc);\n        result.setTree(tree);\n        result.firstNonTightHtmlTag = visitor.getFirstNonTightHtmlTag();\n        result.setParseErrorMessage(errorListener.getErrorMessage());\n    } catch (ParseCancellationException | IllegalArgumentException exc) {\n        result.setParseErrorMessage(errorListener.getErrorMessage());\n    }\n    return result;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "public JavaLanguageLexer(CharStream input) {\n    super(input);\n    _interp = new LexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getVocabulary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getVocabulary", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Vocabulary getVocabulary() {\n    return VOCABULARY;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.getTokenNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.getTokenNames", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<clinit>" ],
    "fullMethods" : [ "@Override\n@Deprecated\npublic String[] getTokenNames() {\n    return tokenNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getTokenNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getTokenNames", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "@Override\n@Deprecated\npublic String[] getTokenNames() {\n    return tokenNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getModeNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getModeNames", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String[] getModeNames() {\n    return modeNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getRuleNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getRuleNames", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String[] getRuleNames() {\n    return ruleNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.getTokenNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.getTokenNames", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<clinit>" ],
    "fullMethods" : [ "@Override\n@Deprecated\npublic String[] getTokenNames() {\n    return tokenNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getATN",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getATN", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic ATN getATN() {\n    return _ATN;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<init>", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<clinit>" ],
    "fullMethods" : [ "public JavadocCommentsParser(TokenStream input) {\n    super(input);\n    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getChannelNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getChannelNames", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String[] getChannelNames() {\n    return channelNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getRuleNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.getRuleNames", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String[] getRuleNames() {\n    return ruleNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getATN",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getATN", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic ATN getATN() {\n    return _ATN;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getChannelNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.getChannelNames", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String[] getChannelNames() {\n    return channelNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.getVocabulary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.getVocabulary", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Vocabulary getVocabulary() {\n    return VOCABULARY;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.getRuleNames",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.getRuleNames", "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String[] getRuleNames() {\n    return ruleNames;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.getATN",
    "thirdPartyMethod" : "org.antlr.v4.runtime.atn.PredictionContextCache.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.atn",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.getATN", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic ATN getATN() {\n    return _ATN;\n}", "" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.CheckstyleParserErrorStrategy.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.BailErrorStrategy.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.CheckstyleParserErrorStrategy.<init>" ],
    "fullMethods" : [ "CheckstyleParserErrorStrategy() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Lexer.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>" ],
    "fullMethods" : [ "/**\n * We need to create a different constructor in order to use our\n * own implementation of the LexerATNSimulator. This is the\n * reason for the unused 'crAwareConstructor' argument.\n *\n * @param input\n * \t\tthe character stream to tokenize\n * @param crAwareConstructor\n * \t\tdummy parameter\n */\npublic JavaLanguageLexer(CharStream input, boolean crAwareConstructor) {\n    super(input);\n    _interp = new CrAwareLexerSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Lexer.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>" ],
    "fullMethods" : [ "public JavadocCommentsLexer(CharStream input) {\n    super(input);\n    _interp = new LexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Lexer.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.<init>" ],
    "fullMethods" : [ "/**\n * We need to create a different constructor in order to use our\n * own implementation of the LexerATNSimulator. This is the reason\n * for the unused 'crAwareConstructor' argument.\n *\n * @param input\n * \t\tthe character stream to tokenize\n * @param crAwareConstructor\n * \t\tdummy parameter\n */\npublic JavadocCommentsLexer(CharStream input, boolean crAwareConstructor) {\n    super(input);\n    _interp = new CrAwareLexerSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Lexer.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer.<init>" ],
    "fullMethods" : [ "public JavaLanguageLexer(CharStream input) {\n    super(input);\n    _interp = new LexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParserBaseVisitor.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.AbstractParseTreeVisitor.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParserBaseVisitor.<init>" ],
    "fullMethods" : [ "JavadocCommentsParserBaseVisitor() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParserBaseVisitor.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.AbstractParseTreeVisitor.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParserBaseVisitor.<init>" ],
    "fullMethods" : [ "JavaLanguageParserBaseVisitor() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.statement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.statement" ],
    "fullMethods" : [ "public final StatementContext statement() throws RecognitionException {\n    StatementContext _localctx = new StatementContext(_ctx, getState());\n    enterRule(_localctx, 160, RULE_statement);\n    int _la;\n    try {\n        int _alt;\n        setState(1107);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 124, _ctx)) {\n            case 1 :\n                _localctx = new BlockStatContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1017);\n                    ((BlockStatContext) (_localctx)).blockLabel = block();\n                }\n                break;\n            case 2 :\n                _localctx = new AssertExpContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1018);\n                    match(ASSERT);\n                    setState(1019);\n                    expression();\n                    setState(1022);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == COLON) {\n                        {\n                            setState(1020);\n                            match(COLON);\n                            setState(1021);\n                            expression();\n                        }\n                    }\n                    setState(1024);\n                    match(SEMI);\n                }\n                break;\n            case 3 :\n                _localctx = new IfStatContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1026);\n                    match(LITERAL_IF);\n                    setState(1027);\n                    parExpression();\n                    setState(1028);\n                    statement();\n                    setState(1030);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 115, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1029);\n                                elseStat();\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 4 :\n                _localctx = new ForStatContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(1032);\n                    match(LITERAL_FOR);\n                    setState(1033);\n                    forControl();\n                    setState(1034);\n                    statement();\n                }\n                break;\n            case 5 :\n                _localctx = new WhileStatContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(1036);\n                    match(LITERAL_WHILE);\n                    setState(1037);\n                    parExpression();\n                    setState(1038);\n                    statement();\n                }\n                break;\n            case 6 :\n                _localctx = new DoStatContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(1040);\n                    match(LITERAL_DO);\n                    setState(1041);\n                    statement();\n                    setState(1042);\n                    match(LITERAL_WHILE);\n                    setState(1043);\n                    parExpression();\n                    setState(1044);\n                    match(SEMI);\n                }\n                break;\n            case 7 :\n                _localctx = new TryStatContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(1046);\n                    match(LITERAL_TRY);\n                    setState(1047);\n                    block();\n                    setState(1057);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LITERAL_CATCH :\n                            {\n                                setState(1049);\n                                _errHandler.sync(this);\n                                _alt = 1;\n                                do {\n                                    switch (_alt) {\n                                        case 1 :\n                                            {\n                                                {\n                                                    setState(1048);\n                                                    catchClause();\n                                                }\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                    setState(1051);\n                                    _errHandler.sync(this);\n                                    _alt = getInterpreter().adaptivePredict(_input, 116, _ctx);\n                                } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n                                setState(1054);\n                                _errHandler.sync(this);\n                                switch (getInterpreter().adaptivePredict(_input, 117, _ctx)) {\n                                    case 1 :\n                                        {\n                                            setState(1053);\n                                            finallyBlock();\n                                        }\n                                        break;\n                                }\n                            }\n                            break;\n                        case LITERAL_FINALLY :\n                            {\n                                setState(1056);\n                                finallyBlock();\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            case 8 :\n                _localctx = new TryWithResourceStatContext(_localctx);\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(1059);\n                    match(LITERAL_TRY);\n                    setState(1060);\n                    resourceSpecification();\n                    setState(1061);\n                    block();\n                    setState(1065);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 119, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(1062);\n                                    catchClause();\n                                }\n                            }\n                        }\n                        setState(1067);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 119, _ctx);\n                    } \n                    setState(1069);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 120, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1068);\n                                finallyBlock();\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 9 :\n                _localctx = new YieldStatContext(_localctx);\n                enterOuterAlt(_localctx, 9);\n                {\n                    setState(1071);\n                    match(LITERAL_YIELD);\n                    setState(1072);\n                    expression();\n                    setState(1073);\n                    match(SEMI);\n                }\n                break;\n            case 10 :\n                _localctx = new SwitchStatContext(_localctx);\n                enterOuterAlt(_localctx, 10);\n                {\n                    setState(1075);\n                    switchExpressionOrStatement();\n                }\n                break;\n            case 11 :\n                _localctx = new SyncStatContext(_localctx);\n                enterOuterAlt(_localctx, 11);\n                {\n                    setState(1076);\n                    match(LITERAL_SYNCHRONIZED);\n                    setState(1077);\n                    parExpression();\n                    setState(1078);\n                    block();\n                }\n                break;\n            case 12 :\n                _localctx = new ReturnStatContext(_localctx);\n                enterOuterAlt(_localctx, 12);\n                {\n                    setState(1080);\n                    match(LITERAL_RETURN);\n                    setState(1082);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1081);\n                            expression();\n                        }\n                    }\n                    setState(1084);\n                    match(SEMI);\n                }\n                break;\n            case 13 :\n                _localctx = new ThrowStatContext(_localctx);\n                enterOuterAlt(_localctx, 13);\n                {\n                    setState(1085);\n                    match(LITERAL_THROW);\n                    setState(1086);\n                    expression();\n                    setState(1087);\n                    match(SEMI);\n                }\n                break;\n            case 14 :\n                _localctx = new BreakStatContext(_localctx);\n                enterOuterAlt(_localctx, 14);\n                {\n                    setState(1089);\n                    match(LITERAL_BREAK);\n                    setState(1091);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                        {\n                            setState(1090);\n                            id();\n                        }\n                    }\n                    setState(1093);\n                    match(SEMI);\n                }\n                break;\n            case 15 :\n                _localctx = new ContinueStatContext(_localctx);\n                enterOuterAlt(_localctx, 15);\n                {\n                    setState(1094);\n                    match(LITERAL_CONTINUE);\n                    setState(1096);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                        {\n                            setState(1095);\n                            id();\n                        }\n                    }\n                    setState(1098);\n                    match(SEMI);\n                }\n                break;\n            case 16 :\n                _localctx = new EmptyStatContext(_localctx);\n                enterOuterAlt(_localctx, 16);\n                {\n                    setState(1099);\n                    match(SEMI);\n                }\n                break;\n            case 17 :\n                _localctx = new ExpStatContext(_localctx);\n                enterOuterAlt(_localctx, 17);\n                {\n                    setState(1100);\n                    ((ExpStatContext) (_localctx)).statementExpression = expression();\n                    setState(1101);\n                    match(SEMI);\n                }\n                break;\n            case 18 :\n                _localctx = new LabelStatContext(_localctx);\n                enterOuterAlt(_localctx, 18);\n                {\n                    setState(1103);\n                    id();\n                    setState(1104);\n                    match(COLON);\n                    setState(1105);\n                    statement();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeDeclaration" ],
    "fullMethods" : [ "public final TypeDeclarationContext typeDeclaration() throws RecognitionException {\n    TypeDeclarationContext _localctx = new TypeDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 6, RULE_typeDeclaration);\n    try {\n        int _alt;\n        setState(336);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(327);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 6, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(324);\n                                    ((TypeDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((TypeDeclarationContext) (_localctx)).mods.add(((TypeDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(329);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 6, _ctx);\n                    } \n                    setState(330);\n                    ((TypeDeclarationContext) (_localctx)).type = types(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(332);\n                    _errHandler.sync(this);\n                    _alt = 1;\n                    do {\n                        switch (_alt) {\n                            case 1 :\n                                {\n                                    {\n                                        setState(331);\n                                        ((TypeDeclarationContext) (_localctx)).SEMI = match(SEMI);\n                                        ((TypeDeclarationContext) (_localctx)).semi.add(((TypeDeclarationContext) (_localctx)).SEMI);\n                                    }\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                        setState(334);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 7, _ctx);\n                    } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.importDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.importDeclaration" ],
    "fullMethods" : [ "public final ImportDeclarationContext importDeclaration() throws RecognitionException {\n    ImportDeclarationContext _localctx = new ImportDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 4, RULE_importDeclaration);\n    int _la;\n    try {\n        setState(322);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case IMPORT :\n                _localctx = new ImportDecContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(310);\n                    match(IMPORT);\n                    setState(312);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LITERAL_STATIC) {\n                        {\n                            setState(311);\n                            match(LITERAL_STATIC);\n                        }\n                    }\n                    setState(314);\n                    qualifiedName();\n                    setState(317);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == DOT) {\n                        {\n                            setState(315);\n                            match(DOT);\n                            setState(316);\n                            match(STAR);\n                        }\n                    }\n                    setState(319);\n                    match(SEMI);\n                }\n                break;\n            case SEMI :\n                _localctx = new SingleSemiImportContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(321);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final FieldAccessNoIdentContext fieldAccessNoIdent() throws RecognitionException {\n    FieldAccessNoIdentContext _localctx = new FieldAccessNoIdentContext(_ctx, getState());\n    enterRule(_localctx, 194, RULE_fieldAccessNoIdent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1225);\n            expr(0);\n            setState(1226);\n            match(DOT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclaratorId",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclaratorId" ],
    "fullMethods" : [ "public final VariableDeclaratorIdContext variableDeclaratorId(List<VariableModifierContext> mods, ParserRuleContext type) throws RecognitionException {\n    VariableDeclaratorIdContext _localctx = new VariableDeclaratorIdContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 88, RULE_variableDeclaratorId);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(686);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case LITERAL_THIS :\n                    {\n                        setState(680);\n                        match(LITERAL_THIS);\n                    }\n                    break;\n                case IDENT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        {\n                            setState(681);\n                            qualifiedName();\n                            setState(684);\n                            _errHandler.sync(this);\n                            _la = _input.LA(1);\n                            if (_la == DOT) {\n                                {\n                                    setState(682);\n                                    match(DOT);\n                                    setState(683);\n                                    match(LITERAL_THIS);\n                                }\n                            }\n                        }\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n            setState(691);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(688);\n                        arrayDeclarator();\n                    }\n                }\n                setState(693);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.superSuffix",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.superSuffix" ],
    "fullMethods" : [ "public final SuperSuffixContext superSuffix() throws RecognitionException {\n    SuperSuffixContext _localctx = new SuperSuffixContext(_ctx, getState());\n    enterRule(_localctx, 264, RULE_superSuffix);\n    int _la;\n    try {\n        setState(1693);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LPAREN :\n                _localctx = new SuperSuffixSimpleContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1679);\n                    match(LPAREN);\n                    setState(1681);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1680);\n                            expressionList();\n                        }\n                    }\n                    setState(1683);\n                    match(RPAREN);\n                }\n                break;\n            case DOT :\n                _localctx = new SuperSuffixDotContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1684);\n                    match(DOT);\n                    setState(1685);\n                    id();\n                    setState(1691);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 200, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1686);\n                                match(LPAREN);\n                                setState(1688);\n                                _errHandler.sync(this);\n                                _la = _input.LA(1);\n                                if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                    {\n                                        setState(1687);\n                                        expressionList();\n                                    }\n                                }\n                                setState(1690);\n                                match(RPAREN);\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.mainDescription",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.mainDescription" ],
    "fullMethods" : [ "public final MainDescriptionContext mainDescription() throws RecognitionException {\n    MainDescriptionContext _localctx = new MainDescriptionContext(_ctx, getState());\n    enterRule(_localctx, 2, RULE_mainDescription);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(125);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(125);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 2, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(121);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(122);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(123);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(124);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(127);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 3, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodBody" ],
    "fullMethods" : [ "public final MethodBodyContext methodBody() throws RecognitionException {\n    MethodBodyContext _localctx = new MethodBodyContext(_ctx, getState());\n    enterRule(_localctx, 70, RULE_methodBody);\n    try {\n        setState(606);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LCURLY :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(604);\n                    block();\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(605);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceOrPrimitiveType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceOrPrimitiveType" ],
    "fullMethods" : [ "public final ClassOrInterfaceOrPrimitiveTypeContext classOrInterfaceOrPrimitiveType() throws RecognitionException {\n    ClassOrInterfaceOrPrimitiveTypeContext _localctx = new ClassOrInterfaceOrPrimitiveTypeContext(_ctx, getState());\n    enterRule(_localctx, 256, RULE_classOrInterfaceOrPrimitiveType);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1660);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case IDENT :\n                case AT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        setState(1658);\n                        classOrInterfaceType(false);\n                    }\n                    break;\n                case LITERAL_VOID :\n                case LITERAL_BOOLEAN :\n                case LITERAL_BYTE :\n                case LITERAL_CHAR :\n                case LITERAL_SHORT :\n                case LITERAL_INT :\n                case LITERAL_FLOAT :\n                case LITERAL_LONG :\n                case LITERAL_DOUBLE :\n                    {\n                        setState(1659);\n                        primitiveType();\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableAccess",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableAccess" ],
    "fullMethods" : [ "public final VariableAccessContext variableAccess() throws RecognitionException {\n    VariableAccessContext _localctx = new VariableAccessContext(_ctx, getState());\n    enterRule(_localctx, 192, RULE_variableAccess);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1218);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 136, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1215);\n                            ((VariableAccessContext) (_localctx)).fieldAccessNoIdent = fieldAccessNoIdent();\n                            ((VariableAccessContext) (_localctx)).accessList.add(((VariableAccessContext) (_localctx)).fieldAccessNoIdent);\n                        }\n                    }\n                }\n                setState(1220);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 136, _ctx);\n            } \n            setState(1223);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case IDENT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        setState(1221);\n                        id();\n                    }\n                    break;\n                case LITERAL_THIS :\n                    {\n                        setState(1222);\n                        match(LITERAL_THIS);\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgument",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgument" ],
    "fullMethods" : [ "public final TypeArgumentContext typeArgument() throws RecognitionException {\n    TypeArgumentContext _localctx = new TypeArgumentContext(_ctx, getState());\n    enterRule(_localctx, 98, RULE_typeArgument);\n    int _la;\n    try {\n        setState(741);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 73, _ctx)) {\n            case 1 :\n                _localctx = new SimpleTypeArgumentContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(731);\n                    typeType(false);\n                }\n                break;\n            case 2 :\n                _localctx = new WildCardTypeArgumentContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(732);\n                    annotations(false);\n                    setState(733);\n                    match(QUESTION);\n                    setState(739);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == EXTENDS_CLAUSE) || (_la == LITERAL_SUPER)) {\n                        {\n                            setState(736);\n                            _errHandler.sync(this);\n                            switch (_input.LA(1)) {\n                                case EXTENDS_CLAUSE :\n                                    {\n                                        setState(734);\n                                        ((WildCardTypeArgumentContext) (_localctx)).upperBound = match(EXTENDS_CLAUSE);\n                                    }\n                                    break;\n                                case LITERAL_SUPER :\n                                    {\n                                        setState(735);\n                                        ((WildCardTypeArgumentContext) (_localctx)).lowerBound = match(LITERAL_SUPER);\n                                    }\n                                    break;\n                                default :\n                                    throw new NoViableAltException(this);\n                            }\n                            setState(738);\n                            typeType(false);\n                        }\n                    }\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.creator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.creator" ],
    "fullMethods" : [ "public final CreatorContext creator() throws RecognitionException {\n    CreatorContext _localctx = new CreatorContext(_ctx, getState());\n    enterRule(_localctx, 230, RULE_creator);\n    try {\n        setState(1557);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LT :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1545);\n                    nonWildcardTypeArguments();\n                    setState(1546);\n                    createdName();\n                    setState(1547);\n                    classCreatorRest();\n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1549);\n                    annotations(false);\n                    setState(1550);\n                    createdName();\n                    setState(1555);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LBRACK :\n                        case AT :\n                            {\n                                setState(1551);\n                                annotations(false);\n                                setState(1552);\n                                arrayCreatorRest();\n                            }\n                            break;\n                        case LPAREN :\n                            {\n                                setState(1554);\n                                classCreatorRest();\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlContent" ],
    "fullMethods" : [ "public final HtmlContentContext htmlContent() throws RecognitionException {\n    HtmlContentContext _localctx = new HtmlContentContext(_ctx, getState());\n    enterRule(_localctx, 102, RULE_htmlContent);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(468);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(468);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 62, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(464);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(465);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(466);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(467);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(470);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 63, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableInitializer",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableInitializer" ],
    "fullMethods" : [ "public final VariableInitializerContext variableInitializer() throws RecognitionException {\n    VariableInitializerContext _localctx = new VariableInitializerContext(_ctx, getState());\n    enterRule(_localctx, 90, RULE_variableInitializer);\n    try {\n        setState(696);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LCURLY :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(694);\n                    arrayInitializer();\n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LPAREN :\n            case LITERAL_THIS :\n            case LITERAL_SUPER :\n            case LITERAL_SWITCH :\n            case PLUS :\n            case MINUS :\n            case INC :\n            case DEC :\n            case BNOT :\n            case LNOT :\n            case LITERAL_TRUE :\n            case LITERAL_FALSE :\n            case LITERAL_NULL :\n            case LITERAL_NEW :\n            case CHAR_LITERAL :\n            case STRING_LITERAL :\n            case AT :\n            case FLOAT_LITERAL :\n            case DOUBLE_LITERAL :\n            case HEX_FLOAT_LITERAL :\n            case HEX_DOUBLE_LITERAL :\n            case LITERAL_RECORD :\n            case TEXT_BLOCK_LITERAL_BEGIN :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n            case DECIMAL_LITERAL_LONG :\n            case DECIMAL_LITERAL :\n            case HEX_LITERAL_LONG :\n            case HEX_LITERAL :\n            case OCT_LITERAL_LONG :\n            case OCT_LITERAL :\n            case BINARY_LITERAL_LONG :\n            case BINARY_LITERAL :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(695);\n                    expression();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableModifier",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableModifier" ],
    "fullMethods" : [ "public final VariableModifierContext variableModifier() throws RecognitionException {\n    VariableModifierContext _localctx = new VariableModifierContext(_ctx, getState());\n    enterRule(_localctx, 12, RULE_variableModifier);\n    try {\n        setState(364);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(362);\n                    match(FINAL);\n                }\n                break;\n            case AT :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(363);\n                    annotation();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightHtmlContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightHtmlContent" ],
    "fullMethods" : [ "public final NonTightHtmlContentContext nonTightHtmlContent() throws RecognitionException {\n    NonTightHtmlContentContext _localctx = new NonTightHtmlContentContext(_ctx, getState());\n    enterRule(_localctx, 104, RULE_nonTightHtmlContent);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(474);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(474);\n                            _errHandler.sync(this);\n                            switch (_input.LA(1)) {\n                                case TEXT :\n                                    {\n                                        setState(472);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case JAVADOC_INLINE_TAG_START :\n                                    {\n                                        setState(473);\n                                        inlineTag();\n                                    }\n                                    break;\n                                default :\n                                    throw new NoViableAltException(this);\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(476);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 65, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final PrimaryContext primary() throws RecognitionException {\n    PrimaryContext _localctx = new PrimaryContext(_ctx, getState());\n    enterRule(_localctx, 226, RULE_primary);\n    int _la;\n    try {\n        setState(1533);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 176, _ctx)) {\n            case 1 :\n                _localctx = new SwitchPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1504);\n                    switchExpressionOrStatement();\n                }\n                break;\n            case 2 :\n                _localctx = new ParenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1505);\n                    match(LPAREN);\n                    setState(1506);\n                    expr(0);\n                    setState(1507);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1509);\n                    match(LITERAL_THIS);\n                }\n                break;\n            case 4 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(1510);\n                    match(LITERAL_SUPER);\n                }\n                break;\n            case 5 :\n                _localctx = new LiteralPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(1511);\n                    literal();\n                }\n                break;\n            case 6 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(1512);\n                    id();\n                }\n                break;\n            case 7 :\n                _localctx = new ClassRefPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(1513);\n                    ((ClassRefPrimaryContext) (_localctx)).type = classOrInterfaceType(false);\n                    setState(1517);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1514);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1519);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1520);\n                    match(DOT);\n                    setState(1521);\n                    match(LITERAL_CLASS);\n                }\n                break;\n            case 8 :\n                _localctx = new PrimitivePrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(1523);\n                    ((PrimitivePrimaryContext) (_localctx)).type = primitiveType();\n                    setState(1527);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1524);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1529);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1530);\n                    match(DOT);\n                    setState(1531);\n                    match(LITERAL_CLASS);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExprContext expr() throws RecognitionException {\n    return expr(0);\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExplicitConstructorInvocationContext explicitConstructorInvocation() throws RecognitionException {\n    ExplicitConstructorInvocationContext _localctx = new ExplicitConstructorInvocationContext(_ctx, getState());\n    enterRule(_localctx, 150, RULE_explicitConstructorInvocation);\n    int _la;\n    try {\n        setState(974);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 107, _ctx)) {\n            case 1 :\n                _localctx = new ExplicitCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(959);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(958);\n                            typeArguments();\n                        }\n                    }\n                    setState(961);\n                    _la = _input.LA(1);\n                    if (!((_la == LITERAL_THIS) || (_la == LITERAL_SUPER))) {\n                        _errHandler.recoverInline(this);\n                    } else {\n                        if (_input.LA(1) == Token.EOF)\n                            matchedEOF = true;\n\n                        _errHandler.reportMatch(this);\n                        consume();\n                    }\n                    setState(962);\n                    arguments();\n                    setState(963);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new PrimaryCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(965);\n                    expr(0);\n                    setState(966);\n                    match(DOT);\n                    setState(968);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(967);\n                            typeArguments();\n                        }\n                    }\n                    setState(970);\n                    match(LITERAL_SUPER);\n                    setState(971);\n                    arguments();\n                    setState(972);\n                    match(SEMI);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localTypeDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localTypeDeclaration" ],
    "fullMethods" : [ "public final LocalTypeDeclarationContext localTypeDeclaration() throws RecognitionException {\n    LocalTypeDeclarationContext _localctx = new LocalTypeDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 158, RULE_localTypeDeclaration);\n    int _la;\n    try {\n        setState(1015);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1005);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while (((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028798088511495L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 1649267441665L) != 0))) {\n                        {\n                            {\n                                setState(1002);\n                                ((LocalTypeDeclarationContext) (_localctx)).modifier = modifier();\n                                ((LocalTypeDeclarationContext) (_localctx)).mods.add(((LocalTypeDeclarationContext) (_localctx)).modifier);\n                            }\n                        }\n                        setState(1007);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1012);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LITERAL_CLASS :\n                            {\n                                setState(1008);\n                                classDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case ENUM :\n                            {\n                                setState(1009);\n                                enumDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case LITERAL_INTERFACE :\n                            {\n                                setState(1010);\n                                interfaceDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case LITERAL_RECORD :\n                            {\n                                setState(1011);\n                                recordDeclaration(_localctx.mods);\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1014);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.types",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.types" ],
    "fullMethods" : [ "public final TypesContext types(List<ModifierContext> mods) throws RecognitionException {\n    TypesContext _localctx = new TypesContext(_ctx, getState(), mods);\n    enterRule(_localctx, 8, RULE_types);\n    try {\n        setState(343);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LITERAL_CLASS :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(338);\n                    classDeclaration(mods);\n                }\n                break;\n            case ENUM :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(339);\n                    enumDeclaration(mods);\n                }\n                break;\n            case LITERAL_INTERFACE :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(340);\n                    interfaceDeclaration(mods);\n                }\n                break;\n            case AT :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(341);\n                    annotationTypeDeclaration(mods);\n                }\n                break;\n            case LITERAL_RECORD :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(342);\n                    recordDeclaration(mods);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.modifier",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.modifier" ],
    "fullMethods" : [ "public final ModifierContext modifier() throws RecognitionException {\n    ModifierContext _localctx = new ModifierContext(_ctx, getState());\n    enterRule(_localctx, 10, RULE_modifier);\n    try {\n        setState(360);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case AT :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(345);\n                    annotation();\n                }\n                break;\n            case LITERAL_PUBLIC :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(346);\n                    match(LITERAL_PUBLIC);\n                }\n                break;\n            case LITERAL_PROTECTED :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(347);\n                    match(LITERAL_PROTECTED);\n                }\n                break;\n            case LITERAL_PRIVATE :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(348);\n                    match(LITERAL_PRIVATE);\n                }\n                break;\n            case LITERAL_STATIC :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(349);\n                    match(LITERAL_STATIC);\n                }\n                break;\n            case ABSTRACT :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(350);\n                    match(ABSTRACT);\n                }\n                break;\n            case LITERAL_DEFAULT :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(351);\n                    match(LITERAL_DEFAULT);\n                }\n                break;\n            case FINAL :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(352);\n                    match(FINAL);\n                }\n                break;\n            case STRICTFP :\n                enterOuterAlt(_localctx, 9);\n                {\n                    setState(353);\n                    match(STRICTFP);\n                }\n                break;\n            case LITERAL_NATIVE :\n                enterOuterAlt(_localctx, 10);\n                {\n                    setState(354);\n                    match(LITERAL_NATIVE);\n                }\n                break;\n            case LITERAL_SYNCHRONIZED :\n                enterOuterAlt(_localctx, 11);\n                {\n                    setState(355);\n                    match(LITERAL_SYNCHRONIZED);\n                }\n                break;\n            case LITERAL_TRANSIENT :\n                enterOuterAlt(_localctx, 12);\n                {\n                    setState(356);\n                    match(LITERAL_TRANSIENT);\n                }\n                break;\n            case LITERAL_VOLATILE :\n                enterOuterAlt(_localctx, 13);\n                {\n                    setState(357);\n                    match(LITERAL_VOLATILE);\n                }\n                break;\n            case LITERAL_NON_SEALED :\n                enterOuterAlt(_localctx, 14);\n                {\n                    setState(358);\n                    match(LITERAL_NON_SEALED);\n                }\n                break;\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 15);\n                {\n                    setState(359);\n                    match(LITERAL_SEALED);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayCreatorRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayCreatorRest" ],
    "fullMethods" : [ "public final ArrayCreatorRestContext arrayCreatorRest() throws RecognitionException {\n    ArrayCreatorRestContext _localctx = new ArrayCreatorRestContext(_ctx, getState());\n    enterRule(_localctx, 238, RULE_arrayCreatorRest);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1586);\n            match(LBRACK);\n            setState(1609);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case RBRACK :\n                    {\n                        setState(1587);\n                        match(RBRACK);\n                        setState(1591);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        while ((_la == LBRACK) || (_la == AT)) {\n                            {\n                                {\n                                    setState(1588);\n                                    arrayDeclarator();\n                                }\n                            }\n                            setState(1593);\n                            _errHandler.sync(this);\n                            _la = _input.LA(1);\n                        } \n                        setState(1594);\n                        arrayInitializer();\n                    }\n                    break;\n                case LITERAL_VOID :\n                case LITERAL_BOOLEAN :\n                case LITERAL_BYTE :\n                case LITERAL_CHAR :\n                case LITERAL_SHORT :\n                case LITERAL_INT :\n                case LITERAL_FLOAT :\n                case LITERAL_LONG :\n                case LITERAL_DOUBLE :\n                case IDENT :\n                case LPAREN :\n                case LITERAL_THIS :\n                case LITERAL_SUPER :\n                case LITERAL_SWITCH :\n                case PLUS :\n                case MINUS :\n                case INC :\n                case DEC :\n                case BNOT :\n                case LNOT :\n                case LITERAL_TRUE :\n                case LITERAL_FALSE :\n                case LITERAL_NULL :\n                case LITERAL_NEW :\n                case CHAR_LITERAL :\n                case STRING_LITERAL :\n                case AT :\n                case FLOAT_LITERAL :\n                case DOUBLE_LITERAL :\n                case HEX_FLOAT_LITERAL :\n                case HEX_DOUBLE_LITERAL :\n                case LITERAL_RECORD :\n                case TEXT_BLOCK_LITERAL_BEGIN :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                case DECIMAL_LITERAL_LONG :\n                case DECIMAL_LITERAL :\n                case HEX_LITERAL_LONG :\n                case HEX_LITERAL :\n                case OCT_LITERAL_LONG :\n                case OCT_LITERAL :\n                case BINARY_LITERAL_LONG :\n                case BINARY_LITERAL :\n                    {\n                        setState(1595);\n                        expression();\n                        setState(1596);\n                        match(RBRACK);\n                        setState(1600);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 187, _ctx);\n                        while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                            if (_alt == 1) {\n                                {\n                                    {\n                                        setState(1597);\n                                        bracketsWithExp();\n                                    }\n                                }\n                            }\n                            setState(1602);\n                            _errHandler.sync(this);\n                            _alt = getInterpreter().adaptivePredict(_input, 187, _ctx);\n                        } \n                        setState(1606);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 188, _ctx);\n                        while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                            if (_alt == 1) {\n                                {\n                                    {\n                                        setState(1603);\n                                        arrayDeclarator();\n                                    }\n                                }\n                            }\n                            setState(1608);\n                            _errHandler.sync(this);\n                            _alt = getInterpreter().adaptivePredict(_input, 188, _ctx);\n                        } \n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExpressionContext expression() throws RecognitionException {\n    ExpressionContext _localctx = new ExpressionContext(_ctx, getState());\n    enterRule(_localctx, 216, RULE_expression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1315);\n            expr(0);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.reference",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.reference" ],
    "fullMethods" : [ "public final ReferenceContext reference() throws RecognitionException {\n    ReferenceContext _localctx = new ReferenceContext(_ctx, getState());\n    enterRule(_localctx, 66, RULE_reference);\n    try {\n        setState(350);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case HASH :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(338);\n                    match(HASH);\n                    setState(339);\n                    memberReference();\n                }\n                break;\n            case IDENTIFIER :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(343);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 43, _ctx)) {\n                        case 1 :\n                            {\n                                setState(340);\n                                ((ReferenceContext) (_localctx)).module = qualifiedName();\n                                setState(341);\n                                match(SLASH);\n                            }\n                            break;\n                    }\n                    setState(345);\n                    ((ReferenceContext) (_localctx)).type = typeName();\n                    setState(348);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 44, _ctx)) {\n                        case 1 :\n                            {\n                                setState(346);\n                                match(HASH);\n                                setState(347);\n                                memberReference();\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTagContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTagContent" ],
    "fullMethods" : [ "public final InlineTagContentContext inlineTagContent() throws RecognitionException {\n    InlineTagContentContext _localctx = new InlineTagContentContext(_ctx, getState());\n    enterRule(_localctx, 40, RULE_inlineTagContent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(270);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case CODE :\n                    {\n                        setState(258);\n                        codeInlineTag();\n                    }\n                    break;\n                case LINK :\n                    {\n                        setState(259);\n                        linkInlineTag();\n                    }\n                    break;\n                case LINKPLAIN :\n                    {\n                        setState(260);\n                        linkPlainInlineTag();\n                    }\n                    break;\n                case VALUE :\n                    {\n                        setState(261);\n                        valueInlineTag();\n                    }\n                    break;\n                case INHERIT_DOC :\n                    {\n                        setState(262);\n                        inheritDocInlineTag();\n                    }\n                    break;\n                case SUMMARY :\n                    {\n                        setState(263);\n                        summaryInlineTag();\n                    }\n                    break;\n                case SYSTEM_PROPERTY :\n                    {\n                        setState(264);\n                        systemPropertyInlineTag();\n                    }\n                    break;\n                case INDEX :\n                    {\n                        setState(265);\n                        indexInlineTag();\n                    }\n                    break;\n                case RETURN :\n                    {\n                        setState(266);\n                        returnInlineTag();\n                    }\n                    break;\n                case LITERAL :\n                    {\n                        setState(267);\n                        literalInlineTag();\n                    }\n                    break;\n                case SNIPPET :\n                    {\n                        setState(268);\n                        snippetInlineTag();\n                    }\n                    break;\n                case CUSTOM_NAME :\n                    {\n                        setState(269);\n                        customInlineTag();\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlockStatementGroup",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlockStatementGroup" ],
    "fullMethods" : [ "public final SwitchBlockStatementGroupContext switchBlockStatementGroup() throws RecognitionException {\n    SwitchBlockStatementGroupContext _localctx = new SwitchBlockStatementGroupContext(_ctx, getState());\n    enterRule(_localctx, 196, RULE_switchBlockStatementGroup);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1229);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            {\n                                setState(1228);\n                                switchLabel();\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(1231);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 138, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n            setState(1234);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            {\n                                setState(1233);\n                                ((SwitchBlockStatementGroupContext) (_localctx)).blockStatement = blockStatement();\n                                ((SwitchBlockStatementGroupContext) (_localctx)).slists.add(((SwitchBlockStatementGroupContext) (_localctx)).blockStatement);\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(1236);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 139, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabel",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabel" ],
    "fullMethods" : [ "public final SwitchLabelContext switchLabel() throws RecognitionException {\n    SwitchLabelContext _localctx = new SwitchLabelContext(_ctx, getState());\n    enterRule(_localctx, 198, RULE_switchLabel);\n    try {\n        setState(1247);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LITERAL_CASE :\n                _localctx = new CaseLabelContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1238);\n                    match(LITERAL_CASE);\n                    setState(1239);\n                    caseConstants();\n                    setState(1241);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 140, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1240);\n                                match(COLON);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case LITERAL_DEFAULT :\n                _localctx = new DefaultLabelContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1243);\n                    match(LITERAL_DEFAULT);\n                    setState(1245);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 141, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1244);\n                                match(COLON);\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.description",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.description" ],
    "fullMethods" : [ "public final DescriptionContext description() throws RecognitionException {\n    DescriptionContext _localctx = new DescriptionContext(_ctx, getState());\n    enterRule(_localctx, 84, RULE_description);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(410);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(410);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 54, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(406);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(407);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(408);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(409);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(412);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 55, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementDeclaration" ],
    "fullMethods" : [ "public final AnnotationTypeElementDeclarationContext annotationTypeElementDeclaration() throws RecognitionException {\n    AnnotationTypeElementDeclarationContext _localctx = new AnnotationTypeElementDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 138, RULE_annotationTypeElementDeclaration);\n    try {\n        int _alt;\n        setState(895);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(890);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 92, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(887);\n                                    ((AnnotationTypeElementDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((AnnotationTypeElementDeclarationContext) (_localctx)).mods.add(((AnnotationTypeElementDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(892);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 92, _ctx);\n                    } \n                    setState(893);\n                    annotationTypeElementRest(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(894);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdName" ],
    "fullMethods" : [ "public final CreatedNameContext createdName() throws RecognitionException {\n    CreatedNameContext _localctx = new CreatedNameContext(_ctx, getState());\n    enterRule(_localctx, 232, RULE_createdName);\n    int _la;\n    try {\n        setState(1571);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case IDENT :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                _localctx = new CreatedNameObjectContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1559);\n                    annotations(false);\n                    setState(1560);\n                    id();\n                    setState(1562);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(1561);\n                            typeArgumentsOrDiamond();\n                        }\n                    }\n                    setState(1567);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while (_la == DOT) {\n                        {\n                            {\n                                setState(1564);\n                                ((CreatedNameObjectContext) (_localctx)).createdNameExtended = createdNameExtended();\n                                ((CreatedNameObjectContext) (_localctx)).extended.add(((CreatedNameObjectContext) (_localctx)).createdNameExtended);\n                            }\n                        }\n                        setState(1569);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n                _localctx = new CreatedNamePrimitiveContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1570);\n                    primitiveType();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBodyDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBodyDeclaration" ],
    "fullMethods" : [ "public final InterfaceBodyDeclarationContext interfaceBodyDeclaration() throws RecognitionException {\n    InterfaceBodyDeclarationContext _localctx = new InterfaceBodyDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 78, RULE_interfaceBodyDeclaration);\n    try {\n        int _alt;\n        setState(633);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case LT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(628);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 52, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(625);\n                                    ((InterfaceBodyDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((InterfaceBodyDeclarationContext) (_localctx)).mods.add(((InterfaceBodyDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(630);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 52, _ctx);\n                    } \n                    setState(631);\n                    interfaceMemberDeclaration(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(632);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.literal",
    "thirdPartyMethod" : "org.antlr.v4.runtime.NoViableAltException.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.literal" ],
    "fullMethods" : [ "public final LiteralContext literal() throws RecognitionException {\n    LiteralContext _localctx = new LiteralContext(_ctx, getState());\n    enterRule(_localctx, 114, RULE_literal);\n    try {\n        setState(814);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case DECIMAL_LITERAL_LONG :\n            case DECIMAL_LITERAL :\n            case HEX_LITERAL_LONG :\n            case HEX_LITERAL :\n            case OCT_LITERAL_LONG :\n            case OCT_LITERAL :\n            case BINARY_LITERAL_LONG :\n            case BINARY_LITERAL :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(806);\n                    integerLiteral();\n                }\n                break;\n            case FLOAT_LITERAL :\n            case DOUBLE_LITERAL :\n            case HEX_FLOAT_LITERAL :\n            case HEX_DOUBLE_LITERAL :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(807);\n                    floatLiteral();\n                }\n                break;\n            case TEXT_BLOCK_LITERAL_BEGIN :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(808);\n                    textBlockLiteral();\n                }\n                break;\n            case CHAR_LITERAL :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(809);\n                    match(CHAR_LITERAL);\n                }\n                break;\n            case STRING_LITERAL :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(810);\n                    match(STRING_LITERAL);\n                }\n                break;\n            case LITERAL_TRUE :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(811);\n                    match(LITERAL_TRUE);\n                }\n                break;\n            case LITERAL_FALSE :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(812);\n                    match(LITERAL_FALSE);\n                }\n                break;\n            case LITERAL_NULL :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(813);\n                    match(LITERAL_NULL);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.ant.CheckstyleAntTask.<init>",
    "thirdPartyMethod" : "org.apache.tools.ant.Task.<init>",
    "thirdPartyPackage" : "org.apache.tools.ant",
    "path" : [ "com.puppycrawl.tools.checkstyle.ant.CheckstyleAntTask.<init>" ],
    "fullMethods" : [ "CheckstyleAntTask() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.GuardedPatternContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.GuardedPatternContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitGuardedPattern(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalLambdaParamContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalLambdaParamContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitFormalLambdaParam(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrefixContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrefixContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPrefix(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArgumentsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArgumentsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitArguments(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ValueInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ValueInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitValueInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValuePairContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValuePairContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitElementValuePair(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableModifierContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableModifierContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitVariableModifier(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitVariableDeclarator(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SimpleMethodCallContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SimpleMethodCallContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSimpleMethodCall(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImplementsClauseContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImplementsClauseContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitImplementsClause(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorBlockContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorBlockContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitConstructorBlock(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeNameContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeNameContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitTypeName(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseLabelContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseLabelContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCaseLabel(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NewExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NewExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitNewExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitNonWildcardTypeArguments(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialFieldTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialFieldTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSerialFieldTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TryWithResourceStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TryWithResourceStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTryWithResourceStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassExtendsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassExtendsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassExtends(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.UsesTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.UsesTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitUsesTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSerialTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotations(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCatchType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SeeTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SeeTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSeeTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InheritDocInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InheritDocInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitInheritDocInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationConstantRestContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationConstantRestContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotationConstantRest(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimitivePrimaryContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimitivePrimaryContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPrimitivePrimary(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledRuleContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledRuleContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchLabeledRule(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IdContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IdContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitId(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.VersionTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.VersionTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitVersionTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MemberDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MemberDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitMemberDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayCreatorRestContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayCreatorRestContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitArrayCreatorRest(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumConstantContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumConstantContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEnumConstant(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordComponent(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodRefContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodRefContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitMethodRef(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourcesContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourcesContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitResources(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InstanceOfExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InstanceOfExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInstanceOfExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElseStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElseStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitElseStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeArgumentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeArgumentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitTypeArgument(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassOrInterfaceType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockStatementGroupContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockStatementGroupContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchBlockStatementGroup(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassBody(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitResource(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FinallyBlockContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FinallyBlockContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitFinallyBlock(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpressionListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpressionListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitExpressionList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.NonTightHtmlContentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.NonTightHtmlContentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitNonTightHtmlContent(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypesContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypesContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypes(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EmptyClassContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EmptyClassContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEmptyClass(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CustomInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CustomInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitCustomInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMemberDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMemberDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInterfaceMemberDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPrimaryExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.MainDescriptionContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.MainDescriptionContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitMainDescription(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLocalType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNamePrimitiveContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNamePrimitiveContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCreatedNamePrimitive(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.GuardContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.GuardContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitGuard(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BitShiftContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BitShiftContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitBitShift(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEnumDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationFieldContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationFieldContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotationField(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ReturnStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ReturnStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitReturnStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableAccessContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableAccessContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitVariableAccess(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpressionContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpressionContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitExpression(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IfStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IfStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitIfStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.DeprecatedTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.DeprecatedTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitDeprecatedTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialDataTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialDataTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSerialDataTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CompactConstructorDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CompactConstructorDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCompactConstructorDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InnerPatternContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InnerPatternContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInnerPattern(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardDiamondContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardDiamondContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitNonWildcardDiamond(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalVarContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalVarContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLocalVar(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassCreatorRestContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassCreatorRestContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassCreatorRest(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeBodyContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeBodyContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotationTypeBody(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledThrowContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledThrowContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchLabeledThrow(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ParenPatternContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ParenPatternContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitParenPattern(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitForStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LiteralPrimaryContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LiteralPrimaryContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLiteralPrimary(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassDefContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassDefContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassDef(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayDeclaratorContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayDeclaratorContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitArrayDeclarator(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlCommentContentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlCommentContentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitHtmlCommentContent(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypePatternDefContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypePatternDefContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypePatternDef(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AssertExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AssertExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAssertExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MultiLambdaParamContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MultiLambdaParamContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitMultiLambdaParam(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ParameterTypeListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ParameterTypeListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitParameterTypeList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ModifierContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ModifierContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitModifier(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceOrPrimitiveTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceOrPrimitiveTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassOrInterfaceOrPrimitiveType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableInitializerContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableInitializerContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitVariableInitializer(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitVariableDeclarators(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeExtendedContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeExtendedContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassOrInterfaceTypeExtended(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlTagStartContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlTagStartContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitHtmlTagStart(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DoStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DoStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitDoStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMethodDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMethodDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInterfaceMethodDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodBodyContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodBodyContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitMethodBody(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassRefPrimaryContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassRefPrimaryContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassRefPrimary(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ParenPrimaryContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ParenPrimaryContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitParenPrimary(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LabelStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LabelStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLabelStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SummaryInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SummaryInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSummaryInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSuperExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForControlContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForControlContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEnhancedForControl(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TernaryOpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TernaryOpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTernaryOp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SelfClosingElementContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SelfClosingElementContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSelfClosingElement(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseConstantsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseConstantsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCaseConstants(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledBlockContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledBlockContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchLabeledBlock(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ContinueStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ContinueStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitContinueStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.AuthorTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.AuthorTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitAuthorTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeUpperBoundsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeUpperBoundsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeUpperBounds(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CompilationUnitContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CompilationUnitContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCompilationUnit(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BracketsWithExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BracketsWithExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitBracketsWithExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlAttributeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlAttributeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitHtmlAttribute(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchClauseContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchClauseContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCatchClause(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldAccessNoIdentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldAccessNoIdentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitFieldAccessNoIdent(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseConstantContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseConstantContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCaseConstant(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LiteralContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LiteralContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLiteral(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeBoundContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeBoundContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeBound(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameObjectContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameObjectContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCreatedNameObject(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReturnInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReturnInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitReturnInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LinkInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LinkInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitLinkInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PackageDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PackageDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPackageDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CodeInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CodeInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitCodeInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DefaultLabelContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DefaultLabelContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitDefaultLabel(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixSimpleContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixSimpleContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSuperSuffixSimple(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorIdContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorIdContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitVariableDeclaratorId(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitResourceDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MultiLambdaParamsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MultiLambdaParamsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitMultiLambdaParams(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitBlock(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlCommentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlCommentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitHtmlComment(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeArgumentsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeArgumentsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitTypeArguments(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValueArrayInitializerContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValueArrayInitializerContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitElementValueArrayInitializer(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitFieldDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeArguments(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BinOpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BinOpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitBinOp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixDotContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixDotContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSuperSuffixDot(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordBodyContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordBodyContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordBody(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InvOpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InvOpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInvOp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceBodyDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceBodyDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInterfaceBodyDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchParameterContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchParameterContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCatchParameter(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimitiveTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimitiveTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPrimitiveType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledExpressionContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledExpressionContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchLabeledExpression(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LambdaExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LambdaExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLambdaExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LastRecordComponentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LastRecordComponentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLastRecordComponent(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationMethodRestContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationMethodRestContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotationMethodRest(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ExceptionTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ExceptionTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitExceptionTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitMethodDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DefaultValueContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DefaultValueContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitDefaultValue(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForControlWithRecordPatternContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForControlWithRecordPatternContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEnhancedForControlWithRecordPattern(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SyncStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SyncStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSyncStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchRulesContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchRulesContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchRules(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SystemPropertyInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SystemPropertyInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSystemPropertyInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TightElementContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TightElementContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitTightElement(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameExtendedContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameExtendedContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCreatedNameExtended(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.JavadocContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.JavadocContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitJavadoc(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CastExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CastExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCastExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForForContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForForContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitForFor(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlocksContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlocksContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchBlocks(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodCallContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodCallContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitMethodCall(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetAttributeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetAttributeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSnippetAttribute(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReferenceContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReferenceContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitReference(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.YieldStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.YieldStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitYieldStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceBodyContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceBodyContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInterfaceBody(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SimpleTypeArgumentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SimpleTypeArgumentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSimpleTypeArgument(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotation(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumBodyDeclarationsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumBodyDeclarationsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEnumBodyDeclarations(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.UnnamedPatternDefContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.UnnamedPatternDefContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitUnnamedPatternDef(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchPrimaryContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchPrimaryContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchPrimary(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TryStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TryStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTryStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitBlockStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SingleSemiImportContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SingleSemiImportContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSingleSemiImport(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.VoidElementContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.VoidElementContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitVoidElement(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotationTypeElementDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TokenPrimaryContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TokenPrimaryContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTokenPrimary(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PatternVariableDefContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PatternVariableDefContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPatternVariableDef(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.BlockTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.BlockTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitBlockTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SinceTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SinceTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSinceTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalTypeDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalTypeDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLocalTypeDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSnippetInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotationTypeDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchExpressionOrStatementContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchExpressionOrStatementContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSwitchExpressionOrStatement(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumConstantsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumConstantsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEnumConstants(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalVariableDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalVariableDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLocalVariableDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeParametersContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeParametersContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeParameters(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValueContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValueContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitElementValue(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceExtendsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceExtendsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInterfaceExtends(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LastFormalParameterContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LastFormalParameterContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitLastFormalParameter(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitConstructorDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HiddenTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HiddenTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitHiddenTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValuePairsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValuePairsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitElementValuePairs(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IntegerLiteralContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IntegerLiteralContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitIntegerLiteral(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PostfixContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PostfixContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPostfix(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ParameterTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ParameterTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitParameterTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameExtendedContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameExtendedContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitQualifiedNameExtended(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DiamondContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DiamondContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitDiamond(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsTypeListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsTypeListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeArgumentsTypeList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitNonWildcardTypeArgs(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlTagEndContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlTagEndContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitHtmlTagEnd(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ThrowsTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ThrowsTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitThrowsTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PermittedSubclassesAndInterfacesContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PermittedSubclassesAndInterfacesContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPermittedSubclassesAndInterfaces(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatorContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatorContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitCreator(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordComponents(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TextBlockLiteralContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TextBlockLiteralContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTextBlockLiteral(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImportDecContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImportDecContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitImportDec(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.StatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.StatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBlockContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBlockContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassBlock(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.WildCardTypeArgumentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.WildCardTypeArgumentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitWildCardTypeArgument(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ThisExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ThisExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitThisExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayInitializerContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayInitializerContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitArrayInitializer(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EmptyStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EmptyStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEmptyStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InitExpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InitExpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInitExp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.MemberReferenceContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.MemberReferenceContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitMemberReference(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParameterListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParameterListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitFormalParameterList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitQualifiedNameList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RefOpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RefOpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRefOp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitClassDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInterfaceDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ThrowsListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ThrowsListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitThrowsList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordPatternContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordPatternContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordPattern(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlContentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlContentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitHtmlContent(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InnerCreatorContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InnerCreatorContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitInnerCreator(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SingleLambdaParamContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SingleLambdaParamContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitSingleLambdaParam(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentsListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentsListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordComponentsList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlElementContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlElementContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitHtmlElement(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ProvidesTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ProvidesTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitProvidesTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LinkPlainInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LinkPlainInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitLinkPlainInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PatternContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PatternContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPattern(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeParameterContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeParameterContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeParameter(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CustomBlockTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CustomBlockTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitCustomBlockTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryCtorCallContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryCtorCallContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitPrimaryCtorCall(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ThrowStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ThrowStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitThrowStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParametersContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParametersContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitFormalParameters(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEnhancedFor(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ParExpressionContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ParExpressionContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitParExpression(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitQualifiedName(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InlineTagContentContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InlineTagContentContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitInlineTagContent(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitAnnotationType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetBodyContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetBodyContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitSnippetBody(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeBoundTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeBoundTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeBoundType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentPatternListContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentPatternListContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordComponentPatternList(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReturnTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReturnTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitReturnTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExplicitCtorCallContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExplicitCtorCallContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitExplicitCtorCall(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FloatLiteralContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FloatLiteralContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitFloatLiteral(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeCastParametersContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeCastParametersContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeCastParameters(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitExpStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BreakStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BreakStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitBreakStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.IndexInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.IndexInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitIndexInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeTypeContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeTypeContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeType(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IndexOpContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IndexOpContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitIndexOp(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordBodyDeclarationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordBodyDeclarationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordBodyDeclaration(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForInitContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForInitContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitForInit(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.QualifiedNameContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.QualifiedNameContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitQualifiedName(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.NonTightElementContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.NonTightElementContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitNonTightElement(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumBodyContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumBodyContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitEnumBody(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceSpecificationContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceSpecificationContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitResourceSpecification(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgsContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgsContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitTypeArgs(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.WhileStatContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.WhileStatContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitWhileStat(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LiteralInlineTagContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LiteralInlineTagContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitLiteralInlineTag(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordPatternDefContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordPatternDefContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitRecordPatternDef(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.DescriptionContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.DescriptionContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavadocCommentsParserVisitor)\n        return ((JavadocCommentsParserVisitor<? extends T>) (visitor)).visitDescription(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParameterContext.accept",
    "thirdPartyMethod" : "org.antlr.v4.runtime.tree.ParseTreeVisitor.visitChildren",
    "thirdPartyPackage" : "org.antlr.v4.runtime.tree",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParameterContext.accept" ],
    "fullMethods" : [ "@Override\npublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n    if (visitor instanceof JavaLanguageParserVisitor)\n        return ((JavaLanguageParserVisitor<? extends T>) (visitor)).visitFormalParameter(this);\n    else\n        return visitor.visitChildren(this);\n\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.DetailAstImpl.initialize",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getText",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.DetailAstImpl.initialize" ],
    "fullMethods" : [ "/**\n * Initializes this DetailAstImpl.\n *\n * @param token\n * \t\tthe token to generate this DetailAstImpl from\n */\npublic void initialize(Token token) {\n    text = token.getText();\n    type = token.getType();\n    lineNo = token.getLine();\n    columnNo = token.getCharPositionInLine();\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavaParser.appendHiddenCommentNodes",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getText",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavaParser.appendHiddenCommentNodes", "com.puppycrawl.tools.checkstyle.JavaParser.createCommentAstFromToken", "com.puppycrawl.tools.checkstyle.JavaParser.createSlCommentNode" ],
    "fullMethods" : [ "/**\n * Appends comment nodes to existing AST.\n * It traverses each node in AST, looks for hidden comment tokens\n * and appends found comment tokens as nodes in AST.\n *\n * @param root\n * \t\tof AST\n * @return root of AST with comment nodes\n */\npublic static DetailAST appendHiddenCommentNodes(DetailAST root) {\n    DetailAST curNode = root;\n    DetailAST lastNode = root;\n    while (curNode != null) {\n        lastNode = curNode;\n        final List<Token> hiddenBefore = ((DetailAstImpl) (curNode)).getHiddenBefore();\n        if (hiddenBefore != null) {\n            DetailAST currentSibling = curNode;\n            final ListIterator<Token> reverseCommentsIterator = hiddenBefore.listIterator(hiddenBefore.size());\n            while (reverseCommentsIterator.hasPrevious()) {\n                final DetailAST newCommentNode = createCommentAstFromToken(((CommonToken) (reverseCommentsIterator.previous())));\n                ((DetailAstImpl) (currentSibling)).addPreviousSibling(newCommentNode);\n                currentSibling = newCommentNode;\n            } \n        }\n        DetailAST toVisit = curNode.getFirstChild();\n        while ((curNode != null) && (toVisit == null)) {\n            toVisit = curNode.getNextSibling();\n            curNode = curNode.getParent();\n        } \n        curNode = toVisit;\n    } \n    if (lastNode != null) {\n        final List<Token> hiddenAfter = ((DetailAstImpl) (lastNode)).getHiddenAfter();\n        if (hiddenAfter != null) {\n            DetailAST currentSibling = lastNode;\n            for (Token token : hiddenAfter) {\n                final DetailAST newCommentNode = createCommentAstFromToken(((CommonToken) (token)));\n                ((DetailAstImpl) (currentSibling)).addNextSibling(newCommentNode);\n                currentSibling = newCommentNode;\n            }\n        }\n    }\n    return root;\n}", "/**\n * Create comment AST from token. Depending on token type\n * SINGLE_LINE_COMMENT or BLOCK_COMMENT_BEGIN is created.\n *\n * @param token\n * \t\tto create the AST\n * @return DetailAST of comment node\n */\nprivate static DetailAST createCommentAstFromToken(CommonToken token) {\n    final DetailAST commentAst;\n    if (token.getType() == TokenTypes.SINGLE_LINE_COMMENT) {\n        commentAst = createSlCommentNode(token);\n    } else {\n        commentAst = ParserUtil.createBlockCommentNode(token);\n    }\n    return commentAst;\n}", "/**\n * Create single-line comment from token.\n *\n * @param token\n * \t\tto create the AST\n * @return DetailAST with SINGLE_LINE_COMMENT type\n */\nprivate static DetailAST createSlCommentNode(Token token) {\n    final DetailAstImpl slComment = new DetailAstImpl();\n    slComment.setType(TokenTypes.SINGLE_LINE_COMMENT);\n    slComment.setText(\"//\");\n    slComment.setColumnNo(token.getCharPositionInLine());\n    slComment.setLineNo(token.getLine());\n    final DetailAstImpl slCommentContent = new DetailAstImpl();\n    slCommentContent.setType(TokenTypes.COMMENT_CONTENT);\n    // plus length of '//'\n    slCommentContent.setColumnNo(token.getCharPositionInLine() + 2);\n    slCommentContent.setLineNo(token.getLine());\n    slCommentContent.setText(token.getText());\n    slComment.addChild(slCommentContent);\n    return slComment;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.JavadocCommentsLexerUtil.getUnclosedTagNameTokens",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getText",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.JavadocCommentsLexerUtil.getUnclosedTagNameTokens" ],
    "fullMethods" : [ "/**\n * Finds unclosed tag name tokens by comparing open and close tag name tokens.\n *\n * <p>\n * This method attempts to match each closing tag with the most recent\n * unmatched opening tag of the same name, considering only tags that appear\n * before it in the token stream. Any remaining unmatched opening tags are\n * considered unclosed and returned.\n * </p>\n *\n * <p>\n * <b>Note:</b> This method must be called after lexing is complete to ensure\n * that all tokens have their index values set.\n * </p>\n *\n * @param openTagNameTokens\n * \t\ta deque of {@link Token} instances representing open tag names\n * @param closeTagNameTokens\n * \t\ta deque of {@link Token} instances representing close tag names\n * @return a set of {@link SimpleToken} instances representing unclosed tag names\n */\npublic static Set<SimpleToken> getUnclosedTagNameTokens(Deque<Token> openTagNameTokens, Deque<Token> closeTagNameTokens) {\n    final Deque<Token> unmatchedOpen = new ArrayDeque<>(openTagNameTokens);\n    for (Token closingTag : closeTagNameTokens) {\n        final Deque<Token> tempStack = new ArrayDeque<>();\n        while (!unmatchedOpen.isEmpty()) {\n            final Token openingTag = unmatchedOpen.pop();\n            if (openingTag.getText().equalsIgnoreCase(closingTag.getText()) && (openingTag.getTokenIndex() < closingTag.getTokenIndex())) {\n                break;\n            }\n            tempStack.push(openingTag);\n        } \n        // Put unmatched tags back\n        while (!tempStack.isEmpty()) {\n            unmatchedOpen.push(tempStack.pop());\n        } \n    }\n    // We cannot map to SimpleToken until lexing has completed, otherwise\n    // the token index will not be set.\n    return unmatchedOpen.stream().map(SimpleToken::from).collect(Collectors.toUnmodifiableSet());\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocNodeImpl.initialize",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getText",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocNodeImpl.initialize" ],
    "fullMethods" : [ "/**\n * Initializes the node from the given token.\n *\n * @param token\n * \t\tthe token to initialize from.\n */\npublic void initialize(Token token) {\n    type = token.getType();\n    text = token.getText();\n    lineNumber = token.getLine() - 1;\n    columnNumber = token.getCharPositionInLine();\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.isVoidTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getText",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.isVoidTag" ],
    "fullMethods" : [ "public boolean isVoidTag() {\n    String tagName = _input.LT(2).getText();\n    return VOID_TAGS.contains(tagName.toLowerCase());\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.TextAccumulator.append",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getText",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.TextAccumulator.append" ],
    "fullMethods" : [ "/**\n * Appends a TEXT token's text to the buffer and tracks the first token.\n *\n * @param token\n * \t\tthe token to accumulate\n */\npublic void append(Token token) {\n    if (buffer.isEmpty()) {\n        startToken = token;\n    }\n    buffer.append(token.getText());\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.syntaxError",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getText",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.syntaxError" ],
    "fullMethods" : [ "/**\n * Logs parser errors in Checkstyle manner. Parser can generate error\n * messages. There is special error that parser can generate. It is\n * missed close HTML tag. This case is special because parser prints\n * error like {@code \"no viable alternative at input 'b \\n *\\n'\"} and it\n * is not clear that error is about missed close HTML tag. Other error\n * messages are not special and logged simply as \"Parse Error...\".\n *\n * <p>{@inheritDoc }\n */\n@Override\npublic void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException ex) {\n    final int lineNumber = offset + line;\n    final String target;\n    if (recognizer instanceof JavadocCommentsLexer lexer) {\n        target = lexer.getPreviousToken().getText();\n    } else {\n        final int ruleIndex = ex.getCtx().getRuleIndex();\n        final String ruleName = recognizer.getRuleNames()[ruleIndex];\n        target = convertUpperCamelToUpperUnderscore(ruleName);\n    }\n    errorMessage = new ParseErrorMessage(lineNumber, MSG_JAVADOC_PARSE_RULE_ERROR, charPositionInLine, msg, target);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.ant.CheckstyleAntTask.FormatterType.<init>",
    "thirdPartyMethod" : "org.apache.tools.ant.types.EnumeratedAttribute.<init>",
    "thirdPartyPackage" : "org.apache.tools.ant.types",
    "path" : [ "com.puppycrawl.tools.checkstyle.ant.CheckstyleAntTask.FormatterType.<init>" ],
    "fullMethods" : [ "FormatterType() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitDescription",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitDescription", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitDescription(JavadocCommentsParser.DescriptionContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.DESCRIPTION, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.DetailAstImpl.initialize",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.DetailAstImpl.initialize" ],
    "fullMethods" : [ "/**\n * Initializes this DetailAstImpl.\n *\n * @param token\n * \t\tthe token to generate this DetailAstImpl from\n */\npublic void initialize(Token token) {\n    text = token.getText();\n    type = token.getType();\n    lineNo = token.getLine();\n    columnNo = token.getCharPositionInLine();\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitVersionTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitVersionTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitVersionTag(JavadocCommentsParser.VersionTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitAuthorTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitAuthorTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitAuthorTag(JavadocCommentsParser.AuthorTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSystemPropertyInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSystemPropertyInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSystemPropertyInlineTag(JavadocCommentsParser.SystemPropertyInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSnippetAttribute",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSnippetAttribute", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSnippetAttribute(JavadocCommentsParser.SnippetAttributeContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.SNIPPET_ATTRIBUTE, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlElement", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitHtmlElement(JavadocCommentsParser.HtmlElementContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.HTML_ELEMENT, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavaAstVisitor.visitIntegerLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavaAstVisitor.visitIntegerLiteral" ],
    "fullMethods" : [ "@Override\npublic DetailAstImpl visitIntegerLiteral(JavaLanguageParser.IntegerLiteralContext ctx) {\n    final int[] longTypes = new int[]{ JavaLanguageLexer.DECIMAL_LITERAL_LONG, JavaLanguageLexer.HEX_LITERAL_LONG, JavaLanguageLexer.OCT_LITERAL_LONG, JavaLanguageLexer.BINARY_LITERAL_LONG };\n    final int tokenType;\n    if (TokenUtil.isOfType(ctx.start.getType(), longTypes)) {\n        tokenType = TokenTypes.NUM_LONG;\n    } else {\n        tokenType = TokenTypes.NUM_INT;\n    }\n    return create(tokenType, ctx.start);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlTagEnd",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlTagEnd", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitHtmlTagEnd(JavadocCommentsParser.HtmlTagEndContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.HTML_TAG_END, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSnippetBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSnippetBody", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSnippetBody(JavadocCommentsParser.SnippetBodyContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.SNIPPET_BODY, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitMainDescription",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitMainDescription", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitMainDescription(JavadocCommentsParser.MainDescriptionContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitReference",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitReference", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitReference(JavadocCommentsParser.ReferenceContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.REFERENCE, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitValueInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitValueInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitValueInlineTag(JavadocCommentsParser.ValueInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocNodeImpl.initialize",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocNodeImpl.initialize" ],
    "fullMethods" : [ "/**\n * Initializes the node from the given token.\n *\n * @param token\n * \t\tthe token to initialize from.\n */\npublic void initialize(Token token) {\n    type = token.getType();\n    text = token.getText();\n    lineNumber = token.getLine() - 1;\n    columnNumber = token.getCharPositionInLine();\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSnippetInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSnippetInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.create" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSnippetInlineTag(JavadocCommentsParser.SnippetInlineTagContext ctx) {\n    final JavadocNodeImpl dummyRoot = new JavadocNodeImpl();\n    if (!ctx.snippetAttributes.isEmpty()) {\n        final JavadocNodeImpl snippetAttributes = createImaginary(JavadocCommentsTokenTypes.SNIPPET_ATTRIBUTES);\n        ctx.snippetAttributes.forEach(snippetAttributeContext -> {\n            final JavadocNodeImpl snippetAttribute = visit(snippetAttributeContext);\n            snippetAttributes.addChild(snippetAttribute);\n        });\n        dummyRoot.addChild(snippetAttributes);\n    }\n    if (ctx.COLON() != null) {\n        dummyRoot.addChild(create(((Token) (ctx.COLON().getPayload()))));\n    }\n    if (ctx.snippetBody() != null) {\n        dummyRoot.addChild(visit(ctx.snippetBody()));\n    }\n    return dummyRoot.getFirstChild();\n}", "/**\n * Creates a JavadocNodeImpl from the given token.\n *\n * @param token\n * \t\tthe token to create the JavadocNodeImpl from\n * @return a new JavadocNodeImpl initialized with the token\n */\nprivate JavadocNodeImpl create(Token token) {\n    final JavadocNodeImpl node = new JavadocNodeImpl();\n    node.initialize(token);\n    // adjust line number to the position of the block comment\n    node.setLineNumber(node.getLineNumber() + blockCommentLineNumber);\n    // adjust first line to indent of /**\n    if (node.getLineNumber() == blockCommentLineNumber) {\n        node.setColumnNumber(node.getColumnNumber() + javadocColumnNumber);\n    }\n    if (isJavadocTag(token.getType())) {\n        node.setType(JavadocCommentsTokenTypes.TAG_NAME);\n    }\n    if (token.getType() == JavadocCommentsLexer.WS) {\n        node.setType(JavadocCommentsTokenTypes.TEXT);\n    }\n    return node;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitTypeArguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitTypeArguments", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitTypeArguments(JavadocCommentsParser.TypeArgumentsContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.TYPE_ARGUMENTS, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitReturnInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitReturnInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitReturnInlineTag(JavadocCommentsParser.ReturnInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitLiteralInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitLiteralInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitLiteralInlineTag(JavadocCommentsParser.LiteralInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitLinkPlainInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitLinkPlainInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitLinkPlainInlineTag(JavadocCommentsParser.LinkPlainInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitReturnTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitReturnTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitReturnTag(JavadocCommentsParser.ReturnTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitUsesTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitUsesTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitUsesTag(JavadocCommentsParser.UsesTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavaAstVisitor.visitPrefix",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavaAstVisitor.visitPrefix" ],
    "fullMethods" : [ "@Override\npublic DetailAstImpl visitPrefix(JavaLanguageParser.PrefixContext ctx) {\n    final int tokenType = switch (ctx.prefix.getType()) {\n        case JavaLanguageLexer.PLUS ->\n            TokenTypes.UNARY_PLUS;\n        case JavaLanguageLexer.MINUS ->\n            TokenTypes.UNARY_MINUS;\n        default ->\n            ctx.prefix.getType();\n    };\n    final DetailAstImpl prefix = create(tokenType, ctx.prefix);\n    prefix.addChild(visit(ctx.expr()));\n    return prefix;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.isYieldStatement" ],
    "fullMethods" : [ "public final BlockStatementContext blockStatement() throws RecognitionException {\n    BlockStatementContext _localctx = new BlockStatementContext(_ctx, getState());\n    enterRule(_localctx, 154, RULE_blockStatement);\n    try {\n        setState(991);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 109, _ctx)) {\n            case 1 :\n                _localctx = new LocalVarContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(985);\n                    if (!(!isYieldStatement()))\n                        throw new FailedPredicateException(this, \"!isYieldStatement()\");\n\n                    setState(986);\n                    localVariableDeclaration();\n                    setState(987);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new StatContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(989);\n                    statement();\n                }\n                break;\n            case 3 :\n                _localctx = new LocalTypeContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(990);\n                    localTypeDeclaration();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "/**\n * Checks if next statement is a yield statement.\n *\n * @return true if next statement is a yield statement.\n */\nprivate boolean isYieldStatement() {\n    return (_input.LT(1).getType() == JavaLanguageLexer.LITERAL_YIELD) && (switchBlockDepth > 0);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSummaryInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSummaryInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSummaryInlineTag(JavadocCommentsParser.SummaryInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitVoidElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitVoidElement", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitVoidElement(JavadocCommentsParser.VoidElementContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.VOID_ELEMENT, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitMemberReference",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitMemberReference", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitMemberReference(JavadocCommentsParser.MemberReferenceContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.MEMBER_REFERENCE, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitJavadoc",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitJavadoc", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitJavadoc(JavadocCommentsParser.JavadocContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.JAVADOC_CONTENT, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitNonTightElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitNonTightElement", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.create" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitNonTightElement(JavadocCommentsParser.NonTightElementContext ctx) {\n    if (firstNonTightHtmlTag == null) {\n        final ParseTree htmlTagStart = ctx.getChild(0);\n        final ParseTree tagNameToken = htmlTagStart.getChild(1);\n        firstNonTightHtmlTag = create(((Token) (tagNameToken.getPayload())));\n    }\n    return flattenedTree(ctx);\n}", "/**\n * Creates a JavadocNodeImpl from the given token.\n *\n * @param token\n * \t\tthe token to create the JavadocNodeImpl from\n * @return a new JavadocNodeImpl initialized with the token\n */\nprivate JavadocNodeImpl create(Token token) {\n    final JavadocNodeImpl node = new JavadocNodeImpl();\n    node.initialize(token);\n    // adjust line number to the position of the block comment\n    node.setLineNumber(node.getLineNumber() + blockCommentLineNumber);\n    // adjust first line to indent of /**\n    if (node.getLineNumber() == blockCommentLineNumber) {\n        node.setColumnNumber(node.getColumnNumber() + javadocColumnNumber);\n    }\n    if (isJavadocTag(token.getType())) {\n        node.setType(JavadocCommentsTokenTypes.TAG_NAME);\n    }\n    if (token.getType() == JavadocCommentsLexer.WS) {\n        node.setType(JavadocCommentsTokenTypes.TEXT);\n    }\n    return node;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitIndexInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitIndexInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitIndexInlineTag(JavadocCommentsParser.IndexInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.TextAccumulator.flushTo",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.TextAccumulator.flushTo", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.create" ],
    "fullMethods" : [ "/**\n * Flushes the accumulated buffer into a single {@link JavadocNodeImpl} node\n * and adds it to the given parent. Clears the buffer after flushing.\n *\n * @param parent\n * \t\tthe parent node to add the new node to\n */\npublic void flushTo(JavadocNodeImpl parent) {\n    if (!buffer.isEmpty()) {\n        final JavadocNodeImpl startNode = create(startToken);\n        startNode.setText(buffer.toString());\n        parent.addChild(startNode);\n        buffer.setLength(0);\n    }\n}", "/**\n * Creates a JavadocNodeImpl from the given token.\n *\n * @param token\n * \t\tthe token to create the JavadocNodeImpl from\n * @return a new JavadocNodeImpl initialized with the token\n */\nprivate JavadocNodeImpl create(Token token) {\n    final JavadocNodeImpl node = new JavadocNodeImpl();\n    node.initialize(token);\n    // adjust line number to the position of the block comment\n    node.setLineNumber(node.getLineNumber() + blockCommentLineNumber);\n    // adjust first line to indent of /**\n    if (node.getLineNumber() == blockCommentLineNumber) {\n        node.setColumnNumber(node.getColumnNumber() + javadocColumnNumber);\n    }\n    if (isJavadocTag(token.getType())) {\n        node.setType(JavadocCommentsTokenTypes.TAG_NAME);\n    }\n    if (token.getType() == JavadocCommentsLexer.WS) {\n        node.setType(JavadocCommentsTokenTypes.TEXT);\n    }\n    return node;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlAttribute",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlAttribute", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitHtmlAttribute(JavadocCommentsParser.HtmlAttributeContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.HTML_ATTRIBUTE, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitCustomBlockTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitCustomBlockTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitCustomBlockTag(JavadocCommentsParser.CustomBlockTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitTightElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitTightElement", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitTightElement(JavadocCommentsParser.TightElementContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitInlineTagContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitInlineTagContent", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitInlineTagContent(JavadocCommentsParser.InlineTagContentContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlComment",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlComment", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitHtmlComment(JavadocCommentsParser.HtmlCommentContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.HTML_COMMENT, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitCodeInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitCodeInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitCodeInlineTag(JavadocCommentsParser.CodeInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSerialTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSerialTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSerialTag(JavadocCommentsParser.SerialTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitProvidesTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitProvidesTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitProvidesTag(JavadocCommentsParser.ProvidesTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.sempred",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.sempred", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement_sempred", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.isYieldStatement" ],
    "fullMethods" : [ "public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {\n    switch (ruleIndex) {\n        case 77 :\n            return blockStatement_sempred(((BlockStatementContext) (_localctx)), predIndex);\n        case 109 :\n            return expr_sempred(((ExprContext) (_localctx)), predIndex);\n    }\n    return true;\n}", "private boolean blockStatement_sempred(BlockStatementContext _localctx, int predIndex) {\n    switch (predIndex) {\n        case 0 :\n            return !isYieldStatement();\n    }\n    return true;\n}", "/**\n * Checks if next statement is a yield statement.\n *\n * @return true if next statement is a yield statement.\n */\nprivate boolean isYieldStatement() {\n    return (_input.LT(1).getType() == JavaLanguageLexer.LITERAL_YIELD) && (switchBlockDepth > 0);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlTagStart",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlTagStart", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.create" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitHtmlTagStart(JavadocCommentsParser.HtmlTagStartContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(JavadocCommentsTokenTypes.HTML_TAG_START);\n    javadocNode.addChild(create(((Token) (ctx.TAG_OPEN().getPayload()))));\n    javadocNode.addChild(create(((Token) (ctx.TAG_NAME().getPayload()))));\n    if (!ctx.htmlAttributes.isEmpty()) {\n        final JavadocNodeImpl htmlAttributes = createImaginary(JavadocCommentsTokenTypes.HTML_ATTRIBUTES);\n        ctx.htmlAttributes.forEach(htmlAttributeContext -> {\n            final JavadocNodeImpl htmlAttribute = visit(htmlAttributeContext);\n            htmlAttributes.addChild(htmlAttribute);\n        });\n        javadocNode.addChild(htmlAttributes);\n    }\n    final Token tagClose = ((Token) (ctx.TAG_CLOSE().getPayload()));\n    addHiddenTokensToTheLeft(tagClose, javadocNode);\n    javadocNode.addChild(create(tagClose));\n    return javadocNode;\n}", "/**\n * Creates a JavadocNodeImpl from the given token.\n *\n * @param token\n * \t\tthe token to create the JavadocNodeImpl from\n * @return a new JavadocNodeImpl initialized with the token\n */\nprivate JavadocNodeImpl create(Token token) {\n    final JavadocNodeImpl node = new JavadocNodeImpl();\n    node.initialize(token);\n    // adjust line number to the position of the block comment\n    node.setLineNumber(node.getLineNumber() + blockCommentLineNumber);\n    // adjust first line to indent of /**\n    if (node.getLineNumber() == blockCommentLineNumber) {\n        node.setColumnNumber(node.getColumnNumber() + javadocColumnNumber);\n    }\n    if (isJavadocTag(token.getType())) {\n        node.setType(JavadocCommentsTokenTypes.TAG_NAME);\n    }\n    if (token.getType() == JavadocCommentsLexer.WS) {\n        node.setType(JavadocCommentsTokenTypes.TEXT);\n    }\n    return node;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitNonTightHtmlContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitNonTightHtmlContent", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitNonTightHtmlContent(JavadocCommentsParser.NonTightHtmlContentContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.HTML_CONTENT, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavaAstVisitor.visitPostfix",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavaAstVisitor.visitPostfix" ],
    "fullMethods" : [ "@Override\npublic DetailAstImpl visitPostfix(JavaLanguageParser.PostfixContext ctx) {\n    final DetailAstImpl postfix;\n    if (ctx.postfix.getType() == JavaLanguageLexer.INC) {\n        postfix = create(TokenTypes.POST_INC, ctx.postfix);\n    } else {\n        postfix = create(TokenTypes.POST_DEC, ctx.postfix);\n    }\n    postfix.addChild(visit(ctx.expr()));\n    return postfix;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitDeprecatedTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitDeprecatedTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitDeprecatedTag(JavadocCommentsParser.DeprecatedTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitExceptionTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitExceptionTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitExceptionTag(JavadocCommentsParser.ExceptionTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitCustomInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitCustomInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitCustomInlineTag(JavadocCommentsParser.CustomInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSinceTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSinceTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSinceTag(JavadocCommentsParser.SinceTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitLinkInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitLinkInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitLinkInlineTag(JavadocCommentsParser.LinkInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSelfClosingElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSelfClosingElement", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.create" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSelfClosingElement(JavadocCommentsParser.SelfClosingElementContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(JavadocCommentsTokenTypes.VOID_ELEMENT);\n    javadocNode.addChild(create(((Token) (ctx.TAG_OPEN().getPayload()))));\n    javadocNode.addChild(create(((Token) (ctx.TAG_NAME().getPayload()))));\n    if (!ctx.htmlAttributes.isEmpty()) {\n        final JavadocNodeImpl htmlAttributes = createImaginary(JavadocCommentsTokenTypes.HTML_ATTRIBUTES);\n        ctx.htmlAttributes.forEach(htmlAttributeContext -> {\n            final JavadocNodeImpl htmlAttribute = visit(htmlAttributeContext);\n            htmlAttributes.addChild(htmlAttribute);\n        });\n        javadocNode.addChild(htmlAttributes);\n    }\n    javadocNode.addChild(create(((Token) (ctx.TAG_SLASH_CLOSE().getPayload()))));\n    return javadocNode;\n}", "/**\n * Creates a JavadocNodeImpl from the given token.\n *\n * @param token\n * \t\tthe token to create the JavadocNodeImpl from\n * @return a new JavadocNodeImpl initialized with the token\n */\nprivate JavadocNodeImpl create(Token token) {\n    final JavadocNodeImpl node = new JavadocNodeImpl();\n    node.initialize(token);\n    // adjust line number to the position of the block comment\n    node.setLineNumber(node.getLineNumber() + blockCommentLineNumber);\n    // adjust first line to indent of /**\n    if (node.getLineNumber() == blockCommentLineNumber) {\n        node.setColumnNumber(node.getColumnNumber() + javadocColumnNumber);\n    }\n    if (isJavadocTag(token.getType())) {\n        node.setType(JavadocCommentsTokenTypes.TAG_NAME);\n    }\n    if (token.getType() == JavadocCommentsLexer.WS) {\n        node.setType(JavadocCommentsTokenTypes.TEXT);\n    }\n    return node;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSerialDataTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSerialDataTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSerialDataTag(JavadocCommentsParser.SerialDataTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitInlineTag" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitInlineTag(JavadocCommentsParser.InlineTagContext ctx) {\n    final JavadocNodeImpl inlineTagNode = createImaginary(JavadocCommentsTokenTypes.JAVADOC_INLINE_TAG);\n    final ParseTree tagContent = ctx.inlineTagContent().getChild(0);\n    if (tagContent instanceof ParserRuleContext context) {\n        final Token tagName = ((Token) (context.getChild(0).getPayload()));\n        final int tokenType = tagName.getType();\n        final JavadocNodeImpl specificTagNode = switch (tokenType) {\n            case JavadocCommentsLexer.CODE ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.CODE_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.LINK ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.LINK_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.LINKPLAIN ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.LINKPLAIN_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.VALUE ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.VALUE_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.INHERIT_DOC ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.INHERIT_DOC_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.SUMMARY ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.SUMMARY_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.SYSTEM_PROPERTY ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.SYSTEM_PROPERTY_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.INDEX ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.INDEX_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.RETURN ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.RETURN_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.LITERAL ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.LITERAL_INLINE_TAG, ctx);\n            case JavadocCommentsLexer.SNIPPET ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.SNIPPET_INLINE_TAG, ctx);\n            default ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.CUSTOM_INLINE_TAG, ctx);\n        };\n        inlineTagNode.addChild(specificTagNode);\n    }\n    return inlineTagNode;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitQualifiedName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitQualifiedName", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitQualifiedName(JavadocCommentsParser.QualifiedNameContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHiddenTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHiddenTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitHiddenTag(JavadocCommentsParser.HiddenTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlContent", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitHtmlContent(JavadocCommentsParser.HtmlContentContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.HTML_CONTENT, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSerialFieldTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSerialFieldTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSerialFieldTag(JavadocCommentsParser.SerialFieldTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitParameterTypeList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitParameterTypeList", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitParameterTypeList(JavadocCommentsParser.ParameterTypeListContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.PARAMETER_TYPE_LIST, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitThrowsTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitThrowsTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitThrowsTag(JavadocCommentsParser.ThrowsTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitTypeName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitTypeName", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitTypeName(JavadocCommentsParser.TypeNameContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavaAstVisitor.visitFloatLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavaAstVisitor.visitFloatLiteral" ],
    "fullMethods" : [ "@Override\npublic DetailAstImpl visitFloatLiteral(JavaLanguageParser.FloatLiteralContext ctx) {\n    final DetailAstImpl floatLiteral;\n    if (TokenUtil.isOfType(ctx.start.getType(), JavaLanguageLexer.DOUBLE_LITERAL, JavaLanguageLexer.HEX_DOUBLE_LITERAL)) {\n        floatLiteral = create(TokenTypes.NUM_DOUBLE, ctx.start);\n    } else {\n        floatLiteral = create(TokenTypes.NUM_FLOAT, ctx.start);\n    }\n    return floatLiteral;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitParameterTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitParameterTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitParameterTag(JavadocCommentsParser.ParameterTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitTypeArgument",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitTypeArgument", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitTypeArgument(JavadocCommentsParser.TypeArgumentContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.TYPE_ARGUMENT, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlCommentContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitHtmlCommentContent", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.buildImaginaryNode", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitHtmlCommentContent(JavadocCommentsParser.HtmlCommentContentContext ctx) {\n    return buildImaginaryNode(JavadocCommentsTokenTypes.HTML_COMMENT_CONTENT, ctx);\n}", "/**\n * Creates an imaginary JavadocNodeImpl of the given token type and\n * processes all children of the given ParserRuleContext.\n *\n * @param tokenType\n * \t\tthe token type of this JavadocNodeImpl\n * @param ctx\n * \t\tthe ParserRuleContext whose children are to be processed\n * @return new JavadocNodeImpl of given type with processed children\n */\nprivate JavadocNodeImpl buildImaginaryNode(int tokenType, ParserRuleContext ctx) {\n    final JavadocNodeImpl javadocNode = createImaginary(tokenType);\n    processChildren(javadocNode, ctx.children);\n    return javadocNode;\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSeeTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitSeeTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitSeeTag(JavadocCommentsParser.SeeTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.JavadocCommentsLexerUtil.isOpenTagName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.JavadocCommentsLexerUtil.isOpenTagName" ],
    "fullMethods" : [ "/**\n * Checks if the previous token is an open tag name.\n *\n * @param previousToken\n * \t\tthe previous token to check\n * @return true if the previous token is null or not a closing tag, false otherwise\n */\npublic static boolean isOpenTagName(Token previousToken) {\n    return (previousToken == null) || (previousToken.getType() != JavadocCommentsTokenTypes.TAG_SLASH);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitBlockTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitBlockTag" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitBlockTag(JavadocCommentsParser.BlockTagContext ctx) {\n    final JavadocNodeImpl blockTagNode = createImaginary(JavadocCommentsTokenTypes.JAVADOC_BLOCK_TAG);\n    final ParseTree tag = ctx.getChild(0);\n    if (tag instanceof ParserRuleContext context) {\n        final Token tagName = ((Token) (context.getChild(1).getPayload()));\n        final int tokenType = tagName.getType();\n        final JavadocNodeImpl specificTagNode = switch (tokenType) {\n            case JavadocCommentsLexer.AUTHOR ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.AUTHOR_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.DEPRECATED ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.DEPRECATED_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.RETURN ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.RETURN_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.PARAM ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.PARAM_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.THROWS ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.THROWS_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.EXCEPTION ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.EXCEPTION_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.SINCE ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.SINCE_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.VERSION ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.VERSION_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.SEE ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.SEE_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.LITERAL_HIDDEN ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.HIDDEN_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.USES ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.USES_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.PROVIDES ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.PROVIDES_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.SERIAL ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.SERIAL_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.SERIAL_DATA ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.SERIAL_DATA_BLOCK_TAG, ctx);\n            case JavadocCommentsLexer.SERIAL_FIELD ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.SERIAL_FIELD_BLOCK_TAG, ctx);\n            default ->\n                buildImaginaryNode(JavadocCommentsTokenTypes.CUSTOM_BLOCK_TAG, ctx);\n        };\n        blockTagNode.addChild(specificTagNode);\n    }\n    return blockTagNode;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitInheritDocInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.visitInheritDocInlineTag", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.flattenedTree", "com.puppycrawl.tools.checkstyle.JavadocCommentsAstVisitor.processChildren" ],
    "fullMethods" : [ "@Override\npublic JavadocNodeImpl visitInheritDocInlineTag(JavadocCommentsParser.InheritDocInlineTagContext ctx) {\n    return flattenedTree(ctx);\n}", "/**\n * Builds the AST for a particular node, then returns a \"flattened\" tree\n * of siblings.\n *\n * @param ctx\n * \t\tthe ParserRuleContext to base tree on\n * @return flattened DetailAstImpl\n */\nprivate JavadocNodeImpl flattenedTree(ParserRuleContext ctx) {\n    final JavadocNodeImpl dummyNode = new JavadocNodeImpl();\n    processChildren(dummyNode, ctx.children);\n    return dummyNode.getFirstChild();\n}", "/**\n * Adds all the children from the given ParseTree or ParserRuleContext\n * list to the parent JavadocNodeImpl.\n *\n * @param parent\n * \t\tthe JavadocNodeImpl to add children to\n * @param children\n * \t\tthe list of children to add\n */\nprivate void processChildren(JavadocNodeImpl parent, List<? extends ParseTree> children) {\n    for (ParseTree child : children) {\n        if (child instanceof TerminalNode terminalNode) {\n            final Token token = ((Token) (terminalNode.getPayload()));\n            // Add hidden tokens before this token\n            addHiddenTokensToTheLeft(token, parent);\n            if (isTextToken(token)) {\n                accumulator.append(token);\n            } else if (token.getType() != Token.EOF) {\n                accumulator.flushTo(parent);\n                parent.addChild(create(token));\n            }\n        } else {\n            accumulator.flushTo(parent);\n            final Token token = ((ParserRuleContext) (child)).getStart();\n            addHiddenTokensToTheLeft(token, parent);\n            parent.addChild(visit(child));\n        }\n    }\n    accumulator.flushTo(parent);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.emit",
    "thirdPartyMethod" : "org.antlr.v4.runtime.Token.getType",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsLexer.emit" ],
    "fullMethods" : [ "@Override\npublic void emit(Token token) {\n    super.emit(token);\n    if (token.getType() == TAG_NAME) {\n        if (JavadocCommentsLexerUtil.isOpenTagName(previousToken)) {\n            openTagNameTokens.push(token);\n        } else {\n            closeTagNameTokens.push(token);\n        }\n    }\n    previousTokenType = token.getType();\n    previousToken = token;\n    if (previousTokenType != NEWLINE) {\n        afterNewline = false;\n    }\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArguments" ],
    "fullMethods" : [ "public final TypeArgumentsContext typeArguments() throws RecognitionException {\n    TypeArgumentsContext _localctx = new TypeArgumentsContext(_ctx, getState());\n    enterRule(_localctx, 262, RULE_typeArguments);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1668);\n            match(LT);\n            setState(1669);\n            typeArgument();\n            setState(1674);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1670);\n                        match(COMMA);\n                        setState(1671);\n                        typeArgument();\n                    }\n                }\n                setState(1676);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(1677);\n            match(GT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.mainDescription",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.mainDescription" ],
    "fullMethods" : [ "public final MainDescriptionContext mainDescription() throws RecognitionException {\n    MainDescriptionContext _localctx = new MainDescriptionContext(_ctx, getState());\n    enterRule(_localctx, 2, RULE_mainDescription);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(125);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(125);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 2, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(121);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(122);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(123);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(124);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(127);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 3, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclarators",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclarators" ],
    "fullMethods" : [ "public final VariableDeclaratorsContext variableDeclarators(List<ModifierContext> mods, TypeTypeContext type) throws RecognitionException {\n    VariableDeclaratorsContext _localctx = new VariableDeclaratorsContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 84, RULE_variableDeclarators);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(661);\n            variableDeclarator(mods, type);\n            setState(666);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(662);\n                        match(COMMA);\n                        setState(663);\n                        variableDeclarator(mods, type);\n                    }\n                }\n                setState(668);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.creator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.creator" ],
    "fullMethods" : [ "public final CreatorContext creator() throws RecognitionException {\n    CreatorContext _localctx = new CreatorContext(_ctx, getState());\n    enterRule(_localctx, 230, RULE_creator);\n    try {\n        setState(1557);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LT :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1545);\n                    nonWildcardTypeArguments();\n                    setState(1546);\n                    createdName();\n                    setState(1547);\n                    classCreatorRest();\n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1549);\n                    annotations(false);\n                    setState(1550);\n                    createdName();\n                    setState(1555);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LBRACK :\n                        case AT :\n                            {\n                                setState(1551);\n                                annotations(false);\n                                setState(1552);\n                                arrayCreatorRest();\n                            }\n                            break;\n                        case LPAREN :\n                            {\n                                setState(1554);\n                                classCreatorRest();\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumBodyDeclarations",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumBodyDeclarations" ],
    "fullMethods" : [ "public final EnumBodyDeclarationsContext enumBodyDeclarations() throws RecognitionException {\n    EnumBodyDeclarationsContext _localctx = new EnumBodyDeclarationsContext(_ctx, getState());\n    enterRule(_localctx, 54, RULE_enumBodyDeclarations);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(522);\n            match(SEMI);\n            setState(526);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028812048202823L) != 0)) || ((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 9007267974217729L) != 0))) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                {\n                    {\n                        setState(523);\n                        classBodyDeclaration();\n                    }\n                }\n                setState(528);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation" ],
    "fullMethods" : [ "public final ExplicitConstructorInvocationContext explicitConstructorInvocation() throws RecognitionException {\n    ExplicitConstructorInvocationContext _localctx = new ExplicitConstructorInvocationContext(_ctx, getState());\n    enterRule(_localctx, 150, RULE_explicitConstructorInvocation);\n    int _la;\n    try {\n        setState(974);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 107, _ctx)) {\n            case 1 :\n                _localctx = new ExplicitCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(959);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(958);\n                            typeArguments();\n                        }\n                    }\n                    setState(961);\n                    _la = _input.LA(1);\n                    if (!((_la == LITERAL_THIS) || (_la == LITERAL_SUPER))) {\n                        _errHandler.recoverInline(this);\n                    } else {\n                        if (_input.LA(1) == Token.EOF)\n                            matchedEOF = true;\n\n                        _errHandler.reportMatch(this);\n                        consume();\n                    }\n                    setState(962);\n                    arguments();\n                    setState(963);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new PrimaryCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(965);\n                    expr(0);\n                    setState(966);\n                    match(DOT);\n                    setState(968);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(967);\n                            typeArguments();\n                        }\n                    }\n                    setState(970);\n                    match(LITERAL_SUPER);\n                    setState(971);\n                    arguments();\n                    setState(972);\n                    match(SEMI);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.valueInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.valueInlineTag" ],
    "fullMethods" : [ "public final ValueInlineTagContext valueInlineTag() throws RecognitionException {\n    ValueInlineTagContext _localctx = new ValueInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 48, RULE_valueInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(289);\n            ((ValueInlineTagContext) (_localctx)).tagName = match(VALUE);\n            setState(291);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == FORMAT_SPECIFIER) {\n                {\n                    setState(290);\n                    match(FORMAT_SPECIFIER);\n                }\n            }\n            setState(294);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((_la == IDENTIFIER) || (_la == HASH)) {\n                {\n                    setState(293);\n                    reference();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localTypeDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localTypeDeclaration" ],
    "fullMethods" : [ "public final LocalTypeDeclarationContext localTypeDeclaration() throws RecognitionException {\n    LocalTypeDeclarationContext _localctx = new LocalTypeDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 158, RULE_localTypeDeclaration);\n    int _la;\n    try {\n        setState(1015);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1005);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while (((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028798088511495L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 1649267441665L) != 0))) {\n                        {\n                            {\n                                setState(1002);\n                                ((LocalTypeDeclarationContext) (_localctx)).modifier = modifier();\n                                ((LocalTypeDeclarationContext) (_localctx)).mods.add(((LocalTypeDeclarationContext) (_localctx)).modifier);\n                            }\n                        }\n                        setState(1007);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1012);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LITERAL_CLASS :\n                            {\n                                setState(1008);\n                                classDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case ENUM :\n                            {\n                                setState(1009);\n                                enumDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case LITERAL_INTERFACE :\n                            {\n                                setState(1010);\n                                interfaceDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case LITERAL_RECORD :\n                            {\n                                setState(1011);\n                                recordDeclaration(_localctx.mods);\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1014);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classExtends",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classExtends" ],
    "fullMethods" : [ "public final ClassExtendsContext classExtends() throws RecognitionException {\n    ClassExtendsContext _localctx = new ClassExtendsContext(_ctx, getState());\n    enterRule(_localctx, 32, RULE_classExtends);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(445);\n            match(EXTENDS_CLAUSE);\n            setState(446);\n            ((ClassExtendsContext) (_localctx)).type = typeType(false);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement" ],
    "fullMethods" : [ "public final BlockStatementContext blockStatement() throws RecognitionException {\n    BlockStatementContext _localctx = new BlockStatementContext(_ctx, getState());\n    enterRule(_localctx, 154, RULE_blockStatement);\n    try {\n        setState(991);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 109, _ctx)) {\n            case 1 :\n                _localctx = new LocalVarContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(985);\n                    if (!(!isYieldStatement()))\n                        throw new FailedPredicateException(this, \"!isYieldStatement()\");\n\n                    setState(986);\n                    localVariableDeclaration();\n                    setState(987);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new StatContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(989);\n                    statement();\n                }\n                break;\n            case 3 :\n                _localctx = new LocalTypeContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(990);\n                    localTypeDeclaration();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elseStat",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elseStat" ],
    "fullMethods" : [ "public final ElseStatContext elseStat() throws RecognitionException {\n    ElseStatContext _localctx = new ElseStatContext(_ctx, getState());\n    enterRule(_localctx, 174, RULE_elseStat);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1156);\n            match(LITERAL_ELSE);\n            setState(1157);\n            statement();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeBody" ],
    "fullMethods" : [ "public final AnnotationTypeBodyContext annotationTypeBody() throws RecognitionException {\n    AnnotationTypeBodyContext _localctx = new AnnotationTypeBodyContext(_ctx, getState());\n    enterRule(_localctx, 136, RULE_annotationTypeBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(878);\n            match(LCURLY);\n            setState(882);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028803458268231L) != 0)) || ((((_la - 153) & (~0x3f)) == 0) && (((1L << (_la - 153)) & 2828401303477157889L) != 0))) || (_la == LITERAL_UNDERSCORE)) {\n                {\n                    {\n                        setState(879);\n                        annotationTypeElementDeclaration();\n                    }\n                }\n                setState(884);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(885);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeType" ],
    "fullMethods" : [ "public final TypeTypeContext typeType(boolean createImaginaryNode) throws RecognitionException {\n    TypeTypeContext _localctx = new TypeTypeContext(_ctx, getState(), createImaginaryNode);\n    enterRule(_localctx, 254, RULE_typeType);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1650);\n            annotations(false);\n            setState(1651);\n            classOrInterfaceOrPrimitiveType();\n            setState(1655);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 195, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1652);\n                            arrayDeclarator();\n                        }\n                    }\n                }\n                setState(1657);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 195, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enhancedForControl",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enhancedForControl" ],
    "fullMethods" : [ "public final EnhancedForControlContext enhancedForControl() throws RecognitionException {\n    EnhancedForControlContext _localctx = new EnhancedForControlContext(_ctx, getState());\n    enterRule(_localctx, 208, RULE_enhancedForControl);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1291);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 151, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1288);\n                            ((EnhancedForControlContext) (_localctx)).variableModifier = variableModifier();\n                            ((EnhancedForControlContext) (_localctx)).mods.add(((EnhancedForControlContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(1293);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 151, _ctx);\n            } \n            setState(1294);\n            ((EnhancedForControlContext) (_localctx)).type = typeType(true);\n            setState(1295);\n            variableDeclaratorId(_localctx.mods, _localctx.type);\n            setState(1296);\n            match(COLON);\n            setState(1297);\n            expression();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValuePair",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValuePair" ],
    "fullMethods" : [ "public final ElementValuePairContext elementValuePair() throws RecognitionException {\n    ElementValuePairContext _localctx = new ElementValuePairContext(_ctx, getState());\n    enterRule(_localctx, 128, RULE_elementValuePair);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(848);\n            id();\n            setState(849);\n            match(ASSIGN);\n            setState(850);\n            elementValue();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typePattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typePattern" ],
    "fullMethods" : [ "public final TypePatternContext typePattern() throws RecognitionException {\n    TypePatternContext _localctx = new TypePatternContext(_ctx, getState());\n    enterRule(_localctx, 278, RULE_typePattern);\n    try {\n        int _alt;\n        setState(1732);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 206, _ctx)) {\n            case 1 :\n                _localctx = new TypePatternDefContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1725);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 205, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(1722);\n                                    ((TypePatternDefContext) (_localctx)).modifier = modifier();\n                                    ((TypePatternDefContext) (_localctx)).mods.add(((TypePatternDefContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(1727);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 205, _ctx);\n                    } \n                    setState(1728);\n                    ((TypePatternDefContext) (_localctx)).type = typeType(true);\n                    setState(1729);\n                    id();\n                }\n                break;\n            case 2 :\n                _localctx = new UnnamedPatternDefContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1731);\n                    match(LITERAL_UNDERSCORE);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.codeInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.codeInlineTag" ],
    "fullMethods" : [ "public final CodeInlineTagContext codeInlineTag() throws RecognitionException {\n    CodeInlineTagContext _localctx = new CodeInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 42, RULE_codeInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(272);\n            ((CodeInlineTagContext) (_localctx)).tagName = match(CODE);\n            setState(276);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == TEXT) {\n                {\n                    {\n                        setState(273);\n                        match(TEXT);\n                    }\n                }\n                setState(278);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBodyDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBodyDeclaration" ],
    "fullMethods" : [ "public final InterfaceBodyDeclarationContext interfaceBodyDeclaration() throws RecognitionException {\n    InterfaceBodyDeclarationContext _localctx = new InterfaceBodyDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 78, RULE_interfaceBodyDeclaration);\n    try {\n        int _alt;\n        setState(633);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case LT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(628);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 52, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(625);\n                                    ((InterfaceBodyDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((InterfaceBodyDeclarationContext) (_localctx)).mods.add(((InterfaceBodyDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(630);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 52, _ctx);\n                    } \n                    setState(631);\n                    interfaceMemberDeclaration(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(632);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resource",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resource" ],
    "fullMethods" : [ "public final ResourceContext resource() throws RecognitionException {\n    ResourceContext _localctx = new ResourceContext(_ctx, getState());\n    enterRule(_localctx, 188, RULE_resource);\n    try {\n        setState(1202);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 134, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1200);\n                    resourceDeclaration();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1201);\n                    variableAccess();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlCommentContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlCommentContent" ],
    "fullMethods" : [ "public final HtmlCommentContentContext htmlCommentContent() throws RecognitionException {\n    HtmlCommentContentContext _localctx = new HtmlCommentContentContext(_ctx, getState());\n    enterRule(_localctx, 108, RULE_htmlCommentContent);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(485);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == TEXT) {\n                {\n                    {\n                        setState(482);\n                        match(TEXT);\n                    }\n                }\n                setState(487);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resourceDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resourceDeclaration" ],
    "fullMethods" : [ "public final ResourceDeclarationContext resourceDeclaration() throws RecognitionException {\n    ResourceDeclarationContext _localctx = new ResourceDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 190, RULE_resourceDeclaration);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1207);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 135, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1204);\n                            ((ResourceDeclarationContext) (_localctx)).variableModifier = variableModifier();\n                            ((ResourceDeclarationContext) (_localctx)).mods.add(((ResourceDeclarationContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(1209);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 135, _ctx);\n            } \n            setState(1210);\n            ((ResourceDeclarationContext) (_localctx)).type = classOrInterfaceType(true);\n            setState(1211);\n            variableDeclaratorId(_localctx.mods, _localctx.type);\n            setState(1212);\n            match(ASSIGN);\n            setState(1213);\n            expression();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeDeclaration" ],
    "fullMethods" : [ "public final TypeDeclarationContext typeDeclaration() throws RecognitionException {\n    TypeDeclarationContext _localctx = new TypeDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 6, RULE_typeDeclaration);\n    try {\n        int _alt;\n        setState(336);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(327);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 6, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(324);\n                                    ((TypeDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((TypeDeclarationContext) (_localctx)).mods.add(((TypeDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(329);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 6, _ctx);\n                    } \n                    setState(330);\n                    ((TypeDeclarationContext) (_localctx)).type = types(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(332);\n                    _errHandler.sync(this);\n                    _alt = 1;\n                    do {\n                        switch (_alt) {\n                            case 1 :\n                                {\n                                    {\n                                        setState(331);\n                                        ((TypeDeclarationContext) (_localctx)).SEMI = match(SEMI);\n                                        ((TypeDeclarationContext) (_localctx)).semi.add(((TypeDeclarationContext) (_localctx)).SEMI);\n                                    }\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                        setState(334);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 7, _ctx);\n                    } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.compactConstructorDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.compactConstructorDeclaration" ],
    "fullMethods" : [ "public final CompactConstructorDeclarationContext compactConstructorDeclaration() throws RecognitionException {\n    CompactConstructorDeclarationContext _localctx = new CompactConstructorDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 30, RULE_compactConstructorDeclaration);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(439);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 24, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(436);\n                            ((CompactConstructorDeclarationContext) (_localctx)).modifier = modifier();\n                            ((CompactConstructorDeclarationContext) (_localctx)).mods.add(((CompactConstructorDeclarationContext) (_localctx)).modifier);\n                        }\n                    }\n                }\n                setState(441);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 24, _ctx);\n            } \n            setState(442);\n            id();\n            setState(443);\n            constructorBlock();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.authorTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.authorTag" ],
    "fullMethods" : [ "public final AuthorTagContext authorTag() throws RecognitionException {\n    AuthorTagContext _localctx = new AuthorTagContext(_ctx, getState());\n    enterRule(_localctx, 6, RULE_authorTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(147);\n            match(AT_SIGN);\n            setState(148);\n            ((AuthorTagContext) (_localctx)).tagName = match(AUTHOR);\n            setState(150);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 5, _ctx)) {\n                case 1 :\n                    {\n                        setState(149);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.superSuffix",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.superSuffix" ],
    "fullMethods" : [ "public final SuperSuffixContext superSuffix() throws RecognitionException {\n    SuperSuffixContext _localctx = new SuperSuffixContext(_ctx, getState());\n    enterRule(_localctx, 264, RULE_superSuffix);\n    int _la;\n    try {\n        setState(1693);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LPAREN :\n                _localctx = new SuperSuffixSimpleContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1679);\n                    match(LPAREN);\n                    setState(1681);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1680);\n                            expressionList();\n                        }\n                    }\n                    setState(1683);\n                    match(RPAREN);\n                }\n                break;\n            case DOT :\n                _localctx = new SuperSuffixDotContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1684);\n                    match(DOT);\n                    setState(1685);\n                    id();\n                    setState(1691);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 200, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1686);\n                                match(LPAREN);\n                                setState(1688);\n                                _errHandler.sync(this);\n                                _la = _input.LA(1);\n                                if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                    {\n                                        setState(1687);\n                                        expressionList();\n                                    }\n                                }\n                                setState(1690);\n                                match(RPAREN);\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlElement" ],
    "fullMethods" : [ "public final HtmlElementContext htmlElement() throws RecognitionException {\n    HtmlElementContext _localctx = new HtmlElementContext(_ctx, getState());\n    enterRule(_localctx, 86, RULE_htmlElement);\n    try {\n        setState(418);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 56, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(414);\n                    voidElement();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(415);\n                    selfClosingElement();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(416);\n                    tightElement();\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(417);\n                    nonTightElement();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceType" ],
    "fullMethods" : [ "public final ClassOrInterfaceTypeContext classOrInterfaceType(boolean createImaginaryNode) throws RecognitionException {\n    ClassOrInterfaceTypeContext _localctx = new ClassOrInterfaceTypeContext(_ctx, getState(), createImaginaryNode);\n    enterRule(_localctx, 94, RULE_classOrInterfaceType);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(714);\n            annotations(false);\n            setState(715);\n            id();\n            setState(717);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 68, _ctx)) {\n                case 1 :\n                    {\n                        setState(716);\n                        typeArguments();\n                    }\n                    break;\n            }\n            setState(722);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 69, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(719);\n                            ((ClassOrInterfaceTypeContext) (_localctx)).classOrInterfaceTypeExtended = classOrInterfaceTypeExtended();\n                            ((ClassOrInterfaceTypeContext) (_localctx)).extended.add(((ClassOrInterfaceTypeContext) (_localctx)).classOrInterfaceTypeExtended);\n                        }\n                    }\n                }\n                setState(724);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 69, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expressionList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expressionList" ],
    "fullMethods" : [ "public final ExpressionListContext expressionList() throws RecognitionException {\n    ExpressionListContext _localctx = new ExpressionListContext(_ctx, getState());\n    enterRule(_localctx, 214, RULE_expressionList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1307);\n            ((ExpressionListContext) (_localctx)).startExp = expression();\n            setState(1312);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1308);\n                        match(COMMA);\n                        setState(1309);\n                        expression();\n                    }\n                }\n                setState(1314);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.returnInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.returnInlineTag" ],
    "fullMethods" : [ "public final ReturnInlineTagContext returnInlineTag() throws RecognitionException {\n    ReturnInlineTagContext _localctx = new ReturnInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 58, RULE_returnInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(313);\n            ((ReturnInlineTagContext) (_localctx)).tagName = match(RETURN);\n            setState(315);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 38, _ctx)) {\n                case 1 :\n                    {\n                        setState(314);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.sinceTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.sinceTag" ],
    "fullMethods" : [ "public final SinceTagContext sinceTag() throws RecognitionException {\n    SinceTagContext _localctx = new SinceTagContext(_ctx, getState());\n    enterRule(_localctx, 18, RULE_sinceTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(186);\n            match(AT_SIGN);\n            setState(187);\n            ((SinceTagContext) (_localctx)).tagName = match(SINCE);\n            setState(189);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 14, _ctx)) {\n                case 1 :\n                    {\n                        setState(188);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgument",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgument" ],
    "fullMethods" : [ "public final TypeArgumentContext typeArgument() throws RecognitionException {\n    TypeArgumentContext _localctx = new TypeArgumentContext(_ctx, getState());\n    enterRule(_localctx, 98, RULE_typeArgument);\n    int _la;\n    try {\n        setState(741);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 73, _ctx)) {\n            case 1 :\n                _localctx = new SimpleTypeArgumentContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(731);\n                    typeType(false);\n                }\n                break;\n            case 2 :\n                _localctx = new WildCardTypeArgumentContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(732);\n                    annotations(false);\n                    setState(733);\n                    match(QUESTION);\n                    setState(739);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == EXTENDS_CLAUSE) || (_la == LITERAL_SUPER)) {\n                        {\n                            setState(736);\n                            _errHandler.sync(this);\n                            switch (_input.LA(1)) {\n                                case EXTENDS_CLAUSE :\n                                    {\n                                        setState(734);\n                                        ((WildCardTypeArgumentContext) (_localctx)).upperBound = match(EXTENDS_CLAUSE);\n                                    }\n                                    break;\n                                case LITERAL_SUPER :\n                                    {\n                                        setState(735);\n                                        ((WildCardTypeArgumentContext) (_localctx)).lowerBound = match(LITERAL_SUPER);\n                                    }\n                                    break;\n                                default :\n                                    throw new NoViableAltException(this);\n                            }\n                            setState(738);\n                            typeType(false);\n                        }\n                    }\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableModifier",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableModifier" ],
    "fullMethods" : [ "public final VariableModifierContext variableModifier() throws RecognitionException {\n    VariableModifierContext _localctx = new VariableModifierContext(_ctx, getState());\n    enterRule(_localctx, 12, RULE_variableModifier);\n    try {\n        setState(364);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(362);\n                    match(FINAL);\n                }\n                break;\n            case AT :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(363);\n                    annotation();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlAttribute",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlAttribute" ],
    "fullMethods" : [ "public final HtmlAttributeContext htmlAttribute() throws RecognitionException {\n    HtmlAttributeContext _localctx = new HtmlAttributeContext(_ctx, getState());\n    enterRule(_localctx, 100, RULE_htmlAttribute);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(459);\n            match(TAG_ATTR_NAME);\n            setState(462);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == EQUALS) {\n                {\n                    setState(460);\n                    match(EQUALS);\n                    setState(461);\n                    match(ATTRIBUTE_VALUE);\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.permittedSubclassesAndInterfaces",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.permittedSubclassesAndInterfaces" ],
    "fullMethods" : [ "public final PermittedSubclassesAndInterfacesContext permittedSubclassesAndInterfaces() throws RecognitionException {\n    PermittedSubclassesAndInterfacesContext _localctx = new PermittedSubclassesAndInterfacesContext(_ctx, getState());\n    enterRule(_localctx, 284, RULE_permittedSubclassesAndInterfaces);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1757);\n            match(LITERAL_PERMITS);\n            setState(1758);\n            classOrInterfaceType(false);\n            setState(1763);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1759);\n                        match(COMMA);\n                        setState(1760);\n                        classOrInterfaceType(false);\n                    }\n                }\n                setState(1765);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.compilationUnit",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.compilationUnit" ],
    "fullMethods" : [ "public final CompilationUnitContext compilationUnit() throws RecognitionException {\n    CompilationUnitContext _localctx = new CompilationUnitContext(_ctx, getState());\n    enterRule(_localctx, 0, RULE_compilationUnit);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(289);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 0, _ctx)) {\n                case 1 :\n                    {\n                        setState(288);\n                        packageDeclaration();\n                    }\n                    break;\n            }\n            setState(294);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 1, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(291);\n                            importDeclaration();\n                        }\n                    }\n                }\n                setState(296);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 1, _ctx);\n            } \n            setState(300);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028803457220679L) != 0)) || ((((_la - 153) & (~0x3f)) == 0) && (((1L << (_la - 153)) & 216313519602270209L) != 0))) {\n                {\n                    {\n                        setState(297);\n                        typeDeclaration();\n                    }\n                }\n                setState(302);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(303);\n            match(EOF);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValueArrayInitializer",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValueArrayInitializer" ],
    "fullMethods" : [ "public final ElementValueArrayInitializerContext elementValueArrayInitializer() throws RecognitionException {\n    ElementValueArrayInitializerContext _localctx = new ElementValueArrayInitializerContext(_ctx, getState());\n    enterRule(_localctx, 132, RULE_elementValueArrayInitializer);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(857);\n            match(LCURLY);\n            setState(866);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((((((_la - 49) & (~0x3f)) == 0) && (((1L << (_la - 49)) & 1101264847871L) != 0)) || ((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 35184372117491L) != 0))) || ((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 4385166758159L) != 0))) {\n                {\n                    setState(858);\n                    elementValue();\n                    setState(863);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 88, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(859);\n                                    match(COMMA);\n                                    setState(860);\n                                    elementValue();\n                                }\n                            }\n                        }\n                        setState(865);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 88, _ctx);\n                    } \n                }\n            }\n            setState(869);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == COMMA) {\n                {\n                    setState(868);\n                    match(COMMA);\n                }\n            }\n            setState(871);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldDeclaration" ],
    "fullMethods" : [ "public final FieldDeclarationContext fieldDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    FieldDeclarationContext _localctx = new FieldDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 76, RULE_fieldDeclaration);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(621);\n            ((FieldDeclarationContext) (_localctx)).type = typeType(true);\n            setState(622);\n            variableDeclarators(_localctx.mods, _localctx.type);\n            setState(623);\n            match(SEMI);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordPattern" ],
    "fullMethods" : [ "public final RecordPatternContext recordPattern() throws RecognitionException {\n    RecordPatternContext _localctx = new RecordPatternContext(_ctx, getState());\n    enterRule(_localctx, 280, RULE_recordPattern);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1737);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 207, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1734);\n                            ((RecordPatternContext) (_localctx)).modifier = modifier();\n                            ((RecordPatternContext) (_localctx)).mods.add(((RecordPatternContext) (_localctx)).modifier);\n                        }\n                    }\n                }\n                setState(1739);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 207, _ctx);\n            } \n            setState(1740);\n            ((RecordPatternContext) (_localctx)).type = typeType(true);\n            setState(1741);\n            match(LPAREN);\n            setState(1743);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028935528512519L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                {\n                    setState(1742);\n                    recordComponentPatternList();\n                }\n            }\n            setState(1745);\n            match(RPAREN);\n            setState(1747);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 209, _ctx)) {\n                case 1 :\n                    {\n                        setState(1746);\n                        id();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.voidElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.voidElement" ],
    "fullMethods" : [ "public final VoidElementContext voidElement() throws RecognitionException {\n    VoidElementContext _localctx = new VoidElementContext(_ctx, getState());\n    enterRule(_localctx, 88, RULE_voidElement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(420);\n            if (!isVoidTag())\n                throw new FailedPredicateException(this, \" isVoidTag() \");\n\n            setState(421);\n            htmlTagStart();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.pattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.pattern" ],
    "fullMethods" : [ "public final PatternContext pattern() throws RecognitionException {\n    PatternContext _localctx = new PatternContext(_ctx, getState());\n    enterRule(_localctx, 268, RULE_pattern);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1701);\n            innerPattern();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classDeclaration" ],
    "fullMethods" : [ "public final ClassDeclarationContext classDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    ClassDeclarationContext _localctx = new ClassDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 14, RULE_classDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(366);\n            match(LITERAL_CLASS);\n            setState(367);\n            id();\n            setState(369);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(368);\n                    typeParameters();\n                }\n            }\n            setState(372);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == EXTENDS_CLAUSE) {\n                {\n                    setState(371);\n                    classExtends();\n                }\n            }\n            setState(375);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_IMPLEMENTS) {\n                {\n                    setState(374);\n                    implementsClause();\n                }\n            }\n            setState(378);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_PERMITS) {\n                {\n                    setState(377);\n                    permittedSubclassesAndInterfaces();\n                }\n            }\n            setState(380);\n            classBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resources",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resources" ],
    "fullMethods" : [ "public final ResourcesContext resources() throws RecognitionException {\n    ResourcesContext _localctx = new ResourcesContext(_ctx, getState());\n    enterRule(_localctx, 186, RULE_resources);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1192);\n            resource();\n            setState(1197);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 133, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1193);\n                            match(SEMI);\n                            setState(1194);\n                            resource();\n                        }\n                    }\n                }\n                setState(1199);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 133, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.caseConstants",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.caseConstants" ],
    "fullMethods" : [ "public final CaseConstantsContext caseConstants() throws RecognitionException {\n    CaseConstantsContext _localctx = new CaseConstantsContext(_ctx, getState());\n    enterRule(_localctx, 200, RULE_caseConstants);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1249);\n            caseConstant();\n            setState(1254);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 143, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1250);\n                            match(COMMA);\n                            setState(1251);\n                            caseConstant();\n                        }\n                    }\n                }\n                setState(1256);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 143, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.parameterTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.parameterTag" ],
    "fullMethods" : [ "public final ParameterTagContext parameterTag() throws RecognitionException {\n    ParameterTagContext _localctx = new ParameterTagContext(_ctx, getState());\n    enterRule(_localctx, 12, RULE_parameterTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(162);\n            match(AT_SIGN);\n            setState(163);\n            ((ParameterTagContext) (_localctx)).tagName = match(PARAM);\n            setState(165);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 8, _ctx)) {\n                case 1 :\n                    {\n                        setState(164);\n                        ((ParameterTagContext) (_localctx)).paramName = match(PARAMETER_NAME);\n                    }\n                    break;\n            }\n            setState(168);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 9, _ctx)) {\n                case 1 :\n                    {\n                        setState(167);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeParameters",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeParameters" ],
    "fullMethods" : [ "public final TypeParametersContext typeParameters() throws RecognitionException {\n    TypeParametersContext _localctx = new TypeParametersContext(_ctx, getState());\n    enterRule(_localctx, 36, RULE_typeParameters);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(451);\n            match(LT);\n            setState(452);\n            typeParameter();\n            setState(457);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(453);\n                        match(COMMA);\n                        setState(454);\n                        typeParameter();\n                    }\n                }\n                setState(459);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(460);\n            match(GT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.integerLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.integerLiteral" ],
    "fullMethods" : [ "public final IntegerLiteralContext integerLiteral() throws RecognitionException {\n    IntegerLiteralContext _localctx = new IntegerLiteralContext(_ctx, getState());\n    enterRule(_localctx, 116, RULE_integerLiteral);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(816);\n            _la = _input.LA(1);\n            if (!((((_la - 226) & (~0x3f)) == 0) && (((1L << (_la - 226)) & 255L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeArgument",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeArgument" ],
    "fullMethods" : [ "public final TypeArgumentContext typeArgument() throws RecognitionException {\n    TypeArgumentContext _localctx = new TypeArgumentContext(_ctx, getState());\n    enterRule(_localctx, 74, RULE_typeArgument);\n    try {\n        setState(377);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 48, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(369);\n                    typeName();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(370);\n                    match(QUESTION);\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(371);\n                    match(QUESTION);\n                    setState(372);\n                    match(EXTENDS);\n                    setState(373);\n                    typeName();\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(374);\n                    match(QUESTION);\n                    setState(375);\n                    match(SUPER);\n                    setState(376);\n                    typeName();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordBodyDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordBodyDeclaration" ],
    "fullMethods" : [ "public final RecordBodyDeclarationContext recordBodyDeclaration() throws RecognitionException {\n    RecordBodyDeclarationContext _localctx = new RecordBodyDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 28, RULE_recordBodyDeclaration);\n    try {\n        setState(434);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 23, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(432);\n                    compactConstructorDeclaration();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(433);\n                    classBodyDeclaration();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.parameterTypeList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.parameterTypeList" ],
    "fullMethods" : [ "public final ParameterTypeListContext parameterTypeList() throws RecognitionException {\n    ParameterTypeListContext _localctx = new ParameterTypeListContext(_ctx, getState());\n    enterRule(_localctx, 78, RULE_parameterTypeList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(387);\n            match(PARAMETER_TYPE);\n            setState(394);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == COMMA) || (_la == PARAMETER_TYPE)) {\n                {\n                    {\n                        setState(389);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == COMMA) {\n                            {\n                                setState(388);\n                                match(COMMA);\n                            }\n                        }\n                        setState(391);\n                        match(PARAMETER_TYPE);\n                    }\n                }\n                setState(396);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent" ],
    "fullMethods" : [ "public final FieldAccessNoIdentContext fieldAccessNoIdent() throws RecognitionException {\n    FieldAccessNoIdentContext _localctx = new FieldAccessNoIdentContext(_ctx, getState());\n    enterRule(_localctx, 194, RULE_fieldAccessNoIdent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1225);\n            expr(0);\n            setState(1226);\n            match(DOT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.innerPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.innerPattern" ],
    "fullMethods" : [ "public final InnerPatternContext innerPattern() throws RecognitionException {\n    InnerPatternContext _localctx = new InnerPatternContext(_ctx, getState());\n    enterRule(_localctx, 270, RULE_innerPattern);\n    try {\n        setState(1706);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 203, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1703);\n                    guardedPattern();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1704);\n                    recordPattern();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1705);\n                    primaryPattern();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialFieldTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialFieldTag" ],
    "fullMethods" : [ "public final SerialFieldTagContext serialFieldTag() throws RecognitionException {\n    SerialFieldTagContext _localctx = new SerialFieldTagContext(_ctx, getState());\n    enterRule(_localctx, 34, RULE_serialFieldTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(238);\n            match(AT_SIGN);\n            setState(239);\n            ((SerialFieldTagContext) (_localctx)).tagName = match(SERIAL_FIELD);\n            setState(241);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 24, _ctx)) {\n                case 1 :\n                    {\n                        setState(240);\n                        ((SerialFieldTagContext) (_localctx)).fieldName = match(IDENTIFIER);\n                    }\n                    break;\n            }\n            setState(244);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 25, _ctx)) {\n                case 1 :\n                    {\n                        setState(243);\n                        match(FIELD_TYPE);\n                    }\n                    break;\n            }\n            setState(247);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 26, _ctx)) {\n                case 1 :\n                    {\n                        setState(246);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.tightElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.tightElement" ],
    "fullMethods" : [ "public final TightElementContext tightElement() throws RecognitionException {\n    TightElementContext _localctx = new TightElementContext(_ctx, getState());\n    enterRule(_localctx, 90, RULE_tightElement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(423);\n            if (!(!JavadocCommentsParserUtil.isNonTightTag(_input, unclosedTagNameTokens)))\n                throw new FailedPredicateException(this, \" !JavadocCommentsParserUtil.isNonTightTag(_input, unclosedTagNameTokens) \");\n\n            setState(424);\n            htmlTagStart();\n            setState(426);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 57, _ctx)) {\n                case 1 :\n                    {\n                        setState(425);\n                        htmlContent();\n                    }\n                    break;\n            }\n            setState(428);\n            htmlTagEnd();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.memberDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.memberDeclaration" ],
    "fullMethods" : [ "public final MemberDeclarationContext memberDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    MemberDeclarationContext _localctx = new MemberDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 66, RULE_memberDeclaration);\n    try {\n        setState(585);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 45, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(577);\n                    recordDeclaration(mods);\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(578);\n                    methodDeclaration(mods);\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(579);\n                    fieldDeclaration(mods);\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(580);\n                    constructorDeclaration(mods);\n                }\n                break;\n            case 5 :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(581);\n                    interfaceDeclaration(mods);\n                }\n                break;\n            case 6 :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(582);\n                    annotationTypeDeclaration(mods);\n                }\n                break;\n            case 7 :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(583);\n                    classDeclaration(mods);\n                }\n                break;\n            case 8 :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(584);\n                    enumDeclaration(mods);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeDeclaration" ],
    "fullMethods" : [ "public final AnnotationTypeDeclarationContext annotationTypeDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    AnnotationTypeDeclarationContext _localctx = new AnnotationTypeDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 134, RULE_annotationTypeDeclaration);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(873);\n            match(AT);\n            setState(874);\n            match(LITERAL_INTERFACE);\n            setState(875);\n            id();\n            setState(876);\n            annotationTypeBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.block",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.block" ],
    "fullMethods" : [ "public final BlockContext block() throws RecognitionException {\n    BlockContext _localctx = new BlockContext(_ctx, getState());\n    enterRule(_localctx, 152, RULE_block);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(976);\n            match(LCURLY);\n            setState(980);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 108, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(977);\n                            blockStatement();\n                        }\n                    }\n                }\n                setState(982);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 108, _ctx);\n            } \n            setState(983);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumConstant",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumConstant" ],
    "fullMethods" : [ "public final EnumConstantContext enumConstant() throws RecognitionException {\n    EnumConstantContext _localctx = new EnumConstantContext(_ctx, getState());\n    enterRule(_localctx, 52, RULE_enumConstant);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(514);\n            annotations(true);\n            setState(515);\n            id();\n            setState(517);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LPAREN) {\n                {\n                    setState(516);\n                    arguments();\n                }\n            }\n            setState(520);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LCURLY) {\n                {\n                    setState(519);\n                    classBody();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchClause",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchClause" ],
    "fullMethods" : [ "public final CatchClauseContext catchClause() throws RecognitionException {\n    CatchClauseContext _localctx = new CatchClauseContext(_ctx, getState());\n    enterRule(_localctx, 176, RULE_catchClause);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1159);\n            match(LITERAL_CATCH);\n            setState(1160);\n            match(LPAREN);\n            setState(1161);\n            catchParameter();\n            setState(1162);\n            match(RPAREN);\n            setState(1163);\n            block();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceMethodDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceMethodDeclaration" ],
    "fullMethods" : [ "public final InterfaceMethodDeclarationContext interfaceMethodDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    InterfaceMethodDeclarationContext _localctx = new InterfaceMethodDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 82, RULE_interfaceMethodDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(645);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(644);\n                    typeParameters();\n                }\n            }\n            setState(647);\n            ((InterfaceMethodDeclarationContext) (_localctx)).type = typeType(true);\n            setState(648);\n            id();\n            setState(649);\n            formalParameters();\n            setState(653);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(650);\n                        ((InterfaceMethodDeclarationContext) (_localctx)).arrayDeclarator = arrayDeclarator();\n                        ((InterfaceMethodDeclarationContext) (_localctx)).cStyleArrDec.add(((InterfaceMethodDeclarationContext) (_localctx)).arrayDeclarator);\n                    }\n                }\n                setState(655);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(657);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_THROWS) {\n                {\n                    setState(656);\n                    throwsList();\n                }\n            }\n            setState(659);\n            methodBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialDataTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialDataTag" ],
    "fullMethods" : [ "public final SerialDataTagContext serialDataTag() throws RecognitionException {\n    SerialDataTagContext _localctx = new SerialDataTagContext(_ctx, getState());\n    enterRule(_localctx, 32, RULE_serialDataTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(233);\n            match(AT_SIGN);\n            setState(234);\n            ((SerialDataTagContext) (_localctx)).tagName = match(SERIAL_DATA);\n            setState(236);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 23, _ctx)) {\n                case 1 :\n                    {\n                        setState(235);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primitiveType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primitiveType" ],
    "fullMethods" : [ "public final PrimitiveTypeContext primitiveType() throws RecognitionException {\n    PrimitiveTypeContext _localctx = new PrimitiveTypeContext(_ctx, getState());\n    enterRule(_localctx, 260, RULE_primitiveType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1666);\n            _la = _input.LA(1);\n            if (!(((_la & (~0x3f)) == 0) && (((1L << _la) & 287667426198290432L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression" ],
    "fullMethods" : [ "public final ExpressionContext expression() throws RecognitionException {\n    ExpressionContext _localctx = new ExpressionContext(_ctx, getState());\n    enterRule(_localctx, 216, RULE_expression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1315);\n            expr(0);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeParameter",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeParameter" ],
    "fullMethods" : [ "public final TypeParameterContext typeParameter() throws RecognitionException {\n    TypeParameterContext _localctx = new TypeParameterContext(_ctx, getState());\n    enterRule(_localctx, 38, RULE_typeParameter);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(462);\n            annotations(false);\n            setState(463);\n            id();\n            setState(465);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == EXTENDS_CLAUSE) {\n                {\n                    setState(464);\n                    typeUpperBounds();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgumentsTypeList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgumentsTypeList" ],
    "fullMethods" : [ "public final TypeArgumentsTypeListContext typeArgumentsTypeList() throws RecognitionException {\n    TypeArgumentsTypeListContext _localctx = new TypeArgumentsTypeListContext(_ctx, getState());\n    enterRule(_localctx, 250, RULE_typeArgumentsTypeList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1634);\n            typeType(false);\n            setState(1639);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1635);\n                        match(COMMA);\n                        setState(1636);\n                        typeType(false);\n                    }\n                }\n                setState(1641);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeCastParameters",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeCastParameters" ],
    "fullMethods" : [ "public final TypeCastParametersContext typeCastParameters() throws RecognitionException {\n    TypeCastParametersContext _localctx = new TypeCastParametersContext(_ctx, getState());\n    enterRule(_localctx, 220, RULE_typeCastParameters);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1476);\n            typeType(true);\n            setState(1481);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == BAND) {\n                {\n                    {\n                        setState(1477);\n                        match(BAND);\n                        setState(1478);\n                        typeType(true);\n                    }\n                }\n                setState(1483);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlockStatementGroup",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlockStatementGroup" ],
    "fullMethods" : [ "public final SwitchBlockStatementGroupContext switchBlockStatementGroup() throws RecognitionException {\n    SwitchBlockStatementGroupContext _localctx = new SwitchBlockStatementGroupContext(_ctx, getState());\n    enterRule(_localctx, 196, RULE_switchBlockStatementGroup);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1229);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            {\n                                setState(1228);\n                                switchLabel();\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(1231);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 138, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n            setState(1234);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            {\n                                setState(1233);\n                                ((SwitchBlockStatementGroupContext) (_localctx)).blockStatement = blockStatement();\n                                ((SwitchBlockStatementGroupContext) (_localctx)).slists.add(((SwitchBlockStatementGroupContext) (_localctx)).blockStatement);\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(1236);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 139, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.literalInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.literalInlineTag" ],
    "fullMethods" : [ "public final LiteralInlineTagContext literalInlineTag() throws RecognitionException {\n    LiteralInlineTagContext _localctx = new LiteralInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 60, RULE_literalInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(317);\n            ((LiteralInlineTagContext) (_localctx)).tagName = match(LITERAL);\n            setState(319);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            do {\n                {\n                    {\n                        setState(318);\n                        match(TEXT);\n                    }\n                }\n                setState(321);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } while (_la == TEXT );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enhancedForControlWithRecordPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enhancedForControlWithRecordPattern" ],
    "fullMethods" : [ "public final EnhancedForControlWithRecordPatternContext enhancedForControlWithRecordPattern() throws RecognitionException {\n    EnhancedForControlWithRecordPatternContext _localctx = new EnhancedForControlWithRecordPatternContext(_ctx, getState());\n    enterRule(_localctx, 210, RULE_enhancedForControlWithRecordPattern);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1299);\n            pattern();\n            setState(1300);\n            match(COLON);\n            setState(1301);\n            expression();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.forInit",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.forInit" ],
    "fullMethods" : [ "public final ForInitContext forInit() throws RecognitionException {\n    ForInitContext _localctx = new ForInitContext(_ctx, getState());\n    enterRule(_localctx, 206, RULE_forInit);\n    try {\n        setState(1286);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 150, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1284);\n                    localVariableDeclaration();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1285);\n                    expressionList();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classBody" ],
    "fullMethods" : [ "public final ClassBodyContext classBody() throws RecognitionException {\n    ClassBodyContext _localctx = new ClassBodyContext(_ctx, getState());\n    enterRule(_localctx, 60, RULE_classBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(545);\n            match(LCURLY);\n            setState(549);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028812048202823L) != 0)) || ((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 9007267974217729L) != 0))) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                {\n                    {\n                        setState(546);\n                        classBodyDeclaration();\n                    }\n                }\n                setState(551);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(552);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.memberReference",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.memberReference" ],
    "fullMethods" : [ "public final MemberReferenceContext memberReference() throws RecognitionException {\n    MemberReferenceContext _localctx = new MemberReferenceContext(_ctx, getState());\n    enterRule(_localctx, 76, RULE_memberReference);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(379);\n            match(IDENTIFIER);\n            setState(385);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 50, _ctx)) {\n                case 1 :\n                    {\n                        setState(380);\n                        match(LPAREN);\n                        setState(382);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == PARAMETER_TYPE) {\n                            {\n                                setState(381);\n                                parameterTypeList();\n                            }\n                        }\n                        setState(384);\n                        match(RPAREN);\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementDeclaration" ],
    "fullMethods" : [ "public final AnnotationTypeElementDeclarationContext annotationTypeElementDeclaration() throws RecognitionException {\n    AnnotationTypeElementDeclarationContext _localctx = new AnnotationTypeElementDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 138, RULE_annotationTypeElementDeclaration);\n    try {\n        int _alt;\n        setState(895);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(890);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 92, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(887);\n                                    ((AnnotationTypeElementDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((AnnotationTypeElementDeclarationContext) (_localctx)).mods.add(((AnnotationTypeElementDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(892);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 92, _ctx);\n                    } \n                    setState(893);\n                    annotationTypeElementRest(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(894);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.floatLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.floatLiteral" ],
    "fullMethods" : [ "public final FloatLiteralContext floatLiteral() throws RecognitionException {\n    FloatLiteralContext _localctx = new FloatLiteralContext(_ctx, getState());\n    enterRule(_localctx, 118, RULE_floatLiteral);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(818);\n            _la = _input.LA(1);\n            if (!((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 15L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.statement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.statement" ],
    "fullMethods" : [ "public final StatementContext statement() throws RecognitionException {\n    StatementContext _localctx = new StatementContext(_ctx, getState());\n    enterRule(_localctx, 160, RULE_statement);\n    int _la;\n    try {\n        int _alt;\n        setState(1107);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 124, _ctx)) {\n            case 1 :\n                _localctx = new BlockStatContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1017);\n                    ((BlockStatContext) (_localctx)).blockLabel = block();\n                }\n                break;\n            case 2 :\n                _localctx = new AssertExpContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1018);\n                    match(ASSERT);\n                    setState(1019);\n                    expression();\n                    setState(1022);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == COLON) {\n                        {\n                            setState(1020);\n                            match(COLON);\n                            setState(1021);\n                            expression();\n                        }\n                    }\n                    setState(1024);\n                    match(SEMI);\n                }\n                break;\n            case 3 :\n                _localctx = new IfStatContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1026);\n                    match(LITERAL_IF);\n                    setState(1027);\n                    parExpression();\n                    setState(1028);\n                    statement();\n                    setState(1030);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 115, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1029);\n                                elseStat();\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 4 :\n                _localctx = new ForStatContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(1032);\n                    match(LITERAL_FOR);\n                    setState(1033);\n                    forControl();\n                    setState(1034);\n                    statement();\n                }\n                break;\n            case 5 :\n                _localctx = new WhileStatContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(1036);\n                    match(LITERAL_WHILE);\n                    setState(1037);\n                    parExpression();\n                    setState(1038);\n                    statement();\n                }\n                break;\n            case 6 :\n                _localctx = new DoStatContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(1040);\n                    match(LITERAL_DO);\n                    setState(1041);\n                    statement();\n                    setState(1042);\n                    match(LITERAL_WHILE);\n                    setState(1043);\n                    parExpression();\n                    setState(1044);\n                    match(SEMI);\n                }\n                break;\n            case 7 :\n                _localctx = new TryStatContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(1046);\n                    match(LITERAL_TRY);\n                    setState(1047);\n                    block();\n                    setState(1057);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LITERAL_CATCH :\n                            {\n                                setState(1049);\n                                _errHandler.sync(this);\n                                _alt = 1;\n                                do {\n                                    switch (_alt) {\n                                        case 1 :\n                                            {\n                                                {\n                                                    setState(1048);\n                                                    catchClause();\n                                                }\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                    setState(1051);\n                                    _errHandler.sync(this);\n                                    _alt = getInterpreter().adaptivePredict(_input, 116, _ctx);\n                                } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n                                setState(1054);\n                                _errHandler.sync(this);\n                                switch (getInterpreter().adaptivePredict(_input, 117, _ctx)) {\n                                    case 1 :\n                                        {\n                                            setState(1053);\n                                            finallyBlock();\n                                        }\n                                        break;\n                                }\n                            }\n                            break;\n                        case LITERAL_FINALLY :\n                            {\n                                setState(1056);\n                                finallyBlock();\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            case 8 :\n                _localctx = new TryWithResourceStatContext(_localctx);\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(1059);\n                    match(LITERAL_TRY);\n                    setState(1060);\n                    resourceSpecification();\n                    setState(1061);\n                    block();\n                    setState(1065);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 119, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(1062);\n                                    catchClause();\n                                }\n                            }\n                        }\n                        setState(1067);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 119, _ctx);\n                    } \n                    setState(1069);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 120, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1068);\n                                finallyBlock();\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 9 :\n                _localctx = new YieldStatContext(_localctx);\n                enterOuterAlt(_localctx, 9);\n                {\n                    setState(1071);\n                    match(LITERAL_YIELD);\n                    setState(1072);\n                    expression();\n                    setState(1073);\n                    match(SEMI);\n                }\n                break;\n            case 10 :\n                _localctx = new SwitchStatContext(_localctx);\n                enterOuterAlt(_localctx, 10);\n                {\n                    setState(1075);\n                    switchExpressionOrStatement();\n                }\n                break;\n            case 11 :\n                _localctx = new SyncStatContext(_localctx);\n                enterOuterAlt(_localctx, 11);\n                {\n                    setState(1076);\n                    match(LITERAL_SYNCHRONIZED);\n                    setState(1077);\n                    parExpression();\n                    setState(1078);\n                    block();\n                }\n                break;\n            case 12 :\n                _localctx = new ReturnStatContext(_localctx);\n                enterOuterAlt(_localctx, 12);\n                {\n                    setState(1080);\n                    match(LITERAL_RETURN);\n                    setState(1082);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1081);\n                            expression();\n                        }\n                    }\n                    setState(1084);\n                    match(SEMI);\n                }\n                break;\n            case 13 :\n                _localctx = new ThrowStatContext(_localctx);\n                enterOuterAlt(_localctx, 13);\n                {\n                    setState(1085);\n                    match(LITERAL_THROW);\n                    setState(1086);\n                    expression();\n                    setState(1087);\n                    match(SEMI);\n                }\n                break;\n            case 14 :\n                _localctx = new BreakStatContext(_localctx);\n                enterOuterAlt(_localctx, 14);\n                {\n                    setState(1089);\n                    match(LITERAL_BREAK);\n                    setState(1091);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                        {\n                            setState(1090);\n                            id();\n                        }\n                    }\n                    setState(1093);\n                    match(SEMI);\n                }\n                break;\n            case 15 :\n                _localctx = new ContinueStatContext(_localctx);\n                enterOuterAlt(_localctx, 15);\n                {\n                    setState(1094);\n                    match(LITERAL_CONTINUE);\n                    setState(1096);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                        {\n                            setState(1095);\n                            id();\n                        }\n                    }\n                    setState(1098);\n                    match(SEMI);\n                }\n                break;\n            case 16 :\n                _localctx = new EmptyStatContext(_localctx);\n                enterOuterAlt(_localctx, 16);\n                {\n                    setState(1099);\n                    match(SEMI);\n                }\n                break;\n            case 17 :\n                _localctx = new ExpStatContext(_localctx);\n                enterOuterAlt(_localctx, 17);\n                {\n                    setState(1100);\n                    ((ExpStatContext) (_localctx)).statementExpression = expression();\n                    setState(1101);\n                    match(SEMI);\n                }\n                break;\n            case 18 :\n                _localctx = new LabelStatContext(_localctx);\n                enterOuterAlt(_localctx, 18);\n                {\n                    setState(1103);\n                    id();\n                    setState(1104);\n                    match(COLON);\n                    setState(1105);\n                    statement();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialTag" ],
    "fullMethods" : [ "public final SerialTagContext serialTag() throws RecognitionException {\n    SerialTagContext _localctx = new SerialTagContext(_ctx, getState());\n    enterRule(_localctx, 30, RULE_serialTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(228);\n            match(AT_SIGN);\n            setState(229);\n            ((SerialTagContext) (_localctx)).tagName = match(SERIAL);\n            setState(231);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 22, _ctx)) {\n                case 1 :\n                    {\n                        setState(230);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.returnTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.returnTag" ],
    "fullMethods" : [ "public final ReturnTagContext returnTag() throws RecognitionException {\n    ReturnTagContext _localctx = new ReturnTagContext(_ctx, getState());\n    enterRule(_localctx, 10, RULE_returnTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(157);\n            match(AT_SIGN);\n            setState(158);\n            ((ReturnTagContext) (_localctx)).tagName = match(RETURN);\n            setState(160);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 7, _ctx)) {\n                case 1 :\n                    {\n                        setState(159);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.blockTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.blockTag" ],
    "fullMethods" : [ "public final BlockTagContext blockTag() throws RecognitionException {\n    BlockTagContext _localctx = new BlockTagContext(_ctx, getState());\n    enterRule(_localctx, 4, RULE_blockTag);\n    try {\n        setState(145);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 4, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(129);\n                    authorTag();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(130);\n                    deprecatedTag();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(131);\n                    returnTag();\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(132);\n                    parameterTag();\n                }\n                break;\n            case 5 :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(133);\n                    throwsTag();\n                }\n                break;\n            case 6 :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(134);\n                    exceptionTag();\n                }\n                break;\n            case 7 :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(135);\n                    sinceTag();\n                }\n                break;\n            case 8 :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(136);\n                    versionTag();\n                }\n                break;\n            case 9 :\n                enterOuterAlt(_localctx, 9);\n                {\n                    setState(137);\n                    seeTag();\n                }\n                break;\n            case 10 :\n                enterOuterAlt(_localctx, 10);\n                {\n                    setState(138);\n                    hiddenTag();\n                }\n                break;\n            case 11 :\n                enterOuterAlt(_localctx, 11);\n                {\n                    setState(139);\n                    usesTag();\n                }\n                break;\n            case 12 :\n                enterOuterAlt(_localctx, 12);\n                {\n                    setState(140);\n                    providesTag();\n                }\n                break;\n            case 13 :\n                enterOuterAlt(_localctx, 13);\n                {\n                    setState(141);\n                    serialTag();\n                }\n                break;\n            case 14 :\n                enterOuterAlt(_localctx, 14);\n                {\n                    setState(142);\n                    serialDataTag();\n                }\n                break;\n            case 15 :\n                enterOuterAlt(_localctx, 15);\n                {\n                    setState(143);\n                    serialFieldTag();\n                }\n                break;\n            case 16 :\n                enterOuterAlt(_localctx, 16);\n                {\n                    setState(144);\n                    customBlockTag();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guard",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guard" ],
    "fullMethods" : [ "public final GuardContext guard() throws RecognitionException {\n    GuardContext _localctx = new GuardContext(_ctx, getState());\n    enterRule(_localctx, 274, RULE_guard);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1712);\n            _la = _input.LA(1);\n            if (!((_la == LAND) || (_la == LITERAL_WHEN))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameters",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameters" ],
    "fullMethods" : [ "public final FormalParametersContext formalParameters() throws RecognitionException {\n    FormalParametersContext _localctx = new FormalParametersContext(_ctx, getState());\n    enterRule(_localctx, 102, RULE_formalParameters);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(754);\n            match(LPAREN);\n            setState(756);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((((_la & (~0x3f)) == 0) && (((1L << _la) & 575898352105816064L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                {\n                    setState(755);\n                    formalParameterList();\n                }\n            }\n            setState(758);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.implementsClause",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.implementsClause" ],
    "fullMethods" : [ "public final ImplementsClauseContext implementsClause() throws RecognitionException {\n    ImplementsClauseContext _localctx = new ImplementsClauseContext(_ctx, getState());\n    enterRule(_localctx, 34, RULE_implementsClause);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(448);\n            match(LITERAL_IMPLEMENTS);\n            setState(449);\n            typeList();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.multiLambdaParams",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.multiLambdaParams" ],
    "fullMethods" : [ "public final MultiLambdaParamsContext multiLambdaParams() throws RecognitionException {\n    MultiLambdaParamsContext _localctx = new MultiLambdaParamsContext(_ctx, getState());\n    enterRule(_localctx, 224, RULE_multiLambdaParams);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1496);\n            id();\n            setState(1501);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1497);\n                        match(COMMA);\n                        setState(1498);\n                        id();\n                    }\n                }\n                setState(1503);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlComment",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlComment" ],
    "fullMethods" : [ "public final HtmlCommentContext htmlComment() throws RecognitionException {\n    HtmlCommentContext _localctx = new HtmlCommentContext(_ctx, getState());\n    enterRule(_localctx, 106, RULE_htmlComment);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(478);\n            match(HTML_COMMENT_START);\n            setState(479);\n            htmlCommentContent();\n            setState(480);\n            match(HTML_COMMENT_END);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetBody" ],
    "fullMethods" : [ "public final SnippetBodyContext snippetBody() throws RecognitionException {\n    SnippetBodyContext _localctx = new SnippetBodyContext(_ctx, getState());\n    enterRule(_localctx, 82, RULE_snippetBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(402);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            do {\n                {\n                    {\n                        setState(401);\n                        match(TEXT);\n                    }\n                }\n                setState(404);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } while (_la == TEXT );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValue",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValue" ],
    "fullMethods" : [ "public final ElementValueContext elementValue() throws RecognitionException {\n    ElementValueContext _localctx = new ElementValueContext(_ctx, getState());\n    enterRule(_localctx, 130, RULE_elementValue);\n    try {\n        setState(855);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 87, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(852);\n                    expression();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(853);\n                    annotation();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(854);\n                    elementValueArrayInitializer();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arguments" ],
    "fullMethods" : [ "public final ArgumentsContext arguments() throws RecognitionException {\n    ArgumentsContext _localctx = new ArgumentsContext(_ctx, getState());\n    enterRule(_localctx, 266, RULE_arguments);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1695);\n            match(LPAREN);\n            setState(1697);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                {\n                    setState(1696);\n                    expressionList();\n                }\n            }\n            setState(1699);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponents",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponents" ],
    "fullMethods" : [ "public final RecordComponentsContext recordComponents() throws RecognitionException {\n    RecordComponentsContext _localctx = new RecordComponentsContext(_ctx, getState());\n    enterRule(_localctx, 20, RULE_recordComponents);\n    int _la;\n    try {\n        int _alt;\n        setState(412);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 21, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(399);\n                    recordComponent();\n                    setState(404);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 19, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(400);\n                                    match(COMMA);\n                                    setState(401);\n                                    recordComponent();\n                                }\n                            }\n                        }\n                        setState(406);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 19, _ctx);\n                    } \n                    setState(409);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == COMMA) {\n                        {\n                            setState(407);\n                            match(COMMA);\n                            setState(408);\n                            lastRecordComponent();\n                        }\n                    }\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(411);\n                    lastRecordComponent();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumDeclaration" ],
    "fullMethods" : [ "public final EnumDeclarationContext enumDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    EnumDeclarationContext _localctx = new EnumDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 46, RULE_enumDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(487);\n            match(ENUM);\n            setState(488);\n            id();\n            setState(490);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_IMPLEMENTS) {\n                {\n                    setState(489);\n                    implementsClause();\n                }\n            }\n            setState(492);\n            enumBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.types",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.types" ],
    "fullMethods" : [ "public final TypesContext types(List<ModifierContext> mods) throws RecognitionException {\n    TypesContext _localctx = new TypesContext(_ctx, getState(), mods);\n    enterRule(_localctx, 8, RULE_types);\n    try {\n        setState(343);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LITERAL_CLASS :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(338);\n                    classDeclaration(mods);\n                }\n                break;\n            case ENUM :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(339);\n                    enumDeclaration(mods);\n                }\n                break;\n            case LITERAL_INTERFACE :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(340);\n                    interfaceDeclaration(mods);\n                }\n                break;\n            case AT :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(341);\n                    annotationTypeDeclaration(mods);\n                }\n                break;\n            case LITERAL_RECORD :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(342);\n                    recordDeclaration(mods);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.caseConstant",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.caseConstant" ],
    "fullMethods" : [ "public final CaseConstantContext caseConstant() throws RecognitionException {\n    CaseConstantContext _localctx = new CaseConstantContext(_ctx, getState());\n    enterRule(_localctx, 202, RULE_caseConstant);\n    try {\n        setState(1260);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 144, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1257);\n                    pattern();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1258);\n                    expression();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1259);\n                    match(LITERAL_DEFAULT);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.reference",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.reference" ],
    "fullMethods" : [ "public final ReferenceContext reference() throws RecognitionException {\n    ReferenceContext _localctx = new ReferenceContext(_ctx, getState());\n    enterRule(_localctx, 66, RULE_reference);\n    try {\n        setState(350);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case HASH :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(338);\n                    match(HASH);\n                    setState(339);\n                    memberReference();\n                }\n                break;\n            case IDENTIFIER :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(343);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 43, _ctx)) {\n                        case 1 :\n                            {\n                                setState(340);\n                                ((ReferenceContext) (_localctx)).module = qualifiedName();\n                                setState(341);\n                                match(SLASH);\n                            }\n                            break;\n                    }\n                    setState(345);\n                    ((ReferenceContext) (_localctx)).type = typeName();\n                    setState(348);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 44, _ctx)) {\n                        case 1 :\n                            {\n                                setState(346);\n                                match(HASH);\n                                setState(347);\n                                memberReference();\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.constructorBlock",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.constructorBlock" ],
    "fullMethods" : [ "public final ConstructorBlockContext constructorBlock() throws RecognitionException {\n    ConstructorBlockContext _localctx = new ConstructorBlockContext(_ctx, getState());\n    enterRule(_localctx, 148, RULE_constructorBlock);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(946);\n            match(LCURLY);\n            setState(948);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 103, _ctx)) {\n                case 1 :\n                    {\n                        setState(947);\n                        explicitConstructorInvocation();\n                    }\n                    break;\n            }\n            setState(953);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 104, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(950);\n                            blockStatement();\n                        }\n                    }\n                }\n                setState(955);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 104, _ctx);\n            } \n            setState(956);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTagContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTagContent" ],
    "fullMethods" : [ "public final InlineTagContentContext inlineTagContent() throws RecognitionException {\n    InlineTagContentContext _localctx = new InlineTagContentContext(_ctx, getState());\n    enterRule(_localctx, 40, RULE_inlineTagContent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(270);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case CODE :\n                    {\n                        setState(258);\n                        codeInlineTag();\n                    }\n                    break;\n                case LINK :\n                    {\n                        setState(259);\n                        linkInlineTag();\n                    }\n                    break;\n                case LINKPLAIN :\n                    {\n                        setState(260);\n                        linkPlainInlineTag();\n                    }\n                    break;\n                case VALUE :\n                    {\n                        setState(261);\n                        valueInlineTag();\n                    }\n                    break;\n                case INHERIT_DOC :\n                    {\n                        setState(262);\n                        inheritDocInlineTag();\n                    }\n                    break;\n                case SUMMARY :\n                    {\n                        setState(263);\n                        summaryInlineTag();\n                    }\n                    break;\n                case SYSTEM_PROPERTY :\n                    {\n                        setState(264);\n                        systemPropertyInlineTag();\n                    }\n                    break;\n                case INDEX :\n                    {\n                        setState(265);\n                        indexInlineTag();\n                    }\n                    break;\n                case RETURN :\n                    {\n                        setState(266);\n                        returnInlineTag();\n                    }\n                    break;\n                case LITERAL :\n                    {\n                        setState(267);\n                        literalInlineTag();\n                    }\n                    break;\n                case SNIPPET :\n                    {\n                        setState(268);\n                        snippetInlineTag();\n                    }\n                    break;\n                case CUSTOM_NAME :\n                    {\n                        setState(269);\n                        customInlineTag();\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameter",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameter" ],
    "fullMethods" : [ "public final FormalParameterContext formalParameter() throws RecognitionException {\n    FormalParameterContext _localctx = new FormalParameterContext(_ctx, getState());\n    enterRule(_localctx, 106, RULE_formalParameter);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(778);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 79, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(775);\n                            ((FormalParameterContext) (_localctx)).variableModifier = variableModifier();\n                            ((FormalParameterContext) (_localctx)).mods.add(((FormalParameterContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(780);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 79, _ctx);\n            } \n            setState(781);\n            ((FormalParameterContext) (_localctx)).type = typeType(true);\n            setState(782);\n            variableDeclaratorId(_localctx.mods, _localctx.type);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.systemPropertyInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.systemPropertyInlineTag" ],
    "fullMethods" : [ "public final SystemPropertyInlineTagContext systemPropertyInlineTag() throws RecognitionException {\n    SystemPropertyInlineTagContext _localctx = new SystemPropertyInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 54, RULE_systemPropertyInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(304);\n            ((SystemPropertyInlineTagContext) (_localctx)).tagName = match(SYSTEM_PROPERTY);\n            setState(306);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == IDENTIFIER) {\n                {\n                    setState(305);\n                    ((SystemPropertyInlineTagContext) (_localctx)).propertyName = qualifiedName();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeName" ],
    "fullMethods" : [ "public final TypeNameContext typeName() throws RecognitionException {\n    TypeNameContext _localctx = new TypeNameContext(_ctx, getState());\n    enterRule(_localctx, 68, RULE_typeName);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(352);\n            qualifiedName();\n            setState(354);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 46, _ctx)) {\n                case 1 :\n                    {\n                        setState(353);\n                        typeArguments();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabel",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabel" ],
    "fullMethods" : [ "public final SwitchLabelContext switchLabel() throws RecognitionException {\n    SwitchLabelContext _localctx = new SwitchLabelContext(_ctx, getState());\n    enterRule(_localctx, 198, RULE_switchLabel);\n    try {\n        setState(1247);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LITERAL_CASE :\n                _localctx = new CaseLabelContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1238);\n                    match(LITERAL_CASE);\n                    setState(1239);\n                    caseConstants();\n                    setState(1241);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 140, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1240);\n                                match(COLON);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case LITERAL_DEFAULT :\n                _localctx = new DefaultLabelContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1243);\n                    match(LITERAL_DEFAULT);\n                    setState(1245);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 141, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1244);\n                                match(COLON);\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponent" ],
    "fullMethods" : [ "public final RecordComponentContext recordComponent() throws RecognitionException {\n    RecordComponentContext _localctx = new RecordComponentContext(_ctx, getState());\n    enterRule(_localctx, 22, RULE_recordComponent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(414);\n            annotations(true);\n            setState(415);\n            ((RecordComponentContext) (_localctx)).type = typeType(true);\n            setState(416);\n            id();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.description",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.description" ],
    "fullMethods" : [ "public final DescriptionContext description() throws RecognitionException {\n    DescriptionContext _localctx = new DescriptionContext(_ctx, getState());\n    enterRule(_localctx, 84, RULE_description);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(410);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(410);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 54, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(406);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(407);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(408);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(409);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(412);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 55, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.linkPlainInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.linkPlainInlineTag" ],
    "fullMethods" : [ "public final LinkPlainInlineTagContext linkPlainInlineTag() throws RecognitionException {\n    LinkPlainInlineTagContext _localctx = new LinkPlainInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 44, RULE_linkPlainInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(279);\n            ((LinkPlainInlineTagContext) (_localctx)).tagName = match(LINKPLAIN);\n            setState(280);\n            reference();\n            setState(282);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 30, _ctx)) {\n                case 1 :\n                    {\n                        setState(281);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetInlineTag" ],
    "fullMethods" : [ "public final SnippetInlineTagContext snippetInlineTag() throws RecognitionException {\n    SnippetInlineTagContext _localctx = new SnippetInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 62, RULE_snippetInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(323);\n            ((SnippetInlineTagContext) (_localctx)).tagName = match(SNIPPET);\n            setState(327);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == SNIPPET_ATTR_NAME) {\n                {\n                    {\n                        setState(324);\n                        ((SnippetInlineTagContext) (_localctx)).snippetAttribute = snippetAttribute();\n                        ((SnippetInlineTagContext) (_localctx)).snippetAttributes.add(((SnippetInlineTagContext) (_localctx)).snippetAttribute);\n                    }\n                }\n                setState(329);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(332);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == COLON) {\n                {\n                    setState(330);\n                    match(COLON);\n                    setState(331);\n                    snippetBody();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumBody" ],
    "fullMethods" : [ "public final EnumBodyContext enumBody() throws RecognitionException {\n    EnumBodyContext _localctx = new EnumBodyContext(_ctx, getState());\n    enterRule(_localctx, 48, RULE_enumBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(494);\n            match(LCURLY);\n            setState(496);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((_la == IDENT) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                {\n                    setState(495);\n                    enumConstants();\n                }\n            }\n            setState(499);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == COMMA) {\n                {\n                    setState(498);\n                    match(COMMA);\n                }\n            }\n            setState(502);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == SEMI) {\n                {\n                    setState(501);\n                    enumBodyDeclarations();\n                }\n            }\n            setState(504);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeBoundType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeBoundType" ],
    "fullMethods" : [ "public final TypeBoundTypeContext typeBoundType() throws RecognitionException {\n    TypeBoundTypeContext _localctx = new TypeBoundTypeContext(_ctx, getState());\n    enterRule(_localctx, 44, RULE_typeBoundType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(479);\n            annotations(false);\n            setState(480);\n            classOrInterfaceOrPrimitiveType();\n            setState(484);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(481);\n                        arrayDeclarator();\n                    }\n                }\n                setState(486);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.deprecatedTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.deprecatedTag" ],
    "fullMethods" : [ "public final DeprecatedTagContext deprecatedTag() throws RecognitionException {\n    DeprecatedTagContext _localctx = new DeprecatedTagContext(_ctx, getState());\n    enterRule(_localctx, 8, RULE_deprecatedTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(152);\n            match(AT_SIGN);\n            setState(153);\n            ((DeprecatedTagContext) (_localctx)).tagName = match(DEPRECATED);\n            setState(155);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 6, _ctx)) {\n                case 1 :\n                    {\n                        setState(154);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayInitializer",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayInitializer" ],
    "fullMethods" : [ "public final ArrayInitializerContext arrayInitializer() throws RecognitionException {\n    ArrayInitializerContext _localctx = new ArrayInitializerContext(_ctx, getState());\n    enterRule(_localctx, 92, RULE_arrayInitializer);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(698);\n            match(LCURLY);\n            setState(707);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((((((_la - 49) & (~0x3f)) == 0) && (((1L << (_la - 49)) & 1101264847871L) != 0)) || ((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 35184372117491L) != 0))) || ((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 4385166758159L) != 0))) {\n                {\n                    setState(699);\n                    variableInitializer();\n                    setState(704);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 65, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(700);\n                                    match(COMMA);\n                                    setState(701);\n                                    variableInitializer();\n                                }\n                            }\n                        }\n                        setState(706);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 65, _ctx);\n                    } \n                }\n            }\n            setState(710);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == COMMA) {\n                {\n                    setState(709);\n                    match(COMMA);\n                }\n            }\n            setState(712);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceExtends",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceExtends" ],
    "fullMethods" : [ "public final InterfaceExtendsContext interfaceExtends() throws RecognitionException {\n    InterfaceExtendsContext _localctx = new InterfaceExtendsContext(_ctx, getState());\n    enterRule(_localctx, 58, RULE_interfaceExtends);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(542);\n            match(EXTENDS_CLAUSE);\n            setState(543);\n            typeList();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumConstants",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumConstants" ],
    "fullMethods" : [ "public final EnumConstantsContext enumConstants() throws RecognitionException {\n    EnumConstantsContext _localctx = new EnumConstantsContext(_ctx, getState());\n    enterRule(_localctx, 50, RULE_enumConstants);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(506);\n            enumConstant();\n            setState(511);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 33, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(507);\n                            match(COMMA);\n                            setState(508);\n                            enumConstant();\n                        }\n                    }\n                }\n                setState(513);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 33, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceOrPrimitiveType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceOrPrimitiveType" ],
    "fullMethods" : [ "public final ClassOrInterfaceOrPrimitiveTypeContext classOrInterfaceOrPrimitiveType() throws RecognitionException {\n    ClassOrInterfaceOrPrimitiveTypeContext _localctx = new ClassOrInterfaceOrPrimitiveTypeContext(_ctx, getState());\n    enterRule(_localctx, 256, RULE_classOrInterfaceOrPrimitiveType);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1660);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case IDENT :\n                case AT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        setState(1658);\n                        classOrInterfaceType(false);\n                    }\n                    break;\n                case LITERAL_VOID :\n                case LITERAL_BOOLEAN :\n                case LITERAL_BYTE :\n                case LITERAL_CHAR :\n                case LITERAL_SHORT :\n                case LITERAL_INT :\n                case LITERAL_FLOAT :\n                case LITERAL_LONG :\n                case LITERAL_DOUBLE :\n                    {\n                        setState(1659);\n                        primitiveType();\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledThrow",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledThrow" ],
    "fullMethods" : [ "public final SwitchLabeledThrowContext switchLabeledThrow() throws RecognitionException {\n    SwitchLabeledThrowContext _localctx = new SwitchLabeledThrowContext(_ctx, getState());\n    enterRule(_localctx, 172, RULE_switchLabeledThrow);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1150);\n            switchLabel();\n            setState(1151);\n            match(LAMBDA);\n            setState(1152);\n            match(LITERAL_THROW);\n            setState(1153);\n            expression();\n            setState(1154);\n            match(SEMI);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.summaryInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.summaryInlineTag" ],
    "fullMethods" : [ "public final SummaryInlineTagContext summaryInlineTag() throws RecognitionException {\n    SummaryInlineTagContext _localctx = new SummaryInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 52, RULE_summaryInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(300);\n            ((SummaryInlineTagContext) (_localctx)).tagName = match(SUMMARY);\n            setState(302);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 35, _ctx)) {\n                case 1 :\n                    {\n                        setState(301);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableAccess",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableAccess" ],
    "fullMethods" : [ "public final VariableAccessContext variableAccess() throws RecognitionException {\n    VariableAccessContext _localctx = new VariableAccessContext(_ctx, getState());\n    enterRule(_localctx, 192, RULE_variableAccess);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1218);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 136, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1215);\n                            ((VariableAccessContext) (_localctx)).fieldAccessNoIdent = fieldAccessNoIdent();\n                            ((VariableAccessContext) (_localctx)).accessList.add(((VariableAccessContext) (_localctx)).fieldAccessNoIdent);\n                        }\n                    }\n                }\n                setState(1220);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 136, _ctx);\n            } \n            setState(1223);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case IDENT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        setState(1221);\n                        id();\n                    }\n                    break;\n                case LITERAL_THIS :\n                    {\n                        setState(1222);\n                        match(LITERAL_THIS);\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchParameter",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchParameter" ],
    "fullMethods" : [ "public final CatchParameterContext catchParameter() throws RecognitionException {\n    CatchParameterContext _localctx = new CatchParameterContext(_ctx, getState());\n    enterRule(_localctx, 178, RULE_catchParameter);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1168);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 130, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1165);\n                            ((CatchParameterContext) (_localctx)).variableModifier = variableModifier();\n                            ((CatchParameterContext) (_localctx)).mods.add(((CatchParameterContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(1170);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 130, _ctx);\n            } \n            setState(1171);\n            catchType();\n            setState(1172);\n            id();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableInitializer",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableInitializer" ],
    "fullMethods" : [ "public final VariableInitializerContext variableInitializer() throws RecognitionException {\n    VariableInitializerContext _localctx = new VariableInitializerContext(_ctx, getState());\n    enterRule(_localctx, 90, RULE_variableInitializer);\n    try {\n        setState(696);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LCURLY :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(694);\n                    arrayInitializer();\n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LPAREN :\n            case LITERAL_THIS :\n            case LITERAL_SUPER :\n            case LITERAL_SWITCH :\n            case PLUS :\n            case MINUS :\n            case INC :\n            case DEC :\n            case BNOT :\n            case LNOT :\n            case LITERAL_TRUE :\n            case LITERAL_FALSE :\n            case LITERAL_NULL :\n            case LITERAL_NEW :\n            case CHAR_LITERAL :\n            case STRING_LITERAL :\n            case AT :\n            case FLOAT_LITERAL :\n            case DOUBLE_LITERAL :\n            case HEX_FLOAT_LITERAL :\n            case HEX_DOUBLE_LITERAL :\n            case LITERAL_RECORD :\n            case TEXT_BLOCK_LITERAL_BEGIN :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n            case DECIMAL_LITERAL_LONG :\n            case DECIMAL_LITERAL :\n            case HEX_LITERAL_LONG :\n            case HEX_LITERAL :\n            case OCT_LITERAL_LONG :\n            case OCT_LITERAL :\n            case BINARY_LITERAL_LONG :\n            case BINARY_LITERAL :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(695);\n                    expression();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classType" ],
    "fullMethods" : [ "public final ClassTypeContext classType() throws RecognitionException {\n    ClassTypeContext _localctx = new ClassTypeContext(_ctx, getState());\n    enterRule(_localctx, 228, RULE_classType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1538);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 177, _ctx)) {\n                case 1 :\n                    {\n                        setState(1535);\n                        classOrInterfaceType(false);\n                        setState(1536);\n                        match(DOT);\n                    }\n                    break;\n            }\n            setState(1540);\n            annotations(false);\n            setState(1541);\n            id();\n            setState(1543);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(1542);\n                    typeArguments();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceTypeExtended",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceTypeExtended" ],
    "fullMethods" : [ "public final ClassOrInterfaceTypeExtendedContext classOrInterfaceTypeExtended() throws RecognitionException {\n    ClassOrInterfaceTypeExtendedContext _localctx = new ClassOrInterfaceTypeExtendedContext(_ctx, getState());\n    enterRule(_localctx, 96, RULE_classOrInterfaceTypeExtended);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(725);\n            match(DOT);\n            setState(726);\n            annotations(false);\n            setState(727);\n            id();\n            setState(729);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 70, _ctx)) {\n                case 1 :\n                    {\n                        setState(728);\n                        typeArguments();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightHtmlContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightHtmlContent" ],
    "fullMethods" : [ "public final NonTightHtmlContentContext nonTightHtmlContent() throws RecognitionException {\n    NonTightHtmlContentContext _localctx = new NonTightHtmlContentContext(_ctx, getState());\n    enterRule(_localctx, 104, RULE_nonTightHtmlContent);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(474);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(474);\n                            _errHandler.sync(this);\n                            switch (_input.LA(1)) {\n                                case TEXT :\n                                    {\n                                        setState(472);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case JAVADOC_INLINE_TAG_START :\n                                    {\n                                        setState(473);\n                                        inlineTag();\n                                    }\n                                    break;\n                                default :\n                                    throw new NoViableAltException(this);\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(476);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 65, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordBody" ],
    "fullMethods" : [ "public final RecordBodyContext recordBody() throws RecognitionException {\n    RecordBodyContext _localctx = new RecordBodyContext(_ctx, getState());\n    enterRule(_localctx, 26, RULE_recordBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(423);\n            match(LCURLY);\n            setState(427);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028812048202823L) != 0)) || ((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 9007267974217729L) != 0))) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                {\n                    {\n                        setState(424);\n                        recordBodyDeclaration();\n                    }\n                }\n                setState(429);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(430);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeBound",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeBound" ],
    "fullMethods" : [ "public final TypeBoundContext typeBound() throws RecognitionException {\n    TypeBoundContext _localctx = new TypeBoundContext(_ctx, getState());\n    enterRule(_localctx, 42, RULE_typeBound);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(471);\n            typeBoundType();\n            setState(476);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == BAND) {\n                {\n                    {\n                        setState(472);\n                        match(BAND);\n                        setState(473);\n                        typeBoundType();\n                    }\n                }\n                setState(478);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.throwsList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.throwsList" ],
    "fullMethods" : [ "public final ThrowsListContext throwsList() throws RecognitionException {\n    ThrowsListContext _localctx = new ThrowsListContext(_ctx, getState());\n    enterRule(_localctx, 72, RULE_throwsList);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(608);\n            match(LITERAL_THROWS);\n            setState(609);\n            qualifiedNameList();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedNameList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedNameList" ],
    "fullMethods" : [ "public final QualifiedNameListContext qualifiedNameList() throws RecognitionException {\n    QualifiedNameListContext _localctx = new QualifiedNameListContext(_ctx, getState());\n    enterRule(_localctx, 100, RULE_qualifiedNameList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(743);\n            annotations(false);\n            setState(744);\n            qualifiedName();\n            setState(751);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(745);\n                        match(COMMA);\n                        setState(746);\n                        annotations(false);\n                        setState(747);\n                        qualifiedName();\n                    }\n                }\n                setState(753);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclarator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclarator" ],
    "fullMethods" : [ "public final VariableDeclaratorContext variableDeclarator(List<ModifierContext> mods, TypeTypeContext type) throws RecognitionException {\n    VariableDeclaratorContext _localctx = new VariableDeclaratorContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 86, RULE_variableDeclarator);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(669);\n            id();\n            setState(673);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(670);\n                        arrayDeclarator();\n                    }\n                }\n                setState(675);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(678);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == ASSIGN) {\n                {\n                    setState(676);\n                    match(ASSIGN);\n                    setState(677);\n                    variableInitializer();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.indexInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.indexInlineTag" ],
    "fullMethods" : [ "public final IndexInlineTagContext indexInlineTag() throws RecognitionException {\n    IndexInlineTagContext _localctx = new IndexInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 56, RULE_indexInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(308);\n            ((IndexInlineTagContext) (_localctx)).tagName = match(INDEX);\n            setState(309);\n            match(INDEX_TERM);\n            setState(311);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 37, _ctx)) {\n                case 1 :\n                    {\n                        setState(310);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordDeclaration" ],
    "fullMethods" : [ "public final RecordDeclarationContext recordDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    RecordDeclarationContext _localctx = new RecordDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 16, RULE_recordDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(382);\n            match(LITERAL_RECORD);\n            setState(383);\n            id();\n            setState(385);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(384);\n                    typeParameters();\n                }\n            }\n            setState(387);\n            recordComponentsList();\n            setState(389);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_IMPLEMENTS) {\n                {\n                    setState(388);\n                    implementsClause();\n                }\n            }\n            setState(391);\n            recordBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceMemberDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceMemberDeclaration" ],
    "fullMethods" : [ "public final InterfaceMemberDeclarationContext interfaceMemberDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    InterfaceMemberDeclarationContext _localctx = new InterfaceMemberDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 80, RULE_interfaceMemberDeclaration);\n    try {\n        setState(642);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 54, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(635);\n                    fieldDeclaration(mods);\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(636);\n                    recordDeclaration(mods);\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(637);\n                    interfaceMethodDeclaration(mods);\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(638);\n                    interfaceDeclaration(mods);\n                }\n                break;\n            case 5 :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(639);\n                    annotationTypeDeclaration(mods);\n                }\n                break;\n            case 6 :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(640);\n                    classDeclaration(mods);\n                }\n                break;\n            case 7 :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(641);\n                    enumDeclaration(mods);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledRule",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledRule" ],
    "fullMethods" : [ "public final SwitchLabeledRuleContext switchLabeledRule() throws RecognitionException {\n    SwitchLabeledRuleContext _localctx = new SwitchLabeledRuleContext(_ctx, getState());\n    enterRule(_localctx, 166, RULE_switchLabeledRule);\n    try {\n        setState(1139);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 129, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1136);\n                    switchLabeledExpression();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1137);\n                    switchLabeledBlock();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1138);\n                    switchLabeledThrow();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledExpression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledExpression" ],
    "fullMethods" : [ "public final SwitchLabeledExpressionContext switchLabeledExpression() throws RecognitionException {\n    SwitchLabeledExpressionContext _localctx = new SwitchLabeledExpressionContext(_ctx, getState());\n    enterRule(_localctx, 168, RULE_switchLabeledExpression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1141);\n            switchLabel();\n            setState(1142);\n            match(LAMBDA);\n            setState(1143);\n            expression();\n            setState(1144);\n            match(SEMI);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTag" ],
    "fullMethods" : [ "public final InlineTagContext inlineTag() throws RecognitionException {\n    InlineTagContext _localctx = new InlineTagContext(_ctx, getState());\n    enterRule(_localctx, 38, RULE_inlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(254);\n            match(JAVADOC_INLINE_TAG_START);\n            setState(255);\n            inlineTagContent();\n            setState(256);\n            match(JAVADOC_INLINE_TAG_END);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotations",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotations" ],
    "fullMethods" : [ "public final AnnotationsContext annotations(boolean createImaginaryNode) throws RecognitionException {\n    AnnotationsContext _localctx = new AnnotationsContext(_ctx, getState(), createImaginaryNode);\n    enterRule(_localctx, 122, RULE_annotations);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(827);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 83, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(824);\n                            ((AnnotationsContext) (_localctx)).annotation = annotation();\n                            ((AnnotationsContext) (_localctx)).anno.add(((AnnotationsContext) (_localctx)).annotation);\n                        }\n                    }\n                }\n                setState(829);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 83, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlTagStart",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlTagStart" ],
    "fullMethods" : [ "public final HtmlTagStartContext htmlTagStart() throws RecognitionException {\n    HtmlTagStartContext _localctx = new HtmlTagStartContext(_ctx, getState());\n    enterRule(_localctx, 96, RULE_htmlTagStart);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(444);\n            match(TAG_OPEN);\n            setState(445);\n            match(TAG_NAME);\n            setState(449);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == TAG_ATTR_NAME) {\n                {\n                    {\n                        setState(446);\n                        ((HtmlTagStartContext) (_localctx)).htmlAttribute = htmlAttribute();\n                        ((HtmlTagStartContext) (_localctx)).htmlAttributes.add(((HtmlTagStartContext) (_localctx)).htmlAttribute);\n                    }\n                }\n                setState(451);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(452);\n            match(TAG_CLOSE);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.literal",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.literal" ],
    "fullMethods" : [ "public final LiteralContext literal() throws RecognitionException {\n    LiteralContext _localctx = new LiteralContext(_ctx, getState());\n    enterRule(_localctx, 114, RULE_literal);\n    try {\n        setState(814);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case DECIMAL_LITERAL_LONG :\n            case DECIMAL_LITERAL :\n            case HEX_LITERAL_LONG :\n            case HEX_LITERAL :\n            case OCT_LITERAL_LONG :\n            case OCT_LITERAL :\n            case BINARY_LITERAL_LONG :\n            case BINARY_LITERAL :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(806);\n                    integerLiteral();\n                }\n                break;\n            case FLOAT_LITERAL :\n            case DOUBLE_LITERAL :\n            case HEX_FLOAT_LITERAL :\n            case HEX_DOUBLE_LITERAL :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(807);\n                    floatLiteral();\n                }\n                break;\n            case TEXT_BLOCK_LITERAL_BEGIN :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(808);\n                    textBlockLiteral();\n                }\n                break;\n            case CHAR_LITERAL :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(809);\n                    match(CHAR_LITERAL);\n                }\n                break;\n            case STRING_LITERAL :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(810);\n                    match(STRING_LITERAL);\n                }\n                break;\n            case LITERAL_TRUE :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(811);\n                    match(LITERAL_TRUE);\n                }\n                break;\n            case LITERAL_FALSE :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(812);\n                    match(LITERAL_FALSE);\n                }\n                break;\n            case LITERAL_NULL :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(813);\n                    match(LITERAL_NULL);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlock",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlock" ],
    "fullMethods" : [ "public final SwitchBlockContext switchBlock() throws RecognitionException {\n    SwitchBlockContext _localctx = new SwitchBlockContext(_ctx, getState());\n    enterRule(_localctx, 164, RULE_switchBlock);\n    int _la;\n    try {\n        int _alt;\n        setState(1134);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 128, _ctx)) {\n            case 1 :\n                _localctx = new SwitchRulesContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1118);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    do {\n                        {\n                            {\n                                setState(1117);\n                                switchLabeledRule();\n                            }\n                        }\n                        setState(1120);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } while ((_la == LITERAL_CASE) || (_la == LITERAL_DEFAULT) );\n                }\n                break;\n            case 2 :\n                _localctx = new SwitchBlocksContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1125);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 126, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(1122);\n                                    ((SwitchBlocksContext) (_localctx)).switchBlockStatementGroup = switchBlockStatementGroup();\n                                    ((SwitchBlocksContext) (_localctx)).groups.add(((SwitchBlocksContext) (_localctx)).switchBlockStatementGroup);\n                                }\n                            }\n                        }\n                        setState(1127);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 126, _ctx);\n                    } \n                    setState(1131);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LITERAL_CASE) || (_la == LITERAL_DEFAULT)) {\n                        {\n                            {\n                                setState(1128);\n                                ((SwitchBlocksContext) (_localctx)).switchLabel = switchLabel();\n                                ((SwitchBlocksContext) (_localctx)).emptyLabels.add(((SwitchBlocksContext) (_localctx)).switchLabel);\n                            }\n                        }\n                        setState(1133);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeList" ],
    "fullMethods" : [ "public final TypeListContext typeList() throws RecognitionException {\n    TypeListContext _localctx = new TypeListContext(_ctx, getState());\n    enterRule(_localctx, 252, RULE_typeList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1642);\n            typeType(false);\n            setState(1647);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1643);\n                        match(COMMA);\n                        setState(1644);\n                        typeType(false);\n                    }\n                }\n                setState(1649);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guardedPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guardedPattern" ],
    "fullMethods" : [ "public final GuardedPatternContext guardedPattern() throws RecognitionException {\n    GuardedPatternContext _localctx = new GuardedPatternContext(_ctx, getState());\n    enterRule(_localctx, 272, RULE_guardedPattern);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1708);\n            primaryPattern();\n            setState(1709);\n            guard();\n            setState(1710);\n            expression();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.importDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.importDeclaration" ],
    "fullMethods" : [ "public final ImportDeclarationContext importDeclaration() throws RecognitionException {\n    ImportDeclarationContext _localctx = new ImportDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 4, RULE_importDeclaration);\n    int _la;\n    try {\n        setState(322);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case IMPORT :\n                _localctx = new ImportDecContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(310);\n                    match(IMPORT);\n                    setState(312);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LITERAL_STATIC) {\n                        {\n                            setState(311);\n                            match(LITERAL_STATIC);\n                        }\n                    }\n                    setState(314);\n                    qualifiedName();\n                    setState(317);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == DOT) {\n                        {\n                            setState(315);\n                            match(DOT);\n                            setState(316);\n                            match(STAR);\n                        }\n                    }\n                    setState(319);\n                    match(SEMI);\n                }\n                break;\n            case SEMI :\n                _localctx = new SingleSemiImportContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(321);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.parExpression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.parExpression" ],
    "fullMethods" : [ "public final ParExpressionContext parExpression() throws RecognitionException {\n    ParExpressionContext _localctx = new ParExpressionContext(_ctx, getState());\n    enterRule(_localctx, 212, RULE_parExpression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1303);\n            match(LPAREN);\n            setState(1304);\n            expression();\n            setState(1305);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.selfClosingElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.selfClosingElement" ],
    "fullMethods" : [ "public final SelfClosingElementContext selfClosingElement() throws RecognitionException {\n    SelfClosingElementContext _localctx = new SelfClosingElementContext(_ctx, getState());\n    enterRule(_localctx, 94, RULE_selfClosingElement);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(434);\n            match(TAG_OPEN);\n            setState(435);\n            match(TAG_NAME);\n            setState(439);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == TAG_ATTR_NAME) {\n                {\n                    {\n                        setState(436);\n                        ((SelfClosingElementContext) (_localctx)).htmlAttribute = htmlAttribute();\n                        ((SelfClosingElementContext) (_localctx)).htmlAttributes.add(((SelfClosingElementContext) (_localctx)).htmlAttribute);\n                    }\n                }\n                setState(441);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(442);\n            match(TAG_SLASH_CLOSE);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.customInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.customInlineTag" ],
    "fullMethods" : [ "public final CustomInlineTagContext customInlineTag() throws RecognitionException {\n    CustomInlineTagContext _localctx = new CustomInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 64, RULE_customInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(334);\n            ((CustomInlineTagContext) (_localctx)).tagName = match(CUSTOM_NAME);\n            setState(336);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 42, _ctx)) {\n                case 1 :\n                    {\n                        setState(335);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameterList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameterList" ],
    "fullMethods" : [ "public final FormalParameterListContext formalParameterList() throws RecognitionException {\n    FormalParameterListContext _localctx = new FormalParameterListContext(_ctx, getState());\n    enterRule(_localctx, 104, RULE_formalParameterList);\n    int _la;\n    try {\n        int _alt;\n        setState(773);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 78, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(760);\n                    formalParameter();\n                    setState(765);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 76, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(761);\n                                    match(COMMA);\n                                    setState(762);\n                                    formalParameter();\n                                }\n                            }\n                        }\n                        setState(767);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 76, _ctx);\n                    } \n                    setState(770);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == COMMA) {\n                        {\n                            setState(768);\n                            match(COMMA);\n                            setState(769);\n                            lastFormalParameter();\n                        }\n                    }\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(772);\n                    lastFormalParameter();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeUpperBounds",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeUpperBounds" ],
    "fullMethods" : [ "public final TypeUpperBoundsContext typeUpperBounds() throws RecognitionException {\n    TypeUpperBoundsContext _localctx = new TypeUpperBoundsContext(_ctx, getState());\n    enterRule(_localctx, 40, RULE_typeUpperBounds);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(467);\n            match(EXTENDS_CLAUSE);\n            setState(468);\n            annotations(false);\n            setState(469);\n            typeBound();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.hiddenTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.hiddenTag" ],
    "fullMethods" : [ "public final HiddenTagContext hiddenTag() throws RecognitionException {\n    HiddenTagContext _localctx = new HiddenTagContext(_ctx, getState());\n    enterRule(_localctx, 24, RULE_hiddenTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(211);\n            match(AT_SIGN);\n            setState(212);\n            ((HiddenTagContext) (_localctx)).tagName = match(LITERAL_HIDDEN);\n            setState(214);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 19, _ctx)) {\n                case 1 :\n                    {\n                        setState(213);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExprContext expr() throws RecognitionException {\n    return expr(0);\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inheritDocInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inheritDocInlineTag" ],
    "fullMethods" : [ "public final InheritDocInlineTagContext inheritDocInlineTag() throws RecognitionException {\n    InheritDocInlineTagContext _localctx = new InheritDocInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 50, RULE_inheritDocInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(296);\n            ((InheritDocInlineTagContext) (_localctx)).tagName = match(INHERIT_DOC);\n            setState(298);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((_la == IDENTIFIER) || (_la == HASH)) {\n                {\n                    setState(297);\n                    reference();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resourceSpecification",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resourceSpecification" ],
    "fullMethods" : [ "public final ResourceSpecificationContext resourceSpecification() throws RecognitionException {\n    ResourceSpecificationContext _localctx = new ResourceSpecificationContext(_ctx, getState());\n    enterRule(_localctx, 184, RULE_resourceSpecification);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1185);\n            match(LPAREN);\n            setState(1186);\n            resources();\n            setState(1188);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == SEMI) {\n                {\n                    setState(1187);\n                    match(SEMI);\n                }\n            }\n            setState(1190);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetAttribute",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetAttribute" ],
    "fullMethods" : [ "public final SnippetAttributeContext snippetAttribute() throws RecognitionException {\n    SnippetAttributeContext _localctx = new SnippetAttributeContext(_ctx, getState());\n    enterRule(_localctx, 80, RULE_snippetAttribute);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(397);\n            match(SNIPPET_ATTR_NAME);\n            setState(398);\n            match(EQUALS);\n            setState(399);\n            match(ATTRIBUTE_VALUE);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.textBlockLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.textBlockLiteral" ],
    "fullMethods" : [ "public final TextBlockLiteralContext textBlockLiteral() throws RecognitionException {\n    TextBlockLiteralContext _localctx = new TextBlockLiteralContext(_ctx, getState());\n    enterRule(_localctx, 120, RULE_textBlockLiteral);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(820);\n            match(TEXT_BLOCK_LITERAL_BEGIN);\n            setState(821);\n            match(TEXT_BLOCK_CONTENT);\n            setState(822);\n            match(TEXT_BLOCK_LITERAL_END);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.modifier",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.modifier" ],
    "fullMethods" : [ "public final ModifierContext modifier() throws RecognitionException {\n    ModifierContext _localctx = new ModifierContext(_ctx, getState());\n    enterRule(_localctx, 10, RULE_modifier);\n    try {\n        setState(360);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case AT :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(345);\n                    annotation();\n                }\n                break;\n            case LITERAL_PUBLIC :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(346);\n                    match(LITERAL_PUBLIC);\n                }\n                break;\n            case LITERAL_PROTECTED :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(347);\n                    match(LITERAL_PROTECTED);\n                }\n                break;\n            case LITERAL_PRIVATE :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(348);\n                    match(LITERAL_PRIVATE);\n                }\n                break;\n            case LITERAL_STATIC :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(349);\n                    match(LITERAL_STATIC);\n                }\n                break;\n            case ABSTRACT :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(350);\n                    match(ABSTRACT);\n                }\n                break;\n            case LITERAL_DEFAULT :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(351);\n                    match(LITERAL_DEFAULT);\n                }\n                break;\n            case FINAL :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(352);\n                    match(FINAL);\n                }\n                break;\n            case STRICTFP :\n                enterOuterAlt(_localctx, 9);\n                {\n                    setState(353);\n                    match(STRICTFP);\n                }\n                break;\n            case LITERAL_NATIVE :\n                enterOuterAlt(_localctx, 10);\n                {\n                    setState(354);\n                    match(LITERAL_NATIVE);\n                }\n                break;\n            case LITERAL_SYNCHRONIZED :\n                enterOuterAlt(_localctx, 11);\n                {\n                    setState(355);\n                    match(LITERAL_SYNCHRONIZED);\n                }\n                break;\n            case LITERAL_TRANSIENT :\n                enterOuterAlt(_localctx, 12);\n                {\n                    setState(356);\n                    match(LITERAL_TRANSIENT);\n                }\n                break;\n            case LITERAL_VOLATILE :\n                enterOuterAlt(_localctx, 13);\n                {\n                    setState(357);\n                    match(LITERAL_VOLATILE);\n                }\n                break;\n            case LITERAL_NON_SEALED :\n                enterOuterAlt(_localctx, 14);\n                {\n                    setState(358);\n                    match(LITERAL_NON_SEALED);\n                }\n                break;\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 15);\n                {\n                    setState(359);\n                    match(LITERAL_SEALED);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.nonWildcardTypeArgumentsOrDiamond",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.nonWildcardTypeArgumentsOrDiamond" ],
    "fullMethods" : [ "public final NonWildcardTypeArgumentsOrDiamondContext nonWildcardTypeArgumentsOrDiamond() throws RecognitionException {\n    NonWildcardTypeArgumentsOrDiamondContext _localctx = new NonWildcardTypeArgumentsOrDiamondContext(_ctx, getState());\n    enterRule(_localctx, 246, RULE_nonWildcardTypeArgumentsOrDiamond);\n    try {\n        setState(1628);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 192, _ctx)) {\n            case 1 :\n                _localctx = new NonWildcardDiamondContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1625);\n                    match(LT);\n                    setState(1626);\n                    match(GT);\n                }\n                break;\n            case 2 :\n                _localctx = new NonWildcardTypeArgsContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1627);\n                    nonWildcardTypeArguments();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodDeclaration" ],
    "fullMethods" : [ "public final MethodDeclarationContext methodDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    MethodDeclarationContext _localctx = new MethodDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 68, RULE_methodDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(588);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(587);\n                    ((MethodDeclarationContext) (_localctx)).typeParams = typeParameters();\n                }\n            }\n            setState(590);\n            ((MethodDeclarationContext) (_localctx)).type = typeType(true);\n            setState(591);\n            id();\n            setState(592);\n            formalParameters();\n            {\n                setState(596);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n                while ((_la == LBRACK) || (_la == AT)) {\n                    {\n                        {\n                            setState(593);\n                            ((MethodDeclarationContext) (_localctx)).arrayDeclarator = arrayDeclarator();\n                            ((MethodDeclarationContext) (_localctx)).cStyleArrDec.add(((MethodDeclarationContext) (_localctx)).arrayDeclarator);\n                        }\n                    }\n                    setState(598);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                } \n            }\n            setState(600);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_THROWS) {\n                {\n                    setState(599);\n                    throwsList();\n                }\n            }\n            setState(602);\n            methodBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.finallyBlock",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.finallyBlock" ],
    "fullMethods" : [ "public final FinallyBlockContext finallyBlock() throws RecognitionException {\n    FinallyBlockContext _localctx = new FinallyBlockContext(_ctx, getState());\n    enterRule(_localctx, 182, RULE_finallyBlock);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1182);\n            match(LITERAL_FINALLY);\n            setState(1183);\n            block();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.id",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.id" ],
    "fullMethods" : [ "public final IdContext id() throws RecognitionException {\n    IdContext _localctx = new IdContext(_ctx, getState());\n    enterRule(_localctx, 286, RULE_id);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1766);\n            _la = _input.LA(1);\n            if (!((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0)))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementRest" ],
    "fullMethods" : [ "public final AnnotationTypeElementRestContext annotationTypeElementRest(List<ModifierContext> mods) throws RecognitionException {\n    AnnotationTypeElementRestContext _localctx = new AnnotationTypeElementRestContext(_ctx, getState(), mods);\n    enterRule(_localctx, 140, RULE_annotationTypeElementRest);\n    try {\n        setState(927);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 100, _ctx)) {\n            case 1 :\n                _localctx = new AnnotationFieldContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(897);\n                    ((AnnotationFieldContext) (_localctx)).type = typeType(true);\n                    setState(900);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 94, _ctx)) {\n                        case 1 :\n                            {\n                                setState(898);\n                                annotationMethodRest(mods, ((AnnotationFieldContext) (_localctx)).type);\n                            }\n                            break;\n                        case 2 :\n                            {\n                                setState(899);\n                                annotationConstantRest(mods, ((AnnotationFieldContext) (_localctx)).type);\n                            }\n                            break;\n                    }\n                    setState(902);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(904);\n                    ((AnnotationTypeContext) (_localctx)).type = typeType(true);\n                    setState(905);\n                    match(SEMI);\n                }\n                break;\n            case 3 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(907);\n                    classDeclaration(mods);\n                    setState(909);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 95, _ctx)) {\n                        case 1 :\n                            {\n                                setState(908);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 4 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(911);\n                    recordDeclaration(mods);\n                    setState(913);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 96, _ctx)) {\n                        case 1 :\n                            {\n                                setState(912);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 5 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(915);\n                    interfaceDeclaration(mods);\n                    setState(917);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 97, _ctx)) {\n                        case 1 :\n                            {\n                                setState(916);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 6 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(919);\n                    enumDeclaration(mods);\n                    setState(921);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 98, _ctx)) {\n                        case 1 :\n                            {\n                                setState(920);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 7 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(923);\n                    annotationTypeDeclaration(mods);\n                    setState(925);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 99, _ctx)) {\n                        case 1 :\n                            {\n                                setState(924);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgumentsOrDiamond",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgumentsOrDiamond" ],
    "fullMethods" : [ "public final TypeArgumentsOrDiamondContext typeArgumentsOrDiamond() throws RecognitionException {\n    TypeArgumentsOrDiamondContext _localctx = new TypeArgumentsOrDiamondContext(_ctx, getState());\n    enterRule(_localctx, 244, RULE_typeArgumentsOrDiamond);\n    try {\n        setState(1623);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 191, _ctx)) {\n            case 1 :\n                _localctx = new DiamondContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1620);\n                    match(LT);\n                    setState(1621);\n                    match(GT);\n                }\n                break;\n            case 2 :\n                _localctx = new TypeArgsContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1622);\n                    typeArguments();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightElement" ],
    "fullMethods" : [ "public final NonTightElementContext nonTightElement() throws RecognitionException {\n    NonTightElementContext _localctx = new NonTightElementContext(_ctx, getState());\n    enterRule(_localctx, 92, RULE_nonTightElement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(430);\n            htmlTagStart();\n            setState(432);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 58, _ctx)) {\n                case 1 :\n                    {\n                        setState(431);\n                        nonTightHtmlContent();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.seeTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.seeTag" ],
    "fullMethods" : [ "public final SeeTagContext seeTag() throws RecognitionException {\n    SeeTagContext _localctx = new SeeTagContext(_ctx, getState());\n    enterRule(_localctx, 22, RULE_seeTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(196);\n            match(AT_SIGN);\n            setState(209);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 18, _ctx)) {\n                case 1 :\n                    {\n                        setState(197);\n                        ((SeeTagContext) (_localctx)).tagName = match(SEE);\n                        setState(198);\n                        match(STRING_LITERAL);\n                    }\n                    break;\n                case 2 :\n                    {\n                        setState(199);\n                        ((SeeTagContext) (_localctx)).tagName = match(SEE);\n                        setState(200);\n                        reference();\n                        setState(202);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 16, _ctx)) {\n                            case 1 :\n                                {\n                                    setState(201);\n                                    description();\n                                }\n                                break;\n                        }\n                    }\n                    break;\n                case 3 :\n                    {\n                        setState(204);\n                        ((SeeTagContext) (_localctx)).tagName = match(SEE);\n                        setState(205);\n                        htmlElement();\n                        setState(207);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 17, _ctx)) {\n                            case 1 :\n                                {\n                                    setState(206);\n                                    description();\n                                }\n                                break;\n                        }\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classCreatorRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classCreatorRest" ],
    "fullMethods" : [ "public final ClassCreatorRestContext classCreatorRest() throws RecognitionException {\n    ClassCreatorRestContext _localctx = new ClassCreatorRestContext(_ctx, getState());\n    enterRule(_localctx, 242, RULE_classCreatorRest);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1616);\n            arguments();\n            setState(1618);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 190, _ctx)) {\n                case 1 :\n                    {\n                        setState(1617);\n                        classBody();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchType" ],
    "fullMethods" : [ "public final CatchTypeContext catchType() throws RecognitionException {\n    CatchTypeContext _localctx = new CatchTypeContext(_ctx, getState());\n    enterRule(_localctx, 180, RULE_catchType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1174);\n            classOrInterfaceType(false);\n            setState(1179);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == BOR) {\n                {\n                    {\n                        setState(1175);\n                        match(BOR);\n                        setState(1176);\n                        classOrInterfaceType(false);\n                    }\n                }\n                setState(1181);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdNameExtended",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdNameExtended" ],
    "fullMethods" : [ "public final CreatedNameExtendedContext createdNameExtended() throws RecognitionException {\n    CreatedNameExtendedContext _localctx = new CreatedNameExtendedContext(_ctx, getState());\n    enterRule(_localctx, 234, RULE_createdNameExtended);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1573);\n            match(DOT);\n            setState(1574);\n            annotations(false);\n            setState(1575);\n            id();\n            setState(1577);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(1576);\n                    typeArgumentsOrDiamond();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledBlock",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledBlock" ],
    "fullMethods" : [ "public final SwitchLabeledBlockContext switchLabeledBlock() throws RecognitionException {\n    SwitchLabeledBlockContext _localctx = new SwitchLabeledBlockContext(_ctx, getState());\n    enterRule(_localctx, 170, RULE_switchLabeledBlock);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1146);\n            switchLabel();\n            setState(1147);\n            match(LAMBDA);\n            setState(1148);\n            block();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.bracketsWithExp",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.bracketsWithExp" ],
    "fullMethods" : [ "public final BracketsWithExpContext bracketsWithExp() throws RecognitionException {\n    BracketsWithExpContext _localctx = new BracketsWithExpContext(_ctx, getState());\n    enterRule(_localctx, 240, RULE_bracketsWithExp);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1611);\n            annotations(false);\n            setState(1612);\n            match(LBRACK);\n            setState(1613);\n            expression();\n            setState(1614);\n            match(RBRACK);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponentPatternList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponentPatternList" ],
    "fullMethods" : [ "public final RecordComponentPatternListContext recordComponentPatternList() throws RecognitionException {\n    RecordComponentPatternListContext _localctx = new RecordComponentPatternListContext(_ctx, getState());\n    enterRule(_localctx, 282, RULE_recordComponentPatternList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1749);\n            innerPattern();\n            setState(1754);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1750);\n                        match(COMMA);\n                        setState(1751);\n                        innerPattern();\n                    }\n                }\n                setState(1756);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.forControl",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.forControl" ],
    "fullMethods" : [ "public final ForControlContext forControl() throws RecognitionException {\n    ForControlContext _localctx = new ForControlContext(_ctx, getState());\n    enterRule(_localctx, 204, RULE_forControl);\n    int _la;\n    try {\n        setState(1282);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 149, _ctx)) {\n            case 1 :\n                _localctx = new EnhancedForContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1262);\n                    match(LPAREN);\n                    setState(1265);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 145, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1263);\n                                enhancedForControl();\n                            }\n                            break;\n                        case 2 :\n                            {\n                                setState(1264);\n                                enhancedForControlWithRecordPattern();\n                            }\n                            break;\n                    }\n                    setState(1267);\n                    match(RPAREN);\n                }\n                break;\n            case 2 :\n                _localctx = new ForForContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1269);\n                    match(LPAREN);\n                    setState(1271);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 37156484702796807L) != 0)) || ((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 35184372117491L) != 0))) || ((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 4385166758159L) != 0))) {\n                        {\n                            setState(1270);\n                            forInit();\n                        }\n                    }\n                    setState(1273);\n                    match(SEMI);\n                    setState(1275);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1274);\n                            ((ForForContext) (_localctx)).forCond = expression();\n                        }\n                    }\n                    setState(1277);\n                    match(SEMI);\n                    setState(1279);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1278);\n                            ((ForForContext) (_localctx)).forUpdate = expressionList();\n                        }\n                    }\n                    setState(1281);\n                    match(RPAREN);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclaratorId",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclaratorId" ],
    "fullMethods" : [ "public final VariableDeclaratorIdContext variableDeclaratorId(List<VariableModifierContext> mods, ParserRuleContext type) throws RecognitionException {\n    VariableDeclaratorIdContext _localctx = new VariableDeclaratorIdContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 88, RULE_variableDeclaratorId);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(686);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case LITERAL_THIS :\n                    {\n                        setState(680);\n                        match(LITERAL_THIS);\n                    }\n                    break;\n                case IDENT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        {\n                            setState(681);\n                            qualifiedName();\n                            setState(684);\n                            _errHandler.sync(this);\n                            _la = _input.LA(1);\n                            if (_la == DOT) {\n                                {\n                                    setState(682);\n                                    match(DOT);\n                                    setState(683);\n                                    match(LITERAL_THIS);\n                                }\n                            }\n                        }\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n            setState(691);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(688);\n                        arrayDeclarator();\n                    }\n                }\n                setState(693);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationMethodRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationMethodRest" ],
    "fullMethods" : [ "public final AnnotationMethodRestContext annotationMethodRest(List<ModifierContext> mods, TypeTypeContext type) throws RecognitionException {\n    AnnotationMethodRestContext _localctx = new AnnotationMethodRestContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 142, RULE_annotationMethodRest);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(929);\n            id();\n            setState(930);\n            match(LPAREN);\n            setState(931);\n            match(RPAREN);\n            setState(935);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(932);\n                        ((AnnotationMethodRestContext) (_localctx)).arrayDeclarator = arrayDeclarator();\n                        ((AnnotationMethodRestContext) (_localctx)).cStyleArrDec.add(((AnnotationMethodRestContext) (_localctx)).arrayDeclarator);\n                    }\n                }\n                setState(937);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(939);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_DEFAULT) {\n                {\n                    setState(938);\n                    defaultValue();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBody" ],
    "fullMethods" : [ "public final InterfaceBodyContext interfaceBody() throws RecognitionException {\n    InterfaceBodyContext _localctx = new InterfaceBodyContext(_ctx, getState());\n    enterRule(_localctx, 62, RULE_interfaceBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(554);\n            match(LCURLY);\n            setState(558);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028803458268231L) != 0)) || ((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 9007267974217729L) != 0))) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                {\n                    {\n                        setState(555);\n                        interfaceBodyDeclaration();\n                    }\n                }\n                setState(560);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(561);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classBodyDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classBodyDeclaration" ],
    "fullMethods" : [ "public final ClassBodyDeclarationContext classBodyDeclaration() throws RecognitionException {\n    ClassBodyDeclarationContext _localctx = new ClassBodyDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 64, RULE_classBodyDeclaration);\n    int _la;\n    try {\n        int _alt;\n        setState(575);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 44, _ctx)) {\n            case 1 :\n                _localctx = new EmptyClassContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(563);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new ClassBlockContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(565);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LITERAL_STATIC) {\n                        {\n                            setState(564);\n                            match(LITERAL_STATIC);\n                        }\n                    }\n                    setState(567);\n                    block();\n                }\n                break;\n            case 3 :\n                _localctx = new ClassDefContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(571);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 43, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(568);\n                                    ((ClassDefContext) (_localctx)).modifier = modifier();\n                                    ((ClassDefContext) (_localctx)).mods.add(((ClassDefContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(573);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 43, _ctx);\n                    } \n                    setState(574);\n                    memberDeclaration(((ClassDefContext) (_localctx)).mods);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponentsList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponentsList" ],
    "fullMethods" : [ "public final RecordComponentsListContext recordComponentsList() throws RecognitionException {\n    RecordComponentsListContext _localctx = new RecordComponentsListContext(_ctx, getState());\n    enterRule(_localctx, 18, RULE_recordComponentsList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(393);\n            match(LPAREN);\n            setState(395);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                {\n                    setState(394);\n                    recordComponents();\n                }\n            }\n            setState(397);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.defaultValue",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.defaultValue" ],
    "fullMethods" : [ "public final DefaultValueContext defaultValue() throws RecognitionException {\n    DefaultValueContext _localctx = new DefaultValueContext(_ctx, getState());\n    enterRule(_localctx, 146, RULE_defaultValue);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(943);\n            match(LITERAL_DEFAULT);\n            setState(944);\n            elementValue();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceDeclaration" ],
    "fullMethods" : [ "public final InterfaceDeclarationContext interfaceDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    InterfaceDeclarationContext _localctx = new InterfaceDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 56, RULE_interfaceDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(529);\n            match(LITERAL_INTERFACE);\n            setState(530);\n            id();\n            setState(532);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(531);\n                    typeParameters();\n                }\n            }\n            setState(535);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == EXTENDS_CLAUSE) {\n                {\n                    setState(534);\n                    interfaceExtends();\n                }\n            }\n            setState(538);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_PERMITS) {\n                {\n                    setState(537);\n                    permittedSubclassesAndInterfaces();\n                }\n            }\n            setState(540);\n            interfaceBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedNameExtended",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedNameExtended" ],
    "fullMethods" : [ "public final QualifiedNameExtendedContext qualifiedNameExtended() throws RecognitionException {\n    QualifiedNameExtendedContext _localctx = new QualifiedNameExtendedContext(_ctx, getState());\n    enterRule(_localctx, 112, RULE_qualifiedNameExtended);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(802);\n            match(DOT);\n            setState(803);\n            annotations(false);\n            setState(804);\n            id();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.nonWildcardTypeArguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.nonWildcardTypeArguments" ],
    "fullMethods" : [ "public final NonWildcardTypeArgumentsContext nonWildcardTypeArguments() throws RecognitionException {\n    NonWildcardTypeArgumentsContext _localctx = new NonWildcardTypeArgumentsContext(_ctx, getState());\n    enterRule(_localctx, 248, RULE_nonWildcardTypeArguments);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1630);\n            match(LT);\n            setState(1631);\n            typeArgumentsTypeList();\n            setState(1632);\n            match(GT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdName" ],
    "fullMethods" : [ "public final CreatedNameContext createdName() throws RecognitionException {\n    CreatedNameContext _localctx = new CreatedNameContext(_ctx, getState());\n    enterRule(_localctx, 232, RULE_createdName);\n    int _la;\n    try {\n        setState(1571);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case IDENT :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                _localctx = new CreatedNameObjectContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1559);\n                    annotations(false);\n                    setState(1560);\n                    id();\n                    setState(1562);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(1561);\n                            typeArgumentsOrDiamond();\n                        }\n                    }\n                    setState(1567);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while (_la == DOT) {\n                        {\n                            {\n                                setState(1564);\n                                ((CreatedNameObjectContext) (_localctx)).createdNameExtended = createdNameExtended();\n                                ((CreatedNameObjectContext) (_localctx)).extended.add(((CreatedNameObjectContext) (_localctx)).createdNameExtended);\n                            }\n                        }\n                        setState(1569);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n                _localctx = new CreatedNamePrimitiveContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1570);\n                    primitiveType();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.packageDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.packageDeclaration" ],
    "fullMethods" : [ "public final PackageDeclarationContext packageDeclaration() throws RecognitionException {\n    PackageDeclarationContext _localctx = new PackageDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 2, RULE_packageDeclaration);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(305);\n            annotations(true);\n            setState(306);\n            match(LITERAL_PACKAGE);\n            setState(307);\n            qualifiedName();\n            setState(308);\n            match(SEMI);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.javadoc",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.javadoc" ],
    "fullMethods" : [ "public final JavadocContext javadoc() throws RecognitionException {\n    JavadocContext _localctx = new JavadocContext(_ctx, getState());\n    enterRule(_localctx, 0, RULE_javadoc);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(111);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 0, _ctx)) {\n                case 1 :\n                    {\n                        setState(110);\n                        mainDescription();\n                    }\n                    break;\n            }\n            setState(116);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == AT_SIGN) {\n                {\n                    {\n                        setState(113);\n                        blockTag();\n                    }\n                }\n                setState(118);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(119);\n            match(EOF);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lambdaParameters",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lambdaParameters" ],
    "fullMethods" : [ "public final LambdaParametersContext lambdaParameters() throws RecognitionException {\n    LambdaParametersContext _localctx = new LambdaParametersContext(_ctx, getState());\n    enterRule(_localctx, 222, RULE_lambdaParameters);\n    int _la;\n    try {\n        setState(1494);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 172, _ctx)) {\n            case 1 :\n                _localctx = new SingleLambdaParamContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1484);\n                    id();\n                }\n                break;\n            case 2 :\n                _localctx = new FormalLambdaParamContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1485);\n                    match(LPAREN);\n                    setState(1487);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((((_la & (~0x3f)) == 0) && (((1L << _la) & 575898352105816064L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                        {\n                            setState(1486);\n                            formalParameterList();\n                        }\n                    }\n                    setState(1489);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new MultiLambdaParamContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1490);\n                    match(LPAREN);\n                    setState(1491);\n                    multiLambdaParams();\n                    setState(1492);\n                    match(RPAREN);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotation",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotation" ],
    "fullMethods" : [ "public final AnnotationContext annotation() throws RecognitionException {\n    AnnotationContext _localctx = new AnnotationContext(_ctx, getState());\n    enterRule(_localctx, 124, RULE_annotation);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(830);\n            match(AT);\n            setState(831);\n            qualifiedName();\n            setState(838);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LPAREN) {\n                {\n                    setState(832);\n                    match(LPAREN);\n                    setState(835);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 84, _ctx)) {\n                        case 1 :\n                            {\n                                setState(833);\n                                elementValuePairs();\n                            }\n                            break;\n                        case 2 :\n                            {\n                                setState(834);\n                                elementValue();\n                            }\n                            break;\n                    }\n                    setState(837);\n                    match(RPAREN);\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.qualifiedName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.qualifiedName" ],
    "fullMethods" : [ "public final QualifiedNameContext qualifiedName() throws RecognitionException {\n    QualifiedNameContext _localctx = new QualifiedNameContext(_ctx, getState());\n    enterRule(_localctx, 70, RULE_qualifiedName);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(356);\n            match(IDENTIFIER);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchExpressionOrStatement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchExpressionOrStatement" ],
    "fullMethods" : [ "public final SwitchExpressionOrStatementContext switchExpressionOrStatement() throws RecognitionException {\n    SwitchExpressionOrStatementContext _localctx = new SwitchExpressionOrStatementContext(_ctx, getState());\n    enterRule(_localctx, 162, RULE_switchExpressionOrStatement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1109);\n            match(LITERAL_SWITCH);\n            setState(1110);\n            parExpression();\n            setState(1111);\n            match(LCURLY);\n            switchBlockDepth++;\n            setState(1113);\n            switchBlock();\n            switchBlockDepth--;\n            setState(1115);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodBody" ],
    "fullMethods" : [ "public final MethodBodyContext methodBody() throws RecognitionException {\n    MethodBodyContext _localctx = new MethodBodyContext(_ctx, getState());\n    enterRule(_localctx, 70, RULE_methodBody);\n    try {\n        setState(606);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LCURLY :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(604);\n                    block();\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(605);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlTagEnd",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlTagEnd" ],
    "fullMethods" : [ "public final HtmlTagEndContext htmlTagEnd() throws RecognitionException {\n    HtmlTagEndContext _localctx = new HtmlTagEndContext(_ctx, getState());\n    enterRule(_localctx, 98, RULE_htmlTagEnd);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(454);\n            match(TAG_OPEN);\n            setState(455);\n            match(TAG_SLASH);\n            setState(456);\n            match(TAG_NAME);\n            setState(457);\n            match(TAG_CLOSE);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.throwsTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.throwsTag" ],
    "fullMethods" : [ "public final ThrowsTagContext throwsTag() throws RecognitionException {\n    ThrowsTagContext _localctx = new ThrowsTagContext(_ctx, getState());\n    enterRule(_localctx, 14, RULE_throwsTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(170);\n            match(AT_SIGN);\n            setState(171);\n            ((ThrowsTagContext) (_localctx)).tagName = match(THROWS);\n            setState(173);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 10, _ctx)) {\n                case 1 :\n                    {\n                        setState(172);\n                        ((ThrowsTagContext) (_localctx)).exceptionName = qualifiedName();\n                    }\n                    break;\n            }\n            setState(176);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 11, _ctx)) {\n                case 1 :\n                    {\n                        setState(175);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedName" ],
    "fullMethods" : [ "public final QualifiedNameContext qualifiedName() throws RecognitionException {\n    QualifiedNameContext _localctx = new QualifiedNameContext(_ctx, getState());\n    enterRule(_localctx, 110, RULE_qualifiedName);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(795);\n            id();\n            setState(799);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 81, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(796);\n                            ((QualifiedNameContext) (_localctx)).qualifiedNameExtended = qualifiedNameExtended();\n                            ((QualifiedNameContext) (_localctx)).extended.add(((QualifiedNameContext) (_localctx)).qualifiedNameExtended);\n                        }\n                    }\n                }\n                setState(801);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 81, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlContent" ],
    "fullMethods" : [ "public final HtmlContentContext htmlContent() throws RecognitionException {\n    HtmlContentContext _localctx = new HtmlContentContext(_ctx, getState());\n    enterRule(_localctx, 102, RULE_htmlContent);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(468);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(468);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 62, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(464);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(465);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(466);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(467);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(470);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 63, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.usesTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.usesTag" ],
    "fullMethods" : [ "public final UsesTagContext usesTag() throws RecognitionException {\n    UsesTagContext _localctx = new UsesTagContext(_ctx, getState());\n    enterRule(_localctx, 26, RULE_usesTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(216);\n            match(AT_SIGN);\n            setState(217);\n            ((UsesTagContext) (_localctx)).tagName = match(USES);\n            setState(218);\n            ((UsesTagContext) (_localctx)).serviceType = qualifiedName();\n            setState(220);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 20, _ctx)) {\n                case 1 :\n                    {\n                        setState(219);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.linkInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.linkInlineTag" ],
    "fullMethods" : [ "public final LinkInlineTagContext linkInlineTag() throws RecognitionException {\n    LinkInlineTagContext _localctx = new LinkInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 46, RULE_linkInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(284);\n            ((LinkInlineTagContext) (_localctx)).tagName = match(LINK);\n            setState(285);\n            reference();\n            setState(287);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 31, _ctx)) {\n                case 1 :\n                    {\n                        setState(286);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary" ],
    "fullMethods" : [ "public final PrimaryContext primary() throws RecognitionException {\n    PrimaryContext _localctx = new PrimaryContext(_ctx, getState());\n    enterRule(_localctx, 226, RULE_primary);\n    int _la;\n    try {\n        setState(1533);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 176, _ctx)) {\n            case 1 :\n                _localctx = new SwitchPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1504);\n                    switchExpressionOrStatement();\n                }\n                break;\n            case 2 :\n                _localctx = new ParenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1505);\n                    match(LPAREN);\n                    setState(1506);\n                    expr(0);\n                    setState(1507);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1509);\n                    match(LITERAL_THIS);\n                }\n                break;\n            case 4 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(1510);\n                    match(LITERAL_SUPER);\n                }\n                break;\n            case 5 :\n                _localctx = new LiteralPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(1511);\n                    literal();\n                }\n                break;\n            case 6 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(1512);\n                    id();\n                }\n                break;\n            case 7 :\n                _localctx = new ClassRefPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(1513);\n                    ((ClassRefPrimaryContext) (_localctx)).type = classOrInterfaceType(false);\n                    setState(1517);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1514);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1519);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1520);\n                    match(DOT);\n                    setState(1521);\n                    match(LITERAL_CLASS);\n                }\n                break;\n            case 8 :\n                _localctx = new PrimitivePrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(1523);\n                    ((PrimitivePrimaryContext) (_localctx)).type = primitiveType();\n                    setState(1527);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1524);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1529);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1530);\n                    match(DOT);\n                    setState(1531);\n                    match(LITERAL_CLASS);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.innerCreator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.innerCreator" ],
    "fullMethods" : [ "public final InnerCreatorContext innerCreator() throws RecognitionException {\n    InnerCreatorContext _localctx = new InnerCreatorContext(_ctx, getState());\n    enterRule(_localctx, 236, RULE_innerCreator);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1579);\n            annotations(false);\n            setState(1580);\n            id();\n            setState(1582);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(1581);\n                    nonWildcardTypeArgumentsOrDiamond();\n                }\n            }\n            setState(1584);\n            classCreatorRest();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localVariableDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localVariableDeclaration" ],
    "fullMethods" : [ "public final LocalVariableDeclarationContext localVariableDeclaration() throws RecognitionException {\n    LocalVariableDeclarationContext _localctx = new LocalVariableDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 156, RULE_localVariableDeclaration);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(996);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 110, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(993);\n                            ((LocalVariableDeclarationContext) (_localctx)).modifier = modifier();\n                            ((LocalVariableDeclarationContext) (_localctx)).mods.add(((LocalVariableDeclarationContext) (_localctx)).modifier);\n                        }\n                    }\n                }\n                setState(998);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 110, _ctx);\n            } \n            setState(999);\n            ((LocalVariableDeclarationContext) (_localctx)).type = typeType(true);\n            setState(1000);\n            variableDeclarators(_localctx.mods, _localctx.type);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lastFormalParameter",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lastFormalParameter" ],
    "fullMethods" : [ "public final LastFormalParameterContext lastFormalParameter() throws RecognitionException {\n    LastFormalParameterContext _localctx = new LastFormalParameterContext(_ctx, getState());\n    enterRule(_localctx, 108, RULE_lastFormalParameter);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(787);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 80, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(784);\n                            ((LastFormalParameterContext) (_localctx)).variableModifier = variableModifier();\n                            ((LastFormalParameterContext) (_localctx)).mods.add(((LastFormalParameterContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(789);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 80, _ctx);\n            } \n            setState(790);\n            ((LastFormalParameterContext) (_localctx)).type = typeType(true);\n            setState(791);\n            annotations(false);\n            setState(792);\n            match(ELLIPSIS);\n            setState(793);\n            variableDeclaratorId(_localctx.mods, _localctx.type);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lastRecordComponent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lastRecordComponent" ],
    "fullMethods" : [ "public final LastRecordComponentContext lastRecordComponent() throws RecognitionException {\n    LastRecordComponentContext _localctx = new LastRecordComponentContext(_ctx, getState());\n    enterRule(_localctx, 24, RULE_lastRecordComponent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(418);\n            annotations(true);\n            setState(419);\n            ((LastRecordComponentContext) (_localctx)).type = typeType(true);\n            setState(420);\n            match(ELLIPSIS);\n            setState(421);\n            id();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primaryPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primaryPattern" ],
    "fullMethods" : [ "public final PrimaryPatternContext primaryPattern() throws RecognitionException {\n    PrimaryPatternContext _localctx = new PrimaryPatternContext(_ctx, getState());\n    enterRule(_localctx, 276, RULE_primaryPattern);\n    try {\n        setState(1720);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 204, _ctx)) {\n            case 1 :\n                _localctx = new PatternVariableDefContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1714);\n                    typePattern();\n                }\n                break;\n            case 2 :\n                _localctx = new ParenPatternContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1715);\n                    match(LPAREN);\n                    setState(1716);\n                    innerPattern();\n                    setState(1717);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new RecordPatternDefContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1719);\n                    recordPattern();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayCreatorRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayCreatorRest" ],
    "fullMethods" : [ "public final ArrayCreatorRestContext arrayCreatorRest() throws RecognitionException {\n    ArrayCreatorRestContext _localctx = new ArrayCreatorRestContext(_ctx, getState());\n    enterRule(_localctx, 238, RULE_arrayCreatorRest);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1586);\n            match(LBRACK);\n            setState(1609);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case RBRACK :\n                    {\n                        setState(1587);\n                        match(RBRACK);\n                        setState(1591);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        while ((_la == LBRACK) || (_la == AT)) {\n                            {\n                                {\n                                    setState(1588);\n                                    arrayDeclarator();\n                                }\n                            }\n                            setState(1593);\n                            _errHandler.sync(this);\n                            _la = _input.LA(1);\n                        } \n                        setState(1594);\n                        arrayInitializer();\n                    }\n                    break;\n                case LITERAL_VOID :\n                case LITERAL_BOOLEAN :\n                case LITERAL_BYTE :\n                case LITERAL_CHAR :\n                case LITERAL_SHORT :\n                case LITERAL_INT :\n                case LITERAL_FLOAT :\n                case LITERAL_LONG :\n                case LITERAL_DOUBLE :\n                case IDENT :\n                case LPAREN :\n                case LITERAL_THIS :\n                case LITERAL_SUPER :\n                case LITERAL_SWITCH :\n                case PLUS :\n                case MINUS :\n                case INC :\n                case DEC :\n                case BNOT :\n                case LNOT :\n                case LITERAL_TRUE :\n                case LITERAL_FALSE :\n                case LITERAL_NULL :\n                case LITERAL_NEW :\n                case CHAR_LITERAL :\n                case STRING_LITERAL :\n                case AT :\n                case FLOAT_LITERAL :\n                case DOUBLE_LITERAL :\n                case HEX_FLOAT_LITERAL :\n                case HEX_DOUBLE_LITERAL :\n                case LITERAL_RECORD :\n                case TEXT_BLOCK_LITERAL_BEGIN :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                case DECIMAL_LITERAL_LONG :\n                case DECIMAL_LITERAL :\n                case HEX_LITERAL_LONG :\n                case HEX_LITERAL :\n                case OCT_LITERAL_LONG :\n                case OCT_LITERAL :\n                case BINARY_LITERAL_LONG :\n                case BINARY_LITERAL :\n                    {\n                        setState(1595);\n                        expression();\n                        setState(1596);\n                        match(RBRACK);\n                        setState(1600);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 187, _ctx);\n                        while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                            if (_alt == 1) {\n                                {\n                                    {\n                                        setState(1597);\n                                        bracketsWithExp();\n                                    }\n                                }\n                            }\n                            setState(1602);\n                            _errHandler.sync(this);\n                            _alt = getInterpreter().adaptivePredict(_input, 187, _ctx);\n                        } \n                        setState(1606);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 188, _ctx);\n                        while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                            if (_alt == 1) {\n                                {\n                                    {\n                                        setState(1603);\n                                        arrayDeclarator();\n                                    }\n                                }\n                            }\n                            setState(1608);\n                            _errHandler.sync(this);\n                            _alt = getInterpreter().adaptivePredict(_input, 188, _ctx);\n                        } \n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValuePairs",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValuePairs" ],
    "fullMethods" : [ "public final ElementValuePairsContext elementValuePairs() throws RecognitionException {\n    ElementValuePairsContext _localctx = new ElementValuePairsContext(_ctx, getState());\n    enterRule(_localctx, 126, RULE_elementValuePairs);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(840);\n            elementValuePair();\n            setState(845);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(841);\n                        match(COMMA);\n                        setState(842);\n                        elementValuePair();\n                    }\n                }\n                setState(847);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.versionTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.versionTag" ],
    "fullMethods" : [ "public final VersionTagContext versionTag() throws RecognitionException {\n    VersionTagContext _localctx = new VersionTagContext(_ctx, getState());\n    enterRule(_localctx, 20, RULE_versionTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(191);\n            match(AT_SIGN);\n            setState(192);\n            ((VersionTagContext) (_localctx)).tagName = match(VERSION);\n            setState(194);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 15, _ctx)) {\n                case 1 :\n                    {\n                        setState(193);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.customBlockTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.customBlockTag" ],
    "fullMethods" : [ "public final CustomBlockTagContext customBlockTag() throws RecognitionException {\n    CustomBlockTagContext _localctx = new CustomBlockTagContext(_ctx, getState());\n    enterRule(_localctx, 36, RULE_customBlockTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(249);\n            match(AT_SIGN);\n            setState(250);\n            ((CustomBlockTagContext) (_localctx)).tagName = match(CUSTOM_NAME);\n            setState(252);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 27, _ctx)) {\n                case 1 :\n                    {\n                        setState(251);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayDeclarator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayDeclarator" ],
    "fullMethods" : [ "public final ArrayDeclaratorContext arrayDeclarator() throws RecognitionException {\n    ArrayDeclaratorContext _localctx = new ArrayDeclaratorContext(_ctx, getState());\n    enterRule(_localctx, 258, RULE_arrayDeclarator);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1662);\n            ((ArrayDeclaratorContext) (_localctx)).anno = annotations(false);\n            setState(1663);\n            match(LBRACK);\n            setState(1664);\n            match(RBRACK);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.exceptionTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.exceptionTag" ],
    "fullMethods" : [ "public final ExceptionTagContext exceptionTag() throws RecognitionException {\n    ExceptionTagContext _localctx = new ExceptionTagContext(_ctx, getState());\n    enterRule(_localctx, 16, RULE_exceptionTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(178);\n            match(AT_SIGN);\n            setState(179);\n            ((ExceptionTagContext) (_localctx)).tagName = match(EXCEPTION);\n            setState(181);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 12, _ctx)) {\n                case 1 :\n                    {\n                        setState(180);\n                        ((ExceptionTagContext) (_localctx)).exceptionName = qualifiedName();\n                    }\n                    break;\n            }\n            setState(184);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 13, _ctx)) {\n                case 1 :\n                    {\n                        setState(183);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.providesTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.providesTag" ],
    "fullMethods" : [ "public final ProvidesTagContext providesTag() throws RecognitionException {\n    ProvidesTagContext _localctx = new ProvidesTagContext(_ctx, getState());\n    enterRule(_localctx, 28, RULE_providesTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(222);\n            match(AT_SIGN);\n            setState(223);\n            ((ProvidesTagContext) (_localctx)).tagName = match(PROVIDES);\n            setState(224);\n            ((ProvidesTagContext) (_localctx)).serviceType = qualifiedName();\n            setState(226);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 21, _ctx)) {\n                case 1 :\n                    {\n                        setState(225);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationConstantRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationConstantRest" ],
    "fullMethods" : [ "public final AnnotationConstantRestContext annotationConstantRest(List<ModifierContext> mods, TypeTypeContext type) throws RecognitionException {\n    AnnotationConstantRestContext _localctx = new AnnotationConstantRestContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 144, RULE_annotationConstantRest);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(941);\n            variableDeclarators(mods, type);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.constructorDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.constructorDeclaration" ],
    "fullMethods" : [ "public final ConstructorDeclarationContext constructorDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    ConstructorDeclarationContext _localctx = new ConstructorDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 74, RULE_constructorDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(612);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(611);\n                    typeParameters();\n                }\n            }\n            setState(614);\n            id();\n            setState(615);\n            formalParameters();\n            setState(617);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_THROWS) {\n                {\n                    setState(616);\n                    throwsList();\n                }\n            }\n            setState(619);\n            ((ConstructorDeclarationContext) (_localctx)).constructorBody = constructorBlock();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeArguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recover",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeArguments" ],
    "fullMethods" : [ "public final TypeArgumentsContext typeArguments() throws RecognitionException {\n    TypeArgumentsContext _localctx = new TypeArgumentsContext(_ctx, getState());\n    enterRule(_localctx, 72, RULE_typeArguments);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(358);\n            match(LT);\n            setState(359);\n            typeArgument();\n            setState(364);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(360);\n                        match(COMMA);\n                        setState(361);\n                        typeArgument();\n                    }\n                }\n                setState(366);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(367);\n            match(GT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlCommentContentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlCommentContentContext.<init>" ],
    "fullMethods" : [ "public HtmlCommentContentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.MemberReferenceContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.MemberReferenceContext.<init>" ],
    "fullMethods" : [ "public MemberReferenceContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentsListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentsListContext.<init>" ],
    "fullMethods" : [ "public RecordComponentsListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParameterListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParameterListContext.<init>" ],
    "fullMethods" : [ "public FormalParameterListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlAttributeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlAttributeContext.<init>" ],
    "fullMethods" : [ "public HtmlAttributeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ParameterTypeListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ParameterTypeListContext.<init>" ],
    "fullMethods" : [ "public ParameterTypeListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassDeclarationContext.<init>" ],
    "fullMethods" : [ "public ClassDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ParameterTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ParameterTagContext.<init>" ],
    "fullMethods" : [ "public ParameterTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForControlContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForControlContext.<init>" ],
    "fullMethods" : [ "public ForControlContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceSpecificationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceSpecificationContext.<init>" ],
    "fullMethods" : [ "public ResourceSpecificationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordBodyDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordBodyDeclarationContext.<init>" ],
    "fullMethods" : [ "public RecordBodyDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForControlContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForControlContext.<init>" ],
    "fullMethods" : [ "public EnhancedForControlContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMethodDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMethodDeclarationContext.<init>" ],
    "fullMethods" : [ "public InterfaceMethodDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceDeclarationContext.<init>" ],
    "fullMethods" : [ "public InterfaceDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordPatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordPatternContext.<init>" ],
    "fullMethods" : [ "public RecordPatternContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InnerCreatorContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InnerCreatorContext.<init>" ],
    "fullMethods" : [ "public InnerCreatorContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledBlockContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledBlockContext.<init>" ],
    "fullMethods" : [ "public SwitchLabeledBlockContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LastFormalParameterContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LastFormalParameterContext.<init>" ],
    "fullMethods" : [ "public LastFormalParameterContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockStatementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockStatementContext.<init>" ],
    "fullMethods" : [ "public BlockStatementContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayDeclaratorContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayDeclaratorContext.<init>" ],
    "fullMethods" : [ "public ArrayDeclaratorContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MemberDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MemberDeclarationContext.<init>" ],
    "fullMethods" : [ "public MemberDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeExtendedContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeExtendedContext.<init>" ],
    "fullMethods" : [ "public ClassOrInterfaceTypeExtendedContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentPatternListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentPatternListContext.<init>" ],
    "fullMethods" : [ "public RecordComponentPatternListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayInitializerContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayInitializerContext.<init>" ],
    "fullMethods" : [ "public ArrayInitializerContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationMethodRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationMethodRestContext.<init>" ],
    "fullMethods" : [ "public AnnotationMethodRestContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods, TypeTypeContext type) {\n    super(parent, invokingState);\n    this.mods = mods;\n    this.type = type;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchClauseContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchClauseContext.<init>" ],
    "fullMethods" : [ "public CatchClauseContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReturnTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReturnTagContext.<init>" ],
    "fullMethods" : [ "public ReturnTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InlineTagContext.<init>" ],
    "fullMethods" : [ "public InlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SummaryInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SummaryInlineTagContext.<init>" ],
    "fullMethods" : [ "public SummaryInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeBoundTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeBoundTypeContext.<init>" ],
    "fullMethods" : [ "public TypeBoundTypeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceBodyDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceBodyDeclarationContext.<init>" ],
    "fullMethods" : [ "public InterfaceBodyDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ModifierContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ModifierContext.<init>" ],
    "fullMethods" : [ "public ModifierContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldDeclarationContext.<init>" ],
    "fullMethods" : [ "public FieldDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeDeclarationContext.<init>" ],
    "fullMethods" : [ "public TypeDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ParExpressionContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ParExpressionContext.<init>" ],
    "fullMethods" : [ "public ParExpressionContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlTagStartContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlTagStartContext.<init>" ],
    "fullMethods" : [ "public HtmlTagStartContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockContext.<init>" ],
    "fullMethods" : [ "public SwitchBlockContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReturnInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReturnInlineTagContext.<init>" ],
    "fullMethods" : [ "public ReturnInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseConstantContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseConstantContext.<init>" ],
    "fullMethods" : [ "public CaseConstantContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeListContext.<init>" ],
    "fullMethods" : [ "public TypeListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordBodyContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordBodyContext.<init>" ],
    "fullMethods" : [ "public RecordBodyContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsContext.<init>" ],
    "fullMethods" : [ "public TypeArgumentsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameContext.<init>" ],
    "fullMethods" : [ "public CreatedNameContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryContext.<init>" ],
    "fullMethods" : [ "public PrimaryContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeBoundContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeBoundContext.<init>" ],
    "fullMethods" : [ "public TypeBoundContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CodeInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CodeInlineTagContext.<init>" ],
    "fullMethods" : [ "public CodeInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationMethodRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationMethodRestContext.<init>" ],
    "fullMethods" : [ "public AnnotationMethodRestContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlCommentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlCommentContext.<init>" ],
    "fullMethods" : [ "public HtmlCommentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TightElementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TightElementContext.<init>" ],
    "fullMethods" : [ "public TightElementContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorBlockContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorBlockContext.<init>" ],
    "fullMethods" : [ "public ConstructorBlockContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DefaultValueContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.DefaultValueContext.<init>" ],
    "fullMethods" : [ "public DefaultValueContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceDeclarationContext.<init>" ],
    "fullMethods" : [ "public ResourceDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassExtendsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassExtendsContext.<init>" ],
    "fullMethods" : [ "public ClassExtendsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValuePairContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValuePairContext.<init>" ],
    "fullMethods" : [ "public ElementValuePairContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.JavadocContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.JavadocContext.<init>" ],
    "fullMethods" : [ "public JavadocContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MultiLambdaParamsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MultiLambdaParamsContext.<init>" ],
    "fullMethods" : [ "public MultiLambdaParamsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorIdContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorIdContext.<init>" ],
    "fullMethods" : [ "public VariableDeclaratorIdContext(ParserRuleContext parent, int invokingState, List<VariableModifierContext> mods, ParserRuleContext type) {\n    super(parent, invokingState);\n    this.mods = mods;\n    this.type = type;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.GuardedPatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.GuardedPatternContext.<init>" ],
    "fullMethods" : [ "public GuardedPatternContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArgumentsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArgumentsContext.<init>" ],
    "fullMethods" : [ "public ArgumentsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.GuardContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.GuardContext.<init>" ],
    "fullMethods" : [ "public GuardContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumBodyDeclarationsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumBodyDeclarationsContext.<init>" ],
    "fullMethods" : [ "public EnumBodyDeclarationsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialTagContext.<init>" ],
    "fullMethods" : [ "public SerialTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.UsesTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.UsesTagContext.<init>" ],
    "fullMethods" : [ "public UsesTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ExceptionTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ExceptionTagContext.<init>" ],
    "fullMethods" : [ "public ExceptionTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForControlWithRecordPatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnhancedForControlWithRecordPatternContext.<init>" ],
    "fullMethods" : [ "public EnhancedForControlWithRecordPatternContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimitiveTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimitiveTypeContext.<init>" ],
    "fullMethods" : [ "public PrimitiveTypeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabelContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabelContext.<init>" ],
    "fullMethods" : [ "public SwitchLabelContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationContext.<init>" ],
    "fullMethods" : [ "public AnnotationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationsContext.<init>" ],
    "fullMethods" : [ "public AnnotationsContext(ParserRuleContext parent, int invokingState, boolean createImaginaryNode) {\n    super(parent, invokingState);\n    this.createImaginaryNode = createImaginaryNode;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IdContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IdContext.<init>" ],
    "fullMethods" : [ "public IdContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReferenceContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ReferenceContext.<init>" ],
    "fullMethods" : [ "public ReferenceContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeNameContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeNameContext.<init>" ],
    "fullMethods" : [ "public TypeNameContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SystemPropertyInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SystemPropertyInlineTagContext.<init>" ],
    "fullMethods" : [ "public SystemPropertyInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImplementsClauseContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImplementsClauseContext.<init>" ],
    "fullMethods" : [ "public ImplementsClauseContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorIdContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorIdContext.<init>" ],
    "fullMethods" : [ "public VariableDeclaratorIdContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourcesContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourcesContext.<init>" ],
    "fullMethods" : [ "public ResourcesContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumConstantsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumConstantsContext.<init>" ],
    "fullMethods" : [ "public EnumConstantsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypePatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypePatternContext.<init>" ],
    "fullMethods" : [ "public TypePatternContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ResourceContext.<init>" ],
    "fullMethods" : [ "public ResourceContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CompilationUnitContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CompilationUnitContext.<init>" ],
    "fullMethods" : [ "public CompilationUnitContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InnerPatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InnerPatternContext.<init>" ],
    "fullMethods" : [ "public InnerPatternContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HiddenTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HiddenTagContext.<init>" ],
    "fullMethods" : [ "public HiddenTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableInitializerContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableInitializerContext.<init>" ],
    "fullMethods" : [ "public VariableInitializerContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorsContext.<init>" ],
    "fullMethods" : [ "public VariableDeclaratorsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MemberDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MemberDeclarationContext.<init>" ],
    "fullMethods" : [ "public MemberDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InheritDocInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InheritDocInlineTagContext.<init>" ],
    "fullMethods" : [ "public InheritDocInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeContext.<init>" ],
    "fullMethods" : [ "public ClassOrInterfaceTypeContext(ParserRuleContext parent, int invokingState, boolean createImaginaryNode) {\n    super(parent, invokingState);\n    this.createImaginaryNode = createImaginaryNode;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpressionContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpressionContext.<init>" ],
    "fullMethods" : [ "public ExpressionContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SinceTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SinceTagContext.<init>" ],
    "fullMethods" : [ "public SinceTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElseStatContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElseStatContext.<init>" ],
    "fullMethods" : [ "public ElseStatContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.VersionTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.VersionTagContext.<init>" ],
    "fullMethods" : [ "public VersionTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlTagEndContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlTagEndContext.<init>" ],
    "fullMethods" : [ "public HtmlTagEndContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalTypeDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalTypeDeclarationContext.<init>" ],
    "fullMethods" : [ "public LocalTypeDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LambdaParametersContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LambdaParametersContext.<init>" ],
    "fullMethods" : [ "public LambdaParametersContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExplicitConstructorInvocationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExplicitConstructorInvocationContext.<init>" ],
    "fullMethods" : [ "public ExplicitConstructorInvocationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordDeclarationContext.<init>" ],
    "fullMethods" : [ "public RecordDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMethodDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMethodDeclarationContext.<init>" ],
    "fullMethods" : [ "public InterfaceMethodDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumDeclarationContext.<init>" ],
    "fullMethods" : [ "public EnumDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledThrowContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledThrowContext.<init>" ],
    "fullMethods" : [ "public SwitchLabeledThrowContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementDeclarationContext.<init>" ],
    "fullMethods" : [ "public AnnotationTypeElementDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceExtendsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceExtendsContext.<init>" ],
    "fullMethods" : [ "public InterfaceExtendsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameExtendedContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameExtendedContext.<init>" ],
    "fullMethods" : [ "public QualifiedNameExtendedContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumDeclarationContext.<init>" ],
    "fullMethods" : [ "public EnumDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImportDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImportDeclarationContext.<init>" ],
    "fullMethods" : [ "public ImportDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumConstantContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumConstantContext.<init>" ],
    "fullMethods" : [ "public EnumConstantContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsOrDiamondContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsOrDiamondContext.<init>" ],
    "fullMethods" : [ "public TypeArgumentsOrDiamondContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialDataTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialDataTagContext.<init>" ],
    "fullMethods" : [ "public SerialDataTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.DescriptionContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.DescriptionContext.<init>" ],
    "fullMethods" : [ "public DescriptionContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableAccessContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableAccessContext.<init>" ],
    "fullMethods" : [ "public VariableAccessContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BracketsWithExpContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BracketsWithExpContext.<init>" ],
    "fullMethods" : [ "public BracketsWithExpContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeBodyContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeBodyContext.<init>" ],
    "fullMethods" : [ "public AnnotationTypeBodyContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CompactConstructorDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CompactConstructorDeclarationContext.<init>" ],
    "fullMethods" : [ "public CompactConstructorDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceDeclarationContext.<init>" ],
    "fullMethods" : [ "public InterfaceDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeArgumentsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeArgumentsContext.<init>" ],
    "fullMethods" : [ "public TypeArgumentsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementRestContext.<init>" ],
    "fullMethods" : [ "public AnnotationTypeElementRestContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValueArrayInitializerContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValueArrayInitializerContext.<init>" ],
    "fullMethods" : [ "public ElementValueArrayInitializerContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorDeclarationContext.<init>" ],
    "fullMethods" : [ "public ConstructorDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.AuthorTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.AuthorTagContext.<init>" ],
    "fullMethods" : [ "public AuthorTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExprContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExprContext.<init>" ],
    "fullMethods" : [ "public ExprContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseConstantsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CaseConstantsContext.<init>" ],
    "fullMethods" : [ "public CaseConstantsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameListContext.<init>" ],
    "fullMethods" : [ "public QualifiedNameListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationConstantRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationConstantRestContext.<init>" ],
    "fullMethods" : [ "public AnnotationConstantRestContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods, TypeTypeContext type) {\n    super(parent, invokingState);\n    this.mods = mods;\n    this.type = type;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockStatementGroupContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockStatementGroupContext.<init>" ],
    "fullMethods" : [ "public SwitchBlockStatementGroupContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordDeclarationContext.<init>" ],
    "fullMethods" : [ "public RecordDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ProvidesTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ProvidesTagContext.<init>" ],
    "fullMethods" : [ "public ProvidesTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeUpperBoundsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeUpperBoundsContext.<init>" ],
    "fullMethods" : [ "public TypeUpperBoundsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlElementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlElementContext.<init>" ],
    "fullMethods" : [ "public HtmlElementContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceOrPrimitiveTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceOrPrimitiveTypeContext.<init>" ],
    "fullMethods" : [ "public ClassOrInterfaceOrPrimitiveTypeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ThrowsListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ThrowsListContext.<init>" ],
    "fullMethods" : [ "public ThrowsListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetBodyContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetBodyContext.<init>" ],
    "fullMethods" : [ "public SnippetBodyContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlContentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.HtmlContentContext.<init>" ],
    "fullMethods" : [ "public HtmlContentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentContext.<init>" ],
    "fullMethods" : [ "public TypeArgumentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LiteralContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LiteralContext.<init>" ],
    "fullMethods" : [ "public LiteralContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassDeclarationContext.<init>" ],
    "fullMethods" : [ "public ClassDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SelfClosingElementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SelfClosingElementContext.<init>" ],
    "fullMethods" : [ "public SelfClosingElementContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FloatLiteralContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FloatLiteralContext.<init>" ],
    "fullMethods" : [ "public FloatLiteralContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PackageDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PackageDeclarationContext.<init>" ],
    "fullMethods" : [ "public PackageDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeParametersContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeParametersContext.<init>" ],
    "fullMethods" : [ "public TypeParametersContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LinkInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LinkInlineTagContext.<init>" ],
    "fullMethods" : [ "public LinkInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumBodyContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.EnumBodyContext.<init>" ],
    "fullMethods" : [ "public EnumBodyContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LinkPlainInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LinkPlainInlineTagContext.<init>" ],
    "fullMethods" : [ "public LinkPlainInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldDeclarationContext.<init>" ],
    "fullMethods" : [ "public FieldDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorContext.<init>" ],
    "fullMethods" : [ "public VariableDeclaratorContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods, TypeTypeContext type) {\n    super(parent, invokingState);\n    this.mods = mods;\n    this.type = type;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockContext.<init>" ],
    "fullMethods" : [ "public BlockContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CustomBlockTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CustomBlockTagContext.<init>" ],
    "fullMethods" : [ "public CustomBlockTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialFieldTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SerialFieldTagContext.<init>" ],
    "fullMethods" : [ "public SerialFieldTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationConstantRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationConstantRestContext.<init>" ],
    "fullMethods" : [ "public AnnotationConstantRestContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.IndexInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.IndexInlineTagContext.<init>" ],
    "fullMethods" : [ "public IndexInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldAccessNoIdentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FieldAccessNoIdentContext.<init>" ],
    "fullMethods" : [ "public FieldAccessNoIdentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodBodyContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodBodyContext.<init>" ],
    "fullMethods" : [ "public MethodBodyContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.QualifiedNameContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.QualifiedNameContext.<init>" ],
    "fullMethods" : [ "public QualifiedNameContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParameterContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParameterContext.<init>" ],
    "fullMethods" : [ "public FormalParameterContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeTypeContext.<init>" ],
    "fullMethods" : [ "public TypeTypeContext(ParserRuleContext parent, int invokingState, boolean createImaginaryNode) {\n    super(parent, invokingState);\n    this.createImaginaryNode = createImaginaryNode;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassCreatorRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassCreatorRestContext.<init>" ],
    "fullMethods" : [ "public ClassCreatorRestContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParametersContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FormalParametersContext.<init>" ],
    "fullMethods" : [ "public FormalParametersContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchParameterContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchParameterContext.<init>" ],
    "fullMethods" : [ "public CatchParameterContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.NonTightElementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.NonTightElementContext.<init>" ],
    "fullMethods" : [ "public NonTightElementContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeParameterContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeParameterContext.<init>" ],
    "fullMethods" : [ "public TypeParameterContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeTypeContext.<init>" ],
    "fullMethods" : [ "public TypeTypeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassTypeContext.<init>" ],
    "fullMethods" : [ "public ClassTypeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForInitContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForInitContext.<init>" ],
    "fullMethods" : [ "public ForInitContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ValueInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ValueInlineTagContext.<init>" ],
    "fullMethods" : [ "public ValueInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.QualifiedNameContext.<init>" ],
    "fullMethods" : [ "public QualifiedNameContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InlineTagContentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.InlineTagContentContext.<init>" ],
    "fullMethods" : [ "public InlineTagContentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationsContext.<init>" ],
    "fullMethods" : [ "public AnnotationsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodDeclarationContext.<init>" ],
    "fullMethods" : [ "public MethodDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixContext.<init>" ],
    "fullMethods" : [ "public SuperSuffixContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LiteralInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.LiteralInlineTagContext.<init>" ],
    "fullMethods" : [ "public LiteralInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.MethodDeclarationContext.<init>" ],
    "fullMethods" : [ "public MethodDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.StatementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.StatementContext.<init>" ],
    "fullMethods" : [ "public StatementContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledExpressionContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledExpressionContext.<init>" ],
    "fullMethods" : [ "public SwitchLabeledExpressionContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsOrDiamondContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsOrDiamondContext.<init>" ],
    "fullMethods" : [ "public NonWildcardTypeArgumentsOrDiamondContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableModifierContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableModifierContext.<init>" ],
    "fullMethods" : [ "public VariableModifierContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorContext.<init>" ],
    "fullMethods" : [ "public VariableDeclaratorContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.VariableDeclaratorsContext.<init>" ],
    "fullMethods" : [ "public VariableDeclaratorsContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods, TypeTypeContext type) {\n    super(parent, invokingState);\n    this.mods = mods;\n    this.type = type;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LastRecordComponentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LastRecordComponentContext.<init>" ],
    "fullMethods" : [ "public LastRecordComponentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CatchTypeContext.<init>" ],
    "fullMethods" : [ "public CatchTypeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeCastParametersContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeCastParametersContext.<init>" ],
    "fullMethods" : [ "public TypeCastParametersContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeDeclarationContext.<init>" ],
    "fullMethods" : [ "public AnnotationTypeDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameExtendedContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameExtendedContext.<init>" ],
    "fullMethods" : [ "public CreatedNameExtendedContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValuePairsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValuePairsContext.<init>" ],
    "fullMethods" : [ "public ElementValuePairsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SeeTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SeeTagContext.<init>" ],
    "fullMethods" : [ "public SeeTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsContext.<init>" ],
    "fullMethods" : [ "public NonWildcardTypeArgumentsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetAttributeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetAttributeContext.<init>" ],
    "fullMethods" : [ "public SnippetAttributeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryPatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryPatternContext.<init>" ],
    "fullMethods" : [ "public PrimaryPatternContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceBodyContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceBodyContext.<init>" ],
    "fullMethods" : [ "public InterfaceBodyContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IntegerLiteralContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.IntegerLiteralContext.<init>" ],
    "fullMethods" : [ "public IntegerLiteralContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalVariableDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LocalVariableDeclarationContext.<init>" ],
    "fullMethods" : [ "public LocalVariableDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatorContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatorContext.<init>" ],
    "fullMethods" : [ "public CreatorContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypesContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypesContext.<init>" ],
    "fullMethods" : [ "public TypesContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FinallyBlockContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.FinallyBlockContext.<init>" ],
    "fullMethods" : [ "public FinallyBlockContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyContext.<init>" ],
    "fullMethods" : [ "public ClassBodyContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.MainDescriptionContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.MainDescriptionContext.<init>" ],
    "fullMethods" : [ "public MainDescriptionContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpressionListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExpressionListContext.<init>" ],
    "fullMethods" : [ "public ExpressionListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMemberDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMemberDeclarationContext.<init>" ],
    "fullMethods" : [ "public InterfaceMemberDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PatternContext.<init>" ],
    "fullMethods" : [ "public PatternContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.VoidElementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.VoidElementContext.<init>" ],
    "fullMethods" : [ "public VoidElementContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.SnippetInlineTagContext.<init>" ],
    "fullMethods" : [ "public SnippetInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypesContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypesContext.<init>" ],
    "fullMethods" : [ "public TypesContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValueContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ElementValueContext.<init>" ],
    "fullMethods" : [ "public ElementValueContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentsContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentsContext.<init>" ],
    "fullMethods" : [ "public RecordComponentsContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledRuleContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabeledRuleContext.<init>" ],
    "fullMethods" : [ "public SwitchLabeledRuleContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchExpressionOrStatementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchExpressionOrStatementContext.<init>" ],
    "fullMethods" : [ "public SwitchExpressionOrStatementContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.NonTightHtmlContentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.NonTightHtmlContentContext.<init>" ],
    "fullMethods" : [ "public NonTightHtmlContentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PermittedSubclassesAndInterfacesContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PermittedSubclassesAndInterfacesContext.<init>" ],
    "fullMethods" : [ "public PermittedSubclassesAndInterfacesContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TextBlockLiteralContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TextBlockLiteralContext.<init>" ],
    "fullMethods" : [ "public TextBlockLiteralContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.DeprecatedTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.DeprecatedTagContext.<init>" ],
    "fullMethods" : [ "public DeprecatedTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementRestContext.<init>" ],
    "fullMethods" : [ "public AnnotationTypeElementRestContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ConstructorDeclarationContext.<init>" ],
    "fullMethods" : [ "public ConstructorDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyDeclarationContext.<init>" ],
    "fullMethods" : [ "public ClassBodyDeclarationContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayCreatorRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ArrayCreatorRestContext.<init>" ],
    "fullMethods" : [ "public ArrayCreatorRestContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeDeclarationContext.<init>" ],
    "fullMethods" : [ "public AnnotationTypeDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ThrowsTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.ThrowsTagContext.<init>" ],
    "fullMethods" : [ "public ThrowsTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.BlockTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.BlockTagContext.<init>" ],
    "fullMethods" : [ "public BlockTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.RecordComponentContext.<init>" ],
    "fullMethods" : [ "public RecordComponentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMemberDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.InterfaceMemberDeclarationContext.<init>" ],
    "fullMethods" : [ "public InterfaceMemberDeclarationContext(ParserRuleContext parent, int invokingState, List<ModifierContext> mods) {\n    super(parent, invokingState);\n    this.mods = mods;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CustomInlineTagContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.CustomInlineTagContext.<init>" ],
    "fullMethods" : [ "public CustomInlineTagContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeArgumentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.TypeArgumentContext.<init>" ],
    "fullMethods" : [ "public TypeArgumentContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsTypeListContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsTypeListContext.<init>" ],
    "fullMethods" : [ "public TypeArgumentsTypeListContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassOrInterfaceTypeContext.<init>" ],
    "fullMethods" : [ "public ClassOrInterfaceTypeContext(ParserRuleContext parent, int invokingState) {\n    super(parent, invokingState);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final FieldAccessNoIdentContext fieldAccessNoIdent() throws RecognitionException {\n    FieldAccessNoIdentContext _localctx = new FieldAccessNoIdentContext(_ctx, getState());\n    enterRule(_localctx, 194, RULE_fieldAccessNoIdent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1225);\n            expr(0);\n            setState(1226);\n            match(DOT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primitiveType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primitiveType" ],
    "fullMethods" : [ "public final PrimitiveTypeContext primitiveType() throws RecognitionException {\n    PrimitiveTypeContext _localctx = new PrimitiveTypeContext(_ctx, getState());\n    enterRule(_localctx, 260, RULE_primitiveType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1666);\n            _la = _input.LA(1);\n            if (!(((_la & (~0x3f)) == 0) && (((1L << _la) & 287667426198290432L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.integerLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.integerLiteral" ],
    "fullMethods" : [ "public final IntegerLiteralContext integerLiteral() throws RecognitionException {\n    IntegerLiteralContext _localctx = new IntegerLiteralContext(_ctx, getState());\n    enterRule(_localctx, 116, RULE_integerLiteral);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(816);\n            _la = _input.LA(1);\n            if (!((((_la - 226) & (~0x3f)) == 0) && (((1L << (_la - 226)) & 255L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guard",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guard" ],
    "fullMethods" : [ "public final GuardContext guard() throws RecognitionException {\n    GuardContext _localctx = new GuardContext(_ctx, getState());\n    enterRule(_localctx, 274, RULE_guard);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1712);\n            _la = _input.LA(1);\n            if (!((_la == LAND) || (_la == LITERAL_WHEN))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.id",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.id" ],
    "fullMethods" : [ "public final IdContext id() throws RecognitionException {\n    IdContext _localctx = new IdContext(_ctx, getState());\n    enterRule(_localctx, 286, RULE_id);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1766);\n            _la = _input.LA(1);\n            if (!((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0)))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExpressionContext expression() throws RecognitionException {\n    ExpressionContext _localctx = new ExpressionContext(_ctx, getState());\n    enterRule(_localctx, 216, RULE_expression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1315);\n            expr(0);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final PrimaryContext primary() throws RecognitionException {\n    PrimaryContext _localctx = new PrimaryContext(_ctx, getState());\n    enterRule(_localctx, 226, RULE_primary);\n    int _la;\n    try {\n        setState(1533);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 176, _ctx)) {\n            case 1 :\n                _localctx = new SwitchPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1504);\n                    switchExpressionOrStatement();\n                }\n                break;\n            case 2 :\n                _localctx = new ParenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1505);\n                    match(LPAREN);\n                    setState(1506);\n                    expr(0);\n                    setState(1507);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1509);\n                    match(LITERAL_THIS);\n                }\n                break;\n            case 4 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(1510);\n                    match(LITERAL_SUPER);\n                }\n                break;\n            case 5 :\n                _localctx = new LiteralPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(1511);\n                    literal();\n                }\n                break;\n            case 6 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(1512);\n                    id();\n                }\n                break;\n            case 7 :\n                _localctx = new ClassRefPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(1513);\n                    ((ClassRefPrimaryContext) (_localctx)).type = classOrInterfaceType(false);\n                    setState(1517);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1514);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1519);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1520);\n                    match(DOT);\n                    setState(1521);\n                    match(LITERAL_CLASS);\n                }\n                break;\n            case 8 :\n                _localctx = new PrimitivePrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(1523);\n                    ((PrimitivePrimaryContext) (_localctx)).type = primitiveType();\n                    setState(1527);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1524);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1529);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1530);\n                    match(DOT);\n                    setState(1531);\n                    match(LITERAL_CLASS);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExprContext expr() throws RecognitionException {\n    return expr(0);\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation" ],
    "fullMethods" : [ "public final ExplicitConstructorInvocationContext explicitConstructorInvocation() throws RecognitionException {\n    ExplicitConstructorInvocationContext _localctx = new ExplicitConstructorInvocationContext(_ctx, getState());\n    enterRule(_localctx, 150, RULE_explicitConstructorInvocation);\n    int _la;\n    try {\n        setState(974);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 107, _ctx)) {\n            case 1 :\n                _localctx = new ExplicitCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(959);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(958);\n                            typeArguments();\n                        }\n                    }\n                    setState(961);\n                    _la = _input.LA(1);\n                    if (!((_la == LITERAL_THIS) || (_la == LITERAL_SUPER))) {\n                        _errHandler.recoverInline(this);\n                    } else {\n                        if (_input.LA(1) == Token.EOF)\n                            matchedEOF = true;\n\n                        _errHandler.reportMatch(this);\n                        consume();\n                    }\n                    setState(962);\n                    arguments();\n                    setState(963);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new PrimaryCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(965);\n                    expr(0);\n                    setState(966);\n                    match(DOT);\n                    setState(968);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(967);\n                            typeArguments();\n                        }\n                    }\n                    setState(970);\n                    match(LITERAL_SUPER);\n                    setState(971);\n                    arguments();\n                    setState(972);\n                    match(SEMI);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.floatLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.floatLiteral" ],
    "fullMethods" : [ "public final FloatLiteralContext floatLiteral() throws RecognitionException {\n    FloatLiteralContext _localctx = new FloatLiteralContext(_ctx, getState());\n    enterRule(_localctx, 118, RULE_floatLiteral);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(818);\n            _la = _input.LA(1);\n            if (!((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 15L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.CheckstyleParserErrorStrategy.recoverInline",
    "thirdPartyMethod" : "org.antlr.v4.runtime.BailErrorStrategy.recoverInline",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.CheckstyleParserErrorStrategy.recoverInline" ],
    "fullMethods" : [ "@Override\npublic Token recoverInline(Parser recognizer) {\n    reportError(recognizer, new InputMismatchException(recognizer));\n    return super.recoverInline(recognizer);\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArguments" ],
    "fullMethods" : [ "public final TypeArgumentsContext typeArguments() throws RecognitionException {\n    TypeArgumentsContext _localctx = new TypeArgumentsContext(_ctx, getState());\n    enterRule(_localctx, 262, RULE_typeArguments);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1668);\n            match(LT);\n            setState(1669);\n            typeArgument();\n            setState(1674);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1670);\n                        match(COMMA);\n                        setState(1671);\n                        typeArgument();\n                    }\n                }\n                setState(1676);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(1677);\n            match(GT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.mainDescription",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.mainDescription" ],
    "fullMethods" : [ "public final MainDescriptionContext mainDescription() throws RecognitionException {\n    MainDescriptionContext _localctx = new MainDescriptionContext(_ctx, getState());\n    enterRule(_localctx, 2, RULE_mainDescription);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(125);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(125);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 2, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(121);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(122);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(123);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(124);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(127);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 3, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclarators",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclarators" ],
    "fullMethods" : [ "public final VariableDeclaratorsContext variableDeclarators(List<ModifierContext> mods, TypeTypeContext type) throws RecognitionException {\n    VariableDeclaratorsContext _localctx = new VariableDeclaratorsContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 84, RULE_variableDeclarators);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(661);\n            variableDeclarator(mods, type);\n            setState(666);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(662);\n                        match(COMMA);\n                        setState(663);\n                        variableDeclarator(mods, type);\n                    }\n                }\n                setState(668);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.creator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.creator" ],
    "fullMethods" : [ "public final CreatorContext creator() throws RecognitionException {\n    CreatorContext _localctx = new CreatorContext(_ctx, getState());\n    enterRule(_localctx, 230, RULE_creator);\n    try {\n        setState(1557);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LT :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1545);\n                    nonWildcardTypeArguments();\n                    setState(1546);\n                    createdName();\n                    setState(1547);\n                    classCreatorRest();\n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1549);\n                    annotations(false);\n                    setState(1550);\n                    createdName();\n                    setState(1555);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LBRACK :\n                        case AT :\n                            {\n                                setState(1551);\n                                annotations(false);\n                                setState(1552);\n                                arrayCreatorRest();\n                            }\n                            break;\n                        case LPAREN :\n                            {\n                                setState(1554);\n                                classCreatorRest();\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumBodyDeclarations",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumBodyDeclarations" ],
    "fullMethods" : [ "public final EnumBodyDeclarationsContext enumBodyDeclarations() throws RecognitionException {\n    EnumBodyDeclarationsContext _localctx = new EnumBodyDeclarationsContext(_ctx, getState());\n    enterRule(_localctx, 54, RULE_enumBodyDeclarations);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(522);\n            match(SEMI);\n            setState(526);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028812048202823L) != 0)) || ((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 9007267974217729L) != 0))) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                {\n                    {\n                        setState(523);\n                        classBodyDeclaration();\n                    }\n                }\n                setState(528);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.explicitConstructorInvocation" ],
    "fullMethods" : [ "public final ExplicitConstructorInvocationContext explicitConstructorInvocation() throws RecognitionException {\n    ExplicitConstructorInvocationContext _localctx = new ExplicitConstructorInvocationContext(_ctx, getState());\n    enterRule(_localctx, 150, RULE_explicitConstructorInvocation);\n    int _la;\n    try {\n        setState(974);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 107, _ctx)) {\n            case 1 :\n                _localctx = new ExplicitCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(959);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(958);\n                            typeArguments();\n                        }\n                    }\n                    setState(961);\n                    _la = _input.LA(1);\n                    if (!((_la == LITERAL_THIS) || (_la == LITERAL_SUPER))) {\n                        _errHandler.recoverInline(this);\n                    } else {\n                        if (_input.LA(1) == Token.EOF)\n                            matchedEOF = true;\n\n                        _errHandler.reportMatch(this);\n                        consume();\n                    }\n                    setState(962);\n                    arguments();\n                    setState(963);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new PrimaryCtorCallContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(965);\n                    expr(0);\n                    setState(966);\n                    match(DOT);\n                    setState(968);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(967);\n                            typeArguments();\n                        }\n                    }\n                    setState(970);\n                    match(LITERAL_SUPER);\n                    setState(971);\n                    arguments();\n                    setState(972);\n                    match(SEMI);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.valueInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.valueInlineTag" ],
    "fullMethods" : [ "public final ValueInlineTagContext valueInlineTag() throws RecognitionException {\n    ValueInlineTagContext _localctx = new ValueInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 48, RULE_valueInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(289);\n            ((ValueInlineTagContext) (_localctx)).tagName = match(VALUE);\n            setState(291);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == FORMAT_SPECIFIER) {\n                {\n                    setState(290);\n                    match(FORMAT_SPECIFIER);\n                }\n            }\n            setState(294);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((_la == IDENTIFIER) || (_la == HASH)) {\n                {\n                    setState(293);\n                    reference();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localTypeDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localTypeDeclaration" ],
    "fullMethods" : [ "public final LocalTypeDeclarationContext localTypeDeclaration() throws RecognitionException {\n    LocalTypeDeclarationContext _localctx = new LocalTypeDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 158, RULE_localTypeDeclaration);\n    int _la;\n    try {\n        setState(1015);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1005);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while (((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028798088511495L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 1649267441665L) != 0))) {\n                        {\n                            {\n                                setState(1002);\n                                ((LocalTypeDeclarationContext) (_localctx)).modifier = modifier();\n                                ((LocalTypeDeclarationContext) (_localctx)).mods.add(((LocalTypeDeclarationContext) (_localctx)).modifier);\n                            }\n                        }\n                        setState(1007);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1012);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LITERAL_CLASS :\n                            {\n                                setState(1008);\n                                classDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case ENUM :\n                            {\n                                setState(1009);\n                                enumDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case LITERAL_INTERFACE :\n                            {\n                                setState(1010);\n                                interfaceDeclaration(_localctx.mods);\n                            }\n                            break;\n                        case LITERAL_RECORD :\n                            {\n                                setState(1011);\n                                recordDeclaration(_localctx.mods);\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1014);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classExtends",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classExtends" ],
    "fullMethods" : [ "public final ClassExtendsContext classExtends() throws RecognitionException {\n    ClassExtendsContext _localctx = new ClassExtendsContext(_ctx, getState());\n    enterRule(_localctx, 32, RULE_classExtends);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(445);\n            match(EXTENDS_CLAUSE);\n            setState(446);\n            ((ClassExtendsContext) (_localctx)).type = typeType(false);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.blockStatement" ],
    "fullMethods" : [ "public final BlockStatementContext blockStatement() throws RecognitionException {\n    BlockStatementContext _localctx = new BlockStatementContext(_ctx, getState());\n    enterRule(_localctx, 154, RULE_blockStatement);\n    try {\n        setState(991);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 109, _ctx)) {\n            case 1 :\n                _localctx = new LocalVarContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(985);\n                    if (!(!isYieldStatement()))\n                        throw new FailedPredicateException(this, \"!isYieldStatement()\");\n\n                    setState(986);\n                    localVariableDeclaration();\n                    setState(987);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new StatContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(989);\n                    statement();\n                }\n                break;\n            case 3 :\n                _localctx = new LocalTypeContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(990);\n                    localTypeDeclaration();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elseStat",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elseStat" ],
    "fullMethods" : [ "public final ElseStatContext elseStat() throws RecognitionException {\n    ElseStatContext _localctx = new ElseStatContext(_ctx, getState());\n    enterRule(_localctx, 174, RULE_elseStat);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1156);\n            match(LITERAL_ELSE);\n            setState(1157);\n            statement();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeBody" ],
    "fullMethods" : [ "public final AnnotationTypeBodyContext annotationTypeBody() throws RecognitionException {\n    AnnotationTypeBodyContext _localctx = new AnnotationTypeBodyContext(_ctx, getState());\n    enterRule(_localctx, 136, RULE_annotationTypeBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(878);\n            match(LCURLY);\n            setState(882);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028803458268231L) != 0)) || ((((_la - 153) & (~0x3f)) == 0) && (((1L << (_la - 153)) & 2828401303477157889L) != 0))) || (_la == LITERAL_UNDERSCORE)) {\n                {\n                    {\n                        setState(879);\n                        annotationTypeElementDeclaration();\n                    }\n                }\n                setState(884);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(885);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeType" ],
    "fullMethods" : [ "public final TypeTypeContext typeType(boolean createImaginaryNode) throws RecognitionException {\n    TypeTypeContext _localctx = new TypeTypeContext(_ctx, getState(), createImaginaryNode);\n    enterRule(_localctx, 254, RULE_typeType);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1650);\n            annotations(false);\n            setState(1651);\n            classOrInterfaceOrPrimitiveType();\n            setState(1655);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 195, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1652);\n                            arrayDeclarator();\n                        }\n                    }\n                }\n                setState(1657);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 195, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enhancedForControl",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enhancedForControl" ],
    "fullMethods" : [ "public final EnhancedForControlContext enhancedForControl() throws RecognitionException {\n    EnhancedForControlContext _localctx = new EnhancedForControlContext(_ctx, getState());\n    enterRule(_localctx, 208, RULE_enhancedForControl);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1291);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 151, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1288);\n                            ((EnhancedForControlContext) (_localctx)).variableModifier = variableModifier();\n                            ((EnhancedForControlContext) (_localctx)).mods.add(((EnhancedForControlContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(1293);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 151, _ctx);\n            } \n            setState(1294);\n            ((EnhancedForControlContext) (_localctx)).type = typeType(true);\n            setState(1295);\n            variableDeclaratorId(_localctx.mods, _localctx.type);\n            setState(1296);\n            match(COLON);\n            setState(1297);\n            expression();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValuePair",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValuePair" ],
    "fullMethods" : [ "public final ElementValuePairContext elementValuePair() throws RecognitionException {\n    ElementValuePairContext _localctx = new ElementValuePairContext(_ctx, getState());\n    enterRule(_localctx, 128, RULE_elementValuePair);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(848);\n            id();\n            setState(849);\n            match(ASSIGN);\n            setState(850);\n            elementValue();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typePattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typePattern" ],
    "fullMethods" : [ "public final TypePatternContext typePattern() throws RecognitionException {\n    TypePatternContext _localctx = new TypePatternContext(_ctx, getState());\n    enterRule(_localctx, 278, RULE_typePattern);\n    try {\n        int _alt;\n        setState(1732);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 206, _ctx)) {\n            case 1 :\n                _localctx = new TypePatternDefContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1725);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 205, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(1722);\n                                    ((TypePatternDefContext) (_localctx)).modifier = modifier();\n                                    ((TypePatternDefContext) (_localctx)).mods.add(((TypePatternDefContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(1727);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 205, _ctx);\n                    } \n                    setState(1728);\n                    ((TypePatternDefContext) (_localctx)).type = typeType(true);\n                    setState(1729);\n                    id();\n                }\n                break;\n            case 2 :\n                _localctx = new UnnamedPatternDefContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1731);\n                    match(LITERAL_UNDERSCORE);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.codeInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.codeInlineTag" ],
    "fullMethods" : [ "public final CodeInlineTagContext codeInlineTag() throws RecognitionException {\n    CodeInlineTagContext _localctx = new CodeInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 42, RULE_codeInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(272);\n            ((CodeInlineTagContext) (_localctx)).tagName = match(CODE);\n            setState(276);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == TEXT) {\n                {\n                    {\n                        setState(273);\n                        match(TEXT);\n                    }\n                }\n                setState(278);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBodyDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBodyDeclaration" ],
    "fullMethods" : [ "public final InterfaceBodyDeclarationContext interfaceBodyDeclaration() throws RecognitionException {\n    InterfaceBodyDeclarationContext _localctx = new InterfaceBodyDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 78, RULE_interfaceBodyDeclaration);\n    try {\n        int _alt;\n        setState(633);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case LT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(628);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 52, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(625);\n                                    ((InterfaceBodyDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((InterfaceBodyDeclarationContext) (_localctx)).mods.add(((InterfaceBodyDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(630);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 52, _ctx);\n                    } \n                    setState(631);\n                    interfaceMemberDeclaration(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(632);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resource",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resource" ],
    "fullMethods" : [ "public final ResourceContext resource() throws RecognitionException {\n    ResourceContext _localctx = new ResourceContext(_ctx, getState());\n    enterRule(_localctx, 188, RULE_resource);\n    try {\n        setState(1202);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 134, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1200);\n                    resourceDeclaration();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1201);\n                    variableAccess();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlCommentContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlCommentContent" ],
    "fullMethods" : [ "public final HtmlCommentContentContext htmlCommentContent() throws RecognitionException {\n    HtmlCommentContentContext _localctx = new HtmlCommentContentContext(_ctx, getState());\n    enterRule(_localctx, 108, RULE_htmlCommentContent);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(485);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == TEXT) {\n                {\n                    {\n                        setState(482);\n                        match(TEXT);\n                    }\n                }\n                setState(487);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resourceDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resourceDeclaration" ],
    "fullMethods" : [ "public final ResourceDeclarationContext resourceDeclaration() throws RecognitionException {\n    ResourceDeclarationContext _localctx = new ResourceDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 190, RULE_resourceDeclaration);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1207);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 135, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1204);\n                            ((ResourceDeclarationContext) (_localctx)).variableModifier = variableModifier();\n                            ((ResourceDeclarationContext) (_localctx)).mods.add(((ResourceDeclarationContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(1209);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 135, _ctx);\n            } \n            setState(1210);\n            ((ResourceDeclarationContext) (_localctx)).type = classOrInterfaceType(true);\n            setState(1211);\n            variableDeclaratorId(_localctx.mods, _localctx.type);\n            setState(1212);\n            match(ASSIGN);\n            setState(1213);\n            expression();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeDeclaration" ],
    "fullMethods" : [ "public final TypeDeclarationContext typeDeclaration() throws RecognitionException {\n    TypeDeclarationContext _localctx = new TypeDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 6, RULE_typeDeclaration);\n    try {\n        int _alt;\n        setState(336);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(327);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 6, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(324);\n                                    ((TypeDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((TypeDeclarationContext) (_localctx)).mods.add(((TypeDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(329);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 6, _ctx);\n                    } \n                    setState(330);\n                    ((TypeDeclarationContext) (_localctx)).type = types(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(332);\n                    _errHandler.sync(this);\n                    _alt = 1;\n                    do {\n                        switch (_alt) {\n                            case 1 :\n                                {\n                                    {\n                                        setState(331);\n                                        ((TypeDeclarationContext) (_localctx)).SEMI = match(SEMI);\n                                        ((TypeDeclarationContext) (_localctx)).semi.add(((TypeDeclarationContext) (_localctx)).SEMI);\n                                    }\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                        setState(334);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 7, _ctx);\n                    } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.compactConstructorDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.compactConstructorDeclaration" ],
    "fullMethods" : [ "public final CompactConstructorDeclarationContext compactConstructorDeclaration() throws RecognitionException {\n    CompactConstructorDeclarationContext _localctx = new CompactConstructorDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 30, RULE_compactConstructorDeclaration);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(439);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 24, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(436);\n                            ((CompactConstructorDeclarationContext) (_localctx)).modifier = modifier();\n                            ((CompactConstructorDeclarationContext) (_localctx)).mods.add(((CompactConstructorDeclarationContext) (_localctx)).modifier);\n                        }\n                    }\n                }\n                setState(441);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 24, _ctx);\n            } \n            setState(442);\n            id();\n            setState(443);\n            constructorBlock();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.authorTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.authorTag" ],
    "fullMethods" : [ "public final AuthorTagContext authorTag() throws RecognitionException {\n    AuthorTagContext _localctx = new AuthorTagContext(_ctx, getState());\n    enterRule(_localctx, 6, RULE_authorTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(147);\n            match(AT_SIGN);\n            setState(148);\n            ((AuthorTagContext) (_localctx)).tagName = match(AUTHOR);\n            setState(150);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 5, _ctx)) {\n                case 1 :\n                    {\n                        setState(149);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.superSuffix",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.superSuffix" ],
    "fullMethods" : [ "public final SuperSuffixContext superSuffix() throws RecognitionException {\n    SuperSuffixContext _localctx = new SuperSuffixContext(_ctx, getState());\n    enterRule(_localctx, 264, RULE_superSuffix);\n    int _la;\n    try {\n        setState(1693);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LPAREN :\n                _localctx = new SuperSuffixSimpleContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1679);\n                    match(LPAREN);\n                    setState(1681);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1680);\n                            expressionList();\n                        }\n                    }\n                    setState(1683);\n                    match(RPAREN);\n                }\n                break;\n            case DOT :\n                _localctx = new SuperSuffixDotContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1684);\n                    match(DOT);\n                    setState(1685);\n                    id();\n                    setState(1691);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 200, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1686);\n                                match(LPAREN);\n                                setState(1688);\n                                _errHandler.sync(this);\n                                _la = _input.LA(1);\n                                if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                    {\n                                        setState(1687);\n                                        expressionList();\n                                    }\n                                }\n                                setState(1690);\n                                match(RPAREN);\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlElement" ],
    "fullMethods" : [ "public final HtmlElementContext htmlElement() throws RecognitionException {\n    HtmlElementContext _localctx = new HtmlElementContext(_ctx, getState());\n    enterRule(_localctx, 86, RULE_htmlElement);\n    try {\n        setState(418);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 56, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(414);\n                    voidElement();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(415);\n                    selfClosingElement();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(416);\n                    tightElement();\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(417);\n                    nonTightElement();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceType" ],
    "fullMethods" : [ "public final ClassOrInterfaceTypeContext classOrInterfaceType(boolean createImaginaryNode) throws RecognitionException {\n    ClassOrInterfaceTypeContext _localctx = new ClassOrInterfaceTypeContext(_ctx, getState(), createImaginaryNode);\n    enterRule(_localctx, 94, RULE_classOrInterfaceType);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(714);\n            annotations(false);\n            setState(715);\n            id();\n            setState(717);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 68, _ctx)) {\n                case 1 :\n                    {\n                        setState(716);\n                        typeArguments();\n                    }\n                    break;\n            }\n            setState(722);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 69, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(719);\n                            ((ClassOrInterfaceTypeContext) (_localctx)).classOrInterfaceTypeExtended = classOrInterfaceTypeExtended();\n                            ((ClassOrInterfaceTypeContext) (_localctx)).extended.add(((ClassOrInterfaceTypeContext) (_localctx)).classOrInterfaceTypeExtended);\n                        }\n                    }\n                }\n                setState(724);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 69, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expressionList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expressionList" ],
    "fullMethods" : [ "public final ExpressionListContext expressionList() throws RecognitionException {\n    ExpressionListContext _localctx = new ExpressionListContext(_ctx, getState());\n    enterRule(_localctx, 214, RULE_expressionList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1307);\n            ((ExpressionListContext) (_localctx)).startExp = expression();\n            setState(1312);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1308);\n                        match(COMMA);\n                        setState(1309);\n                        expression();\n                    }\n                }\n                setState(1314);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.returnInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.returnInlineTag" ],
    "fullMethods" : [ "public final ReturnInlineTagContext returnInlineTag() throws RecognitionException {\n    ReturnInlineTagContext _localctx = new ReturnInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 58, RULE_returnInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(313);\n            ((ReturnInlineTagContext) (_localctx)).tagName = match(RETURN);\n            setState(315);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 38, _ctx)) {\n                case 1 :\n                    {\n                        setState(314);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.sinceTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.sinceTag" ],
    "fullMethods" : [ "public final SinceTagContext sinceTag() throws RecognitionException {\n    SinceTagContext _localctx = new SinceTagContext(_ctx, getState());\n    enterRule(_localctx, 18, RULE_sinceTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(186);\n            match(AT_SIGN);\n            setState(187);\n            ((SinceTagContext) (_localctx)).tagName = match(SINCE);\n            setState(189);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 14, _ctx)) {\n                case 1 :\n                    {\n                        setState(188);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgument",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgument" ],
    "fullMethods" : [ "public final TypeArgumentContext typeArgument() throws RecognitionException {\n    TypeArgumentContext _localctx = new TypeArgumentContext(_ctx, getState());\n    enterRule(_localctx, 98, RULE_typeArgument);\n    int _la;\n    try {\n        setState(741);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 73, _ctx)) {\n            case 1 :\n                _localctx = new SimpleTypeArgumentContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(731);\n                    typeType(false);\n                }\n                break;\n            case 2 :\n                _localctx = new WildCardTypeArgumentContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(732);\n                    annotations(false);\n                    setState(733);\n                    match(QUESTION);\n                    setState(739);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == EXTENDS_CLAUSE) || (_la == LITERAL_SUPER)) {\n                        {\n                            setState(736);\n                            _errHandler.sync(this);\n                            switch (_input.LA(1)) {\n                                case EXTENDS_CLAUSE :\n                                    {\n                                        setState(734);\n                                        ((WildCardTypeArgumentContext) (_localctx)).upperBound = match(EXTENDS_CLAUSE);\n                                    }\n                                    break;\n                                case LITERAL_SUPER :\n                                    {\n                                        setState(735);\n                                        ((WildCardTypeArgumentContext) (_localctx)).lowerBound = match(LITERAL_SUPER);\n                                    }\n                                    break;\n                                default :\n                                    throw new NoViableAltException(this);\n                            }\n                            setState(738);\n                            typeType(false);\n                        }\n                    }\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableModifier",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableModifier" ],
    "fullMethods" : [ "public final VariableModifierContext variableModifier() throws RecognitionException {\n    VariableModifierContext _localctx = new VariableModifierContext(_ctx, getState());\n    enterRule(_localctx, 12, RULE_variableModifier);\n    try {\n        setState(364);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(362);\n                    match(FINAL);\n                }\n                break;\n            case AT :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(363);\n                    annotation();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlAttribute",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlAttribute" ],
    "fullMethods" : [ "public final HtmlAttributeContext htmlAttribute() throws RecognitionException {\n    HtmlAttributeContext _localctx = new HtmlAttributeContext(_ctx, getState());\n    enterRule(_localctx, 100, RULE_htmlAttribute);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(459);\n            match(TAG_ATTR_NAME);\n            setState(462);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == EQUALS) {\n                {\n                    setState(460);\n                    match(EQUALS);\n                    setState(461);\n                    match(ATTRIBUTE_VALUE);\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.permittedSubclassesAndInterfaces",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.permittedSubclassesAndInterfaces" ],
    "fullMethods" : [ "public final PermittedSubclassesAndInterfacesContext permittedSubclassesAndInterfaces() throws RecognitionException {\n    PermittedSubclassesAndInterfacesContext _localctx = new PermittedSubclassesAndInterfacesContext(_ctx, getState());\n    enterRule(_localctx, 284, RULE_permittedSubclassesAndInterfaces);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1757);\n            match(LITERAL_PERMITS);\n            setState(1758);\n            classOrInterfaceType(false);\n            setState(1763);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1759);\n                        match(COMMA);\n                        setState(1760);\n                        classOrInterfaceType(false);\n                    }\n                }\n                setState(1765);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.compilationUnit",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.compilationUnit" ],
    "fullMethods" : [ "public final CompilationUnitContext compilationUnit() throws RecognitionException {\n    CompilationUnitContext _localctx = new CompilationUnitContext(_ctx, getState());\n    enterRule(_localctx, 0, RULE_compilationUnit);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(289);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 0, _ctx)) {\n                case 1 :\n                    {\n                        setState(288);\n                        packageDeclaration();\n                    }\n                    break;\n            }\n            setState(294);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 1, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(291);\n                            importDeclaration();\n                        }\n                    }\n                }\n                setState(296);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 1, _ctx);\n            } \n            setState(300);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028803457220679L) != 0)) || ((((_la - 153) & (~0x3f)) == 0) && (((1L << (_la - 153)) & 216313519602270209L) != 0))) {\n                {\n                    {\n                        setState(297);\n                        typeDeclaration();\n                    }\n                }\n                setState(302);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(303);\n            match(EOF);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValueArrayInitializer",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValueArrayInitializer" ],
    "fullMethods" : [ "public final ElementValueArrayInitializerContext elementValueArrayInitializer() throws RecognitionException {\n    ElementValueArrayInitializerContext _localctx = new ElementValueArrayInitializerContext(_ctx, getState());\n    enterRule(_localctx, 132, RULE_elementValueArrayInitializer);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(857);\n            match(LCURLY);\n            setState(866);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((((((_la - 49) & (~0x3f)) == 0) && (((1L << (_la - 49)) & 1101264847871L) != 0)) || ((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 35184372117491L) != 0))) || ((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 4385166758159L) != 0))) {\n                {\n                    setState(858);\n                    elementValue();\n                    setState(863);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 88, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(859);\n                                    match(COMMA);\n                                    setState(860);\n                                    elementValue();\n                                }\n                            }\n                        }\n                        setState(865);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 88, _ctx);\n                    } \n                }\n            }\n            setState(869);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == COMMA) {\n                {\n                    setState(868);\n                    match(COMMA);\n                }\n            }\n            setState(871);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldDeclaration" ],
    "fullMethods" : [ "public final FieldDeclarationContext fieldDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    FieldDeclarationContext _localctx = new FieldDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 76, RULE_fieldDeclaration);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(621);\n            ((FieldDeclarationContext) (_localctx)).type = typeType(true);\n            setState(622);\n            variableDeclarators(_localctx.mods, _localctx.type);\n            setState(623);\n            match(SEMI);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordPattern" ],
    "fullMethods" : [ "public final RecordPatternContext recordPattern() throws RecognitionException {\n    RecordPatternContext _localctx = new RecordPatternContext(_ctx, getState());\n    enterRule(_localctx, 280, RULE_recordPattern);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1737);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 207, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1734);\n                            ((RecordPatternContext) (_localctx)).modifier = modifier();\n                            ((RecordPatternContext) (_localctx)).mods.add(((RecordPatternContext) (_localctx)).modifier);\n                        }\n                    }\n                }\n                setState(1739);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 207, _ctx);\n            } \n            setState(1740);\n            ((RecordPatternContext) (_localctx)).type = typeType(true);\n            setState(1741);\n            match(LPAREN);\n            setState(1743);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028935528512519L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                {\n                    setState(1742);\n                    recordComponentPatternList();\n                }\n            }\n            setState(1745);\n            match(RPAREN);\n            setState(1747);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 209, _ctx)) {\n                case 1 :\n                    {\n                        setState(1746);\n                        id();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.voidElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.voidElement" ],
    "fullMethods" : [ "public final VoidElementContext voidElement() throws RecognitionException {\n    VoidElementContext _localctx = new VoidElementContext(_ctx, getState());\n    enterRule(_localctx, 88, RULE_voidElement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(420);\n            if (!isVoidTag())\n                throw new FailedPredicateException(this, \" isVoidTag() \");\n\n            setState(421);\n            htmlTagStart();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.pattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.pattern" ],
    "fullMethods" : [ "public final PatternContext pattern() throws RecognitionException {\n    PatternContext _localctx = new PatternContext(_ctx, getState());\n    enterRule(_localctx, 268, RULE_pattern);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1701);\n            innerPattern();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classDeclaration" ],
    "fullMethods" : [ "public final ClassDeclarationContext classDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    ClassDeclarationContext _localctx = new ClassDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 14, RULE_classDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(366);\n            match(LITERAL_CLASS);\n            setState(367);\n            id();\n            setState(369);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(368);\n                    typeParameters();\n                }\n            }\n            setState(372);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == EXTENDS_CLAUSE) {\n                {\n                    setState(371);\n                    classExtends();\n                }\n            }\n            setState(375);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_IMPLEMENTS) {\n                {\n                    setState(374);\n                    implementsClause();\n                }\n            }\n            setState(378);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_PERMITS) {\n                {\n                    setState(377);\n                    permittedSubclassesAndInterfaces();\n                }\n            }\n            setState(380);\n            classBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resources",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resources" ],
    "fullMethods" : [ "public final ResourcesContext resources() throws RecognitionException {\n    ResourcesContext _localctx = new ResourcesContext(_ctx, getState());\n    enterRule(_localctx, 186, RULE_resources);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1192);\n            resource();\n            setState(1197);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 133, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1193);\n                            match(SEMI);\n                            setState(1194);\n                            resource();\n                        }\n                    }\n                }\n                setState(1199);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 133, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.caseConstants",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.caseConstants" ],
    "fullMethods" : [ "public final CaseConstantsContext caseConstants() throws RecognitionException {\n    CaseConstantsContext _localctx = new CaseConstantsContext(_ctx, getState());\n    enterRule(_localctx, 200, RULE_caseConstants);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1249);\n            caseConstant();\n            setState(1254);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 143, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1250);\n                            match(COMMA);\n                            setState(1251);\n                            caseConstant();\n                        }\n                    }\n                }\n                setState(1256);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 143, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.parameterTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.parameterTag" ],
    "fullMethods" : [ "public final ParameterTagContext parameterTag() throws RecognitionException {\n    ParameterTagContext _localctx = new ParameterTagContext(_ctx, getState());\n    enterRule(_localctx, 12, RULE_parameterTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(162);\n            match(AT_SIGN);\n            setState(163);\n            ((ParameterTagContext) (_localctx)).tagName = match(PARAM);\n            setState(165);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 8, _ctx)) {\n                case 1 :\n                    {\n                        setState(164);\n                        ((ParameterTagContext) (_localctx)).paramName = match(PARAMETER_NAME);\n                    }\n                    break;\n            }\n            setState(168);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 9, _ctx)) {\n                case 1 :\n                    {\n                        setState(167);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeParameters",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeParameters" ],
    "fullMethods" : [ "public final TypeParametersContext typeParameters() throws RecognitionException {\n    TypeParametersContext _localctx = new TypeParametersContext(_ctx, getState());\n    enterRule(_localctx, 36, RULE_typeParameters);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(451);\n            match(LT);\n            setState(452);\n            typeParameter();\n            setState(457);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(453);\n                        match(COMMA);\n                        setState(454);\n                        typeParameter();\n                    }\n                }\n                setState(459);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(460);\n            match(GT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.integerLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.integerLiteral" ],
    "fullMethods" : [ "public final IntegerLiteralContext integerLiteral() throws RecognitionException {\n    IntegerLiteralContext _localctx = new IntegerLiteralContext(_ctx, getState());\n    enterRule(_localctx, 116, RULE_integerLiteral);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(816);\n            _la = _input.LA(1);\n            if (!((((_la - 226) & (~0x3f)) == 0) && (((1L << (_la - 226)) & 255L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeArgument",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeArgument" ],
    "fullMethods" : [ "public final TypeArgumentContext typeArgument() throws RecognitionException {\n    TypeArgumentContext _localctx = new TypeArgumentContext(_ctx, getState());\n    enterRule(_localctx, 74, RULE_typeArgument);\n    try {\n        setState(377);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 48, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(369);\n                    typeName();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(370);\n                    match(QUESTION);\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(371);\n                    match(QUESTION);\n                    setState(372);\n                    match(EXTENDS);\n                    setState(373);\n                    typeName();\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(374);\n                    match(QUESTION);\n                    setState(375);\n                    match(SUPER);\n                    setState(376);\n                    typeName();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordBodyDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordBodyDeclaration" ],
    "fullMethods" : [ "public final RecordBodyDeclarationContext recordBodyDeclaration() throws RecognitionException {\n    RecordBodyDeclarationContext _localctx = new RecordBodyDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 28, RULE_recordBodyDeclaration);\n    try {\n        setState(434);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 23, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(432);\n                    compactConstructorDeclaration();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(433);\n                    classBodyDeclaration();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.parameterTypeList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.parameterTypeList" ],
    "fullMethods" : [ "public final ParameterTypeListContext parameterTypeList() throws RecognitionException {\n    ParameterTypeListContext _localctx = new ParameterTypeListContext(_ctx, getState());\n    enterRule(_localctx, 78, RULE_parameterTypeList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(387);\n            match(PARAMETER_TYPE);\n            setState(394);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == COMMA) || (_la == PARAMETER_TYPE)) {\n                {\n                    {\n                        setState(389);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == COMMA) {\n                            {\n                                setState(388);\n                                match(COMMA);\n                            }\n                        }\n                        setState(391);\n                        match(PARAMETER_TYPE);\n                    }\n                }\n                setState(396);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.fieldAccessNoIdent" ],
    "fullMethods" : [ "public final FieldAccessNoIdentContext fieldAccessNoIdent() throws RecognitionException {\n    FieldAccessNoIdentContext _localctx = new FieldAccessNoIdentContext(_ctx, getState());\n    enterRule(_localctx, 194, RULE_fieldAccessNoIdent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1225);\n            expr(0);\n            setState(1226);\n            match(DOT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.innerPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.innerPattern" ],
    "fullMethods" : [ "public final InnerPatternContext innerPattern() throws RecognitionException {\n    InnerPatternContext _localctx = new InnerPatternContext(_ctx, getState());\n    enterRule(_localctx, 270, RULE_innerPattern);\n    try {\n        setState(1706);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 203, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1703);\n                    guardedPattern();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1704);\n                    recordPattern();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1705);\n                    primaryPattern();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialFieldTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialFieldTag" ],
    "fullMethods" : [ "public final SerialFieldTagContext serialFieldTag() throws RecognitionException {\n    SerialFieldTagContext _localctx = new SerialFieldTagContext(_ctx, getState());\n    enterRule(_localctx, 34, RULE_serialFieldTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(238);\n            match(AT_SIGN);\n            setState(239);\n            ((SerialFieldTagContext) (_localctx)).tagName = match(SERIAL_FIELD);\n            setState(241);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 24, _ctx)) {\n                case 1 :\n                    {\n                        setState(240);\n                        ((SerialFieldTagContext) (_localctx)).fieldName = match(IDENTIFIER);\n                    }\n                    break;\n            }\n            setState(244);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 25, _ctx)) {\n                case 1 :\n                    {\n                        setState(243);\n                        match(FIELD_TYPE);\n                    }\n                    break;\n            }\n            setState(247);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 26, _ctx)) {\n                case 1 :\n                    {\n                        setState(246);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.tightElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.tightElement" ],
    "fullMethods" : [ "public final TightElementContext tightElement() throws RecognitionException {\n    TightElementContext _localctx = new TightElementContext(_ctx, getState());\n    enterRule(_localctx, 90, RULE_tightElement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(423);\n            if (!(!JavadocCommentsParserUtil.isNonTightTag(_input, unclosedTagNameTokens)))\n                throw new FailedPredicateException(this, \" !JavadocCommentsParserUtil.isNonTightTag(_input, unclosedTagNameTokens) \");\n\n            setState(424);\n            htmlTagStart();\n            setState(426);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 57, _ctx)) {\n                case 1 :\n                    {\n                        setState(425);\n                        htmlContent();\n                    }\n                    break;\n            }\n            setState(428);\n            htmlTagEnd();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.memberDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.memberDeclaration" ],
    "fullMethods" : [ "public final MemberDeclarationContext memberDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    MemberDeclarationContext _localctx = new MemberDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 66, RULE_memberDeclaration);\n    try {\n        setState(585);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 45, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(577);\n                    recordDeclaration(mods);\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(578);\n                    methodDeclaration(mods);\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(579);\n                    fieldDeclaration(mods);\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(580);\n                    constructorDeclaration(mods);\n                }\n                break;\n            case 5 :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(581);\n                    interfaceDeclaration(mods);\n                }\n                break;\n            case 6 :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(582);\n                    annotationTypeDeclaration(mods);\n                }\n                break;\n            case 7 :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(583);\n                    classDeclaration(mods);\n                }\n                break;\n            case 8 :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(584);\n                    enumDeclaration(mods);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeDeclaration" ],
    "fullMethods" : [ "public final AnnotationTypeDeclarationContext annotationTypeDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    AnnotationTypeDeclarationContext _localctx = new AnnotationTypeDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 134, RULE_annotationTypeDeclaration);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(873);\n            match(AT);\n            setState(874);\n            match(LITERAL_INTERFACE);\n            setState(875);\n            id();\n            setState(876);\n            annotationTypeBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.block",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.block" ],
    "fullMethods" : [ "public final BlockContext block() throws RecognitionException {\n    BlockContext _localctx = new BlockContext(_ctx, getState());\n    enterRule(_localctx, 152, RULE_block);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(976);\n            match(LCURLY);\n            setState(980);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 108, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(977);\n                            blockStatement();\n                        }\n                    }\n                }\n                setState(982);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 108, _ctx);\n            } \n            setState(983);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumConstant",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumConstant" ],
    "fullMethods" : [ "public final EnumConstantContext enumConstant() throws RecognitionException {\n    EnumConstantContext _localctx = new EnumConstantContext(_ctx, getState());\n    enterRule(_localctx, 52, RULE_enumConstant);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(514);\n            annotations(true);\n            setState(515);\n            id();\n            setState(517);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LPAREN) {\n                {\n                    setState(516);\n                    arguments();\n                }\n            }\n            setState(520);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LCURLY) {\n                {\n                    setState(519);\n                    classBody();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchClause",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchClause" ],
    "fullMethods" : [ "public final CatchClauseContext catchClause() throws RecognitionException {\n    CatchClauseContext _localctx = new CatchClauseContext(_ctx, getState());\n    enterRule(_localctx, 176, RULE_catchClause);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1159);\n            match(LITERAL_CATCH);\n            setState(1160);\n            match(LPAREN);\n            setState(1161);\n            catchParameter();\n            setState(1162);\n            match(RPAREN);\n            setState(1163);\n            block();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceMethodDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceMethodDeclaration" ],
    "fullMethods" : [ "public final InterfaceMethodDeclarationContext interfaceMethodDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    InterfaceMethodDeclarationContext _localctx = new InterfaceMethodDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 82, RULE_interfaceMethodDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(645);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(644);\n                    typeParameters();\n                }\n            }\n            setState(647);\n            ((InterfaceMethodDeclarationContext) (_localctx)).type = typeType(true);\n            setState(648);\n            id();\n            setState(649);\n            formalParameters();\n            setState(653);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(650);\n                        ((InterfaceMethodDeclarationContext) (_localctx)).arrayDeclarator = arrayDeclarator();\n                        ((InterfaceMethodDeclarationContext) (_localctx)).cStyleArrDec.add(((InterfaceMethodDeclarationContext) (_localctx)).arrayDeclarator);\n                    }\n                }\n                setState(655);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(657);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_THROWS) {\n                {\n                    setState(656);\n                    throwsList();\n                }\n            }\n            setState(659);\n            methodBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialDataTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialDataTag" ],
    "fullMethods" : [ "public final SerialDataTagContext serialDataTag() throws RecognitionException {\n    SerialDataTagContext _localctx = new SerialDataTagContext(_ctx, getState());\n    enterRule(_localctx, 32, RULE_serialDataTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(233);\n            match(AT_SIGN);\n            setState(234);\n            ((SerialDataTagContext) (_localctx)).tagName = match(SERIAL_DATA);\n            setState(236);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 23, _ctx)) {\n                case 1 :\n                    {\n                        setState(235);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primitiveType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primitiveType" ],
    "fullMethods" : [ "public final PrimitiveTypeContext primitiveType() throws RecognitionException {\n    PrimitiveTypeContext _localctx = new PrimitiveTypeContext(_ctx, getState());\n    enterRule(_localctx, 260, RULE_primitiveType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1666);\n            _la = _input.LA(1);\n            if (!(((_la & (~0x3f)) == 0) && (((1L << _la) & 287667426198290432L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expression" ],
    "fullMethods" : [ "public final ExpressionContext expression() throws RecognitionException {\n    ExpressionContext _localctx = new ExpressionContext(_ctx, getState());\n    enterRule(_localctx, 216, RULE_expression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1315);\n            expr(0);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeParameter",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeParameter" ],
    "fullMethods" : [ "public final TypeParameterContext typeParameter() throws RecognitionException {\n    TypeParameterContext _localctx = new TypeParameterContext(_ctx, getState());\n    enterRule(_localctx, 38, RULE_typeParameter);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(462);\n            annotations(false);\n            setState(463);\n            id();\n            setState(465);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == EXTENDS_CLAUSE) {\n                {\n                    setState(464);\n                    typeUpperBounds();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgumentsTypeList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgumentsTypeList" ],
    "fullMethods" : [ "public final TypeArgumentsTypeListContext typeArgumentsTypeList() throws RecognitionException {\n    TypeArgumentsTypeListContext _localctx = new TypeArgumentsTypeListContext(_ctx, getState());\n    enterRule(_localctx, 250, RULE_typeArgumentsTypeList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1634);\n            typeType(false);\n            setState(1639);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1635);\n                        match(COMMA);\n                        setState(1636);\n                        typeType(false);\n                    }\n                }\n                setState(1641);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeCastParameters",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeCastParameters" ],
    "fullMethods" : [ "public final TypeCastParametersContext typeCastParameters() throws RecognitionException {\n    TypeCastParametersContext _localctx = new TypeCastParametersContext(_ctx, getState());\n    enterRule(_localctx, 220, RULE_typeCastParameters);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1476);\n            typeType(true);\n            setState(1481);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == BAND) {\n                {\n                    {\n                        setState(1477);\n                        match(BAND);\n                        setState(1478);\n                        typeType(true);\n                    }\n                }\n                setState(1483);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlockStatementGroup",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlockStatementGroup" ],
    "fullMethods" : [ "public final SwitchBlockStatementGroupContext switchBlockStatementGroup() throws RecognitionException {\n    SwitchBlockStatementGroupContext _localctx = new SwitchBlockStatementGroupContext(_ctx, getState());\n    enterRule(_localctx, 196, RULE_switchBlockStatementGroup);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1229);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            {\n                                setState(1228);\n                                switchLabel();\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(1231);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 138, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n            setState(1234);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            {\n                                setState(1233);\n                                ((SwitchBlockStatementGroupContext) (_localctx)).blockStatement = blockStatement();\n                                ((SwitchBlockStatementGroupContext) (_localctx)).slists.add(((SwitchBlockStatementGroupContext) (_localctx)).blockStatement);\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(1236);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 139, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.literalInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.literalInlineTag" ],
    "fullMethods" : [ "public final LiteralInlineTagContext literalInlineTag() throws RecognitionException {\n    LiteralInlineTagContext _localctx = new LiteralInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 60, RULE_literalInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(317);\n            ((LiteralInlineTagContext) (_localctx)).tagName = match(LITERAL);\n            setState(319);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            do {\n                {\n                    {\n                        setState(318);\n                        match(TEXT);\n                    }\n                }\n                setState(321);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } while (_la == TEXT );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enhancedForControlWithRecordPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enhancedForControlWithRecordPattern" ],
    "fullMethods" : [ "public final EnhancedForControlWithRecordPatternContext enhancedForControlWithRecordPattern() throws RecognitionException {\n    EnhancedForControlWithRecordPatternContext _localctx = new EnhancedForControlWithRecordPatternContext(_ctx, getState());\n    enterRule(_localctx, 210, RULE_enhancedForControlWithRecordPattern);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1299);\n            pattern();\n            setState(1300);\n            match(COLON);\n            setState(1301);\n            expression();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.forInit",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.forInit" ],
    "fullMethods" : [ "public final ForInitContext forInit() throws RecognitionException {\n    ForInitContext _localctx = new ForInitContext(_ctx, getState());\n    enterRule(_localctx, 206, RULE_forInit);\n    try {\n        setState(1286);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 150, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1284);\n                    localVariableDeclaration();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1285);\n                    expressionList();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classBody" ],
    "fullMethods" : [ "public final ClassBodyContext classBody() throws RecognitionException {\n    ClassBodyContext _localctx = new ClassBodyContext(_ctx, getState());\n    enterRule(_localctx, 60, RULE_classBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(545);\n            match(LCURLY);\n            setState(549);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028812048202823L) != 0)) || ((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 9007267974217729L) != 0))) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                {\n                    {\n                        setState(546);\n                        classBodyDeclaration();\n                    }\n                }\n                setState(551);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(552);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.memberReference",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.memberReference" ],
    "fullMethods" : [ "public final MemberReferenceContext memberReference() throws RecognitionException {\n    MemberReferenceContext _localctx = new MemberReferenceContext(_ctx, getState());\n    enterRule(_localctx, 76, RULE_memberReference);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(379);\n            match(IDENTIFIER);\n            setState(385);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 50, _ctx)) {\n                case 1 :\n                    {\n                        setState(380);\n                        match(LPAREN);\n                        setState(382);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == PARAMETER_TYPE) {\n                            {\n                                setState(381);\n                                parameterTypeList();\n                            }\n                        }\n                        setState(384);\n                        match(RPAREN);\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementDeclaration" ],
    "fullMethods" : [ "public final AnnotationTypeElementDeclarationContext annotationTypeElementDeclaration() throws RecognitionException {\n    AnnotationTypeElementDeclarationContext _localctx = new AnnotationTypeElementDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 138, RULE_annotationTypeElementDeclaration);\n    try {\n        int _alt;\n        setState(895);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case FINAL :\n            case ABSTRACT :\n            case STRICTFP :\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LITERAL_PRIVATE :\n            case LITERAL_PUBLIC :\n            case LITERAL_PROTECTED :\n            case LITERAL_STATIC :\n            case LITERAL_TRANSIENT :\n            case LITERAL_NATIVE :\n            case LITERAL_SYNCHRONIZED :\n            case LITERAL_VOLATILE :\n            case LITERAL_CLASS :\n            case LITERAL_INTERFACE :\n            case LITERAL_DEFAULT :\n            case ENUM :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(890);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 92, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(887);\n                                    ((AnnotationTypeElementDeclarationContext) (_localctx)).modifier = modifier();\n                                    ((AnnotationTypeElementDeclarationContext) (_localctx)).mods.add(((AnnotationTypeElementDeclarationContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(892);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 92, _ctx);\n                    } \n                    setState(893);\n                    annotationTypeElementRest(_localctx.mods);\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(894);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.floatLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.floatLiteral" ],
    "fullMethods" : [ "public final FloatLiteralContext floatLiteral() throws RecognitionException {\n    FloatLiteralContext _localctx = new FloatLiteralContext(_ctx, getState());\n    enterRule(_localctx, 118, RULE_floatLiteral);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(818);\n            _la = _input.LA(1);\n            if (!((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 15L) != 0))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.statement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.statement" ],
    "fullMethods" : [ "public final StatementContext statement() throws RecognitionException {\n    StatementContext _localctx = new StatementContext(_ctx, getState());\n    enterRule(_localctx, 160, RULE_statement);\n    int _la;\n    try {\n        int _alt;\n        setState(1107);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 124, _ctx)) {\n            case 1 :\n                _localctx = new BlockStatContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1017);\n                    ((BlockStatContext) (_localctx)).blockLabel = block();\n                }\n                break;\n            case 2 :\n                _localctx = new AssertExpContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1018);\n                    match(ASSERT);\n                    setState(1019);\n                    expression();\n                    setState(1022);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == COLON) {\n                        {\n                            setState(1020);\n                            match(COLON);\n                            setState(1021);\n                            expression();\n                        }\n                    }\n                    setState(1024);\n                    match(SEMI);\n                }\n                break;\n            case 3 :\n                _localctx = new IfStatContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1026);\n                    match(LITERAL_IF);\n                    setState(1027);\n                    parExpression();\n                    setState(1028);\n                    statement();\n                    setState(1030);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 115, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1029);\n                                elseStat();\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 4 :\n                _localctx = new ForStatContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(1032);\n                    match(LITERAL_FOR);\n                    setState(1033);\n                    forControl();\n                    setState(1034);\n                    statement();\n                }\n                break;\n            case 5 :\n                _localctx = new WhileStatContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(1036);\n                    match(LITERAL_WHILE);\n                    setState(1037);\n                    parExpression();\n                    setState(1038);\n                    statement();\n                }\n                break;\n            case 6 :\n                _localctx = new DoStatContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(1040);\n                    match(LITERAL_DO);\n                    setState(1041);\n                    statement();\n                    setState(1042);\n                    match(LITERAL_WHILE);\n                    setState(1043);\n                    parExpression();\n                    setState(1044);\n                    match(SEMI);\n                }\n                break;\n            case 7 :\n                _localctx = new TryStatContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(1046);\n                    match(LITERAL_TRY);\n                    setState(1047);\n                    block();\n                    setState(1057);\n                    _errHandler.sync(this);\n                    switch (_input.LA(1)) {\n                        case LITERAL_CATCH :\n                            {\n                                setState(1049);\n                                _errHandler.sync(this);\n                                _alt = 1;\n                                do {\n                                    switch (_alt) {\n                                        case 1 :\n                                            {\n                                                {\n                                                    setState(1048);\n                                                    catchClause();\n                                                }\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                    setState(1051);\n                                    _errHandler.sync(this);\n                                    _alt = getInterpreter().adaptivePredict(_input, 116, _ctx);\n                                } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n                                setState(1054);\n                                _errHandler.sync(this);\n                                switch (getInterpreter().adaptivePredict(_input, 117, _ctx)) {\n                                    case 1 :\n                                        {\n                                            setState(1053);\n                                            finallyBlock();\n                                        }\n                                        break;\n                                }\n                            }\n                            break;\n                        case LITERAL_FINALLY :\n                            {\n                                setState(1056);\n                                finallyBlock();\n                            }\n                            break;\n                        default :\n                            throw new NoViableAltException(this);\n                    }\n                }\n                break;\n            case 8 :\n                _localctx = new TryWithResourceStatContext(_localctx);\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(1059);\n                    match(LITERAL_TRY);\n                    setState(1060);\n                    resourceSpecification();\n                    setState(1061);\n                    block();\n                    setState(1065);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 119, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(1062);\n                                    catchClause();\n                                }\n                            }\n                        }\n                        setState(1067);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 119, _ctx);\n                    } \n                    setState(1069);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 120, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1068);\n                                finallyBlock();\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 9 :\n                _localctx = new YieldStatContext(_localctx);\n                enterOuterAlt(_localctx, 9);\n                {\n                    setState(1071);\n                    match(LITERAL_YIELD);\n                    setState(1072);\n                    expression();\n                    setState(1073);\n                    match(SEMI);\n                }\n                break;\n            case 10 :\n                _localctx = new SwitchStatContext(_localctx);\n                enterOuterAlt(_localctx, 10);\n                {\n                    setState(1075);\n                    switchExpressionOrStatement();\n                }\n                break;\n            case 11 :\n                _localctx = new SyncStatContext(_localctx);\n                enterOuterAlt(_localctx, 11);\n                {\n                    setState(1076);\n                    match(LITERAL_SYNCHRONIZED);\n                    setState(1077);\n                    parExpression();\n                    setState(1078);\n                    block();\n                }\n                break;\n            case 12 :\n                _localctx = new ReturnStatContext(_localctx);\n                enterOuterAlt(_localctx, 12);\n                {\n                    setState(1080);\n                    match(LITERAL_RETURN);\n                    setState(1082);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1081);\n                            expression();\n                        }\n                    }\n                    setState(1084);\n                    match(SEMI);\n                }\n                break;\n            case 13 :\n                _localctx = new ThrowStatContext(_localctx);\n                enterOuterAlt(_localctx, 13);\n                {\n                    setState(1085);\n                    match(LITERAL_THROW);\n                    setState(1086);\n                    expression();\n                    setState(1087);\n                    match(SEMI);\n                }\n                break;\n            case 14 :\n                _localctx = new BreakStatContext(_localctx);\n                enterOuterAlt(_localctx, 14);\n                {\n                    setState(1089);\n                    match(LITERAL_BREAK);\n                    setState(1091);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                        {\n                            setState(1090);\n                            id();\n                        }\n                    }\n                    setState(1093);\n                    match(SEMI);\n                }\n                break;\n            case 15 :\n                _localctx = new ContinueStatContext(_localctx);\n                enterOuterAlt(_localctx, 15);\n                {\n                    setState(1094);\n                    match(LITERAL_CONTINUE);\n                    setState(1096);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                        {\n                            setState(1095);\n                            id();\n                        }\n                    }\n                    setState(1098);\n                    match(SEMI);\n                }\n                break;\n            case 16 :\n                _localctx = new EmptyStatContext(_localctx);\n                enterOuterAlt(_localctx, 16);\n                {\n                    setState(1099);\n                    match(SEMI);\n                }\n                break;\n            case 17 :\n                _localctx = new ExpStatContext(_localctx);\n                enterOuterAlt(_localctx, 17);\n                {\n                    setState(1100);\n                    ((ExpStatContext) (_localctx)).statementExpression = expression();\n                    setState(1101);\n                    match(SEMI);\n                }\n                break;\n            case 18 :\n                _localctx = new LabelStatContext(_localctx);\n                enterOuterAlt(_localctx, 18);\n                {\n                    setState(1103);\n                    id();\n                    setState(1104);\n                    match(COLON);\n                    setState(1105);\n                    statement();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.serialTag" ],
    "fullMethods" : [ "public final SerialTagContext serialTag() throws RecognitionException {\n    SerialTagContext _localctx = new SerialTagContext(_ctx, getState());\n    enterRule(_localctx, 30, RULE_serialTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(228);\n            match(AT_SIGN);\n            setState(229);\n            ((SerialTagContext) (_localctx)).tagName = match(SERIAL);\n            setState(231);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 22, _ctx)) {\n                case 1 :\n                    {\n                        setState(230);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.returnTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.returnTag" ],
    "fullMethods" : [ "public final ReturnTagContext returnTag() throws RecognitionException {\n    ReturnTagContext _localctx = new ReturnTagContext(_ctx, getState());\n    enterRule(_localctx, 10, RULE_returnTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(157);\n            match(AT_SIGN);\n            setState(158);\n            ((ReturnTagContext) (_localctx)).tagName = match(RETURN);\n            setState(160);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 7, _ctx)) {\n                case 1 :\n                    {\n                        setState(159);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.blockTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.blockTag" ],
    "fullMethods" : [ "public final BlockTagContext blockTag() throws RecognitionException {\n    BlockTagContext _localctx = new BlockTagContext(_ctx, getState());\n    enterRule(_localctx, 4, RULE_blockTag);\n    try {\n        setState(145);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 4, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(129);\n                    authorTag();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(130);\n                    deprecatedTag();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(131);\n                    returnTag();\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(132);\n                    parameterTag();\n                }\n                break;\n            case 5 :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(133);\n                    throwsTag();\n                }\n                break;\n            case 6 :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(134);\n                    exceptionTag();\n                }\n                break;\n            case 7 :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(135);\n                    sinceTag();\n                }\n                break;\n            case 8 :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(136);\n                    versionTag();\n                }\n                break;\n            case 9 :\n                enterOuterAlt(_localctx, 9);\n                {\n                    setState(137);\n                    seeTag();\n                }\n                break;\n            case 10 :\n                enterOuterAlt(_localctx, 10);\n                {\n                    setState(138);\n                    hiddenTag();\n                }\n                break;\n            case 11 :\n                enterOuterAlt(_localctx, 11);\n                {\n                    setState(139);\n                    usesTag();\n                }\n                break;\n            case 12 :\n                enterOuterAlt(_localctx, 12);\n                {\n                    setState(140);\n                    providesTag();\n                }\n                break;\n            case 13 :\n                enterOuterAlt(_localctx, 13);\n                {\n                    setState(141);\n                    serialTag();\n                }\n                break;\n            case 14 :\n                enterOuterAlt(_localctx, 14);\n                {\n                    setState(142);\n                    serialDataTag();\n                }\n                break;\n            case 15 :\n                enterOuterAlt(_localctx, 15);\n                {\n                    setState(143);\n                    serialFieldTag();\n                }\n                break;\n            case 16 :\n                enterOuterAlt(_localctx, 16);\n                {\n                    setState(144);\n                    customBlockTag();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guard",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guard" ],
    "fullMethods" : [ "public final GuardContext guard() throws RecognitionException {\n    GuardContext _localctx = new GuardContext(_ctx, getState());\n    enterRule(_localctx, 274, RULE_guard);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1712);\n            _la = _input.LA(1);\n            if (!((_la == LAND) || (_la == LITERAL_WHEN))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameters",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameters" ],
    "fullMethods" : [ "public final FormalParametersContext formalParameters() throws RecognitionException {\n    FormalParametersContext _localctx = new FormalParametersContext(_ctx, getState());\n    enterRule(_localctx, 102, RULE_formalParameters);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(754);\n            match(LPAREN);\n            setState(756);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((((_la & (~0x3f)) == 0) && (((1L << _la) & 575898352105816064L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                {\n                    setState(755);\n                    formalParameterList();\n                }\n            }\n            setState(758);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.implementsClause",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.implementsClause" ],
    "fullMethods" : [ "public final ImplementsClauseContext implementsClause() throws RecognitionException {\n    ImplementsClauseContext _localctx = new ImplementsClauseContext(_ctx, getState());\n    enterRule(_localctx, 34, RULE_implementsClause);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(448);\n            match(LITERAL_IMPLEMENTS);\n            setState(449);\n            typeList();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.multiLambdaParams",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.multiLambdaParams" ],
    "fullMethods" : [ "public final MultiLambdaParamsContext multiLambdaParams() throws RecognitionException {\n    MultiLambdaParamsContext _localctx = new MultiLambdaParamsContext(_ctx, getState());\n    enterRule(_localctx, 224, RULE_multiLambdaParams);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1496);\n            id();\n            setState(1501);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1497);\n                        match(COMMA);\n                        setState(1498);\n                        id();\n                    }\n                }\n                setState(1503);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlComment",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlComment" ],
    "fullMethods" : [ "public final HtmlCommentContext htmlComment() throws RecognitionException {\n    HtmlCommentContext _localctx = new HtmlCommentContext(_ctx, getState());\n    enterRule(_localctx, 106, RULE_htmlComment);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(478);\n            match(HTML_COMMENT_START);\n            setState(479);\n            htmlCommentContent();\n            setState(480);\n            match(HTML_COMMENT_END);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetBody" ],
    "fullMethods" : [ "public final SnippetBodyContext snippetBody() throws RecognitionException {\n    SnippetBodyContext _localctx = new SnippetBodyContext(_ctx, getState());\n    enterRule(_localctx, 82, RULE_snippetBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(402);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            do {\n                {\n                    {\n                        setState(401);\n                        match(TEXT);\n                    }\n                }\n                setState(404);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } while (_la == TEXT );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValue",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValue" ],
    "fullMethods" : [ "public final ElementValueContext elementValue() throws RecognitionException {\n    ElementValueContext _localctx = new ElementValueContext(_ctx, getState());\n    enterRule(_localctx, 130, RULE_elementValue);\n    try {\n        setState(855);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 87, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(852);\n                    expression();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(853);\n                    annotation();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(854);\n                    elementValueArrayInitializer();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arguments" ],
    "fullMethods" : [ "public final ArgumentsContext arguments() throws RecognitionException {\n    ArgumentsContext _localctx = new ArgumentsContext(_ctx, getState());\n    enterRule(_localctx, 266, RULE_arguments);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1695);\n            match(LPAREN);\n            setState(1697);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                {\n                    setState(1696);\n                    expressionList();\n                }\n            }\n            setState(1699);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponents",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponents" ],
    "fullMethods" : [ "public final RecordComponentsContext recordComponents() throws RecognitionException {\n    RecordComponentsContext _localctx = new RecordComponentsContext(_ctx, getState());\n    enterRule(_localctx, 20, RULE_recordComponents);\n    int _la;\n    try {\n        int _alt;\n        setState(412);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 21, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(399);\n                    recordComponent();\n                    setState(404);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 19, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(400);\n                                    match(COMMA);\n                                    setState(401);\n                                    recordComponent();\n                                }\n                            }\n                        }\n                        setState(406);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 19, _ctx);\n                    } \n                    setState(409);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == COMMA) {\n                        {\n                            setState(407);\n                            match(COMMA);\n                            setState(408);\n                            lastRecordComponent();\n                        }\n                    }\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(411);\n                    lastRecordComponent();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumDeclaration" ],
    "fullMethods" : [ "public final EnumDeclarationContext enumDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    EnumDeclarationContext _localctx = new EnumDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 46, RULE_enumDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(487);\n            match(ENUM);\n            setState(488);\n            id();\n            setState(490);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_IMPLEMENTS) {\n                {\n                    setState(489);\n                    implementsClause();\n                }\n            }\n            setState(492);\n            enumBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.types",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.types" ],
    "fullMethods" : [ "public final TypesContext types(List<ModifierContext> mods) throws RecognitionException {\n    TypesContext _localctx = new TypesContext(_ctx, getState(), mods);\n    enterRule(_localctx, 8, RULE_types);\n    try {\n        setState(343);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LITERAL_CLASS :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(338);\n                    classDeclaration(mods);\n                }\n                break;\n            case ENUM :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(339);\n                    enumDeclaration(mods);\n                }\n                break;\n            case LITERAL_INTERFACE :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(340);\n                    interfaceDeclaration(mods);\n                }\n                break;\n            case AT :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(341);\n                    annotationTypeDeclaration(mods);\n                }\n                break;\n            case LITERAL_RECORD :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(342);\n                    recordDeclaration(mods);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.caseConstant",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.caseConstant" ],
    "fullMethods" : [ "public final CaseConstantContext caseConstant() throws RecognitionException {\n    CaseConstantContext _localctx = new CaseConstantContext(_ctx, getState());\n    enterRule(_localctx, 202, RULE_caseConstant);\n    try {\n        setState(1260);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 144, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1257);\n                    pattern();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1258);\n                    expression();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1259);\n                    match(LITERAL_DEFAULT);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.reference",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.reference" ],
    "fullMethods" : [ "public final ReferenceContext reference() throws RecognitionException {\n    ReferenceContext _localctx = new ReferenceContext(_ctx, getState());\n    enterRule(_localctx, 66, RULE_reference);\n    try {\n        setState(350);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case HASH :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(338);\n                    match(HASH);\n                    setState(339);\n                    memberReference();\n                }\n                break;\n            case IDENTIFIER :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(343);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 43, _ctx)) {\n                        case 1 :\n                            {\n                                setState(340);\n                                ((ReferenceContext) (_localctx)).module = qualifiedName();\n                                setState(341);\n                                match(SLASH);\n                            }\n                            break;\n                    }\n                    setState(345);\n                    ((ReferenceContext) (_localctx)).type = typeName();\n                    setState(348);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 44, _ctx)) {\n                        case 1 :\n                            {\n                                setState(346);\n                                match(HASH);\n                                setState(347);\n                                memberReference();\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.constructorBlock",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.constructorBlock" ],
    "fullMethods" : [ "public final ConstructorBlockContext constructorBlock() throws RecognitionException {\n    ConstructorBlockContext _localctx = new ConstructorBlockContext(_ctx, getState());\n    enterRule(_localctx, 148, RULE_constructorBlock);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(946);\n            match(LCURLY);\n            setState(948);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 103, _ctx)) {\n                case 1 :\n                    {\n                        setState(947);\n                        explicitConstructorInvocation();\n                    }\n                    break;\n            }\n            setState(953);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 104, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(950);\n                            blockStatement();\n                        }\n                    }\n                }\n                setState(955);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 104, _ctx);\n            } \n            setState(956);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTagContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTagContent" ],
    "fullMethods" : [ "public final InlineTagContentContext inlineTagContent() throws RecognitionException {\n    InlineTagContentContext _localctx = new InlineTagContentContext(_ctx, getState());\n    enterRule(_localctx, 40, RULE_inlineTagContent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(270);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case CODE :\n                    {\n                        setState(258);\n                        codeInlineTag();\n                    }\n                    break;\n                case LINK :\n                    {\n                        setState(259);\n                        linkInlineTag();\n                    }\n                    break;\n                case LINKPLAIN :\n                    {\n                        setState(260);\n                        linkPlainInlineTag();\n                    }\n                    break;\n                case VALUE :\n                    {\n                        setState(261);\n                        valueInlineTag();\n                    }\n                    break;\n                case INHERIT_DOC :\n                    {\n                        setState(262);\n                        inheritDocInlineTag();\n                    }\n                    break;\n                case SUMMARY :\n                    {\n                        setState(263);\n                        summaryInlineTag();\n                    }\n                    break;\n                case SYSTEM_PROPERTY :\n                    {\n                        setState(264);\n                        systemPropertyInlineTag();\n                    }\n                    break;\n                case INDEX :\n                    {\n                        setState(265);\n                        indexInlineTag();\n                    }\n                    break;\n                case RETURN :\n                    {\n                        setState(266);\n                        returnInlineTag();\n                    }\n                    break;\n                case LITERAL :\n                    {\n                        setState(267);\n                        literalInlineTag();\n                    }\n                    break;\n                case SNIPPET :\n                    {\n                        setState(268);\n                        snippetInlineTag();\n                    }\n                    break;\n                case CUSTOM_NAME :\n                    {\n                        setState(269);\n                        customInlineTag();\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameter",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameter" ],
    "fullMethods" : [ "public final FormalParameterContext formalParameter() throws RecognitionException {\n    FormalParameterContext _localctx = new FormalParameterContext(_ctx, getState());\n    enterRule(_localctx, 106, RULE_formalParameter);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(778);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 79, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(775);\n                            ((FormalParameterContext) (_localctx)).variableModifier = variableModifier();\n                            ((FormalParameterContext) (_localctx)).mods.add(((FormalParameterContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(780);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 79, _ctx);\n            } \n            setState(781);\n            ((FormalParameterContext) (_localctx)).type = typeType(true);\n            setState(782);\n            variableDeclaratorId(_localctx.mods, _localctx.type);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.systemPropertyInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.systemPropertyInlineTag" ],
    "fullMethods" : [ "public final SystemPropertyInlineTagContext systemPropertyInlineTag() throws RecognitionException {\n    SystemPropertyInlineTagContext _localctx = new SystemPropertyInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 54, RULE_systemPropertyInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(304);\n            ((SystemPropertyInlineTagContext) (_localctx)).tagName = match(SYSTEM_PROPERTY);\n            setState(306);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == IDENTIFIER) {\n                {\n                    setState(305);\n                    ((SystemPropertyInlineTagContext) (_localctx)).propertyName = qualifiedName();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeName" ],
    "fullMethods" : [ "public final TypeNameContext typeName() throws RecognitionException {\n    TypeNameContext _localctx = new TypeNameContext(_ctx, getState());\n    enterRule(_localctx, 68, RULE_typeName);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(352);\n            qualifiedName();\n            setState(354);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 46, _ctx)) {\n                case 1 :\n                    {\n                        setState(353);\n                        typeArguments();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabel",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabel" ],
    "fullMethods" : [ "public final SwitchLabelContext switchLabel() throws RecognitionException {\n    SwitchLabelContext _localctx = new SwitchLabelContext(_ctx, getState());\n    enterRule(_localctx, 198, RULE_switchLabel);\n    try {\n        setState(1247);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LITERAL_CASE :\n                _localctx = new CaseLabelContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1238);\n                    match(LITERAL_CASE);\n                    setState(1239);\n                    caseConstants();\n                    setState(1241);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 140, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1240);\n                                match(COLON);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case LITERAL_DEFAULT :\n                _localctx = new DefaultLabelContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1243);\n                    match(LITERAL_DEFAULT);\n                    setState(1245);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 141, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1244);\n                                match(COLON);\n                            }\n                            break;\n                    }\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponent" ],
    "fullMethods" : [ "public final RecordComponentContext recordComponent() throws RecognitionException {\n    RecordComponentContext _localctx = new RecordComponentContext(_ctx, getState());\n    enterRule(_localctx, 22, RULE_recordComponent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(414);\n            annotations(true);\n            setState(415);\n            ((RecordComponentContext) (_localctx)).type = typeType(true);\n            setState(416);\n            id();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.description",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.description" ],
    "fullMethods" : [ "public final DescriptionContext description() throws RecognitionException {\n    DescriptionContext _localctx = new DescriptionContext(_ctx, getState());\n    enterRule(_localctx, 84, RULE_description);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(410);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(410);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 54, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(406);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(407);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(408);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(409);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(412);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 55, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.linkPlainInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.linkPlainInlineTag" ],
    "fullMethods" : [ "public final LinkPlainInlineTagContext linkPlainInlineTag() throws RecognitionException {\n    LinkPlainInlineTagContext _localctx = new LinkPlainInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 44, RULE_linkPlainInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(279);\n            ((LinkPlainInlineTagContext) (_localctx)).tagName = match(LINKPLAIN);\n            setState(280);\n            reference();\n            setState(282);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 30, _ctx)) {\n                case 1 :\n                    {\n                        setState(281);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetInlineTag" ],
    "fullMethods" : [ "public final SnippetInlineTagContext snippetInlineTag() throws RecognitionException {\n    SnippetInlineTagContext _localctx = new SnippetInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 62, RULE_snippetInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(323);\n            ((SnippetInlineTagContext) (_localctx)).tagName = match(SNIPPET);\n            setState(327);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == SNIPPET_ATTR_NAME) {\n                {\n                    {\n                        setState(324);\n                        ((SnippetInlineTagContext) (_localctx)).snippetAttribute = snippetAttribute();\n                        ((SnippetInlineTagContext) (_localctx)).snippetAttributes.add(((SnippetInlineTagContext) (_localctx)).snippetAttribute);\n                    }\n                }\n                setState(329);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(332);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == COLON) {\n                {\n                    setState(330);\n                    match(COLON);\n                    setState(331);\n                    snippetBody();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumBody" ],
    "fullMethods" : [ "public final EnumBodyContext enumBody() throws RecognitionException {\n    EnumBodyContext _localctx = new EnumBodyContext(_ctx, getState());\n    enterRule(_localctx, 48, RULE_enumBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(494);\n            match(LCURLY);\n            setState(496);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((_la == IDENT) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                {\n                    setState(495);\n                    enumConstants();\n                }\n            }\n            setState(499);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == COMMA) {\n                {\n                    setState(498);\n                    match(COMMA);\n                }\n            }\n            setState(502);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == SEMI) {\n                {\n                    setState(501);\n                    enumBodyDeclarations();\n                }\n            }\n            setState(504);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeBoundType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeBoundType" ],
    "fullMethods" : [ "public final TypeBoundTypeContext typeBoundType() throws RecognitionException {\n    TypeBoundTypeContext _localctx = new TypeBoundTypeContext(_ctx, getState());\n    enterRule(_localctx, 44, RULE_typeBoundType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(479);\n            annotations(false);\n            setState(480);\n            classOrInterfaceOrPrimitiveType();\n            setState(484);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(481);\n                        arrayDeclarator();\n                    }\n                }\n                setState(486);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.deprecatedTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.deprecatedTag" ],
    "fullMethods" : [ "public final DeprecatedTagContext deprecatedTag() throws RecognitionException {\n    DeprecatedTagContext _localctx = new DeprecatedTagContext(_ctx, getState());\n    enterRule(_localctx, 8, RULE_deprecatedTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(152);\n            match(AT_SIGN);\n            setState(153);\n            ((DeprecatedTagContext) (_localctx)).tagName = match(DEPRECATED);\n            setState(155);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 6, _ctx)) {\n                case 1 :\n                    {\n                        setState(154);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayInitializer",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayInitializer" ],
    "fullMethods" : [ "public final ArrayInitializerContext arrayInitializer() throws RecognitionException {\n    ArrayInitializerContext _localctx = new ArrayInitializerContext(_ctx, getState());\n    enterRule(_localctx, 92, RULE_arrayInitializer);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(698);\n            match(LCURLY);\n            setState(707);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((((((_la - 49) & (~0x3f)) == 0) && (((1L << (_la - 49)) & 1101264847871L) != 0)) || ((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 35184372117491L) != 0))) || ((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 4385166758159L) != 0))) {\n                {\n                    setState(699);\n                    variableInitializer();\n                    setState(704);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 65, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(700);\n                                    match(COMMA);\n                                    setState(701);\n                                    variableInitializer();\n                                }\n                            }\n                        }\n                        setState(706);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 65, _ctx);\n                    } \n                }\n            }\n            setState(710);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == COMMA) {\n                {\n                    setState(709);\n                    match(COMMA);\n                }\n            }\n            setState(712);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceExtends",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceExtends" ],
    "fullMethods" : [ "public final InterfaceExtendsContext interfaceExtends() throws RecognitionException {\n    InterfaceExtendsContext _localctx = new InterfaceExtendsContext(_ctx, getState());\n    enterRule(_localctx, 58, RULE_interfaceExtends);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(542);\n            match(EXTENDS_CLAUSE);\n            setState(543);\n            typeList();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumConstants",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.enumConstants" ],
    "fullMethods" : [ "public final EnumConstantsContext enumConstants() throws RecognitionException {\n    EnumConstantsContext _localctx = new EnumConstantsContext(_ctx, getState());\n    enterRule(_localctx, 50, RULE_enumConstants);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(506);\n            enumConstant();\n            setState(511);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 33, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(507);\n                            match(COMMA);\n                            setState(508);\n                            enumConstant();\n                        }\n                    }\n                }\n                setState(513);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 33, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceOrPrimitiveType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceOrPrimitiveType" ],
    "fullMethods" : [ "public final ClassOrInterfaceOrPrimitiveTypeContext classOrInterfaceOrPrimitiveType() throws RecognitionException {\n    ClassOrInterfaceOrPrimitiveTypeContext _localctx = new ClassOrInterfaceOrPrimitiveTypeContext(_ctx, getState());\n    enterRule(_localctx, 256, RULE_classOrInterfaceOrPrimitiveType);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1660);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case IDENT :\n                case AT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        setState(1658);\n                        classOrInterfaceType(false);\n                    }\n                    break;\n                case LITERAL_VOID :\n                case LITERAL_BOOLEAN :\n                case LITERAL_BYTE :\n                case LITERAL_CHAR :\n                case LITERAL_SHORT :\n                case LITERAL_INT :\n                case LITERAL_FLOAT :\n                case LITERAL_LONG :\n                case LITERAL_DOUBLE :\n                    {\n                        setState(1659);\n                        primitiveType();\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledThrow",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledThrow" ],
    "fullMethods" : [ "public final SwitchLabeledThrowContext switchLabeledThrow() throws RecognitionException {\n    SwitchLabeledThrowContext _localctx = new SwitchLabeledThrowContext(_ctx, getState());\n    enterRule(_localctx, 172, RULE_switchLabeledThrow);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1150);\n            switchLabel();\n            setState(1151);\n            match(LAMBDA);\n            setState(1152);\n            match(LITERAL_THROW);\n            setState(1153);\n            expression();\n            setState(1154);\n            match(SEMI);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.summaryInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.summaryInlineTag" ],
    "fullMethods" : [ "public final SummaryInlineTagContext summaryInlineTag() throws RecognitionException {\n    SummaryInlineTagContext _localctx = new SummaryInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 52, RULE_summaryInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(300);\n            ((SummaryInlineTagContext) (_localctx)).tagName = match(SUMMARY);\n            setState(302);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 35, _ctx)) {\n                case 1 :\n                    {\n                        setState(301);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableAccess",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableAccess" ],
    "fullMethods" : [ "public final VariableAccessContext variableAccess() throws RecognitionException {\n    VariableAccessContext _localctx = new VariableAccessContext(_ctx, getState());\n    enterRule(_localctx, 192, RULE_variableAccess);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1218);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 136, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1215);\n                            ((VariableAccessContext) (_localctx)).fieldAccessNoIdent = fieldAccessNoIdent();\n                            ((VariableAccessContext) (_localctx)).accessList.add(((VariableAccessContext) (_localctx)).fieldAccessNoIdent);\n                        }\n                    }\n                }\n                setState(1220);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 136, _ctx);\n            } \n            setState(1223);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case IDENT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        setState(1221);\n                        id();\n                    }\n                    break;\n                case LITERAL_THIS :\n                    {\n                        setState(1222);\n                        match(LITERAL_THIS);\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchParameter",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchParameter" ],
    "fullMethods" : [ "public final CatchParameterContext catchParameter() throws RecognitionException {\n    CatchParameterContext _localctx = new CatchParameterContext(_ctx, getState());\n    enterRule(_localctx, 178, RULE_catchParameter);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1168);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 130, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(1165);\n                            ((CatchParameterContext) (_localctx)).variableModifier = variableModifier();\n                            ((CatchParameterContext) (_localctx)).mods.add(((CatchParameterContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(1170);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 130, _ctx);\n            } \n            setState(1171);\n            catchType();\n            setState(1172);\n            id();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableInitializer",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableInitializer" ],
    "fullMethods" : [ "public final VariableInitializerContext variableInitializer() throws RecognitionException {\n    VariableInitializerContext _localctx = new VariableInitializerContext(_ctx, getState());\n    enterRule(_localctx, 90, RULE_variableInitializer);\n    try {\n        setState(696);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LCURLY :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(694);\n                    arrayInitializer();\n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n            case IDENT :\n            case LPAREN :\n            case LITERAL_THIS :\n            case LITERAL_SUPER :\n            case LITERAL_SWITCH :\n            case PLUS :\n            case MINUS :\n            case INC :\n            case DEC :\n            case BNOT :\n            case LNOT :\n            case LITERAL_TRUE :\n            case LITERAL_FALSE :\n            case LITERAL_NULL :\n            case LITERAL_NEW :\n            case CHAR_LITERAL :\n            case STRING_LITERAL :\n            case AT :\n            case FLOAT_LITERAL :\n            case DOUBLE_LITERAL :\n            case HEX_FLOAT_LITERAL :\n            case HEX_DOUBLE_LITERAL :\n            case LITERAL_RECORD :\n            case TEXT_BLOCK_LITERAL_BEGIN :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n            case DECIMAL_LITERAL_LONG :\n            case DECIMAL_LITERAL :\n            case HEX_LITERAL_LONG :\n            case HEX_LITERAL :\n            case OCT_LITERAL_LONG :\n            case OCT_LITERAL :\n            case BINARY_LITERAL_LONG :\n            case BINARY_LITERAL :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(695);\n                    expression();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classType" ],
    "fullMethods" : [ "public final ClassTypeContext classType() throws RecognitionException {\n    ClassTypeContext _localctx = new ClassTypeContext(_ctx, getState());\n    enterRule(_localctx, 228, RULE_classType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1538);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 177, _ctx)) {\n                case 1 :\n                    {\n                        setState(1535);\n                        classOrInterfaceType(false);\n                        setState(1536);\n                        match(DOT);\n                    }\n                    break;\n            }\n            setState(1540);\n            annotations(false);\n            setState(1541);\n            id();\n            setState(1543);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(1542);\n                    typeArguments();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceTypeExtended",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classOrInterfaceTypeExtended" ],
    "fullMethods" : [ "public final ClassOrInterfaceTypeExtendedContext classOrInterfaceTypeExtended() throws RecognitionException {\n    ClassOrInterfaceTypeExtendedContext _localctx = new ClassOrInterfaceTypeExtendedContext(_ctx, getState());\n    enterRule(_localctx, 96, RULE_classOrInterfaceTypeExtended);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(725);\n            match(DOT);\n            setState(726);\n            annotations(false);\n            setState(727);\n            id();\n            setState(729);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 70, _ctx)) {\n                case 1 :\n                    {\n                        setState(728);\n                        typeArguments();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightHtmlContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightHtmlContent" ],
    "fullMethods" : [ "public final NonTightHtmlContentContext nonTightHtmlContent() throws RecognitionException {\n    NonTightHtmlContentContext _localctx = new NonTightHtmlContentContext(_ctx, getState());\n    enterRule(_localctx, 104, RULE_nonTightHtmlContent);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(474);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(474);\n                            _errHandler.sync(this);\n                            switch (_input.LA(1)) {\n                                case TEXT :\n                                    {\n                                        setState(472);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case JAVADOC_INLINE_TAG_START :\n                                    {\n                                        setState(473);\n                                        inlineTag();\n                                    }\n                                    break;\n                                default :\n                                    throw new NoViableAltException(this);\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(476);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 65, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordBody" ],
    "fullMethods" : [ "public final RecordBodyContext recordBody() throws RecognitionException {\n    RecordBodyContext _localctx = new RecordBodyContext(_ctx, getState());\n    enterRule(_localctx, 26, RULE_recordBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(423);\n            match(LCURLY);\n            setState(427);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028812048202823L) != 0)) || ((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 9007267974217729L) != 0))) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                {\n                    {\n                        setState(424);\n                        recordBodyDeclaration();\n                    }\n                }\n                setState(429);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(430);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeBound",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeBound" ],
    "fullMethods" : [ "public final TypeBoundContext typeBound() throws RecognitionException {\n    TypeBoundContext _localctx = new TypeBoundContext(_ctx, getState());\n    enterRule(_localctx, 42, RULE_typeBound);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(471);\n            typeBoundType();\n            setState(476);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == BAND) {\n                {\n                    {\n                        setState(472);\n                        match(BAND);\n                        setState(473);\n                        typeBoundType();\n                    }\n                }\n                setState(478);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.throwsList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.throwsList" ],
    "fullMethods" : [ "public final ThrowsListContext throwsList() throws RecognitionException {\n    ThrowsListContext _localctx = new ThrowsListContext(_ctx, getState());\n    enterRule(_localctx, 72, RULE_throwsList);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(608);\n            match(LITERAL_THROWS);\n            setState(609);\n            qualifiedNameList();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedNameList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedNameList" ],
    "fullMethods" : [ "public final QualifiedNameListContext qualifiedNameList() throws RecognitionException {\n    QualifiedNameListContext _localctx = new QualifiedNameListContext(_ctx, getState());\n    enterRule(_localctx, 100, RULE_qualifiedNameList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(743);\n            annotations(false);\n            setState(744);\n            qualifiedName();\n            setState(751);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(745);\n                        match(COMMA);\n                        setState(746);\n                        annotations(false);\n                        setState(747);\n                        qualifiedName();\n                    }\n                }\n                setState(753);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclarator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclarator" ],
    "fullMethods" : [ "public final VariableDeclaratorContext variableDeclarator(List<ModifierContext> mods, TypeTypeContext type) throws RecognitionException {\n    VariableDeclaratorContext _localctx = new VariableDeclaratorContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 86, RULE_variableDeclarator);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(669);\n            id();\n            setState(673);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(670);\n                        arrayDeclarator();\n                    }\n                }\n                setState(675);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(678);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == ASSIGN) {\n                {\n                    setState(676);\n                    match(ASSIGN);\n                    setState(677);\n                    variableInitializer();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.indexInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.indexInlineTag" ],
    "fullMethods" : [ "public final IndexInlineTagContext indexInlineTag() throws RecognitionException {\n    IndexInlineTagContext _localctx = new IndexInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 56, RULE_indexInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(308);\n            ((IndexInlineTagContext) (_localctx)).tagName = match(INDEX);\n            setState(309);\n            match(INDEX_TERM);\n            setState(311);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 37, _ctx)) {\n                case 1 :\n                    {\n                        setState(310);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordDeclaration" ],
    "fullMethods" : [ "public final RecordDeclarationContext recordDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    RecordDeclarationContext _localctx = new RecordDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 16, RULE_recordDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(382);\n            match(LITERAL_RECORD);\n            setState(383);\n            id();\n            setState(385);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(384);\n                    typeParameters();\n                }\n            }\n            setState(387);\n            recordComponentsList();\n            setState(389);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_IMPLEMENTS) {\n                {\n                    setState(388);\n                    implementsClause();\n                }\n            }\n            setState(391);\n            recordBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceMemberDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceMemberDeclaration" ],
    "fullMethods" : [ "public final InterfaceMemberDeclarationContext interfaceMemberDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    InterfaceMemberDeclarationContext _localctx = new InterfaceMemberDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 80, RULE_interfaceMemberDeclaration);\n    try {\n        setState(642);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 54, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(635);\n                    fieldDeclaration(mods);\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(636);\n                    recordDeclaration(mods);\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(637);\n                    interfaceMethodDeclaration(mods);\n                }\n                break;\n            case 4 :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(638);\n                    interfaceDeclaration(mods);\n                }\n                break;\n            case 5 :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(639);\n                    annotationTypeDeclaration(mods);\n                }\n                break;\n            case 6 :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(640);\n                    classDeclaration(mods);\n                }\n                break;\n            case 7 :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(641);\n                    enumDeclaration(mods);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledRule",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledRule" ],
    "fullMethods" : [ "public final SwitchLabeledRuleContext switchLabeledRule() throws RecognitionException {\n    SwitchLabeledRuleContext _localctx = new SwitchLabeledRuleContext(_ctx, getState());\n    enterRule(_localctx, 166, RULE_switchLabeledRule);\n    try {\n        setState(1139);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 129, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1136);\n                    switchLabeledExpression();\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1137);\n                    switchLabeledBlock();\n                }\n                break;\n            case 3 :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1138);\n                    switchLabeledThrow();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledExpression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledExpression" ],
    "fullMethods" : [ "public final SwitchLabeledExpressionContext switchLabeledExpression() throws RecognitionException {\n    SwitchLabeledExpressionContext _localctx = new SwitchLabeledExpressionContext(_ctx, getState());\n    enterRule(_localctx, 168, RULE_switchLabeledExpression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1141);\n            switchLabel();\n            setState(1142);\n            match(LAMBDA);\n            setState(1143);\n            expression();\n            setState(1144);\n            match(SEMI);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inlineTag" ],
    "fullMethods" : [ "public final InlineTagContext inlineTag() throws RecognitionException {\n    InlineTagContext _localctx = new InlineTagContext(_ctx, getState());\n    enterRule(_localctx, 38, RULE_inlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(254);\n            match(JAVADOC_INLINE_TAG_START);\n            setState(255);\n            inlineTagContent();\n            setState(256);\n            match(JAVADOC_INLINE_TAG_END);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotations",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotations" ],
    "fullMethods" : [ "public final AnnotationsContext annotations(boolean createImaginaryNode) throws RecognitionException {\n    AnnotationsContext _localctx = new AnnotationsContext(_ctx, getState(), createImaginaryNode);\n    enterRule(_localctx, 122, RULE_annotations);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(827);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 83, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(824);\n                            ((AnnotationsContext) (_localctx)).annotation = annotation();\n                            ((AnnotationsContext) (_localctx)).anno.add(((AnnotationsContext) (_localctx)).annotation);\n                        }\n                    }\n                }\n                setState(829);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 83, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlTagStart",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlTagStart" ],
    "fullMethods" : [ "public final HtmlTagStartContext htmlTagStart() throws RecognitionException {\n    HtmlTagStartContext _localctx = new HtmlTagStartContext(_ctx, getState());\n    enterRule(_localctx, 96, RULE_htmlTagStart);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(444);\n            match(TAG_OPEN);\n            setState(445);\n            match(TAG_NAME);\n            setState(449);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == TAG_ATTR_NAME) {\n                {\n                    {\n                        setState(446);\n                        ((HtmlTagStartContext) (_localctx)).htmlAttribute = htmlAttribute();\n                        ((HtmlTagStartContext) (_localctx)).htmlAttributes.add(((HtmlTagStartContext) (_localctx)).htmlAttribute);\n                    }\n                }\n                setState(451);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(452);\n            match(TAG_CLOSE);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.literal",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.literal" ],
    "fullMethods" : [ "public final LiteralContext literal() throws RecognitionException {\n    LiteralContext _localctx = new LiteralContext(_ctx, getState());\n    enterRule(_localctx, 114, RULE_literal);\n    try {\n        setState(814);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case DECIMAL_LITERAL_LONG :\n            case DECIMAL_LITERAL :\n            case HEX_LITERAL_LONG :\n            case HEX_LITERAL :\n            case OCT_LITERAL_LONG :\n            case OCT_LITERAL :\n            case BINARY_LITERAL_LONG :\n            case BINARY_LITERAL :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(806);\n                    integerLiteral();\n                }\n                break;\n            case FLOAT_LITERAL :\n            case DOUBLE_LITERAL :\n            case HEX_FLOAT_LITERAL :\n            case HEX_DOUBLE_LITERAL :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(807);\n                    floatLiteral();\n                }\n                break;\n            case TEXT_BLOCK_LITERAL_BEGIN :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(808);\n                    textBlockLiteral();\n                }\n                break;\n            case CHAR_LITERAL :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(809);\n                    match(CHAR_LITERAL);\n                }\n                break;\n            case STRING_LITERAL :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(810);\n                    match(STRING_LITERAL);\n                }\n                break;\n            case LITERAL_TRUE :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(811);\n                    match(LITERAL_TRUE);\n                }\n                break;\n            case LITERAL_FALSE :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(812);\n                    match(LITERAL_FALSE);\n                }\n                break;\n            case LITERAL_NULL :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(813);\n                    match(LITERAL_NULL);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlock",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchBlock" ],
    "fullMethods" : [ "public final SwitchBlockContext switchBlock() throws RecognitionException {\n    SwitchBlockContext _localctx = new SwitchBlockContext(_ctx, getState());\n    enterRule(_localctx, 164, RULE_switchBlock);\n    int _la;\n    try {\n        int _alt;\n        setState(1134);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 128, _ctx)) {\n            case 1 :\n                _localctx = new SwitchRulesContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1118);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    do {\n                        {\n                            {\n                                setState(1117);\n                                switchLabeledRule();\n                            }\n                        }\n                        setState(1120);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } while ((_la == LITERAL_CASE) || (_la == LITERAL_DEFAULT) );\n                }\n                break;\n            case 2 :\n                _localctx = new SwitchBlocksContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1125);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 126, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(1122);\n                                    ((SwitchBlocksContext) (_localctx)).switchBlockStatementGroup = switchBlockStatementGroup();\n                                    ((SwitchBlocksContext) (_localctx)).groups.add(((SwitchBlocksContext) (_localctx)).switchBlockStatementGroup);\n                                }\n                            }\n                        }\n                        setState(1127);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 126, _ctx);\n                    } \n                    setState(1131);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LITERAL_CASE) || (_la == LITERAL_DEFAULT)) {\n                        {\n                            {\n                                setState(1128);\n                                ((SwitchBlocksContext) (_localctx)).switchLabel = switchLabel();\n                                ((SwitchBlocksContext) (_localctx)).emptyLabels.add(((SwitchBlocksContext) (_localctx)).switchLabel);\n                            }\n                        }\n                        setState(1133);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeList" ],
    "fullMethods" : [ "public final TypeListContext typeList() throws RecognitionException {\n    TypeListContext _localctx = new TypeListContext(_ctx, getState());\n    enterRule(_localctx, 252, RULE_typeList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1642);\n            typeType(false);\n            setState(1647);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1643);\n                        match(COMMA);\n                        setState(1644);\n                        typeType(false);\n                    }\n                }\n                setState(1649);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guardedPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.guardedPattern" ],
    "fullMethods" : [ "public final GuardedPatternContext guardedPattern() throws RecognitionException {\n    GuardedPatternContext _localctx = new GuardedPatternContext(_ctx, getState());\n    enterRule(_localctx, 272, RULE_guardedPattern);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1708);\n            primaryPattern();\n            setState(1709);\n            guard();\n            setState(1710);\n            expression();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.importDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.importDeclaration" ],
    "fullMethods" : [ "public final ImportDeclarationContext importDeclaration() throws RecognitionException {\n    ImportDeclarationContext _localctx = new ImportDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 4, RULE_importDeclaration);\n    int _la;\n    try {\n        setState(322);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case IMPORT :\n                _localctx = new ImportDecContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(310);\n                    match(IMPORT);\n                    setState(312);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LITERAL_STATIC) {\n                        {\n                            setState(311);\n                            match(LITERAL_STATIC);\n                        }\n                    }\n                    setState(314);\n                    qualifiedName();\n                    setState(317);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == DOT) {\n                        {\n                            setState(315);\n                            match(DOT);\n                            setState(316);\n                            match(STAR);\n                        }\n                    }\n                    setState(319);\n                    match(SEMI);\n                }\n                break;\n            case SEMI :\n                _localctx = new SingleSemiImportContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(321);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.parExpression",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.parExpression" ],
    "fullMethods" : [ "public final ParExpressionContext parExpression() throws RecognitionException {\n    ParExpressionContext _localctx = new ParExpressionContext(_ctx, getState());\n    enterRule(_localctx, 212, RULE_parExpression);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1303);\n            match(LPAREN);\n            setState(1304);\n            expression();\n            setState(1305);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.selfClosingElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.selfClosingElement" ],
    "fullMethods" : [ "public final SelfClosingElementContext selfClosingElement() throws RecognitionException {\n    SelfClosingElementContext _localctx = new SelfClosingElementContext(_ctx, getState());\n    enterRule(_localctx, 94, RULE_selfClosingElement);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(434);\n            match(TAG_OPEN);\n            setState(435);\n            match(TAG_NAME);\n            setState(439);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == TAG_ATTR_NAME) {\n                {\n                    {\n                        setState(436);\n                        ((SelfClosingElementContext) (_localctx)).htmlAttribute = htmlAttribute();\n                        ((SelfClosingElementContext) (_localctx)).htmlAttributes.add(((SelfClosingElementContext) (_localctx)).htmlAttribute);\n                    }\n                }\n                setState(441);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(442);\n            match(TAG_SLASH_CLOSE);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.customInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.customInlineTag" ],
    "fullMethods" : [ "public final CustomInlineTagContext customInlineTag() throws RecognitionException {\n    CustomInlineTagContext _localctx = new CustomInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 64, RULE_customInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(334);\n            ((CustomInlineTagContext) (_localctx)).tagName = match(CUSTOM_NAME);\n            setState(336);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 42, _ctx)) {\n                case 1 :\n                    {\n                        setState(335);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameterList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.formalParameterList" ],
    "fullMethods" : [ "public final FormalParameterListContext formalParameterList() throws RecognitionException {\n    FormalParameterListContext _localctx = new FormalParameterListContext(_ctx, getState());\n    enterRule(_localctx, 104, RULE_formalParameterList);\n    int _la;\n    try {\n        int _alt;\n        setState(773);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 78, _ctx)) {\n            case 1 :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(760);\n                    formalParameter();\n                    setState(765);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 76, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(761);\n                                    match(COMMA);\n                                    setState(762);\n                                    formalParameter();\n                                }\n                            }\n                        }\n                        setState(767);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 76, _ctx);\n                    } \n                    setState(770);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == COMMA) {\n                        {\n                            setState(768);\n                            match(COMMA);\n                            setState(769);\n                            lastFormalParameter();\n                        }\n                    }\n                }\n                break;\n            case 2 :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(772);\n                    lastFormalParameter();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeUpperBounds",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeUpperBounds" ],
    "fullMethods" : [ "public final TypeUpperBoundsContext typeUpperBounds() throws RecognitionException {\n    TypeUpperBoundsContext _localctx = new TypeUpperBoundsContext(_ctx, getState());\n    enterRule(_localctx, 40, RULE_typeUpperBounds);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(467);\n            match(EXTENDS_CLAUSE);\n            setState(468);\n            annotations(false);\n            setState(469);\n            typeBound();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.hiddenTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.hiddenTag" ],
    "fullMethods" : [ "public final HiddenTagContext hiddenTag() throws RecognitionException {\n    HiddenTagContext _localctx = new HiddenTagContext(_ctx, getState());\n    enterRule(_localctx, 24, RULE_hiddenTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(211);\n            match(AT_SIGN);\n            setState(212);\n            ((HiddenTagContext) (_localctx)).tagName = match(LITERAL_HIDDEN);\n            setState(214);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 19, _ctx)) {\n                case 1 :\n                    {\n                        setState(213);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr", "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.expr" ],
    "fullMethods" : [ "public final ExprContext expr() throws RecognitionException {\n    return expr(0);\n}", "private ExprContext expr(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExprContext _localctx = new ExprContext(_ctx, _parentState);\n    ExprContext _prevctx = _localctx;\n    int _startState = 218;\n    enterRecursionRule(_localctx, 218, RULE_expr, _p);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1359);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 158, _ctx)) {\n                case 1 :\n                    {\n                        _localctx = new PrimaryExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1318);\n                        primary();\n                    }\n                    break;\n                case 2 :\n                    {\n                        _localctx = new SimpleMethodCallContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1319);\n                        id();\n                        setState(1320);\n                        match(LPAREN);\n                        setState(1322);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                            {\n                                setState(1321);\n                                expressionList();\n                            }\n                        }\n                        setState(1324);\n                        match(RPAREN);\n                    }\n                    break;\n                case 3 :\n                    {\n                        _localctx = new NewExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1326);\n                        match(LITERAL_NEW);\n                        setState(1327);\n                        creator();\n                    }\n                    break;\n                case 4 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1328);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 51L) != 0))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1329);\n                        expr(20);\n                    }\n                    break;\n                case 5 :\n                    {\n                        _localctx = new PrefixContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1330);\n                        ((PrefixContext) (_localctx)).prefix = _input.LT(1);\n                        _la = _input.LA(1);\n                        if (!((_la == BNOT) || (_la == LNOT))) {\n                            ((PrefixContext) (_localctx)).prefix = ((Token) (_errHandler.recoverInline(this)));\n                        } else {\n                            if (_input.LA(1) == Token.EOF)\n                                matchedEOF = true;\n\n                            _errHandler.reportMatch(this);\n                            consume();\n                        }\n                        setState(1331);\n                        expr(19);\n                    }\n                    break;\n                case 6 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1332);\n                        typeType(false);\n                        setState(1333);\n                        match(DOUBLE_COLON);\n                        setState(1335);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1334);\n                                typeArguments();\n                            }\n                        }\n                        setState(1339);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case IDENT :\n                            case LITERAL_RECORD :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                                {\n                                    setState(1337);\n                                    id();\n                                }\n                                break;\n                            case LITERAL_NEW :\n                                {\n                                    setState(1338);\n                                    match(LITERAL_NEW);\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n                case 7 :\n                    {\n                        _localctx = new MethodRefContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1341);\n                        classType();\n                        setState(1342);\n                        match(DOUBLE_COLON);\n                        setState(1344);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        if (_la == LT) {\n                            {\n                                setState(1343);\n                                typeArguments();\n                            }\n                        }\n                        setState(1346);\n                        match(LITERAL_NEW);\n                    }\n                    break;\n                case 8 :\n                    {\n                        _localctx = new CastExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1348);\n                        match(LPAREN);\n                        setState(1349);\n                        typeCastParameters();\n                        setState(1350);\n                        match(RPAREN);\n                        setState(1351);\n                        expr(15);\n                    }\n                    break;\n                case 9 :\n                    {\n                        _localctx = new LambdaExpContext(_localctx);\n                        _ctx = _localctx;\n                        _prevctx = _localctx;\n                        setState(1353);\n                        lambdaParameters();\n                        setState(1354);\n                        match(LAMBDA);\n                        setState(1357);\n                        _errHandler.sync(this);\n                        switch (_input.LA(1)) {\n                            case LITERAL_VOID :\n                            case LITERAL_BOOLEAN :\n                            case LITERAL_BYTE :\n                            case LITERAL_CHAR :\n                            case LITERAL_SHORT :\n                            case LITERAL_INT :\n                            case LITERAL_FLOAT :\n                            case LITERAL_LONG :\n                            case LITERAL_DOUBLE :\n                            case IDENT :\n                            case LPAREN :\n                            case LITERAL_THIS :\n                            case LITERAL_SUPER :\n                            case LITERAL_SWITCH :\n                            case PLUS :\n                            case MINUS :\n                            case INC :\n                            case DEC :\n                            case BNOT :\n                            case LNOT :\n                            case LITERAL_TRUE :\n                            case LITERAL_FALSE :\n                            case LITERAL_NULL :\n                            case LITERAL_NEW :\n                            case CHAR_LITERAL :\n                            case STRING_LITERAL :\n                            case AT :\n                            case FLOAT_LITERAL :\n                            case DOUBLE_LITERAL :\n                            case HEX_FLOAT_LITERAL :\n                            case HEX_DOUBLE_LITERAL :\n                            case LITERAL_RECORD :\n                            case TEXT_BLOCK_LITERAL_BEGIN :\n                            case LITERAL_YIELD :\n                            case LITERAL_NON_SEALED :\n                            case LITERAL_SEALED :\n                            case LITERAL_PERMITS :\n                            case LITERAL_WHEN :\n                            case LITERAL_UNDERSCORE :\n                            case DECIMAL_LITERAL_LONG :\n                            case DECIMAL_LITERAL :\n                            case HEX_LITERAL_LONG :\n                            case HEX_LITERAL :\n                            case OCT_LITERAL_LONG :\n                            case OCT_LITERAL :\n                            case BINARY_LITERAL_LONG :\n                            case BINARY_LITERAL :\n                                {\n                                    setState(1355);\n                                    expr(0);\n                                }\n                                break;\n                            case LCURLY :\n                                {\n                                    setState(1356);\n                                    block();\n                                }\n                                break;\n                            default :\n                                throw new NoViableAltException(this);\n                        }\n                    }\n                    break;\n            }\n            _ctx.stop = _input.LT(-1);\n            setState(1473);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    if (_parseListeners != null)\n                        triggerExitRuleEvent();\n\n                    _prevctx = _localctx;\n                    {\n                        setState(1471);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 168, _ctx)) {\n                            case 1 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1361);\n                                    if (!precpred(_ctx, 14))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 14)\");\n\n                                    setState(1362);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!(((_la == STAR) || (_la == DIV)) || (_la == MOD))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1363);\n                                    expr(15);\n                                }\n                                break;\n                            case 2 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1364);\n                                    if (!precpred(_ctx, 13))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 13)\");\n\n                                    setState(1365);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == PLUS) || (_la == MINUS))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1366);\n                                    expr(14);\n                                }\n                                break;\n                            case 3 :\n                                {\n                                    _localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1367);\n                                    if (!precpred(_ctx, 12))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 12)\");\n\n                                    setState(1375);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 159, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1368);\n                                                match(LT);\n                                                setState(1369);\n                                                match(LT);\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1370);\n                                                match(GT);\n                                                setState(1371);\n                                                match(GT);\n                                                setState(1372);\n                                                match(GT);\n                                            }\n                                            break;\n                                        case 3 :\n                                            {\n                                                setState(1373);\n                                                match(GT);\n                                                setState(1374);\n                                                match(GT);\n                                            }\n                                            break;\n                                    }\n                                    setState(1377);\n                                    expr(13);\n                                }\n                                break;\n                            case 4 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1378);\n                                    if (!precpred(_ctx, 10))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n\n                                    setState(1379);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 15L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1380);\n                                    expr(11);\n                                }\n                                break;\n                            case 5 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1381);\n                                    if (!precpred(_ctx, 9))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n\n                                    setState(1382);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == NOT_EQUAL) || (_la == EQUAL))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1383);\n                                    expr(10);\n                                }\n                                break;\n                            case 6 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1384);\n                                    if (!precpred(_ctx, 8))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n\n                                    setState(1385);\n                                    ((BinOpContext) (_localctx)).bop = match(BAND);\n                                    setState(1386);\n                                    expr(9);\n                                }\n                                break;\n                            case 7 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1387);\n                                    if (!precpred(_ctx, 7))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n\n                                    setState(1388);\n                                    ((BinOpContext) (_localctx)).bop = match(BXOR);\n                                    setState(1389);\n                                    expr(8);\n                                }\n                                break;\n                            case 8 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1390);\n                                    if (!precpred(_ctx, 6))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n\n                                    setState(1391);\n                                    ((BinOpContext) (_localctx)).bop = match(BOR);\n                                    setState(1392);\n                                    expr(7);\n                                }\n                                break;\n                            case 9 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1393);\n                                    if (!precpred(_ctx, 5))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\n                                    setState(1394);\n                                    ((BinOpContext) (_localctx)).bop = match(LAND);\n                                    setState(1395);\n                                    expr(6);\n                                }\n                                break;\n                            case 10 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1396);\n                                    if (!precpred(_ctx, 4))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\n                                    setState(1397);\n                                    ((BinOpContext) (_localctx)).bop = match(LOR);\n                                    setState(1398);\n                                    expr(5);\n                                }\n                                break;\n                            case 11 :\n                                {\n                                    _localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1399);\n                                    if (!precpred(_ctx, 3))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n\n                                    setState(1400);\n                                    ((TernaryOpContext) (_localctx)).bop = match(QUESTION);\n                                    setState(1401);\n                                    expr(0);\n                                    setState(1402);\n                                    match(COLON);\n                                    setState(1403);\n                                    expr(3);\n                                }\n                                break;\n                            case 12 :\n                                {\n                                    _localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1405);\n                                    if (!precpred(_ctx, 2))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n\n                                    setState(1406);\n                                    ((BinOpContext) (_localctx)).bop = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((((_la - 80) & (~0x3f)) == 0) && (((1L << (_la - 80)) & 536608769L) != 0))) {\n                                        ((BinOpContext) (_localctx)).bop = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                    setState(1407);\n                                    expr(2);\n                                }\n                                break;\n                            case 13 :\n                                {\n                                    _localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1408);\n                                    if (!precpred(_ctx, 30))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 30)\");\n\n                                    setState(1409);\n                                    ((RefOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1410);\n                                    id();\n                                }\n                                break;\n                            case 14 :\n                                {\n                                    _localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1411);\n                                    if (!precpred(_ctx, 29))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 29)\");\n\n                                    setState(1412);\n                                    ((MethodCallContext) (_localctx)).bop = match(DOT);\n                                    setState(1413);\n                                    id();\n                                    setState(1414);\n                                    match(LPAREN);\n                                    setState(1416);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1415);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1418);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 15 :\n                                {\n                                    _localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1420);\n                                    if (!precpred(_ctx, 28))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 28)\");\n\n                                    setState(1421);\n                                    ((ThisExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1422);\n                                    match(LITERAL_THIS);\n                                }\n                                break;\n                            case 16 :\n                                {\n                                    _localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1423);\n                                    if (!precpred(_ctx, 27))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 27)\");\n\n                                    setState(1424);\n                                    ((InitExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1425);\n                                    match(LITERAL_NEW);\n                                    setState(1427);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1426);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1429);\n                                    innerCreator();\n                                }\n                                break;\n                            case 17 :\n                                {\n                                    _localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1430);\n                                    if (!precpred(_ctx, 26))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 26)\");\n\n                                    setState(1431);\n                                    ((SuperExpContext) (_localctx)).bop = match(DOT);\n                                    setState(1433);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1432);\n                                            nonWildcardTypeArguments();\n                                        }\n                                    }\n                                    setState(1435);\n                                    match(LITERAL_SUPER);\n                                    setState(1437);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 163, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1436);\n                                                superSuffix();\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                            case 18 :\n                                {\n                                    _localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1439);\n                                    if (!precpred(_ctx, 25))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 25)\");\n\n                                    setState(1440);\n                                    ((InvOpContext) (_localctx)).bop = match(DOT);\n                                    setState(1441);\n                                    nonWildcardTypeArguments();\n                                    setState(1442);\n                                    id();\n                                    setState(1443);\n                                    match(LPAREN);\n                                    setState(1445);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                                        {\n                                            setState(1444);\n                                            expressionList();\n                                        }\n                                    }\n                                    setState(1447);\n                                    match(RPAREN);\n                                }\n                                break;\n                            case 19 :\n                                {\n                                    _localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1449);\n                                    if (!precpred(_ctx, 24))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 24)\");\n\n                                    setState(1450);\n                                    match(LBRACK);\n                                    setState(1451);\n                                    expr(0);\n                                    setState(1452);\n                                    match(RBRACK);\n                                }\n                                break;\n                            case 20 :\n                                {\n                                    _localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1454);\n                                    if (!precpred(_ctx, 21))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 21)\");\n\n                                    setState(1455);\n                                    ((PostfixContext) (_localctx)).postfix = _input.LT(1);\n                                    _la = _input.LA(1);\n                                    if (!((_la == INC) || (_la == DEC))) {\n                                        ((PostfixContext) (_localctx)).postfix = ((Token) (_errHandler.recoverInline(this)));\n                                    } else {\n                                        if (_input.LA(1) == Token.EOF)\n                                            matchedEOF = true;\n\n                                        _errHandler.reportMatch(this);\n                                        consume();\n                                    }\n                                }\n                                break;\n                            case 21 :\n                                {\n                                    _localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1456);\n                                    if (!precpred(_ctx, 18))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 18)\");\n\n                                    setState(1457);\n                                    match(DOUBLE_COLON);\n                                    setState(1459);\n                                    _errHandler.sync(this);\n                                    _la = _input.LA(1);\n                                    if (_la == LT) {\n                                        {\n                                            setState(1458);\n                                            typeArguments();\n                                        }\n                                    }\n                                    setState(1463);\n                                    _errHandler.sync(this);\n                                    switch (_input.LA(1)) {\n                                        case IDENT :\n                                        case LITERAL_RECORD :\n                                        case LITERAL_YIELD :\n                                        case LITERAL_NON_SEALED :\n                                        case LITERAL_SEALED :\n                                        case LITERAL_PERMITS :\n                                        case LITERAL_WHEN :\n                                        case LITERAL_UNDERSCORE :\n                                            {\n                                                setState(1461);\n                                                id();\n                                            }\n                                            break;\n                                        case LITERAL_NEW :\n                                            {\n                                                setState(1462);\n                                                match(LITERAL_NEW);\n                                            }\n                                            break;\n                                        default :\n                                            throw new NoViableAltException(this);\n                                    }\n                                }\n                                break;\n                            case 22 :\n                                {\n                                    _localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));\n                                    pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                    setState(1465);\n                                    if (!precpred(_ctx, 11))\n                                        throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n\n                                    setState(1466);\n                                    ((InstanceOfExpContext) (_localctx)).bop = match(LITERAL_INSTANCEOF);\n                                    setState(1469);\n                                    _errHandler.sync(this);\n                                    switch (getInterpreter().adaptivePredict(_input, 167, _ctx)) {\n                                        case 1 :\n                                            {\n                                                setState(1467);\n                                                primaryPattern();\n                                            }\n                                            break;\n                                        case 2 :\n                                            {\n                                                setState(1468);\n                                                typeType(true);\n                                            }\n                                            break;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                }\n                setState(1475);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 169, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inheritDocInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.inheritDocInlineTag" ],
    "fullMethods" : [ "public final InheritDocInlineTagContext inheritDocInlineTag() throws RecognitionException {\n    InheritDocInlineTagContext _localctx = new InheritDocInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 50, RULE_inheritDocInlineTag);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(296);\n            ((InheritDocInlineTagContext) (_localctx)).tagName = match(INHERIT_DOC);\n            setState(298);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((_la == IDENTIFIER) || (_la == HASH)) {\n                {\n                    setState(297);\n                    reference();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resourceSpecification",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.resourceSpecification" ],
    "fullMethods" : [ "public final ResourceSpecificationContext resourceSpecification() throws RecognitionException {\n    ResourceSpecificationContext _localctx = new ResourceSpecificationContext(_ctx, getState());\n    enterRule(_localctx, 184, RULE_resourceSpecification);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1185);\n            match(LPAREN);\n            setState(1186);\n            resources();\n            setState(1188);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == SEMI) {\n                {\n                    setState(1187);\n                    match(SEMI);\n                }\n            }\n            setState(1190);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetAttribute",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.snippetAttribute" ],
    "fullMethods" : [ "public final SnippetAttributeContext snippetAttribute() throws RecognitionException {\n    SnippetAttributeContext _localctx = new SnippetAttributeContext(_ctx, getState());\n    enterRule(_localctx, 80, RULE_snippetAttribute);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(397);\n            match(SNIPPET_ATTR_NAME);\n            setState(398);\n            match(EQUALS);\n            setState(399);\n            match(ATTRIBUTE_VALUE);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.textBlockLiteral",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.textBlockLiteral" ],
    "fullMethods" : [ "public final TextBlockLiteralContext textBlockLiteral() throws RecognitionException {\n    TextBlockLiteralContext _localctx = new TextBlockLiteralContext(_ctx, getState());\n    enterRule(_localctx, 120, RULE_textBlockLiteral);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(820);\n            match(TEXT_BLOCK_LITERAL_BEGIN);\n            setState(821);\n            match(TEXT_BLOCK_CONTENT);\n            setState(822);\n            match(TEXT_BLOCK_LITERAL_END);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.modifier",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.modifier" ],
    "fullMethods" : [ "public final ModifierContext modifier() throws RecognitionException {\n    ModifierContext _localctx = new ModifierContext(_ctx, getState());\n    enterRule(_localctx, 10, RULE_modifier);\n    try {\n        setState(360);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case AT :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(345);\n                    annotation();\n                }\n                break;\n            case LITERAL_PUBLIC :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(346);\n                    match(LITERAL_PUBLIC);\n                }\n                break;\n            case LITERAL_PROTECTED :\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(347);\n                    match(LITERAL_PROTECTED);\n                }\n                break;\n            case LITERAL_PRIVATE :\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(348);\n                    match(LITERAL_PRIVATE);\n                }\n                break;\n            case LITERAL_STATIC :\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(349);\n                    match(LITERAL_STATIC);\n                }\n                break;\n            case ABSTRACT :\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(350);\n                    match(ABSTRACT);\n                }\n                break;\n            case LITERAL_DEFAULT :\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(351);\n                    match(LITERAL_DEFAULT);\n                }\n                break;\n            case FINAL :\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(352);\n                    match(FINAL);\n                }\n                break;\n            case STRICTFP :\n                enterOuterAlt(_localctx, 9);\n                {\n                    setState(353);\n                    match(STRICTFP);\n                }\n                break;\n            case LITERAL_NATIVE :\n                enterOuterAlt(_localctx, 10);\n                {\n                    setState(354);\n                    match(LITERAL_NATIVE);\n                }\n                break;\n            case LITERAL_SYNCHRONIZED :\n                enterOuterAlt(_localctx, 11);\n                {\n                    setState(355);\n                    match(LITERAL_SYNCHRONIZED);\n                }\n                break;\n            case LITERAL_TRANSIENT :\n                enterOuterAlt(_localctx, 12);\n                {\n                    setState(356);\n                    match(LITERAL_TRANSIENT);\n                }\n                break;\n            case LITERAL_VOLATILE :\n                enterOuterAlt(_localctx, 13);\n                {\n                    setState(357);\n                    match(LITERAL_VOLATILE);\n                }\n                break;\n            case LITERAL_NON_SEALED :\n                enterOuterAlt(_localctx, 14);\n                {\n                    setState(358);\n                    match(LITERAL_NON_SEALED);\n                }\n                break;\n            case LITERAL_SEALED :\n                enterOuterAlt(_localctx, 15);\n                {\n                    setState(359);\n                    match(LITERAL_SEALED);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.nonWildcardTypeArgumentsOrDiamond",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.nonWildcardTypeArgumentsOrDiamond" ],
    "fullMethods" : [ "public final NonWildcardTypeArgumentsOrDiamondContext nonWildcardTypeArgumentsOrDiamond() throws RecognitionException {\n    NonWildcardTypeArgumentsOrDiamondContext _localctx = new NonWildcardTypeArgumentsOrDiamondContext(_ctx, getState());\n    enterRule(_localctx, 246, RULE_nonWildcardTypeArgumentsOrDiamond);\n    try {\n        setState(1628);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 192, _ctx)) {\n            case 1 :\n                _localctx = new NonWildcardDiamondContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1625);\n                    match(LT);\n                    setState(1626);\n                    match(GT);\n                }\n                break;\n            case 2 :\n                _localctx = new NonWildcardTypeArgsContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1627);\n                    nonWildcardTypeArguments();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodDeclaration" ],
    "fullMethods" : [ "public final MethodDeclarationContext methodDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    MethodDeclarationContext _localctx = new MethodDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 68, RULE_methodDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(588);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(587);\n                    ((MethodDeclarationContext) (_localctx)).typeParams = typeParameters();\n                }\n            }\n            setState(590);\n            ((MethodDeclarationContext) (_localctx)).type = typeType(true);\n            setState(591);\n            id();\n            setState(592);\n            formalParameters();\n            {\n                setState(596);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n                while ((_la == LBRACK) || (_la == AT)) {\n                    {\n                        {\n                            setState(593);\n                            ((MethodDeclarationContext) (_localctx)).arrayDeclarator = arrayDeclarator();\n                            ((MethodDeclarationContext) (_localctx)).cStyleArrDec.add(((MethodDeclarationContext) (_localctx)).arrayDeclarator);\n                        }\n                    }\n                    setState(598);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                } \n            }\n            setState(600);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_THROWS) {\n                {\n                    setState(599);\n                    throwsList();\n                }\n            }\n            setState(602);\n            methodBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.finallyBlock",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.finallyBlock" ],
    "fullMethods" : [ "public final FinallyBlockContext finallyBlock() throws RecognitionException {\n    FinallyBlockContext _localctx = new FinallyBlockContext(_ctx, getState());\n    enterRule(_localctx, 182, RULE_finallyBlock);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1182);\n            match(LITERAL_FINALLY);\n            setState(1183);\n            block();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.id",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.id" ],
    "fullMethods" : [ "public final IdContext id() throws RecognitionException {\n    IdContext _localctx = new IdContext(_ctx, getState());\n    enterRule(_localctx, 286, RULE_id);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1766);\n            _la = _input.LA(1);\n            if (!((_la == IDENT) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0)))) {\n                _errHandler.recoverInline(this);\n            } else {\n                if (_input.LA(1) == Token.EOF)\n                    matchedEOF = true;\n\n                _errHandler.reportMatch(this);\n                consume();\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationTypeElementRest" ],
    "fullMethods" : [ "public final AnnotationTypeElementRestContext annotationTypeElementRest(List<ModifierContext> mods) throws RecognitionException {\n    AnnotationTypeElementRestContext _localctx = new AnnotationTypeElementRestContext(_ctx, getState(), mods);\n    enterRule(_localctx, 140, RULE_annotationTypeElementRest);\n    try {\n        setState(927);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 100, _ctx)) {\n            case 1 :\n                _localctx = new AnnotationFieldContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(897);\n                    ((AnnotationFieldContext) (_localctx)).type = typeType(true);\n                    setState(900);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 94, _ctx)) {\n                        case 1 :\n                            {\n                                setState(898);\n                                annotationMethodRest(mods, ((AnnotationFieldContext) (_localctx)).type);\n                            }\n                            break;\n                        case 2 :\n                            {\n                                setState(899);\n                                annotationConstantRest(mods, ((AnnotationFieldContext) (_localctx)).type);\n                            }\n                            break;\n                    }\n                    setState(902);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(904);\n                    ((AnnotationTypeContext) (_localctx)).type = typeType(true);\n                    setState(905);\n                    match(SEMI);\n                }\n                break;\n            case 3 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(907);\n                    classDeclaration(mods);\n                    setState(909);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 95, _ctx)) {\n                        case 1 :\n                            {\n                                setState(908);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 4 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(911);\n                    recordDeclaration(mods);\n                    setState(913);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 96, _ctx)) {\n                        case 1 :\n                            {\n                                setState(912);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 5 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(915);\n                    interfaceDeclaration(mods);\n                    setState(917);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 97, _ctx)) {\n                        case 1 :\n                            {\n                                setState(916);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 6 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(919);\n                    enumDeclaration(mods);\n                    setState(921);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 98, _ctx)) {\n                        case 1 :\n                            {\n                                setState(920);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n            case 7 :\n                _localctx = new AnnotationTypeContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(923);\n                    annotationTypeDeclaration(mods);\n                    setState(925);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 99, _ctx)) {\n                        case 1 :\n                            {\n                                setState(924);\n                                match(SEMI);\n                            }\n                            break;\n                    }\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgumentsOrDiamond",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.typeArgumentsOrDiamond" ],
    "fullMethods" : [ "public final TypeArgumentsOrDiamondContext typeArgumentsOrDiamond() throws RecognitionException {\n    TypeArgumentsOrDiamondContext _localctx = new TypeArgumentsOrDiamondContext(_ctx, getState());\n    enterRule(_localctx, 244, RULE_typeArgumentsOrDiamond);\n    try {\n        setState(1623);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 191, _ctx)) {\n            case 1 :\n                _localctx = new DiamondContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1620);\n                    match(LT);\n                    setState(1621);\n                    match(GT);\n                }\n                break;\n            case 2 :\n                _localctx = new TypeArgsContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1622);\n                    typeArguments();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightElement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.nonTightElement" ],
    "fullMethods" : [ "public final NonTightElementContext nonTightElement() throws RecognitionException {\n    NonTightElementContext _localctx = new NonTightElementContext(_ctx, getState());\n    enterRule(_localctx, 92, RULE_nonTightElement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(430);\n            htmlTagStart();\n            setState(432);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 58, _ctx)) {\n                case 1 :\n                    {\n                        setState(431);\n                        nonTightHtmlContent();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.seeTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.seeTag" ],
    "fullMethods" : [ "public final SeeTagContext seeTag() throws RecognitionException {\n    SeeTagContext _localctx = new SeeTagContext(_ctx, getState());\n    enterRule(_localctx, 22, RULE_seeTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(196);\n            match(AT_SIGN);\n            setState(209);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 18, _ctx)) {\n                case 1 :\n                    {\n                        setState(197);\n                        ((SeeTagContext) (_localctx)).tagName = match(SEE);\n                        setState(198);\n                        match(STRING_LITERAL);\n                    }\n                    break;\n                case 2 :\n                    {\n                        setState(199);\n                        ((SeeTagContext) (_localctx)).tagName = match(SEE);\n                        setState(200);\n                        reference();\n                        setState(202);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 16, _ctx)) {\n                            case 1 :\n                                {\n                                    setState(201);\n                                    description();\n                                }\n                                break;\n                        }\n                    }\n                    break;\n                case 3 :\n                    {\n                        setState(204);\n                        ((SeeTagContext) (_localctx)).tagName = match(SEE);\n                        setState(205);\n                        htmlElement();\n                        setState(207);\n                        _errHandler.sync(this);\n                        switch (getInterpreter().adaptivePredict(_input, 17, _ctx)) {\n                            case 1 :\n                                {\n                                    setState(206);\n                                    description();\n                                }\n                                break;\n                        }\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classCreatorRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classCreatorRest" ],
    "fullMethods" : [ "public final ClassCreatorRestContext classCreatorRest() throws RecognitionException {\n    ClassCreatorRestContext _localctx = new ClassCreatorRestContext(_ctx, getState());\n    enterRule(_localctx, 242, RULE_classCreatorRest);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1616);\n            arguments();\n            setState(1618);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 190, _ctx)) {\n                case 1 :\n                    {\n                        setState(1617);\n                        classBody();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchType",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.catchType" ],
    "fullMethods" : [ "public final CatchTypeContext catchType() throws RecognitionException {\n    CatchTypeContext _localctx = new CatchTypeContext(_ctx, getState());\n    enterRule(_localctx, 180, RULE_catchType);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1174);\n            classOrInterfaceType(false);\n            setState(1179);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == BOR) {\n                {\n                    {\n                        setState(1175);\n                        match(BOR);\n                        setState(1176);\n                        classOrInterfaceType(false);\n                    }\n                }\n                setState(1181);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdNameExtended",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdNameExtended" ],
    "fullMethods" : [ "public final CreatedNameExtendedContext createdNameExtended() throws RecognitionException {\n    CreatedNameExtendedContext _localctx = new CreatedNameExtendedContext(_ctx, getState());\n    enterRule(_localctx, 234, RULE_createdNameExtended);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1573);\n            match(DOT);\n            setState(1574);\n            annotations(false);\n            setState(1575);\n            id();\n            setState(1577);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(1576);\n                    typeArgumentsOrDiamond();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledBlock",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchLabeledBlock" ],
    "fullMethods" : [ "public final SwitchLabeledBlockContext switchLabeledBlock() throws RecognitionException {\n    SwitchLabeledBlockContext _localctx = new SwitchLabeledBlockContext(_ctx, getState());\n    enterRule(_localctx, 170, RULE_switchLabeledBlock);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1146);\n            switchLabel();\n            setState(1147);\n            match(LAMBDA);\n            setState(1148);\n            block();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.bracketsWithExp",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.bracketsWithExp" ],
    "fullMethods" : [ "public final BracketsWithExpContext bracketsWithExp() throws RecognitionException {\n    BracketsWithExpContext _localctx = new BracketsWithExpContext(_ctx, getState());\n    enterRule(_localctx, 240, RULE_bracketsWithExp);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1611);\n            annotations(false);\n            setState(1612);\n            match(LBRACK);\n            setState(1613);\n            expression();\n            setState(1614);\n            match(RBRACK);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponentPatternList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponentPatternList" ],
    "fullMethods" : [ "public final RecordComponentPatternListContext recordComponentPatternList() throws RecognitionException {\n    RecordComponentPatternListContext _localctx = new RecordComponentPatternListContext(_ctx, getState());\n    enterRule(_localctx, 282, RULE_recordComponentPatternList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1749);\n            innerPattern();\n            setState(1754);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(1750);\n                        match(COMMA);\n                        setState(1751);\n                        innerPattern();\n                    }\n                }\n                setState(1756);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.forControl",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.forControl" ],
    "fullMethods" : [ "public final ForControlContext forControl() throws RecognitionException {\n    ForControlContext _localctx = new ForControlContext(_ctx, getState());\n    enterRule(_localctx, 204, RULE_forControl);\n    int _la;\n    try {\n        setState(1282);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 149, _ctx)) {\n            case 1 :\n                _localctx = new EnhancedForContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1262);\n                    match(LPAREN);\n                    setState(1265);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 145, _ctx)) {\n                        case 1 :\n                            {\n                                setState(1263);\n                                enhancedForControl();\n                            }\n                            break;\n                        case 2 :\n                            {\n                                setState(1264);\n                                enhancedForControlWithRecordPattern();\n                            }\n                            break;\n                    }\n                    setState(1267);\n                    match(RPAREN);\n                }\n                break;\n            case 2 :\n                _localctx = new ForForContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1269);\n                    match(LPAREN);\n                    setState(1271);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 37156484702796807L) != 0)) || ((((_la - 125) & (~0x3f)) == 0) && (((1L << (_la - 125)) & 35184372117491L) != 0))) || ((((_la - 192) & (~0x3f)) == 0) && (((1L << (_la - 192)) & 4385166758159L) != 0))) {\n                        {\n                            setState(1270);\n                            forInit();\n                        }\n                    }\n                    setState(1273);\n                    match(SEMI);\n                    setState(1275);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1274);\n                            ((ForForContext) (_localctx)).forCond = expression();\n                        }\n                    }\n                    setState(1277);\n                    match(SEMI);\n                    setState(1279);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 76) & (~0x3f)) == 0) && (((1L << (_la - 76)) & (-2313161358608162803L)) != 0))) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & (-54021599296225279L)) != 0))) {\n                        {\n                            setState(1278);\n                            ((ForForContext) (_localctx)).forUpdate = expressionList();\n                        }\n                    }\n                    setState(1281);\n                    match(RPAREN);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclaratorId",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.variableDeclaratorId" ],
    "fullMethods" : [ "public final VariableDeclaratorIdContext variableDeclaratorId(List<VariableModifierContext> mods, ParserRuleContext type) throws RecognitionException {\n    VariableDeclaratorIdContext _localctx = new VariableDeclaratorIdContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 88, RULE_variableDeclaratorId);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(686);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case LITERAL_THIS :\n                    {\n                        setState(680);\n                        match(LITERAL_THIS);\n                    }\n                    break;\n                case IDENT :\n                case LITERAL_RECORD :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                    {\n                        {\n                            setState(681);\n                            qualifiedName();\n                            setState(684);\n                            _errHandler.sync(this);\n                            _la = _input.LA(1);\n                            if (_la == DOT) {\n                                {\n                                    setState(682);\n                                    match(DOT);\n                                    setState(683);\n                                    match(LITERAL_THIS);\n                                }\n                            }\n                        }\n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n            setState(691);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(688);\n                        arrayDeclarator();\n                    }\n                }\n                setState(693);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationMethodRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationMethodRest" ],
    "fullMethods" : [ "public final AnnotationMethodRestContext annotationMethodRest(List<ModifierContext> mods, TypeTypeContext type) throws RecognitionException {\n    AnnotationMethodRestContext _localctx = new AnnotationMethodRestContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 142, RULE_annotationMethodRest);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(929);\n            id();\n            setState(930);\n            match(LPAREN);\n            setState(931);\n            match(RPAREN);\n            setState(935);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((_la == LBRACK) || (_la == AT)) {\n                {\n                    {\n                        setState(932);\n                        ((AnnotationMethodRestContext) (_localctx)).arrayDeclarator = arrayDeclarator();\n                        ((AnnotationMethodRestContext) (_localctx)).cStyleArrDec.add(((AnnotationMethodRestContext) (_localctx)).arrayDeclarator);\n                    }\n                }\n                setState(937);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(939);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_DEFAULT) {\n                {\n                    setState(938);\n                    defaultValue();\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceBody" ],
    "fullMethods" : [ "public final InterfaceBodyContext interfaceBody() throws RecognitionException {\n    InterfaceBodyContext _localctx = new InterfaceBodyContext(_ctx, getState());\n    enterRule(_localctx, 62, RULE_interfaceBody);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(554);\n            match(LCURLY);\n            setState(558);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while ((((((_la - 39) & (~0x3f)) == 0) && (((1L << (_la - 39)) & 36028803458268231L) != 0)) || ((((_la - 117) & (~0x3f)) == 0) && (((1L << (_la - 117)) & 9007267974217729L) != 0))) || ((((_la - 200) & (~0x3f)) == 0) && (((1L << (_la - 200)) & 16797313L) != 0))) {\n                {\n                    {\n                        setState(555);\n                        interfaceBodyDeclaration();\n                    }\n                }\n                setState(560);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(561);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classBodyDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.classBodyDeclaration" ],
    "fullMethods" : [ "public final ClassBodyDeclarationContext classBodyDeclaration() throws RecognitionException {\n    ClassBodyDeclarationContext _localctx = new ClassBodyDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 64, RULE_classBodyDeclaration);\n    int _la;\n    try {\n        int _alt;\n        setState(575);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 44, _ctx)) {\n            case 1 :\n                _localctx = new EmptyClassContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(563);\n                    match(SEMI);\n                }\n                break;\n            case 2 :\n                _localctx = new ClassBlockContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(565);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LITERAL_STATIC) {\n                        {\n                            setState(564);\n                            match(LITERAL_STATIC);\n                        }\n                    }\n                    setState(567);\n                    block();\n                }\n                break;\n            case 3 :\n                _localctx = new ClassDefContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(571);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 43, _ctx);\n                    while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                        if (_alt == 1) {\n                            {\n                                {\n                                    setState(568);\n                                    ((ClassDefContext) (_localctx)).modifier = modifier();\n                                    ((ClassDefContext) (_localctx)).mods.add(((ClassDefContext) (_localctx)).modifier);\n                                }\n                            }\n                        }\n                        setState(573);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 43, _ctx);\n                    } \n                    setState(574);\n                    memberDeclaration(((ClassDefContext) (_localctx)).mods);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponentsList",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.recordComponentsList" ],
    "fullMethods" : [ "public final RecordComponentsListContext recordComponentsList() throws RecognitionException {\n    RecordComponentsListContext _localctx = new RecordComponentsListContext(_ctx, getState());\n    enterRule(_localctx, 18, RULE_recordComponentsList);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(393);\n            match(LPAREN);\n            setState(395);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if ((((_la & (~0x3f)) == 0) && (((1L << _la) & 575897802350002176L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                {\n                    setState(394);\n                    recordComponents();\n                }\n            }\n            setState(397);\n            match(RPAREN);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.defaultValue",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.defaultValue" ],
    "fullMethods" : [ "public final DefaultValueContext defaultValue() throws RecognitionException {\n    DefaultValueContext _localctx = new DefaultValueContext(_ctx, getState());\n    enterRule(_localctx, 146, RULE_defaultValue);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(943);\n            match(LITERAL_DEFAULT);\n            setState(944);\n            elementValue();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.interfaceDeclaration" ],
    "fullMethods" : [ "public final InterfaceDeclarationContext interfaceDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    InterfaceDeclarationContext _localctx = new InterfaceDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 56, RULE_interfaceDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(529);\n            match(LITERAL_INTERFACE);\n            setState(530);\n            id();\n            setState(532);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(531);\n                    typeParameters();\n                }\n            }\n            setState(535);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == EXTENDS_CLAUSE) {\n                {\n                    setState(534);\n                    interfaceExtends();\n                }\n            }\n            setState(538);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_PERMITS) {\n                {\n                    setState(537);\n                    permittedSubclassesAndInterfaces();\n                }\n            }\n            setState(540);\n            interfaceBody();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedNameExtended",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedNameExtended" ],
    "fullMethods" : [ "public final QualifiedNameExtendedContext qualifiedNameExtended() throws RecognitionException {\n    QualifiedNameExtendedContext _localctx = new QualifiedNameExtendedContext(_ctx, getState());\n    enterRule(_localctx, 112, RULE_qualifiedNameExtended);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(802);\n            match(DOT);\n            setState(803);\n            annotations(false);\n            setState(804);\n            id();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.nonWildcardTypeArguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.nonWildcardTypeArguments" ],
    "fullMethods" : [ "public final NonWildcardTypeArgumentsContext nonWildcardTypeArguments() throws RecognitionException {\n    NonWildcardTypeArgumentsContext _localctx = new NonWildcardTypeArgumentsContext(_ctx, getState());\n    enterRule(_localctx, 248, RULE_nonWildcardTypeArguments);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1630);\n            match(LT);\n            setState(1631);\n            typeArgumentsTypeList();\n            setState(1632);\n            match(GT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.createdName" ],
    "fullMethods" : [ "public final CreatedNameContext createdName() throws RecognitionException {\n    CreatedNameContext _localctx = new CreatedNameContext(_ctx, getState());\n    enterRule(_localctx, 232, RULE_createdName);\n    int _la;\n    try {\n        setState(1571);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case IDENT :\n            case AT :\n            case LITERAL_RECORD :\n            case LITERAL_YIELD :\n            case LITERAL_NON_SEALED :\n            case LITERAL_SEALED :\n            case LITERAL_PERMITS :\n            case LITERAL_WHEN :\n            case LITERAL_UNDERSCORE :\n                _localctx = new CreatedNameObjectContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1559);\n                    annotations(false);\n                    setState(1560);\n                    id();\n                    setState(1562);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if (_la == LT) {\n                        {\n                            setState(1561);\n                            typeArgumentsOrDiamond();\n                        }\n                    }\n                    setState(1567);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while (_la == DOT) {\n                        {\n                            {\n                                setState(1564);\n                                ((CreatedNameObjectContext) (_localctx)).createdNameExtended = createdNameExtended();\n                                ((CreatedNameObjectContext) (_localctx)).extended.add(((CreatedNameObjectContext) (_localctx)).createdNameExtended);\n                            }\n                        }\n                        setState(1569);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                }\n                break;\n            case LITERAL_VOID :\n            case LITERAL_BOOLEAN :\n            case LITERAL_BYTE :\n            case LITERAL_CHAR :\n            case LITERAL_SHORT :\n            case LITERAL_INT :\n            case LITERAL_FLOAT :\n            case LITERAL_LONG :\n            case LITERAL_DOUBLE :\n                _localctx = new CreatedNamePrimitiveContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1570);\n                    primitiveType();\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.packageDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.packageDeclaration" ],
    "fullMethods" : [ "public final PackageDeclarationContext packageDeclaration() throws RecognitionException {\n    PackageDeclarationContext _localctx = new PackageDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 2, RULE_packageDeclaration);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(305);\n            annotations(true);\n            setState(306);\n            match(LITERAL_PACKAGE);\n            setState(307);\n            qualifiedName();\n            setState(308);\n            match(SEMI);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.javadoc",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.javadoc" ],
    "fullMethods" : [ "public final JavadocContext javadoc() throws RecognitionException {\n    JavadocContext _localctx = new JavadocContext(_ctx, getState());\n    enterRule(_localctx, 0, RULE_javadoc);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(111);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 0, _ctx)) {\n                case 1 :\n                    {\n                        setState(110);\n                        mainDescription();\n                    }\n                    break;\n            }\n            setState(116);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == AT_SIGN) {\n                {\n                    {\n                        setState(113);\n                        blockTag();\n                    }\n                }\n                setState(118);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(119);\n            match(EOF);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lambdaParameters",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lambdaParameters" ],
    "fullMethods" : [ "public final LambdaParametersContext lambdaParameters() throws RecognitionException {\n    LambdaParametersContext _localctx = new LambdaParametersContext(_ctx, getState());\n    enterRule(_localctx, 222, RULE_lambdaParameters);\n    int _la;\n    try {\n        setState(1494);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 172, _ctx)) {\n            case 1 :\n                _localctx = new SingleLambdaParamContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1484);\n                    id();\n                }\n                break;\n            case 2 :\n                _localctx = new FormalLambdaParamContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1485);\n                    match(LPAREN);\n                    setState(1487);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    if ((((_la & (~0x3f)) == 0) && (((1L << _la) & 575898352105816064L) != 0)) || ((((_la - 170) & (~0x3f)) == 0) && (((1L << (_la - 170)) & 18035977498918913L) != 0))) {\n                        {\n                            setState(1486);\n                            formalParameterList();\n                        }\n                    }\n                    setState(1489);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new MultiLambdaParamContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1490);\n                    match(LPAREN);\n                    setState(1491);\n                    multiLambdaParams();\n                    setState(1492);\n                    match(RPAREN);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotation",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotation" ],
    "fullMethods" : [ "public final AnnotationContext annotation() throws RecognitionException {\n    AnnotationContext _localctx = new AnnotationContext(_ctx, getState());\n    enterRule(_localctx, 124, RULE_annotation);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(830);\n            match(AT);\n            setState(831);\n            qualifiedName();\n            setState(838);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LPAREN) {\n                {\n                    setState(832);\n                    match(LPAREN);\n                    setState(835);\n                    _errHandler.sync(this);\n                    switch (getInterpreter().adaptivePredict(_input, 84, _ctx)) {\n                        case 1 :\n                            {\n                                setState(833);\n                                elementValuePairs();\n                            }\n                            break;\n                        case 2 :\n                            {\n                                setState(834);\n                                elementValue();\n                            }\n                            break;\n                    }\n                    setState(837);\n                    match(RPAREN);\n                }\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.qualifiedName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.qualifiedName" ],
    "fullMethods" : [ "public final QualifiedNameContext qualifiedName() throws RecognitionException {\n    QualifiedNameContext _localctx = new QualifiedNameContext(_ctx, getState());\n    enterRule(_localctx, 70, RULE_qualifiedName);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(356);\n            match(IDENTIFIER);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchExpressionOrStatement",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.switchExpressionOrStatement" ],
    "fullMethods" : [ "public final SwitchExpressionOrStatementContext switchExpressionOrStatement() throws RecognitionException {\n    SwitchExpressionOrStatementContext _localctx = new SwitchExpressionOrStatementContext(_ctx, getState());\n    enterRule(_localctx, 162, RULE_switchExpressionOrStatement);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1109);\n            match(LITERAL_SWITCH);\n            setState(1110);\n            parExpression();\n            setState(1111);\n            match(LCURLY);\n            switchBlockDepth++;\n            setState(1113);\n            switchBlock();\n            switchBlockDepth--;\n            setState(1115);\n            match(RCURLY);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodBody",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.methodBody" ],
    "fullMethods" : [ "public final MethodBodyContext methodBody() throws RecognitionException {\n    MethodBodyContext _localctx = new MethodBodyContext(_ctx, getState());\n    enterRule(_localctx, 70, RULE_methodBody);\n    try {\n        setState(606);\n        _errHandler.sync(this);\n        switch (_input.LA(1)) {\n            case LCURLY :\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(604);\n                    block();\n                }\n                break;\n            case SEMI :\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(605);\n                    match(SEMI);\n                }\n                break;\n            default :\n                throw new NoViableAltException(this);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlTagEnd",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlTagEnd" ],
    "fullMethods" : [ "public final HtmlTagEndContext htmlTagEnd() throws RecognitionException {\n    HtmlTagEndContext _localctx = new HtmlTagEndContext(_ctx, getState());\n    enterRule(_localctx, 98, RULE_htmlTagEnd);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(454);\n            match(TAG_OPEN);\n            setState(455);\n            match(TAG_SLASH);\n            setState(456);\n            match(TAG_NAME);\n            setState(457);\n            match(TAG_CLOSE);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.throwsTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.throwsTag" ],
    "fullMethods" : [ "public final ThrowsTagContext throwsTag() throws RecognitionException {\n    ThrowsTagContext _localctx = new ThrowsTagContext(_ctx, getState());\n    enterRule(_localctx, 14, RULE_throwsTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(170);\n            match(AT_SIGN);\n            setState(171);\n            ((ThrowsTagContext) (_localctx)).tagName = match(THROWS);\n            setState(173);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 10, _ctx)) {\n                case 1 :\n                    {\n                        setState(172);\n                        ((ThrowsTagContext) (_localctx)).exceptionName = qualifiedName();\n                    }\n                    break;\n            }\n            setState(176);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 11, _ctx)) {\n                case 1 :\n                    {\n                        setState(175);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedName",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.qualifiedName" ],
    "fullMethods" : [ "public final QualifiedNameContext qualifiedName() throws RecognitionException {\n    QualifiedNameContext _localctx = new QualifiedNameContext(_ctx, getState());\n    enterRule(_localctx, 110, RULE_qualifiedName);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(795);\n            id();\n            setState(799);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 81, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(796);\n                            ((QualifiedNameContext) (_localctx)).qualifiedNameExtended = qualifiedNameExtended();\n                            ((QualifiedNameContext) (_localctx)).extended.add(((QualifiedNameContext) (_localctx)).qualifiedNameExtended);\n                        }\n                    }\n                }\n                setState(801);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 81, _ctx);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlContent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.htmlContent" ],
    "fullMethods" : [ "public final HtmlContentContext htmlContent() throws RecognitionException {\n    HtmlContentContext _localctx = new HtmlContentContext(_ctx, getState());\n    enterRule(_localctx, 102, RULE_htmlContent);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(468);\n            _errHandler.sync(this);\n            _alt = 1;\n            do {\n                switch (_alt) {\n                    case 1 :\n                        {\n                            setState(468);\n                            _errHandler.sync(this);\n                            switch (getInterpreter().adaptivePredict(_input, 62, _ctx)) {\n                                case 1 :\n                                    {\n                                        setState(464);\n                                        match(TEXT);\n                                    }\n                                    break;\n                                case 2 :\n                                    {\n                                        setState(465);\n                                        htmlElement();\n                                    }\n                                    break;\n                                case 3 :\n                                    {\n                                        setState(466);\n                                        inlineTag();\n                                    }\n                                    break;\n                                case 4 :\n                                    {\n                                        setState(467);\n                                        htmlComment();\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default :\n                        throw new NoViableAltException(this);\n                }\n                setState(470);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 63, _ctx);\n            } while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER) );\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.usesTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.usesTag" ],
    "fullMethods" : [ "public final UsesTagContext usesTag() throws RecognitionException {\n    UsesTagContext _localctx = new UsesTagContext(_ctx, getState());\n    enterRule(_localctx, 26, RULE_usesTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(216);\n            match(AT_SIGN);\n            setState(217);\n            ((UsesTagContext) (_localctx)).tagName = match(USES);\n            setState(218);\n            ((UsesTagContext) (_localctx)).serviceType = qualifiedName();\n            setState(220);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 20, _ctx)) {\n                case 1 :\n                    {\n                        setState(219);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.linkInlineTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.linkInlineTag" ],
    "fullMethods" : [ "public final LinkInlineTagContext linkInlineTag() throws RecognitionException {\n    LinkInlineTagContext _localctx = new LinkInlineTagContext(_ctx, getState());\n    enterRule(_localctx, 46, RULE_linkInlineTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(284);\n            ((LinkInlineTagContext) (_localctx)).tagName = match(LINK);\n            setState(285);\n            reference();\n            setState(287);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 31, _ctx)) {\n                case 1 :\n                    {\n                        setState(286);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primary" ],
    "fullMethods" : [ "public final PrimaryContext primary() throws RecognitionException {\n    PrimaryContext _localctx = new PrimaryContext(_ctx, getState());\n    enterRule(_localctx, 226, RULE_primary);\n    int _la;\n    try {\n        setState(1533);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 176, _ctx)) {\n            case 1 :\n                _localctx = new SwitchPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1504);\n                    switchExpressionOrStatement();\n                }\n                break;\n            case 2 :\n                _localctx = new ParenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1505);\n                    match(LPAREN);\n                    setState(1506);\n                    expr(0);\n                    setState(1507);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1509);\n                    match(LITERAL_THIS);\n                }\n                break;\n            case 4 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 4);\n                {\n                    setState(1510);\n                    match(LITERAL_SUPER);\n                }\n                break;\n            case 5 :\n                _localctx = new LiteralPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 5);\n                {\n                    setState(1511);\n                    literal();\n                }\n                break;\n            case 6 :\n                _localctx = new TokenPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 6);\n                {\n                    setState(1512);\n                    id();\n                }\n                break;\n            case 7 :\n                _localctx = new ClassRefPrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 7);\n                {\n                    setState(1513);\n                    ((ClassRefPrimaryContext) (_localctx)).type = classOrInterfaceType(false);\n                    setState(1517);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1514);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1519);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1520);\n                    match(DOT);\n                    setState(1521);\n                    match(LITERAL_CLASS);\n                }\n                break;\n            case 8 :\n                _localctx = new PrimitivePrimaryContext(_localctx);\n                enterOuterAlt(_localctx, 8);\n                {\n                    setState(1523);\n                    ((PrimitivePrimaryContext) (_localctx)).type = primitiveType();\n                    setState(1527);\n                    _errHandler.sync(this);\n                    _la = _input.LA(1);\n                    while ((_la == LBRACK) || (_la == AT)) {\n                        {\n                            {\n                                setState(1524);\n                                arrayDeclarator();\n                            }\n                        }\n                        setState(1529);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                    } \n                    setState(1530);\n                    match(DOT);\n                    setState(1531);\n                    match(LITERAL_CLASS);\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.innerCreator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.innerCreator" ],
    "fullMethods" : [ "public final InnerCreatorContext innerCreator() throws RecognitionException {\n    InnerCreatorContext _localctx = new InnerCreatorContext(_ctx, getState());\n    enterRule(_localctx, 236, RULE_innerCreator);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1579);\n            annotations(false);\n            setState(1580);\n            id();\n            setState(1582);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(1581);\n                    nonWildcardTypeArgumentsOrDiamond();\n                }\n            }\n            setState(1584);\n            classCreatorRest();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localVariableDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.localVariableDeclaration" ],
    "fullMethods" : [ "public final LocalVariableDeclarationContext localVariableDeclaration() throws RecognitionException {\n    LocalVariableDeclarationContext _localctx = new LocalVariableDeclarationContext(_ctx, getState());\n    enterRule(_localctx, 156, RULE_localVariableDeclaration);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(996);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 110, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(993);\n                            ((LocalVariableDeclarationContext) (_localctx)).modifier = modifier();\n                            ((LocalVariableDeclarationContext) (_localctx)).mods.add(((LocalVariableDeclarationContext) (_localctx)).modifier);\n                        }\n                    }\n                }\n                setState(998);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 110, _ctx);\n            } \n            setState(999);\n            ((LocalVariableDeclarationContext) (_localctx)).type = typeType(true);\n            setState(1000);\n            variableDeclarators(_localctx.mods, _localctx.type);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lastFormalParameter",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lastFormalParameter" ],
    "fullMethods" : [ "public final LastFormalParameterContext lastFormalParameter() throws RecognitionException {\n    LastFormalParameterContext _localctx = new LastFormalParameterContext(_ctx, getState());\n    enterRule(_localctx, 108, RULE_lastFormalParameter);\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(787);\n            _errHandler.sync(this);\n            _alt = getInterpreter().adaptivePredict(_input, 80, _ctx);\n            while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                if (_alt == 1) {\n                    {\n                        {\n                            setState(784);\n                            ((LastFormalParameterContext) (_localctx)).variableModifier = variableModifier();\n                            ((LastFormalParameterContext) (_localctx)).mods.add(((LastFormalParameterContext) (_localctx)).variableModifier);\n                        }\n                    }\n                }\n                setState(789);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 80, _ctx);\n            } \n            setState(790);\n            ((LastFormalParameterContext) (_localctx)).type = typeType(true);\n            setState(791);\n            annotations(false);\n            setState(792);\n            match(ELLIPSIS);\n            setState(793);\n            variableDeclaratorId(_localctx.mods, _localctx.type);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lastRecordComponent",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.lastRecordComponent" ],
    "fullMethods" : [ "public final LastRecordComponentContext lastRecordComponent() throws RecognitionException {\n    LastRecordComponentContext _localctx = new LastRecordComponentContext(_ctx, getState());\n    enterRule(_localctx, 24, RULE_lastRecordComponent);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(418);\n            annotations(true);\n            setState(419);\n            ((LastRecordComponentContext) (_localctx)).type = typeType(true);\n            setState(420);\n            match(ELLIPSIS);\n            setState(421);\n            id();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primaryPattern",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.primaryPattern" ],
    "fullMethods" : [ "public final PrimaryPatternContext primaryPattern() throws RecognitionException {\n    PrimaryPatternContext _localctx = new PrimaryPatternContext(_ctx, getState());\n    enterRule(_localctx, 276, RULE_primaryPattern);\n    try {\n        setState(1720);\n        _errHandler.sync(this);\n        switch (getInterpreter().adaptivePredict(_input, 204, _ctx)) {\n            case 1 :\n                _localctx = new PatternVariableDefContext(_localctx);\n                enterOuterAlt(_localctx, 1);\n                {\n                    setState(1714);\n                    typePattern();\n                }\n                break;\n            case 2 :\n                _localctx = new ParenPatternContext(_localctx);\n                enterOuterAlt(_localctx, 2);\n                {\n                    setState(1715);\n                    match(LPAREN);\n                    setState(1716);\n                    innerPattern();\n                    setState(1717);\n                    match(RPAREN);\n                }\n                break;\n            case 3 :\n                _localctx = new RecordPatternDefContext(_localctx);\n                enterOuterAlt(_localctx, 3);\n                {\n                    setState(1719);\n                    recordPattern();\n                }\n                break;\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayCreatorRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayCreatorRest" ],
    "fullMethods" : [ "public final ArrayCreatorRestContext arrayCreatorRest() throws RecognitionException {\n    ArrayCreatorRestContext _localctx = new ArrayCreatorRestContext(_ctx, getState());\n    enterRule(_localctx, 238, RULE_arrayCreatorRest);\n    int _la;\n    try {\n        int _alt;\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1586);\n            match(LBRACK);\n            setState(1609);\n            _errHandler.sync(this);\n            switch (_input.LA(1)) {\n                case RBRACK :\n                    {\n                        setState(1587);\n                        match(RBRACK);\n                        setState(1591);\n                        _errHandler.sync(this);\n                        _la = _input.LA(1);\n                        while ((_la == LBRACK) || (_la == AT)) {\n                            {\n                                {\n                                    setState(1588);\n                                    arrayDeclarator();\n                                }\n                            }\n                            setState(1593);\n                            _errHandler.sync(this);\n                            _la = _input.LA(1);\n                        } \n                        setState(1594);\n                        arrayInitializer();\n                    }\n                    break;\n                case LITERAL_VOID :\n                case LITERAL_BOOLEAN :\n                case LITERAL_BYTE :\n                case LITERAL_CHAR :\n                case LITERAL_SHORT :\n                case LITERAL_INT :\n                case LITERAL_FLOAT :\n                case LITERAL_LONG :\n                case LITERAL_DOUBLE :\n                case IDENT :\n                case LPAREN :\n                case LITERAL_THIS :\n                case LITERAL_SUPER :\n                case LITERAL_SWITCH :\n                case PLUS :\n                case MINUS :\n                case INC :\n                case DEC :\n                case BNOT :\n                case LNOT :\n                case LITERAL_TRUE :\n                case LITERAL_FALSE :\n                case LITERAL_NULL :\n                case LITERAL_NEW :\n                case CHAR_LITERAL :\n                case STRING_LITERAL :\n                case AT :\n                case FLOAT_LITERAL :\n                case DOUBLE_LITERAL :\n                case HEX_FLOAT_LITERAL :\n                case HEX_DOUBLE_LITERAL :\n                case LITERAL_RECORD :\n                case TEXT_BLOCK_LITERAL_BEGIN :\n                case LITERAL_YIELD :\n                case LITERAL_NON_SEALED :\n                case LITERAL_SEALED :\n                case LITERAL_PERMITS :\n                case LITERAL_WHEN :\n                case LITERAL_UNDERSCORE :\n                case DECIMAL_LITERAL_LONG :\n                case DECIMAL_LITERAL :\n                case HEX_LITERAL_LONG :\n                case HEX_LITERAL :\n                case OCT_LITERAL_LONG :\n                case OCT_LITERAL :\n                case BINARY_LITERAL_LONG :\n                case BINARY_LITERAL :\n                    {\n                        setState(1595);\n                        expression();\n                        setState(1596);\n                        match(RBRACK);\n                        setState(1600);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 187, _ctx);\n                        while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                            if (_alt == 1) {\n                                {\n                                    {\n                                        setState(1597);\n                                        bracketsWithExp();\n                                    }\n                                }\n                            }\n                            setState(1602);\n                            _errHandler.sync(this);\n                            _alt = getInterpreter().adaptivePredict(_input, 187, _ctx);\n                        } \n                        setState(1606);\n                        _errHandler.sync(this);\n                        _alt = getInterpreter().adaptivePredict(_input, 188, _ctx);\n                        while ((_alt != 2) && (_alt != ATN.INVALID_ALT_NUMBER)) {\n                            if (_alt == 1) {\n                                {\n                                    {\n                                        setState(1603);\n                                        arrayDeclarator();\n                                    }\n                                }\n                            }\n                            setState(1608);\n                            _errHandler.sync(this);\n                            _alt = getInterpreter().adaptivePredict(_input, 188, _ctx);\n                        } \n                    }\n                    break;\n                default :\n                    throw new NoViableAltException(this);\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValuePairs",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.elementValuePairs" ],
    "fullMethods" : [ "public final ElementValuePairsContext elementValuePairs() throws RecognitionException {\n    ElementValuePairsContext _localctx = new ElementValuePairsContext(_ctx, getState());\n    enterRule(_localctx, 126, RULE_elementValuePairs);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(840);\n            elementValuePair();\n            setState(845);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(841);\n                        match(COMMA);\n                        setState(842);\n                        elementValuePair();\n                    }\n                }\n                setState(847);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.versionTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.versionTag" ],
    "fullMethods" : [ "public final VersionTagContext versionTag() throws RecognitionException {\n    VersionTagContext _localctx = new VersionTagContext(_ctx, getState());\n    enterRule(_localctx, 20, RULE_versionTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(191);\n            match(AT_SIGN);\n            setState(192);\n            ((VersionTagContext) (_localctx)).tagName = match(VERSION);\n            setState(194);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 15, _ctx)) {\n                case 1 :\n                    {\n                        setState(193);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.customBlockTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.customBlockTag" ],
    "fullMethods" : [ "public final CustomBlockTagContext customBlockTag() throws RecognitionException {\n    CustomBlockTagContext _localctx = new CustomBlockTagContext(_ctx, getState());\n    enterRule(_localctx, 36, RULE_customBlockTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(249);\n            match(AT_SIGN);\n            setState(250);\n            ((CustomBlockTagContext) (_localctx)).tagName = match(CUSTOM_NAME);\n            setState(252);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 27, _ctx)) {\n                case 1 :\n                    {\n                        setState(251);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayDeclarator",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.arrayDeclarator" ],
    "fullMethods" : [ "public final ArrayDeclaratorContext arrayDeclarator() throws RecognitionException {\n    ArrayDeclaratorContext _localctx = new ArrayDeclaratorContext(_ctx, getState());\n    enterRule(_localctx, 258, RULE_arrayDeclarator);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(1662);\n            ((ArrayDeclaratorContext) (_localctx)).anno = annotations(false);\n            setState(1663);\n            match(LBRACK);\n            setState(1664);\n            match(RBRACK);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.exceptionTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.exceptionTag" ],
    "fullMethods" : [ "public final ExceptionTagContext exceptionTag() throws RecognitionException {\n    ExceptionTagContext _localctx = new ExceptionTagContext(_ctx, getState());\n    enterRule(_localctx, 16, RULE_exceptionTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(178);\n            match(AT_SIGN);\n            setState(179);\n            ((ExceptionTagContext) (_localctx)).tagName = match(EXCEPTION);\n            setState(181);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 12, _ctx)) {\n                case 1 :\n                    {\n                        setState(180);\n                        ((ExceptionTagContext) (_localctx)).exceptionName = qualifiedName();\n                    }\n                    break;\n            }\n            setState(184);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 13, _ctx)) {\n                case 1 :\n                    {\n                        setState(183);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.providesTag",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.providesTag" ],
    "fullMethods" : [ "public final ProvidesTagContext providesTag() throws RecognitionException {\n    ProvidesTagContext _localctx = new ProvidesTagContext(_ctx, getState());\n    enterRule(_localctx, 28, RULE_providesTag);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(222);\n            match(AT_SIGN);\n            setState(223);\n            ((ProvidesTagContext) (_localctx)).tagName = match(PROVIDES);\n            setState(224);\n            ((ProvidesTagContext) (_localctx)).serviceType = qualifiedName();\n            setState(226);\n            _errHandler.sync(this);\n            switch (getInterpreter().adaptivePredict(_input, 21, _ctx)) {\n                case 1 :\n                    {\n                        setState(225);\n                        description();\n                    }\n                    break;\n            }\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationConstantRest",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.annotationConstantRest" ],
    "fullMethods" : [ "public final AnnotationConstantRestContext annotationConstantRest(List<ModifierContext> mods, TypeTypeContext type) throws RecognitionException {\n    AnnotationConstantRestContext _localctx = new AnnotationConstantRestContext(_ctx, getState(), mods, type);\n    enterRule(_localctx, 144, RULE_annotationConstantRest);\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(941);\n            variableDeclarators(mods, type);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.constructorDeclaration",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.constructorDeclaration" ],
    "fullMethods" : [ "public final ConstructorDeclarationContext constructorDeclaration(List<ModifierContext> mods) throws RecognitionException {\n    ConstructorDeclarationContext _localctx = new ConstructorDeclarationContext(_ctx, getState(), mods);\n    enterRule(_localctx, 74, RULE_constructorDeclaration);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(612);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LT) {\n                {\n                    setState(611);\n                    typeParameters();\n                }\n            }\n            setState(614);\n            id();\n            setState(615);\n            formalParameters();\n            setState(617);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            if (_la == LITERAL_THROWS) {\n                {\n                    setState(616);\n                    throwsList();\n                }\n            }\n            setState(619);\n            ((ConstructorDeclarationContext) (_localctx)).constructorBody = constructorBlock();\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeArguments",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ANTLRErrorStrategy.reportError",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.javadoc.JavadocCommentsParser.typeArguments" ],
    "fullMethods" : [ "public final TypeArgumentsContext typeArguments() throws RecognitionException {\n    TypeArgumentsContext _localctx = new TypeArgumentsContext(_ctx, getState());\n    enterRule(_localctx, 72, RULE_typeArguments);\n    int _la;\n    try {\n        enterOuterAlt(_localctx, 1);\n        {\n            setState(358);\n            match(LT);\n            setState(359);\n            typeArgument();\n            setState(364);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la == COMMA) {\n                {\n                    {\n                        setState(360);\n                        match(COMMA);\n                        setState(361);\n                        typeArgument();\n                    }\n                }\n                setState(366);\n                _errHandler.sync(this);\n                _la = _input.LA(1);\n            } \n            setState(367);\n            match(GT);\n        }\n    } catch (RecognitionException re) {\n        _localctx.exception = re;\n        _errHandler.reportError(this, re);\n        _errHandler.recover(this, re);\n    } finally {\n        exitRule();\n    }\n    return _localctx;\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImportDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ImportDeclarationContext.<init>" ],
    "fullMethods" : [ "public ImportDeclarationContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockStatementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.BlockStatementContext.<init>" ],
    "fullMethods" : [ "public BlockStatementContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.CreatedNameContext.<init>" ],
    "fullMethods" : [ "public CreatedNameContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LambdaParametersContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.LambdaParametersContext.<init>" ],
    "fullMethods" : [ "public LambdaParametersContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.StatementContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.StatementContext.<init>" ],
    "fullMethods" : [ "public StatementContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabelContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchLabelContext.<init>" ],
    "fullMethods" : [ "public SwitchLabelContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryContext.<init>" ],
    "fullMethods" : [ "public PrimaryContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementRestContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.AnnotationTypeElementRestContext.<init>" ],
    "fullMethods" : [ "public AnnotationTypeElementRestContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExplicitConstructorInvocationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExplicitConstructorInvocationContext.<init>" ],
    "fullMethods" : [ "public ExplicitConstructorInvocationContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsOrDiamondContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.NonWildcardTypeArgumentsOrDiamondContext.<init>" ],
    "fullMethods" : [ "public NonWildcardTypeArgumentsOrDiamondContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForControlContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ForControlContext.<init>" ],
    "fullMethods" : [ "public ForControlContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypePatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypePatternContext.<init>" ],
    "fullMethods" : [ "public TypePatternContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentContext.<init>" ],
    "fullMethods" : [ "public TypeArgumentContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExprContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ExprContext.<init>" ],
    "fullMethods" : [ "public ExprContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SwitchBlockContext.<init>" ],
    "fullMethods" : [ "public SwitchBlockContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.SuperSuffixContext.<init>" ],
    "fullMethods" : [ "public SuperSuffixContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyDeclarationContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.ClassBodyDeclarationContext.<init>" ],
    "fullMethods" : [ "public ClassBodyDeclarationContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsOrDiamondContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.TypeArgumentsOrDiamondContext.<init>" ],
    "fullMethods" : [ "public TypeArgumentsOrDiamondContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryPatternContext.<init>",
    "thirdPartyMethod" : "org.antlr.v4.runtime.ParserRuleContext.<init>",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser.PrimaryPatternContext.<init>" ],
    "fullMethods" : [ "public PrimaryPatternContext() {\n}" ]
  }, {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.syntaxError",
    "thirdPartyMethod" : "org.antlr.v4.runtime.RuleContext.getRuleIndex",
    "thirdPartyPackage" : "org.antlr.v4.runtime",
    "path" : [ "com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser.DescriptiveErrorListener.syntaxError" ],
    "fullMethods" : [ "/**\n * Logs parser errors in Checkstyle manner. Parser can generate error\n * messages. There is special error that parser can generate. It is\n * missed close HTML tag. This case is special because parser prints\n * error like {@code \"no viable alternative at input 'b \\n *\\n'\"} and it\n * is not clear that error is about missed close HTML tag. Other error\n * messages are not special and logged simply as \"Parse Error...\".\n *\n * <p>{@inheritDoc }\n */\n@Override\npublic void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException ex) {\n    final int lineNumber = offset + line;\n    final String target;\n    if (recognizer instanceof JavadocCommentsLexer lexer) {\n        target = lexer.getPreviousToken().getText();\n    } else {\n        final int ruleIndex = ex.getCtx().getRuleIndex();\n        final String ruleName = recognizer.getRuleNames()[ruleIndex];\n        target = convertUpperCamelToUpperUnderscore(ruleName);\n    }\n    errorMessage = new ParseErrorMessage(lineNumber, MSG_JAVADOC_PARSE_RULE_ERROR, charPositionInLine, msg, target);\n}" ]
  } ]
}