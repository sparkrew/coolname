[
  {
    "entryPoint" : "com.graphhopper.util.GHUtility.loadCustomModelFromJar",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.readValue",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.util.GHUtility.loadCustomModelFromJar", "com.fasterxml.jackson.databind.ObjectMapper.readValue" ],
    "fullMethods" : [
      "public static CustomModel loadCustomModelFromJar(String name) {\n        try {\n            InputStream is = GHUtility.class.getResourceAsStream(\"/com/graphhopper/custom_models/\" + name);\n            if (is == null)\n                throw new IllegalArgumentException(\"There is no built-in custom model '\" + name + \"'\");\n            String json = readJSONFileWithoutComments(new InputStreamReader(is));\n            ObjectMapper objectMapper = Jackson.newObjectMapper();\n            return objectMapper.readValue(json, CustomModel.class);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(\"Could not load built-in custom model '\" + name + \"'\", e);\n        }\n    }",
      "/**\n     * Method to deserialize JSON content from given JSON content String.\n     *\n     * @throws StreamReadException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws DatabindException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    public <T> T readValue(String content, Class<T> valueType)\n        throws JsonProcessingException, JsonMappingException\n    {\n        _assertNotNull(\"content\", content);\n        return readValue(content, _typeFactory.constructType(valueType));\n    }"
    ]
  },
  {
    "entryPoint" : "com.graphhopper.reader.osm.WaySegmentParser.Pass2Handler.handleNode",
    "thirdPartyMethod" : "org.slf4j.LoggerFactory.getLogger",
    "thirdPartyPackage" : "org.slf4j",
    "path" : [ "com.graphhopper.reader.osm.WaySegmentParser.Pass2Handler.handleNode", "com.graphhopper.reader.osm.WaySegmentParser.<clinit>", "org.slf4j.LoggerFactory.getLogger" ],
    "fullMethods" : [
      "@Override\n        public void handleNode(ReaderNode node) {\n            if (!handledNodes) {\n                LOGGER.info(\"pass2 - start reading OSM nodes\");\n                handledNodes = true;\n            }\n            if (handledWays)\n                throw new IllegalStateException(\"OSM node elements must be located before way elements in OSM file\");\n            if (handledRelations)\n                throw new IllegalStateException(\"OSM node elements must be located before relation elements in OSM file\");\n\n            if (++nodeCounter % 10_000_000 == 0)\n                LOGGER.info(\"pass2 - processed nodes: \" + nf(nodeCounter) + \", accepted nodes: \" + nf(acceptedNodes) +\n                        \", \" + Helper.getMemInfo());\n\n            long nodeType = nodeData.addCoordinatesIfMapped(node.getId(), node.getLat(), node.getLon(), () -> elevationProvider.applyAsDouble(node));\n            if (nodeType == EMPTY_NODE)\n                return;\n\n            acceptedNodes++;\n\n            // remember which nodes we want to split\n            if (splitNodeFilter.test(node)) {\n                if (nodeType == JUNCTION_NODE) {\n                    LOGGER.debug(\"OSM node {} at {},{} is a barrier node at a junction. The barrier will be ignored\",\n                            node.getId(), Helper.round(node.getLat(), 7), Helper.round(node.getLon(), 7));\n                    ignoredSplitNodes++;\n                } else\n                    nodeData.setSplitNode(node.getId());\n            }\n\n            // store node tags if at least one important tag is included and make this available for the edge handler\n            for (Map.Entry<String, Object> e : node.getTags().entrySet()) {\n                if (INCLUDE_IF_NODE_TAGS.contains(e.getKey())) {\n                    node.removeTag(\"created_by\");\n                    node.removeTag(\"source\");\n                    node.removeTag(\"note\");\n                    node.removeTag(\"fixme\");\n                    nodeData.setTags(node);\n                    break;\n                }\n            }\n        }",
      "private WaySegmentParser(OSMNodeData nodeData) {\n        this.nodeData = nodeData;\n    }",
      "public static Logger getLogger(Class<?> clazz) {\n        Logger logger = getLogger(clazz.getName());\n        if (DETECT_LOGGER_NAME_MISMATCH) {\n            Class<?> autoComputedCallingClass = Util.getCallingClass();\n            if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) {\n                Reporter.warn(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(), autoComputedCallingClass.getName()));\n                Reporter.warn(\"See https://www.slf4j.org/codes.html#loggerNameMismatch for an explanation\");\n            }\n        }\n\n        return logger;\n    }"
    ]
  },
  {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.Main.main",
    "thirdPartyMethod" : "picocli.CommandLine.ParseResult.hasMatchedOption",
    "thirdPartyPackage" : "picocli.CommandLine",
    "path" : [ "com.puppycrawl.tools.checkstyle.Main.main", "com.puppycrawl.tools.checkstyle.Main.execute", "com.puppycrawl.tools.checkstyle.Main.CliOptions.validateCli", "picocli.CommandLine.ParseResult.hasMatchedOption" ],
    "fullMethods" : [
      "/**\n     * Loops over the files specified checking them for errors. The exit code\n     * is the number of errors found in all the files.\n     *\n     * @param args the command line arguments.\n     * @throws IOException if there is a problem with files access\n     * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace, CallToSystemExit\n     * @noinspectionreason UseOfSystemOutOrSystemErr - driver class for Checkstyle requires\n     *      usage of System.out and System.err\n     * @noinspectionreason CallToPrintStackTrace - driver class for Checkstyle must be able to\n     *      show all details in case of failure\n     * @noinspectionreason CallToSystemExit - driver class must call exit\n     **/\n    public static void main(String... args) throws IOException {\n\n        final CliOptions cliOptions = new CliOptions();\n        final CommandLine commandLine = new CommandLine(cliOptions);\n        commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n        commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n\n        // provide proper exit code based on results.\n        int exitStatus = 0;\n        int errorCounter = 0;\n        try {\n            final ParseResult parseResult = commandLine.parseArgs(args);\n            if (parseResult.isVersionHelpRequested()) {\n                printVersionToSystemOutput();\n            }\n            else if (parseResult.isUsageHelpRequested()) {\n                commandLine.usage(System.out);\n            }\n            else {\n                exitStatus = execute(parseResult, cliOptions);\n                errorCounter = exitStatus;\n            }\n        }\n        catch (ParameterException exc) {\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n            System.err.println(exc.getMessage());\n            System.err.println(\"Usage: checkstyle [OPTIONS]... file(s) or folder(s) ...\");\n            System.err.println(\"Try 'checkstyle --help' for more information.\");\n        }\n        catch (CheckstyleException exc) {\n            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n            errorCounter = 1;\n            exc.printStackTrace();\n        }\n        finally {\n            // return exit code base on validation of Checker\n            if (errorCounter > 0) {\n                final LocalizedMessage errorCounterViolation = new LocalizedMessage(\n                        Definitions.CHECKSTYLE_BUNDLE, Main.class,\n                        ERROR_COUNTER, String.valueOf(errorCounter));\n                // print error count statistic to error output stream,\n                // output stream might be used by validation report content\n                System.err.println(errorCounterViolation.getMessage());\n            }\n        }\n        Runtime.getRuntime().exit(exitStatus);\n    }",
      "/**\n     * Validates the user input and returns {@value #EXIT_WITH_INVALID_USER_INPUT_CODE} if\n     * invalid, otherwise executes CheckStyle and returns the number of violations.\n     *\n     * @param parseResult generic access to options and parameters found on the command line\n     * @param options encapsulates options and parameters specified on the command line\n     * @return number of violations\n     * @throws IOException if a file could not be read.\n     * @throws CheckstyleException if something happens processing the files.\n     * @noinspection UseOfSystemOutOrSystemErr\n     * @noinspectionreason UseOfSystemOutOrSystemErr - driver class for Checkstyle requires\n     *      usage of System.out and System.err\n     */\n    private static int execute(ParseResult parseResult, CliOptions options)\n            throws IOException, CheckstyleException {\n\n        final int exitStatus;\n\n        // return error if something is wrong in arguments\n        final List<File> filesToProcess = getFilesToProcess(options);\n        final List<String> messages = options.validateCli(parseResult, filesToProcess);\n        final boolean hasMessages = !messages.isEmpty();\n        if (hasMessages) {\n            messages.forEach(System.out::println);\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n        }\n        else {\n            exitStatus = runCli(options, filesToProcess);\n        }\n        return exitStatus;\n    }",
      "/**\n         * Validates the user-specified command line options.\n         *\n         * @param parseResult used to verify if the format option was specified on the command line\n         * @param filesToProcess the list of files whose style to check\n         * @return list of violations\n         */\n        // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation\n        private List<String> validateCli(ParseResult parseResult, List<File> filesToProcess) {\n            final List<String> result = new ArrayList<>();\n            final boolean hasConfigurationFile = configurationFile != null;\n            final boolean hasSuppressionLineColumnNumber = suppressionLineColumnNumber != null;\n\n            if (filesToProcess.isEmpty()) {\n                result.add(\"Files to process must be specified, found 0.\");\n            }\n            // ensure there is no conflicting options\n            else if (printAst || printAstWithComments || printJavadocTree || printTreeWithJavadoc\n                || xpath != null) {\n                if (suppressionLineColumnNumber != null || configurationFile != null\n                        || propertiesFile != null || outputPath != null\n                        || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n                    result.add(\"Option '-t' cannot be used with other options.\");\n                }\n                else if (filesToProcess.size() > 1) {\n                    result.add(\"Printing AST is allowed for only one file.\");\n                }\n            }\n            else if (hasSuppressionLineColumnNumber) {\n                if (configurationFile != null || propertiesFile != null\n                        || outputPath != null\n                        || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n                    result.add(\"Option '-s' cannot be used with other options.\");\n                }\n                else if (filesToProcess.size() > 1) {\n                    result.add(\"Printing xpath suppressions is allowed for only one file.\");\n                }\n            }\n            else if (hasConfigurationFile) {\n                try {\n                    // test location only\n                    CommonUtil.getUriByFilename(configurationFile);\n                }\n                catch (CheckstyleException ignored) {\n                    final String msg = \"Could not find config XML file '%s'.\";\n                    result.add(String.format(Locale.ROOT, msg, configurationFile));\n                }\n                result.addAll(validateOptionalCliParametersIfConfigDefined());\n            }\n            else {\n                result.add(\"Must specify a config XML file.\");\n            }\n\n            return result;\n        }",
      "/** Returns whether an option whose aliases include the specified name was matched on the command line.\n         * @param name used to search the matched options. May be an alias of the option name that was actually specified on the command line.\n         *      The specified name may include option name prefix characters or not. */\n        public boolean hasMatchedOption(String name)        { return matchedOption(name) != null; }"
    ]
  },
  {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.xpath.iterators.PrecedingIterator.next",
    "thirdPartyMethod" : "net.sf.saxon.tree.util.Navigator.EmptyTextFilter.next",
    "thirdPartyPackage" : "net.sf.saxon.tree.util",
    "path" : [ "com.puppycrawl.tools.checkstyle.xpath.iterators.PrecedingIterator.next", "net.sf.saxon.tree.util.Navigator.EmptyTextFilter.next" ],
    "fullMethods" : [
      "/**\n     * Get the next item in the sequence.\n     *\n     * @return the next Item. If there are no more nodes, return null.\n     */\n    @Override\n    public NodeInfo next() {\n        NodeInfo result = null;\n\n        while (result == null) {\n            if (descendantEnum != null) {\n                result = descendantEnum.next();\n            }\n\n            if (result == null && previousSiblingEnum != null) {\n                result = previousSiblingEnum.next();\n                if (result == null) {\n                    previousSiblingEnum = null;\n                }\n                else {\n                    descendantEnum = new ReverseDescendantIterator(result);\n                }\n            }\n\n            if (result == null) {\n                result = ancestorEnum.next();\n                if (result == null) {\n                    break;\n                }\n                previousSiblingEnum = result.iterateAxis(AxisInfo.PRECEDING_SIBLING);\n            }\n        }\n        return result;\n    }",
      " @Override\n        public NodeInfo next() {\n            while (true) {\n                NodeInfo next = base.next();\n                if (next == null) {\n                    return null;\n                }\n                if (!(next.getNodeKind() == Type.TEXT && next.getUnicodeStringValue().isEmpty())) {\n                    return next;\n                }\n            }\n        }"
    ]
  }
]