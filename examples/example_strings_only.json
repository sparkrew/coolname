[
  {
    "entryPoint" : "com.graphhopper.util.GHUtility.loadCustomModelFromJar",
    "entryPointBody" : "public static CustomModel loadCustomModelFromJar(String name) {\n        try {\n            InputStream is = GHUtility.class.getResourceAsStream(\"/com/graphhopper/custom_models/\" + name);\n            if (is == null)\n                throw new IllegalArgumentException(\"There is no built-in custom model '\" + name + \"'\");\n            String json = readJSONFileWithoutComments(new InputStreamReader(is));\n            ObjectMapper objectMapper = Jackson.newObjectMapper();\n            return objectMapper.readValue(json, CustomModel.class);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(\"Could not load built-in custom model '\" + name + \"'\", e);\n        }\n    }",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.readValue",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.util.GHUtility.loadCustomModelFromJar", "com.fasterxml.jackson.databind.ObjectMapper.readValue" ]
  },
  {
    "entryPoint" : "com.graphhopper.reader.osm.WaySegmentParser.Pass2Handler.handleNode",
    "entryPointBody" : "@Override\n        public void handleNode(ReaderNode node) {\n            if (!handledNodes) {\n                LOGGER.info(\"pass2 - start reading OSM nodes\");\n                handledNodes = true;\n            }\n            if (handledWays)\n                throw new IllegalStateException(\"OSM node elements must be located before way elements in OSM file\");\n            if (handledRelations)\n                throw new IllegalStateException(\"OSM node elements must be located before relation elements in OSM file\");\n\n            if (++nodeCounter % 10_000_000 == 0)\n                LOGGER.info(\"pass2 - processed nodes: \" + nf(nodeCounter) + \", accepted nodes: \" + nf(acceptedNodes) +\n                        \", \" + Helper.getMemInfo());\n\n            long nodeType = nodeData.addCoordinatesIfMapped(node.getId(), node.getLat(), node.getLon(), () -> elevationProvider.applyAsDouble(node));\n            if (nodeType == EMPTY_NODE)\n                return;\n\n            acceptedNodes++;\n\n            // remember which nodes we want to split\n            if (splitNodeFilter.test(node)) {\n                if (nodeType == JUNCTION_NODE) {\n                    LOGGER.debug(\"OSM node {} at {},{} is a barrier node at a junction. The barrier will be ignored\",\n                            node.getId(), Helper.round(node.getLat(), 7), Helper.round(node.getLon(), 7));\n                    ignoredSplitNodes++;\n                } else\n                    nodeData.setSplitNode(node.getId());\n            }\n\n            // store node tags if at least one important tag is included and make this available for the edge handler\n            for (Map.Entry<String, Object> e : node.getTags().entrySet()) {\n                if (INCLUDE_IF_NODE_TAGS.contains(e.getKey())) {\n                    node.removeTag(\"created_by\");\n                    node.removeTag(\"source\");\n                    node.removeTag(\"note\");\n                    node.removeTag(\"fixme\");\n                    nodeData.setTags(node);\n                    break;\n                }\n            }\n        }",
    "thirdPartyMethod" : "org.slf4j.LoggerFactory.getLogger",
    "thirdPartyPackage" : "org.slf4j",
    "path" : [ "com.graphhopper.reader.osm.WaySegmentParser.Pass2Handler.handleNode", "com.graphhopper.reader.osm.WaySegmentParser.<clinit>", "org.slf4j.LoggerFactory.getLogger" ]
  },
  {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.Main.main",
    "entryPointBody" : "/**\n     * Loops over the files specified checking them for errors. The exit code\n     * is the number of errors found in all the files.\n     *\n     * @param args the command line arguments.\n     * @throws IOException if there is a problem with files access\n     * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace, CallToSystemExit\n     * @noinspectionreason UseOfSystemOutOrSystemErr - driver class for Checkstyle requires\n     *      usage of System.out and System.err\n     * @noinspectionreason CallToPrintStackTrace - driver class for Checkstyle must be able to\n     *      show all details in case of failure\n     * @noinspectionreason CallToSystemExit - driver class must call exit\n     **/\n    public static void main(String... args) throws IOException {\n\n        final CliOptions cliOptions = new CliOptions();\n        final CommandLine commandLine = new CommandLine(cliOptions);\n        commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n        commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n\n        // provide proper exit code based on results.\n        int exitStatus = 0;\n        int errorCounter = 0;\n        try {\n            final ParseResult parseResult = commandLine.parseArgs(args);\n            if (parseResult.isVersionHelpRequested()) {\n                printVersionToSystemOutput();\n            }\n            else if (parseResult.isUsageHelpRequested()) {\n                commandLine.usage(System.out);\n            }\n            else {\n                exitStatus = execute(parseResult, cliOptions);\n                errorCounter = exitStatus;\n            }\n        }\n        catch (ParameterException exc) {\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n            System.err.println(exc.getMessage());\n            System.err.println(\"Usage: checkstyle [OPTIONS]... file(s) or folder(s) ...\");\n            System.err.println(\"Try 'checkstyle --help' for more information.\");\n        }\n        catch (CheckstyleException exc) {\n            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n            errorCounter = 1;\n            exc.printStackTrace();\n        }\n        finally {\n            // return exit code base on validation of Checker\n            if (errorCounter > 0) {\n                final LocalizedMessage errorCounterViolation = new LocalizedMessage(\n                        Definitions.CHECKSTYLE_BUNDLE, Main.class,\n                        ERROR_COUNTER, String.valueOf(errorCounter));\n                // print error count statistic to error output stream,\n                // output stream might be used by validation report content\n                System.err.println(errorCounterViolation.getMessage());\n            }\n        }\n        Runtime.getRuntime().exit(exitStatus);\n    }",
    "thirdPartyMethod" : "picocli.CommandLine.ParseResult.hasMatchedOption",
    "thirdPartyPackage" : "picocli.CommandLine",
    "path" : [ "com.puppycrawl.tools.checkstyle.Main.main", "com.puppycrawl.tools.checkstyle.Main.execute", "com.puppycrawl.tools.checkstyle.Main.CliOptions.validateCli", "picocli.CommandLine.ParseResult.hasMatchedOption" ]
  },
  {
    "entryPoint" : "com.puppycrawl.tools.checkstyle.xpath.iterators.PrecedingIterator.next",
    "entryPointBody" : "/**\n     * Get the next item in the sequence.\n     *\n     * @return the next Item. If there are no more nodes, return null.\n     */\n    @Override\n    public NodeInfo next() {\n        NodeInfo result = null;\n\n        while (result == null) {\n            if (descendantEnum != null) {\n                result = descendantEnum.next();\n            }\n\n            if (result == null && previousSiblingEnum != null) {\n                result = previousSiblingEnum.next();\n                if (result == null) {\n                    previousSiblingEnum = null;\n                }\n                else {\n                    descendantEnum = new ReverseDescendantIterator(result);\n                }\n            }\n\n            if (result == null) {\n                result = ancestorEnum.next();\n                if (result == null) {\n                    break;\n                }\n                previousSiblingEnum = result.iterateAxis(AxisInfo.PRECEDING_SIBLING);\n            }\n        }\n        return result;\n    }",
    "thirdPartyMethod" : "net.sf.saxon.tree.util.Navigator.EmptyTextFilter.next",
    "thirdPartyPackage" : "net.sf.saxon.tree.util",
    "path" : [ "com.puppycrawl.tools.checkstyle.xpath.iterators.PrecedingIterator.next", "net.sf.saxon.tree.util.Navigator.EmptyTextFilter.next" ]
  }
]