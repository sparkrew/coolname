{
  "slicedPaths" : [ {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.read",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.KryoException.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.read", "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.require" ],
    "methodSlices" : [ "@Override\npublic int read() throws KryoException {\n    require(1)\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.zip.ZipFile.getInputStream",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.zip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.createInstance",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.createInstance", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.checkKryoInitialized", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic T createInstance() {\n}", "private void checkKryoInitialized() {\n    if (this.kryo == null) {\n        this.kryo = getKryoInstance();\n        // Enable reference tracking.\n        kryo.setReferences(true);\n        // Throwable and all subclasses should be serialized via java serialization\n        // Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.\n        // This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for\n        // details.\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n        // Add default serializers first, so that the type registrations without a serializer\n        // are registered with a default serializer\n        for (Map.Entry<Class<?>, SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n        }\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n        }\n        KryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values(), flinkChillPackageRegistrar != null ? flinkChillPackageRegistrar.getNextRegistrationId() : kryo.getNextRegistrationId());\n        kryo.setRegistrationRequired(false);\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializerSnapshot<T> oldSerializerSnapshot) {\n}", "@Override\npublic TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializerSnapshot<T> oldSerializerSnapshot) {\n}", "private TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(MergeResult<Class<?>, SerializableSerializer<?>> reconfiguredDefaultKryoSerializers, MergeResult<Class<?>, Class<? extends Serializer<?>>> reconfiguredDefaultKryoSerializerClasses, MergeResult<String, KryoRegistration> reconfiguredRegistrations) {\n    if ((reconfiguredDefaultKryoSerializers.isOrderedSubset() && reconfiguredDefaultKryoSerializerClasses.isOrderedSubset()) && reconfiguredRegistrations.isOrderedSubset()) {\n        return TypeSerializerSchemaCompatibility.compatibleAsIs();\n    }\n    // reconfigure a new KryoSerializer\n    KryoSerializer<T> reconfiguredSerializer = new KryoSerializer<>(snapshotData.getTypeClass(), reconfiguredDefaultKryoSerializers.getMerged(), reconfiguredDefaultKryoSerializerClasses.getMerged(), reconfiguredRegistrations.getMerged());\n    return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(reconfiguredSerializer);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<init>",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<init>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "// ------------------------------------------------------------------------\npublic KryoSerializer(Class<T> type, SerializerConfig serializerConfig) {\n    this.type = checkNotNull(type);\n    this.defaultSerializers = ((SerializerConfigImpl) (serializerConfig)).getDefaultKryoSerializers();\n    this.defaultSerializerClasses = serializerConfig.getDefaultKryoSerializerClasses();\n    this.kryoRegistrations = buildKryoRegistrations(this.type, serializerConfig.getRegisteredKryoTypes(), serializerConfig.getRegisteredTypesWithKryoSerializerClasses(), ((SerializerConfigImpl) (serializerConfig)).getRegisteredTypesWithKryoSerializers(), serializerConfig.isForceKryoAvroEnabled());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.restoreSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.restoreSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic TypeSerializer<T> restoreSerializer() {\n    return new KryoSerializer<>(snapshotData.getTypeClass(), snapshotData.getDefaultKryoSerializers().unwrapOptionals(), snapshotData.getDefaultKryoSerializerClasses().unwrapOptionals(), snapshotData.getKryoRegistrations().unwrapOptionals());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic void copy(DataInputView source, DataOutputView target) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (this.copyInstance == null) {\n            this.copyInstance = createInstance();\n        }\n        T tmp = deserialize(copyInstance, source);\n        serialize(tmp, target);\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.deserialize",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.deserialize", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic T deserialize(DataInputView source) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (source != previousIn) {\n            DataInputViewStream inputStream = new DataInputViewStream(source);\n            input = new NoFetchingInput(inputStream);\n            previousIn = source;\n        }\n        try {\n            return ((T) (kryo.readClassAndObject(input)));\n        } catch (KryoBufferUnderflowException ke) {\n            // 2023-04-26: Existing Flink code expects a java.io.EOFException in this scenario\n            throw new EOFException(ke.getMessage());\n        } catch (KryoException ke) {\n            Throwable cause = ke.getCause();\n            if (cause instanceof EOFException) {\n                throw ((EOFException) (cause));\n            } else {\n                throw ke;\n            }\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.PojoTypeInfo.createSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.PojoTypeInfo.createSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\n@PublicEvolving\n@SuppressWarnings(\"unchecked\")\npublic TypeSerializer<T> createSerializer(SerializerConfig config) {\n    if (config.isForceKryoEnabled()) {\n        return new KryoSerializer<>(getTypeClass(), config);\n    }\n    if (config.isForceAvroEnabled()) {\n        return AvroUtils.getAvroUtils().createAvroSerializer(getTypeClass());\n    }\n    return createPojoSerializer(config);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.GenericTypeInfo.createSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.GenericTypeInfo.createSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\n@PublicEvolving\npublic TypeSerializer<T> createSerializer(SerializerConfig config) {\n    if (config.hasGenericTypesDisabled()) {\n        throw new UnsupportedOperationException((\"Generic types have been disabled in the ExecutionConfig and type \" + this.typeClass.getName()) + \" is treated as a generic type.\");\n    }\n    return new KryoSerializer<T>(this.typeClass, config);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.serialize",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.serialize", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic void serialize(T record, DataOutputView target) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (target != previousOut) {\n            DataOutputViewStream outputStream = new DataOutputViewStream(target);\n            output = new Output(outputStream);\n            previousOut = target;\n        }\n        // Sanity check: Make sure that the output is cleared/has been flushed by the last call\n        // otherwise data might be written multiple times in case of a previous EOFException\n        if (output.position() != 0) {\n            throw new IllegalStateException(\"The Kryo Output still contains data from a previous \" + \"serialize call. It has to be flushed or cleared at the end of the serialize call.\");\n        }\n        try {\n            kryo.writeClassAndObject(output, record);\n            output.flush();\n        } catch (KryoException ke) {\n            // make sure that the Kryo output buffer is reset in case that we can recover from\n            // the exception (e.g. EOFException which denotes buffer full)\n            output.reset();\n            Throwable cause = ke.getCause();\n            if (cause instanceof EOFException) {\n                throw ((EOFException) (cause));\n            } else {\n                throw ke;\n            }\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic T copy(T from) {\n    if (from == null) {\n        return null;\n    }\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        try {\n            return kryo.copy(from);\n        } catch (KryoException ke) {\n            // kryo was unable to copy it, so we do it through serialization:\n            ByteArrayOutputStream baout = new ByteArrayOutputStream();\n            Output output = new Output(baout);\n            kryo.writeObject(output, from);\n            output.close();\n            ByteArrayInputStream bain = new ByteArrayInputStream(baout.toByteArray());\n            Input input = new Input(bain);\n            return ((T) (kryo.readObject(input, from.getClass())));\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.getKryo",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.getKryo", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.checkKryoInitialized", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@VisibleForTesting\npublic Kryo getKryo() {\n    checkKryoInitialized()\n}", "private void checkKryoInitialized() {\n    if (this.kryo == null) {\n        this.kryo = getKryoInstance();\n        // Enable reference tracking.\n        kryo.setReferences(true);\n        // Throwable and all subclasses should be serialized via java serialization\n        // Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.\n        // This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for\n        // details.\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n        // Add default serializers first, so that the type registrations without a serializer\n        // are registered with a default serializer\n        for (Map.Entry<Class<?>, SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n        }\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n        }\n        KryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values(), flinkChillPackageRegistrar != null ? flinkChillPackageRegistrar.getNextRegistrationId() : kryo.getNextRegistrationId());\n        kryo.setRegistrationRequired(false);\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.duplicate",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.setLogger",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.duplicate", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic KryoSerializer<T> duplicate() {\n    return new KryoSerializer<>(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.YamlParserUtils.FlinkConfigRepresenter.<init>",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.representer.StandardRepresenter.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.representer",
    "path" : [ "org.apache.flink.configuration.YamlParserUtils.FlinkConfigRepresenter.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.util.ObjectMap.get",
    "thirdPartyPackage" : "com.esotericsoftware.kryo.util",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.write",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.util.ObjectMap.get",
    "thirdPartyPackage" : "com.esotericsoftware.kryo.util",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.write" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.tar.TarArchiveEntry.getName",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.tar",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava", "org.apache.flink.util.CompressionUtils.unpackEntry" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}", "// Follow the pattern suggested in\n// https://commons.apache.org/proper/commons-compress/examples.html\nprivate static void extractTarFileUsingJava(String inFilePath, String targetDirPath, boolean gzipped) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.KryoException.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.write",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.KryoException.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.write" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.GlobalConfiguration.loadConfiguration",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.GlobalConfiguration.loadConfiguration", "org.apache.flink.configuration.GlobalConfiguration.loadYAMLResource", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "/**\n * Loads the configuration files from the specified directory. If the dynamic properties\n * configuration is not null, then it is added to the loaded configuration.\n *\n * @param configDir\n * \t\tdirectory to load the configuration from\n * @param dynamicProperties\n * \t\tconfiguration file containing the dynamic properties. Null if none.\n * @return The configuration loaded from the given configuration directory\n */\npublic static Configuration loadConfiguration(final String configDir, @Nullable\nfinal Configuration dynamicProperties) {\n}", "/**\n * Loads a YAML-file of key-value pairs.\n *\n * <p>Keys can be expressed either as nested keys or as {@literal KEY_SEPARATOR} separated keys.\n * For example, the following configurations are equivalent:\n *\n * <pre>\n * jobmanager.rpc.address: localhost # network address for communication with the job manager\n * jobmanager.rpc.port   : 6123      # network port to connect to for communication with the job manager\n * taskmanager.rpc.port  : 6122      # network port the task manager expects incoming IPC connections\n * </pre>\n *\n * <pre>\n * jobmanager:\n *     rpc:\n *         address: localhost # network address for communication with the job manager\n *         port: 6123         # network port to connect to for communication with the job manager\n * taskmanager:\n *     rpc:\n *         port: 6122         # network port the task manager expects incoming IPC connections\n * </pre>\n *\n * @param file\n * \t\tthe YAML file to read from\n * @see <a href=\"http://www.yaml.org/spec/1.2/spec.html\">YAML 1.2 specification</a>\n */\nprivate static Configuration loadYAMLResource(File file) {\n    final Configuration config = new Configuration();\n    try {\n        Map<String, Object> configDocument = flatten(YamlParserUtils.loadYamlFile(file));\n        configDocument.forEach((k, v) -> config.setValueInternal(k, v, false));\n        return config;\n    } catch (Exception e) {\n        throw new RuntimeException(\"Error parsing YAML configuration.\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.YamlParserUtils.convertToObject",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.YamlParserUtils.convertToObject", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "public static synchronized <T> T convertToObject(String value, Class<T> type) {\n    try {\n        return type.cast(loader.loadFromString(value));\n    } catch (MarkedYamlEngineException exception) {\n        throw wrapExceptionToHiddenSensitiveData(exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.YamlParserUtils.convertAndDumpYamlFromFlatMap",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.YamlParserUtils.convertAndDumpYamlFromFlatMap", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "/**\n * Converts a flat map into a nested map structure and outputs the result as a list of\n * YAML-formatted strings. Each item in the list represents a single line of the YAML data. The\n * method is synchronized and thus thread-safe.\n *\n * @param flattenMap\n * \t\tA map containing flattened keys (e.g., \"parent.child.key\") associated with\n * \t\ttheir values.\n * @return A list of strings that represents the YAML data, where each item corresponds to a\nline of the data.\n */\n@SuppressWarnings(\"unchecked\")\npublic static synchronized List<String> convertAndDumpYamlFromFlatMap(Map<String, Object> flattenMap) {\n    try {\n        Map<String, Object> nestedMap = new LinkedHashMap<>();\n        for (Map.Entry<String, Object> entry : flattenMap.entrySet()) {\n            String[] keys = entry.getKey().split(\"\\\\.\");\n            Map<String, Object> currentMap = nestedMap;\n            for (int i = 0; i < (keys.length - 1); i++) {\n                currentMap = ((Map<String, Object>) (currentMap.computeIfAbsent(keys[i], k -> new LinkedHashMap<>())));\n            }\n            currentMap.put(keys[keys.length - 1], entry.getValue());\n        }\n        String data = blockerDumper.dumpToString(nestedMap);\n        String linebreak = blockerDumperSettings.getBestLineBreak();\n        return Arrays.asList(data.split(linebreak));\n    } catch (MarkedYamlEngineException exception) {\n        throw wrapExceptionToHiddenSensitiveData(exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.DelegatingConfiguration.toFileWritableMap",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.DelegatingConfiguration.toFileWritableMap", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Map<String, String> toFileWritableMap() {\n    Map<String, String> map = backingConfig.toFileWritableMap();\n    Map<String, String> prefixed = new HashMap<>();\n    for (Map.Entry<String, String> entry : map.entrySet()) {\n        if (entry.getKey().startsWith(prefix)) {\n            String keyWithoutPrefix = entry.getKey().substring(prefix.length());\n            prefixed.put(keyWithoutPrefix, YamlParserUtils.toYAMLString(entry.getValue()));\n        }\n    }\n    return prefixed;\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.ConfigurationUtils.convertConfigToWritableLines",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.ConfigurationUtils.convertConfigToWritableLines", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "/**\n * Converts the provided configuration data into a format suitable for writing to a file, based\n * on the {@code flattenYaml} flag and the {@code standardYaml} attribute of the configuration\n * object.\n *\n * <p>Only when {@code flattenYaml} is set to {@code false} and the configuration object is\n * standard yaml, a nested YAML format is used. Otherwise, a flat key-value pair format is\n * output.\n *\n * <p>Each entry in the returned list represents a single line that can be written directly to a\n * file.\n *\n * <p>Example input (flat map configuration data):\n *\n * <pre>{@code {\n *      \"parent.child\": \"value1\",\n *      \"parent.child2\": \"value2\"\n * }}</pre>\n *\n * <p>Example output when {@code flattenYaml} is {@code false} and the configuration object is\n * standard yaml:\n *\n * <pre>{@code parent:\n *   child: value1\n *   child2: value2}</pre>\n *\n * <p>Otherwise, the Example output is:\n *\n * <pre>{@code parent.child: value1\n * parent.child2: value2}</pre>\n *\n * @param configuration\n * \t\tThe configuration to be converted.\n * @param flattenYaml\n * \t\tA boolean flag indicating if the configuration data should be output in a\n * \t\tflattened format.\n * @return A list of strings, where each string represents a line of the file-writable data in\nthe chosen format.\n */\npublic static List<String> convertConfigToWritableLines(Configuration configuration, boolean flattenYaml) {\n    if (!flattenYaml) {\n        return YamlParserUtils.convertAndDumpYamlFromFlatMap(Collections.unmodifiableMap(configuration.confData));\n    } else {\n        Map<String, String> fileWritableMap = configuration.toFileWritableMap();\n        return fileWritableMap.entrySet().stream().map(entry -> (entry.getKey() + \": \") + entry.getValue()).collect(Collectors.toList());\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.YamlParserUtils.loadYamlFile",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.YamlParserUtils.loadYamlFile", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "/**\n * Loads the contents of the given YAML file into a map.\n *\n * @param file\n * \t\tthe YAML file to load.\n * @return a non-null map representing the YAML content. If the file is empty or only contains\ncomments, an empty map is returned.\n * @throws FileNotFoundException\n * \t\tif the YAML file is not found.\n * @throws YamlEngineException\n * \t\tif the file cannot be parsed.\n * @throws IOException\n * \t\tif an I/O error occurs while reading from the file stream.\n */\n@Nonnull\npublic static synchronized Map<String, Object> loadYamlFile(File file) throws Exception {\n    try (FileInputStream inputStream = new FileInputStream(file)) {\n        Map<String, Object> yamlResult = ((Map<String, Object>) (loader.loadFromInputStream(inputStream)));\n        return yamlResult == null ? new HashMap<>() : yamlResult;\n    } catch (FileNotFoundException e) {\n        LOG.error(\"Failed to find YAML file\", e);\n        throw e;\n    } catch (IOException | YamlEngineException e) {\n        if (e instanceof MarkedYamlEngineException) {\n            YamlEngineException exception = wrapExceptionToHiddenSensitiveData(((MarkedYamlEngineException) (e)));\n            LOG.error(\"Failed to parse YAML configuration\", exception);\n            throw exception;\n        } else {\n            throw e;\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.ConfigurationUtils.parseMapToString",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.ConfigurationUtils.parseMapToString", "org.apache.flink.configuration.ConfigurationUtils.convertToString", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "public static String parseMapToString(Map<String, String> map) {\n}", "static String convertToString(Object o) {\n    if (o.getClass() == String.class) {\n        return ((String) (o));\n    } else {\n        return YamlParserUtils.toYAMLString(o);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.Configuration.toMap",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.Configuration.toMap", "org.apache.flink.configuration.ConfigurationUtils.convertToString", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "// --------------------------------------------------------------------------------------------\n@Override\npublic Map<String, String> toMap() {\n}", "static String convertToString(Object o) {\n    if (o.getClass() == String.class) {\n        return ((String) (o));\n    } else {\n        return YamlParserUtils.toYAMLString(o);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.YamlParserUtils.toYAMLString",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.YamlParserUtils.toYAMLString", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "/**\n * Converts the given value to a string representation in the YAML syntax. This method uses a\n * YAML parser to convert the object to YAML format.\n *\n * <p>The resulting YAML string may have line breaks at the end of each line. This method\n * removes the line break at the end of the string if it exists.\n *\n * <p>Note: This method may perform escaping on certain characters in the value to ensure proper\n * YAML syntax.\n *\n * @param value\n * \t\tThe value to be converted.\n * @return The string representation of the value in YAML syntax.\n */\npublic static synchronized String toYAMLString(Object value) {\n    try {\n        String output = flowDumper.dumpToString(value);\n        // remove the line break\n        String linebreak = flowDumperSettings.getBestLineBreak();\n        if (output.endsWith(linebreak)) {\n            output = output.substring(0, output.length() - linebreak.length());\n        }\n        return output;\n    } catch (MarkedYamlEngineException exception) {\n        throw wrapExceptionToHiddenSensitiveData(exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.ConfigurationUtils.convertToList",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.ConfigurationUtils.convertToList", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic static <T> T convertToList(Object rawValue, Class<?> atomicClass) {\n    if (rawValue instanceof List) {\n        return ((T) (rawValue));\n    } else {\n        try {\n            List<Object> data = YamlParserUtils.convertToObject(rawValue.toString(), List.class);\n            // The Yaml parser conversion results in data of type List<Map<Object, Object>>,\n            // such as List<Map<Object, Boolean>>. However, ConfigOption currently requires that\n            // the data for Map type be strictly of the type Map<String, String>. Therefore, we\n            // convert each map in the list to Map<String, String>.\n            if (atomicClass == Map.class) {\n                return ((T) (data.stream().map(map -> convertToStringMap(((Map<Object, Object>) (map)))).collect(Collectors.toList())));\n            }\n            return ((T) (data.stream().map(s -> convertValue(s, atomicClass)).collect(Collectors.toList())));\n        } catch (Exception e) {\n            // Fallback to legacy pattern\n            return convertToListWithLegacyProperties(rawValue, atomicClass);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.ConfigurationUtils.convertValue",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.ConfigurationUtils.convertValue", "org.apache.flink.configuration.ConfigurationUtils.convertToString", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "// --------------------------------------------------------------------------------------------\n// Type conversion\n// --------------------------------------------------------------------------------------------\n/**\n * Tries to convert the raw value into the provided type.\n *\n * @param rawValue\n * \t\trawValue to convert into the provided type clazz\n * @param clazz\n * \t\tclazz specifying the target type\n * @param <T>\n * \t\ttype of the result\n * @return the converted value if rawValue is of type clazz\n * @throws IllegalArgumentException\n * \t\tif the rawValue cannot be converted in the specified target\n * \t\ttype clazz\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T convertValue(Object rawValue, Class<?> clazz) {\n}", "static String convertToString(Object o) {\n    if (o.getClass() == String.class) {\n        return ((String) (o));\n    } else {\n        return YamlParserUtils.toYAMLString(o);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.ConfigurationUtils.parseStringToMap",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.ConfigurationUtils.parseStringToMap", "org.apache.flink.configuration.ConfigurationUtils.convertToProperties", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "/**\n * Parses a string as a map of strings. The expected format of the map to be parsed` by FLINK\n * parser is:\n *\n * <pre>\n * key1:value1,key2:value2\n * </pre>\n *\n * <p>The expected format of the map to be parsed by standard YAML parser is:\n *\n * <pre>\n * {key1: value1, key2: value2}\n * </pre>\n *\n * <p>Parts of the string can be escaped by wrapping with single or double quotes.\n *\n * @param stringSerializedMap\n * \t\ta string to parse\n * @return parsed map\n */\npublic static Map<String, String> parseStringToMap(String stringSerializedMap) {\n}", "@SuppressWarnings(\"unchecked\")\nstatic Map<String, String> convertToProperties(Object o) {\n    if (o instanceof Map) {\n        return ((Map<String, String>) (o));\n    } else {\n        try {\n            Map<Object, Object> map = YamlParserUtils.convertToObject(o.toString(), Map.class);\n            return convertToStringMap(map);\n        } catch (Exception e) {\n            // Fallback to legacy pattern\n            return convertToPropertiesWithLegacyPattern(o);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.Configuration.toFileWritableMap",
    "thirdPartyMethod" : "org.snakeyaml.engine.v2.api.Dump.<init>",
    "thirdPartyPackage" : "org.snakeyaml.engine.v2.api",
    "path" : [ "org.apache.flink.configuration.Configuration.toFileWritableMap", "org.apache.flink.configuration.YamlParserUtils.<clinit>" ],
    "methodSlices" : [ "/**\n * Convert Config into a {@code Map<String, String>} representation.\n *\n * <p>NOTE: This method is extracted from the {@link Configuration#toMap} method and should be\n * called when Config needs to be written to a file.\n *\n * <p>This method ensures the value is properly escaped when writing the key-value pair to a\n * standard YAML file.\n */\n@Internal\npublic Map<String, String> toFileWritableMap() {\n    synchronized(this.confData) {\n        Map<String, String> ret = CollectionUtil.newHashMapWithExpectedSize(this.confData.size());\n        for (Map.Entry<String, Object> entry : confData.entrySet()) {\n            // Because some character in standard yaml should be escaped by quotes, such as\n            // '*', here we should wrap the value by Yaml pattern\n            ret.put(entry.getKey(), YamlParserUtils.toYAMLString(entry.getValue()));\n        }\n        return ret;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.tar.TarArchiveEntry.isDirectory",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.tar",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava", "org.apache.flink.util.CompressionUtils.unpackEntry" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}", "// Follow the pattern suggested in\n// https://commons.apache.org/proper/commons-compress/examples.html\nprivate static void extractTarFileUsingJava(String inFilePath, String targetDirPath, boolean gzipped) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.duplicate",
    "thirdPartyMethod" : "org.apache.commons.lang3.exception.CloneFailedException.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3.exception",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.duplicate", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<init>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.deepCopySerializer" ],
    "methodSlices" : [ "@Override\npublic KryoSerializer<T> duplicate() {\n}", "/**\n * Copy-constructor that does not copy transient fields. They will be initialized once required.\n */\nprotected KryoSerializer(KryoSerializer<T> toCopy) {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.ExecutionConfig.configure",
    "thirdPartyMethod" : "org.apache.commons.compress.utils.Sets.newHashSet",
    "thirdPartyPackage" : "org.apache.commons.compress.utils",
    "path" : [ "org.apache.flink.api.common.ExecutionConfig.configure", "org.apache.flink.configuration.RestartStrategyOptions.<clinit>", "org.apache.flink.configuration.RestartStrategyOptions.RestartStrategyType.<clinit>" ],
    "methodSlices" : [ "/**\n * Sets all relevant options contained in the {@link ReadableConfig} such as e.g. {@link PipelineOptions#CLOSURE_CLEANER_LEVEL}.\n *\n * <p>It will change the value of a setting only if a corresponding option was set in the {@code configuration}. If a key is not present, the current value of a field will remain untouched.\n *\n * @param configuration\n * \t\ta configuration to read the values from\n * @param classLoader\n * \t\ta class loader to use when loading classes\n */\npublic void configure(ReadableConfig configuration, ClassLoader classLoader) {\n    configuration.getOptional(PipelineOptions.AUTO_GENERATE_UIDS).ifPresent(this::setAutoGeneratedUids);\n    configuration.getOptional(PipelineOptions.AUTO_WATERMARK_INTERVAL).ifPresent(this::setAutoWatermarkInterval);\n    configuration.getOptional(PipelineOptions.CLOSURE_CLEANER_LEVEL).ifPresent(this::setClosureCleanerLevel);\n    configuration.getOptional(PipelineOptions.GLOBAL_JOB_PARAMETERS).ifPresent(this::setGlobalJobParameters);\n    configuration.getOptional(MetricOptions.LATENCY_INTERVAL).ifPresent(interval -> setLatencyTrackingInterval(interval.toMillis()));\n    configuration.getOptional(StateChangelogOptions.PERIODIC_MATERIALIZATION_ENABLED).ifPresent(this::enablePeriodicMaterialize);\n    configuration.getOptional(StateChangelogOptions.PERIODIC_MATERIALIZATION_INTERVAL).ifPresent(this::setPeriodicMaterializeIntervalMillis);\n    configuration.getOptional(StateChangelogOptions.MATERIALIZATION_MAX_FAILURES_ALLOWED).ifPresent(this::setMaterializationMaxAllowedFailures);\n    configuration.getOptional(PipelineOptions.MAX_PARALLELISM).ifPresent(this::setMaxParallelism);\n    configuration.getOptional(CoreOptions.DEFAULT_PARALLELISM).ifPresent(this::setParallelism);\n    configuration.getOptional(PipelineOptions.OBJECT_REUSE).ifPresent(this::setObjectReuse);\n    configuration.getOptional(TaskManagerOptions.TASK_CANCELLATION_INTERVAL).ifPresent(interval -> setTaskCancellationInterval(interval.toMillis()));\n    configuration.getOptional(TaskManagerOptions.TASK_CANCELLATION_TIMEOUT).ifPresent(timeout -> setTaskCancellationTimeout(timeout.toMillis()));\n    configuration.getOptional(ExecutionOptions.SNAPSHOT_COMPRESSION).ifPresent(this::setUseSnapshotCompression);\n    configuration.getOptional(RestartStrategyOptions.RESTART_STRATEGY).ifPresent(s -> this.setRestartStrategy(configuration));\n    configuration.getOptional(JobManagerOptions.SCHEDULER).ifPresent(t -> this.configuration.set(JobManagerOptions.SCHEDULER, t));\n    serializerConfig.configure(configuration, classLoader);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.RestartStrategyOptions.RestartStrategyType.values",
    "thirdPartyMethod" : "org.apache.commons.compress.utils.Sets.newHashSet",
    "thirdPartyPackage" : "org.apache.commons.compress.utils",
    "path" : [ "org.apache.flink.configuration.RestartStrategyOptions.RestartStrategyType.values", "org.apache.flink.configuration.RestartStrategyOptions.RestartStrategyType.<clinit>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.RestartStrategyDescriptionUtils.getRestartStrategyDescription",
    "thirdPartyMethod" : "org.apache.commons.compress.utils.Sets.newHashSet",
    "thirdPartyPackage" : "org.apache.commons.compress.utils",
    "path" : [ "org.apache.flink.api.common.RestartStrategyDescriptionUtils.getRestartStrategyDescription", "org.apache.flink.configuration.RestartStrategyOptions.<clinit>", "org.apache.flink.configuration.RestartStrategyOptions.RestartStrategyType.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns a descriptive string of the restart strategy configured in the given Configuration\n * object.\n *\n * @param configuration\n * \t\tthe Configuration to extract the restart strategy from\n * @return a description of the restart strategy\n */\npublic static String getRestartStrategyDescription(Configuration configuration) {\n    final Optional<String> restartStrategyNameOptional = configuration.getOptional(RestartStrategyOptions.RESTART_STRATEGY);\n    return restartStrategyNameOptional.map(restartStrategyName -> {\n        switch (RestartStrategyOptions.RestartStrategyType.of(restartStrategyName.toLowerCase())) {\n            case NO_RESTART_STRATEGY :\n                return \"Restart deactivated.\";\n            case FIXED_DELAY :\n                return getFixedDelayDescription(configuration);\n            case FAILURE_RATE :\n                return getFailureRateDescription(configuration);\n            case EXPONENTIAL_DELAY :\n                return getExponentialDelayDescription(configuration);\n            default :\n                throw new IllegalArgumentException((\"Unknown restart strategy \" + restartStrategyName) + \".\");\n        }\n    }).orElse(\"Cluster level default restart strategy\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.configuration.RestartStrategyOptions.RestartStrategyType.of",
    "thirdPartyMethod" : "org.apache.commons.compress.utils.Sets.newHashSet",
    "thirdPartyPackage" : "org.apache.commons.compress.utils",
    "path" : [ "org.apache.flink.configuration.RestartStrategyOptions.RestartStrategyType.of", "org.apache.flink.configuration.RestartStrategyOptions.RestartStrategyType.<clinit>" ],
    "methodSlices" : [ "/**\n * Return the corresponding RestartStrategyType based on the displayed value.\n */\npublic static RestartStrategyType of(String value) {\n    for (RestartStrategyType restartStrategyType : RestartStrategyType.values()) {\n        if (restartStrategyType.getAllAvailableValues().contains(value)) {\n            return restartStrategyType;\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"%s is an unknown value of RestartStrategyType.\", value));\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.serialize",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.io.Output.position",
    "thirdPartyPackage" : "com.esotericsoftware.kryo.io",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.serialize" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.zip.ZipFile.close",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.zip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.zip.ZipFile.getEntries",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.zip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.Kryo.getClassLoader",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.KryoUtils.copy",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.Kryo.copy",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.KryoUtils.copy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.KryoUtils.copy",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.Kryo.copy",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.KryoUtils.copy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.Kryo.copy",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.<init>",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.io.Input.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo.io",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.operators.Keys.ExpressionKeys.toString",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.join",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "org.apache.flink.api.common.operators.Keys.ExpressionKeys.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.io.compression.Bzip2InputStreamFactory.create",
    "thirdPartyMethod" : "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.compress.compressors.bzip2",
    "path" : [ "org.apache.flink.api.common.io.compression.Bzip2InputStreamFactory.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.io.compression.XZInputStreamFactory.create",
    "thirdPartyMethod" : "org.apache.commons.compress.compressors.xz.XZCompressorInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.compress.compressors.xz",
    "path" : [ "org.apache.flink.api.common.io.compression.XZInputStreamFactory.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.ClosureCleaner.clean",
    "thirdPartyMethod" : "org.apache.commons.lang3.ClassUtils.isPrimitiveOrWrapper",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "org.apache.flink.api.java.ClosureCleaner.clean", "org.apache.flink.api.java.ClosureCleaner.clean" ],
    "methodSlices" : [ "/**\n * Tries to clean the closure of the given object, if the object is a non-static inner class.\n *\n * @param func\n * \t\tThe object whose closure should be cleaned.\n * @param level\n * \t\tthe clean up level.\n * @param checkSerializable\n * \t\tFlag to indicate whether serializability should be checked after the\n * \t\tclosure cleaning attempt.\n * @throws InvalidProgramException\n * \t\tThrown, if 'checkSerializable' is true, and the object was\n * \t\tnot serializable after the closure cleaning.\n * @throws RuntimeException\n * \t\tA RuntimeException may be thrown, if the code of the class could not\n * \t\tbe loaded, in order to process during the closure cleaning.\n */\npublic static void clean(Object func, ExecutionConfig.ClosureCleanerLevel level, boolean checkSerializable) {\n    clean(func, level, checkSerializable, Collections.newSetFromMap(new IdentityHashMap<>()))\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.createInstance",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.createInstance", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.checkKryoInitialized", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@Override\npublic T createInstance() {\n}", "private void checkKryoInitialized() {\n    if (this.kryo == null) {\n        this.kryo = getKryoInstance();\n        // Enable reference tracking.\n        kryo.setReferences(true);\n        // Throwable and all subclasses should be serialized via java serialization\n        // Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.\n        // This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for\n        // details.\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n        // Add default serializers first, so that the type registrations without a serializer\n        // are registered with a default serializer\n        for (Map.Entry<Class<?>, SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n        }\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n        }\n        KryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values(), flinkChillPackageRegistrar != null ? flinkChillPackageRegistrar.getNextRegistrationId() : kryo.getNextRegistrationId());\n        kryo.setRegistrationRequired(false);\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n    }\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@Override\npublic TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializerSnapshot<T> oldSerializerSnapshot) {\n}", "@Override\npublic TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializerSnapshot<T> oldSerializerSnapshot) {\n}", "private TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(MergeResult<Class<?>, SerializableSerializer<?>> reconfiguredDefaultKryoSerializers, MergeResult<Class<?>, Class<? extends Serializer<?>>> reconfiguredDefaultKryoSerializerClasses, MergeResult<String, KryoRegistration> reconfiguredRegistrations) {\n    if ((reconfiguredDefaultKryoSerializers.isOrderedSubset() && reconfiguredDefaultKryoSerializerClasses.isOrderedSubset()) && reconfiguredRegistrations.isOrderedSubset()) {\n        return TypeSerializerSchemaCompatibility.compatibleAsIs();\n    }\n    // reconfigure a new KryoSerializer\n    KryoSerializer<T> reconfiguredSerializer = new KryoSerializer<>(snapshotData.getTypeClass(), reconfiguredDefaultKryoSerializers.getMerged(), reconfiguredDefaultKryoSerializerClasses.getMerged(), reconfiguredRegistrations.getMerged());\n    return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(reconfiguredSerializer);\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<init>",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<init>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "// ------------------------------------------------------------------------\npublic KryoSerializer(Class<T> type, SerializerConfig serializerConfig) {\n    this.type = checkNotNull(type);\n    this.defaultSerializers = ((SerializerConfigImpl) (serializerConfig)).getDefaultKryoSerializers();\n    this.defaultSerializerClasses = serializerConfig.getDefaultKryoSerializerClasses();\n    this.kryoRegistrations = buildKryoRegistrations(this.type, serializerConfig.getRegisteredKryoTypes(), serializerConfig.getRegisteredTypesWithKryoSerializerClasses(), ((SerializerConfigImpl) (serializerConfig)).getRegisteredTypesWithKryoSerializers(), serializerConfig.isForceKryoAvroEnabled());\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.restoreSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.restoreSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@Override\npublic TypeSerializer<T> restoreSerializer() {\n    return new KryoSerializer<>(snapshotData.getTypeClass(), snapshotData.getDefaultKryoSerializers().unwrapOptionals(), snapshotData.getDefaultKryoSerializerClasses().unwrapOptionals(), snapshotData.getKryoRegistrations().unwrapOptionals());\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@Override\npublic void copy(DataInputView source, DataOutputView target) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (this.copyInstance == null) {\n            this.copyInstance = createInstance();\n        }\n        T tmp = deserialize(copyInstance, source);\n        serialize(tmp, target);\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.deserialize",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.deserialize", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic T deserialize(DataInputView source) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (source != previousIn) {\n            DataInputViewStream inputStream = new DataInputViewStream(source);\n            input = new NoFetchingInput(inputStream);\n            previousIn = source;\n        }\n        try {\n            return ((T) (kryo.readClassAndObject(input)));\n        } catch (KryoBufferUnderflowException ke) {\n            // 2023-04-26: Existing Flink code expects a java.io.EOFException in this scenario\n            throw new EOFException(ke.getMessage());\n        } catch (KryoException ke) {\n            Throwable cause = ke.getCause();\n            if (cause instanceof EOFException) {\n                throw ((EOFException) (cause));\n            } else {\n                throw ke;\n            }\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.PojoTypeInfo.createSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.PojoTypeInfo.createSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@Override\n@PublicEvolving\n@SuppressWarnings(\"unchecked\")\npublic TypeSerializer<T> createSerializer(SerializerConfig config) {\n    if (config.isForceKryoEnabled()) {\n        return new KryoSerializer<>(getTypeClass(), config);\n    }\n    if (config.isForceAvroEnabled()) {\n        return AvroUtils.getAvroUtils().createAvroSerializer(getTypeClass());\n    }\n    return createPojoSerializer(config);\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.GenericTypeInfo.createSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.GenericTypeInfo.createSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@Override\n@PublicEvolving\npublic TypeSerializer<T> createSerializer(SerializerConfig config) {\n    if (config.hasGenericTypesDisabled()) {\n        throw new UnsupportedOperationException((\"Generic types have been disabled in the ExecutionConfig and type \" + this.typeClass.getName()) + \" is treated as a generic type.\");\n    }\n    return new KryoSerializer<T>(this.typeClass, config);\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.serialize",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.serialize", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@Override\npublic void serialize(T record, DataOutputView target) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (target != previousOut) {\n            DataOutputViewStream outputStream = new DataOutputViewStream(target);\n            output = new Output(outputStream);\n            previousOut = target;\n        }\n        // Sanity check: Make sure that the output is cleared/has been flushed by the last call\n        // otherwise data might be written multiple times in case of a previous EOFException\n        if (output.position() != 0) {\n            throw new IllegalStateException(\"The Kryo Output still contains data from a previous \" + \"serialize call. It has to be flushed or cleared at the end of the serialize call.\");\n        }\n        try {\n            kryo.writeClassAndObject(output, record);\n            output.flush();\n        } catch (KryoException ke) {\n            // make sure that the Kryo output buffer is reset in case that we can recover from\n            // the exception (e.g. EOFException which denotes buffer full)\n            output.reset();\n            Throwable cause = ke.getCause();\n            if (cause instanceof EOFException) {\n                throw ((EOFException) (cause));\n            } else {\n                throw ke;\n            }\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic T copy(T from) {\n    if (from == null) {\n        return null;\n    }\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        try {\n            return kryo.copy(from);\n        } catch (KryoException ke) {\n            // kryo was unable to copy it, so we do it through serialization:\n            ByteArrayOutputStream baout = new ByteArrayOutputStream();\n            Output output = new Output(baout);\n            kryo.writeObject(output, from);\n            output.close();\n            ByteArrayInputStream bain = new ByteArrayInputStream(baout.toByteArray());\n            Input input = new Input(bain);\n            return ((T) (kryo.readObject(input, from.getClass())));\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.getKryo",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.getKryo", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.checkKryoInitialized", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@VisibleForTesting\npublic Kryo getKryo() {\n    checkKryoInitialized()\n}", "private void checkKryoInitialized() {\n    if (this.kryo == null) {\n        this.kryo = getKryoInstance();\n        // Enable reference tracking.\n        kryo.setReferences(true);\n        // Throwable and all subclasses should be serialized via java serialization\n        // Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.\n        // This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for\n        // details.\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n        // Add default serializers first, so that the type registrations without a serializer\n        // are registered with a default serializer\n        for (Map.Entry<Class<?>, SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n        }\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n        }\n        KryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values(), flinkChillPackageRegistrar != null ? flinkChillPackageRegistrar.getNextRegistrationId() : kryo.getNextRegistrationId());\n        kryo.setRegistrationRequired(false);\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n    }\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.duplicate",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.Logger.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.minlog.Log",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.duplicate", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging", "org.apache.flink.api.java.typeutils.runtime.kryo.MinlogForwarder.<init>" ],
    "methodSlices" : [ "@Override\npublic KryoSerializer<T> duplicate() {\n    return new KryoSerializer<>(this);\n}", "", "static void configureKryoLogging() {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.tar.TarArchiveEntry.getDirectoryEntries",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.tar",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava", "org.apache.flink.util.CompressionUtils.unpackEntry" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}", "// Follow the pattern suggested in\n// https://commons.apache.org/proper/commons-compress/examples.html\nprivate static void extractTarFileUsingJava(String inFilePath, String targetDirPath, boolean gzipped) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.operators.util.JoinHashMap.insertOrReplace",
    "thirdPartyMethod" : "org.apache.commons.collections.map.AbstractHashedMap.HashEntry.setValue",
    "thirdPartyPackage" : "org.apache.commons.collections.map.AbstractHashedMap",
    "path" : [ "org.apache.flink.api.common.operators.util.JoinHashMap.insertOrReplace" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.read",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.KryoException.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.read" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.readBytes",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.KryoException.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.readBytes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.skip",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.KryoException.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.NoFetchingInput.skip" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.zip.ZipArchiveEntry.getName",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.zip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.tar.TarArchiveInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.tar",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.zip.ZipFile.<init>",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.zip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.<init>",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.Serializer.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.Serializers.DummyAvroKryoSerializerClass.<init>",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.Serializer.<init>",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.Serializers.DummyAvroKryoSerializerClass.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.tar.TarArchiveEntry.getLinkName",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.tar",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava", "org.apache.flink.util.CompressionUtils.unpackEntry" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}", "// Follow the pattern suggested in\n// https://commons.apache.org/proper/commons-compress/examples.html\nprivate static void extractTarFileUsingJava(String inFilePath, String targetDirPath, boolean gzipped) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.util.ObjectMap.put",
    "thirdPartyPackage" : "com.esotericsoftware.kryo.util",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.write",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.util.ObjectMap.put",
    "thirdPartyPackage" : "com.esotericsoftware.kryo.util",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.write" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.operators.util.JoinHashMap.Prober.lookupMatch",
    "thirdPartyMethod" : "org.apache.commons.collections.map.AbstractHashedMap.HashEntry.getValue",
    "thirdPartyPackage" : "org.apache.commons.collections.map.AbstractHashedMap",
    "path" : [ "org.apache.flink.api.common.operators.util.JoinHashMap.Prober.lookupMatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.operators.util.JoinHashMap.insertOrReplace",
    "thirdPartyMethod" : "org.apache.commons.collections.map.AbstractHashedMap.HashEntry.getValue",
    "thirdPartyPackage" : "org.apache.commons.collections.map.AbstractHashedMap",
    "path" : [ "org.apache.flink.api.common.operators.util.JoinHashMap.insertOrReplace" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.Kryo.getGraphContext",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.read" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.write",
    "thirdPartyMethod" : "com.esotericsoftware.kryo.Kryo.getGraphContext",
    "thirdPartyPackage" : "com.esotericsoftware.kryo",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.JavaSerializer.write" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.tar.TarArchiveEntry.isSymbolicLink",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.tar",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava", "org.apache.flink.util.CompressionUtils.unpackEntry" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}", "// Follow the pattern suggested in\n// https://commons.apache.org/proper/commons-compress/examples.html\nprivate static void extractTarFileUsingJava(String inFilePath, String targetDirPath, boolean gzipped) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.zip.ZipArchiveEntry.isDirectory",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.zip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.zip.ZipArchiveEntry.getUnixMode",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.zip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.common.operators.util.JoinHashMap.<init>",
    "thirdPartyMethod" : "org.apache.commons.collections.map.AbstractHashedMap.<init>",
    "thirdPartyPackage" : "org.apache.commons.collections.map",
    "path" : [ "org.apache.flink.api.common.operators.util.JoinHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.util.Utils.getSerializerTree",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.repeat",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "org.apache.flink.util.Utils.getSerializerTree", "org.apache.flink.util.Utils.getSerializerTree" ],
    "methodSlices" : [ "// --------------------------------------------------------------------------------------------\n/**\n * Debugging utility to understand the hierarchy of serializers created by the Java API. Tested\n * in GroupReduceITCase.testGroupByGenericType()\n */\npublic static <T> String getSerializerTree(TypeInformation<T> ti) {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.compress.compressors.gzip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.tar",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractTarFile",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.tar.TarArchiveInputStream.close",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.tar",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractTarFile", "org.apache.flink.util.CompressionUtils.extractTarFileUsingJava" ],
    "methodSlices" : [ "public static void extractTarFile(String inFilePath, String targetDirPath) throws IOException {\n}" ]
  }, {
    "entryPoint" : "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions",
    "thirdPartyMethod" : "org.apache.commons.compress.archivers.zip.ZipArchiveEntry.isUnixSymlink",
    "thirdPartyPackage" : "org.apache.commons.compress.archivers.zip",
    "path" : [ "org.apache.flink.util.CompressionUtils.extractZipFileWithPermissions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.createInstance",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.createInstance", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.checkKryoInitialized", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic T createInstance() {\n}", "private void checkKryoInitialized() {\n    if (this.kryo == null) {\n        this.kryo = getKryoInstance();\n        // Enable reference tracking.\n        kryo.setReferences(true);\n        // Throwable and all subclasses should be serialized via java serialization\n        // Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.\n        // This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for\n        // details.\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n        // Add default serializers first, so that the type registrations without a serializer\n        // are registered with a default serializer\n        for (Map.Entry<Class<?>, SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n        }\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n        }\n        KryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values(), flinkChillPackageRegistrar != null ? flinkChillPackageRegistrar.getNextRegistrationId() : kryo.getNextRegistrationId());\n        kryo.setRegistrationRequired(false);\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.resolveSchemaCompatibility", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializerSnapshot<T> oldSerializerSnapshot) {\n}", "@Override\npublic TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializerSnapshot<T> oldSerializerSnapshot) {\n}", "private TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(MergeResult<Class<?>, SerializableSerializer<?>> reconfiguredDefaultKryoSerializers, MergeResult<Class<?>, Class<? extends Serializer<?>>> reconfiguredDefaultKryoSerializerClasses, MergeResult<String, KryoRegistration> reconfiguredRegistrations) {\n    if ((reconfiguredDefaultKryoSerializers.isOrderedSubset() && reconfiguredDefaultKryoSerializerClasses.isOrderedSubset()) && reconfiguredRegistrations.isOrderedSubset()) {\n        return TypeSerializerSchemaCompatibility.compatibleAsIs();\n    }\n    // reconfigure a new KryoSerializer\n    KryoSerializer<T> reconfiguredSerializer = new KryoSerializer<>(snapshotData.getTypeClass(), reconfiguredDefaultKryoSerializers.getMerged(), reconfiguredDefaultKryoSerializerClasses.getMerged(), reconfiguredRegistrations.getMerged());\n    return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(reconfiguredSerializer);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<init>",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<init>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "// ------------------------------------------------------------------------\npublic KryoSerializer(Class<T> type, SerializerConfig serializerConfig) {\n    this.type = checkNotNull(type);\n    this.defaultSerializers = ((SerializerConfigImpl) (serializerConfig)).getDefaultKryoSerializers();\n    this.defaultSerializerClasses = serializerConfig.getDefaultKryoSerializerClasses();\n    this.kryoRegistrations = buildKryoRegistrations(this.type, serializerConfig.getRegisteredKryoTypes(), serializerConfig.getRegisteredTypesWithKryoSerializerClasses(), ((SerializerConfigImpl) (serializerConfig)).getRegisteredTypesWithKryoSerializers(), serializerConfig.isForceKryoAvroEnabled());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.restoreSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerSnapshot.restoreSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic TypeSerializer<T> restoreSerializer() {\n    return new KryoSerializer<>(snapshotData.getTypeClass(), snapshotData.getDefaultKryoSerializers().unwrapOptionals(), snapshotData.getDefaultKryoSerializerClasses().unwrapOptionals(), snapshotData.getKryoRegistrations().unwrapOptionals());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic void copy(DataInputView source, DataOutputView target) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (this.copyInstance == null) {\n            this.copyInstance = createInstance();\n        }\n        T tmp = deserialize(copyInstance, source);\n        serialize(tmp, target);\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.deserialize",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.deserialize", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic T deserialize(DataInputView source) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (source != previousIn) {\n            DataInputViewStream inputStream = new DataInputViewStream(source);\n            input = new NoFetchingInput(inputStream);\n            previousIn = source;\n        }\n        try {\n            return ((T) (kryo.readClassAndObject(input)));\n        } catch (KryoBufferUnderflowException ke) {\n            // 2023-04-26: Existing Flink code expects a java.io.EOFException in this scenario\n            throw new EOFException(ke.getMessage());\n        } catch (KryoException ke) {\n            Throwable cause = ke.getCause();\n            if (cause instanceof EOFException) {\n                throw ((EOFException) (cause));\n            } else {\n                throw ke;\n            }\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.PojoTypeInfo.createSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.PojoTypeInfo.createSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\n@PublicEvolving\n@SuppressWarnings(\"unchecked\")\npublic TypeSerializer<T> createSerializer(SerializerConfig config) {\n    if (config.isForceKryoEnabled()) {\n        return new KryoSerializer<>(getTypeClass(), config);\n    }\n    if (config.isForceAvroEnabled()) {\n        return AvroUtils.getAvroUtils().createAvroSerializer(getTypeClass());\n    }\n    return createPojoSerializer(config);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.GenericTypeInfo.createSerializer",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.GenericTypeInfo.createSerializer", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\n@PublicEvolving\npublic TypeSerializer<T> createSerializer(SerializerConfig config) {\n    if (config.hasGenericTypesDisabled()) {\n        throw new UnsupportedOperationException((\"Generic types have been disabled in the ExecutionConfig and type \" + this.typeClass.getName()) + \" is treated as a generic type.\");\n    }\n    return new KryoSerializer<T>(this.typeClass, config);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.serialize",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.serialize", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic void serialize(T record, DataOutputView target) throws IOException {\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        if (target != previousOut) {\n            DataOutputViewStream outputStream = new DataOutputViewStream(target);\n            output = new Output(outputStream);\n            previousOut = target;\n        }\n        // Sanity check: Make sure that the output is cleared/has been flushed by the last call\n        // otherwise data might be written multiple times in case of a previous EOFException\n        if (output.position() != 0) {\n            throw new IllegalStateException(\"The Kryo Output still contains data from a previous \" + \"serialize call. It has to be flushed or cleared at the end of the serialize call.\");\n        }\n        try {\n            kryo.writeClassAndObject(output, record);\n            output.flush();\n        } catch (KryoException ke) {\n            // make sure that the Kryo output buffer is reset in case that we can recover from\n            // the exception (e.g. EOFException which denotes buffer full)\n            output.reset();\n            Throwable cause = ke.getCause();\n            if (cause instanceof EOFException) {\n                throw ((EOFException) (cause));\n            } else {\n                throw ke;\n            }\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.copy", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic T copy(T from) {\n    if (from == null) {\n        return null;\n    }\n    if (CONCURRENT_ACCESS_CHECK) {\n        enterExclusiveThread();\n    }\n    try {\n        checkKryoInitialized();\n        try {\n            return kryo.copy(from);\n        } catch (KryoException ke) {\n            // kryo was unable to copy it, so we do it through serialization:\n            ByteArrayOutputStream baout = new ByteArrayOutputStream();\n            Output output = new Output(baout);\n            kryo.writeObject(output, from);\n            output.close();\n            ByteArrayInputStream bain = new ByteArrayInputStream(baout.toByteArray());\n            Input input = new Input(bain);\n            return ((T) (kryo.readObject(input, from.getClass())));\n        }\n    } finally {\n        if (CONCURRENT_ACCESS_CHECK) {\n            exitExclusiveThread();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.getKryo",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.getKryo", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.checkKryoInitialized", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@VisibleForTesting\npublic Kryo getKryo() {\n    checkKryoInitialized()\n}", "private void checkKryoInitialized() {\n    if (this.kryo == null) {\n        this.kryo = getKryoInstance();\n        // Enable reference tracking.\n        kryo.setReferences(true);\n        // Throwable and all subclasses should be serialized via java serialization\n        // Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.\n        // This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for\n        // details.\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n        // Add default serializers first, so that the type registrations without a serializer\n        // are registered with a default serializer\n        for (Map.Entry<Class<?>, SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n        }\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n        }\n        KryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values(), flinkChillPackageRegistrar != null ? flinkChillPackageRegistrar.getNextRegistrationId() : kryo.getNextRegistrationId());\n        kryo.setRegistrationRequired(false);\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.duplicate",
    "thirdPartyMethod" : "com.esotericsoftware.minlog.Log.TRACE",
    "thirdPartyPackage" : "com.esotericsoftware.minlog",
    "path" : [ "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.duplicate", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.<clinit>", "org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.configureKryoLogging" ],
    "methodSlices" : [ "@Override\npublic KryoSerializer<T> duplicate() {\n    return new KryoSerializer<>(this);\n}", "" ]
  } ]
}