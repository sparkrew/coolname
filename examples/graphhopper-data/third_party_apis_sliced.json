{
  "slicedPaths" : [ {
    "entryPoint" : "com.graphhopper.reader.dem.AbstractTiffElevationProvider.getEle",
    "thirdPartyMethod" : "org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder.<init>",
    "thirdPartyPackage" : "org.apache.xmlgraphics.image.codec.tiff",
    "path" : [ "com.graphhopper.reader.dem.AbstractTiffElevationProvider.getEle", "com.graphhopper.reader.dem.GMTEDProvider.readFile" ],
    "methodSlices" : [ "@Override\npublic double getEle(double lat, double lon) {\n    // Return fast, if there is no data available\n    if (isOutsideSupportedArea(lat, lon))\n        return 0;\n\n    lat = ((int) (lat * precision)) / precision;\n    lon = ((int) (lon * precision)) / precision;\n    String name = getFileName(lat, lon);\n    HeightTile demProvider = cacheData.get(name);\n    if (demProvider == null) {\n        if (!cacheDir.exists())\n            cacheDir.mkdirs();\n\n        int minLat = getMinLatForTile(lat);\n        int minLon = getMinLonForTile(lon);\n        // less restrictive against boundary checking\n        demProvider = new HeightTile(minLat, minLon, WIDTH, HEIGHT, LON_DEGREE * precision, LON_DEGREE, LAT_DEGREE);\n        demProvider.setInterpolate(interpolate);\n        cacheData.put(name, demProvider);\n        DataAccess heights = getDirectory().create(name + \".gh\");\n        demProvider.setHeights(heights);\n        boolean loadExisting = false;\n        try {\n            loadExisting = heights.loadExisting();\n        } catch (Exception ex) {\n            logger.warn(((\"cannot load \" + name) + \", error: \") + ex.getMessage());\n        }\n        if (!loadExisting) {\n            File zipFile = new File(cacheDir, new File(getFileNameOfLocalFile(lat, lon)).getName());\n            if (!zipFile.exists())\n                try {\n                    String zippedURL = getDownloadURL(lat, lon);\n                    downloadToFile(zipFile, zippedURL);\n                } catch (SSLException ex) {\n                    throw new IllegalStateException(\"SSL problem with elevation provider \" + getClass().getSimpleName(), ex);\n                } catch (IOException ex) {\n                    demProvider.setSeaLevel(true);\n                    // use small size on disc and in-memory\n                    heights.create(10).flush();\n                    return 0;\n                }\n\n            // short == 2 bytes\n            heights.create((2L * WIDTH) * HEIGHT);\n            Raster raster = readFile(zipFile, name + \".tif\");\n            fillDataAccessWithElevationData(raster, heights, WIDTH);\n        }// loadExisting\n\n    }\n    if (demProvider.isSeaLevel())\n        return 0;\n\n    return demProvider.getHeight(lat, lon);\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.triangulate.DelaunayTriangulationBuilder.getEdges",
    "thirdPartyPackage" : "org.locationtech.jts.triangulate",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.equals",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.equals",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.equals" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Geometry.convexHull",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.toString",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.toString",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.setShortcutForPrepareEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.setShortcutForPrepareEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.sortGraphForGivenOrdering",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.GraphHopper.sortGraphForGivenOrdering" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param excludeSingleNodeComponents\n * \t\tif set to true components that only contain a single node will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponents() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays", "com.graphhopper.reader.osm.WayToEdgeConverter.buildResult" ],
    "methodSlices" : [ "/**\n * Finds the edge IDs associated with the given OSM ways that are adjacent to each other. For example for given\n * from-, via- and to-ways there can be multiple edges associated with each (because each way can be split into\n * multiple edges). We then need to find the from-edge that is connected with one of the via-edges which in turn\n * must be connected with one of the to-edges. We use DFS/backtracking to do this.\n * There can also be *multiple* via-ways, but the concept is the same.\n * Note that there can also be multiple from- or to-*ways*, but only one of each of them should be considered at a\n * time. In contrast to the via-ways there are only multiple from/to-ways, because of restrictions like no_entry or\n * no_exit where there can be multiple from- or to-members. So we need to find one edge-chain for each pair of from-\n * and to-ways.\n * Besides the edge IDs we also return the node IDs that connect the edges, so we can add turn restrictions at these\n * nodes later.\n */\npublic EdgeResult convertForViaWays(LongArrayList fromWays, LongArrayList viaWays, LongArrayList toWays) throws OSMRestrictionException {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.shuffle",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.shuffle" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgesMap.putIfReserved",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgesMap.putIfReserved" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.build", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.buildFirstEdgesByNode" ],
    "methodSlices" : [ "public void prepareForContraction() {\n}", "" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.isPermutation",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.isPermutation" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.ArrayEdgeIntAccess.setInt",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ev.ArrayEdgeIntAccess.setInt" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.LineIntIndex.store",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.LineIntIndex.store", "com.graphhopper.storage.index.LineIntIndex.store" ],
    "methodSlices" : [ "public void store(InMemConstructionIndex inMem) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.range",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.range" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.ArrayEdgeIntAccess.getInt",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ev.ArrayEdgeIntAccess.getInt" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.RestrictionTopology.node",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.RestrictionTopology.node", "com.graphhopper.reader.osm.RestrictionTopology.<init>" ],
    "methodSlices" : [ "public static RestrictionTopology node(IntArrayList fromEdges, int viaNode, IntArrayList toEdges) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.calcEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.calcEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.calcPoints",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.calcPoints" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentForEdgeKey", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeTransitionFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForEdgeKey(int p, int adjNode) {\n    // we have to create a new explorer on each iteration because of the nested edge iterations\nfinal int edge = getEdgeFromEdgeKey(p)\n    EdgeExplorer explorer = graph.createEdgeExplorer()\n    EdgeIterator iter = explorer.setBaseNode(adjNode)\n    while (iter.next()) {\n    if (!edgeTransitionFilter.accept(edge, iter))\n        continue;\n\n    int q = createEdgeKey(iter, false);\n    handleNeighbor(p, q, iter.getAdjNode());\n} \n    buildComponent(p)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.finishSearch",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.finishSearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.getFinalEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.getFinalEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.reverse",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.reverse" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.RestrictionTopology.way",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.RestrictionTopology.way", "com.graphhopper.reader.osm.RestrictionTopology.<init>" ],
    "methodSlices" : [ "public static RestrictionTopology way(IntArrayList fromEdges, IntArrayList viaEdges, IntArrayList toEdges, IntArrayList viaNodes) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForEdgeState", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.startSearch", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param edgeTransitionFilter\n * \t\tOnly edge transitions accepted by this filter will be considered when we explore the graph.\n * \t\tIf a turn is not accepted the corresponding path will be ignored (edges that are only connected\n * \t\tby a path with such a turn will not be considered to belong to the same component)\n * @param excludeSingleEdgeComponents\n * \t\tif set to true components that only contain a single edge will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private ConnectedComponents findComponents() {\n}", "private void findComponentsForEdgeState(EdgeIteratorState edge) {\n    int edgeKeyFwd = createEdgeKey(edge, false)\n    if (!edgeKeyIndex.has(edgeKeyFwd))\n    pushFindComponentForEdgeKey(edgeKeyFwd, edge.getAdjNode());\n\n    startSearch()\n    // We need to start the search for both edge keys of this edge, but its important to check if the second\n// has already been found by the first search. So we cannot simply push them both and start the search once.\nint edgeKeyBwd = createEdgeKey(edge, true)\n    if (!edgeKeyIndex.has(edgeKeyBwd))\n    pushFindComponentForEdgeKey(edgeKeyBwd, edge.getAdjNode());\n\n    startSearch()\n}", "private void startSearch() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.forEveryEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.forEveryEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForEdgeState", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.startSearch", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}", "private ConnectedComponents findComponentsForStartEdges(IntContainer startEdges) {\n}", "private void findComponentsForEdgeState(EdgeIteratorState edge) {\n    int edgeKeyFwd = createEdgeKey(edge, false)\n    if (!edgeKeyIndex.has(edgeKeyFwd))\n    pushFindComponentForEdgeKey(edgeKeyFwd, edge.getAdjNode());\n\n    startSearch()\n    // We need to start the search for both edge keys of this edge, but its important to check if the second\n// has already been found by the first search. So we cannot simply push them both and start the search once.\nint edgeKeyBwd = createEdgeKey(edge, true)\n    if (!edgeKeyIndex.has(edgeKeyBwd))\n    pushFindComponentForEdgeKey(edgeKeyBwd, edge.getAdjNode());\n\n    startSearch()\n}", "private void startSearch() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.createViaEdgeRestriction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.createViaEdgeRestriction" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.getLast",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.getLast" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.calcNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.calcNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.getEdgeCount",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.getEdgeCount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentForNode", "com.graphhopper.routing.subnetwork.TarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForNode(int v) {\n    // we have to create a new explorer on each iteration because of the nested edge iterations\nEdgeExplorer explorer = graph.createEdgeExplorer(edgeFilter)\n    EdgeIterator iter = explorer.setBaseNode(v)\n    while (iter.next()) {\n    int w = iter.getAdjNode();\n    if (nodeIndex[w] == (-1)) {\n        findComponentForNode(w);\n        nodeLowLink[v] = Math.min(nodeLowLink[v], nodeLowLink[w]);\n    } else if (nodeOnStack.get(w))\n        nodeLowLink[v] = Math.min(nodeLowLink[v], nodeIndex[w]);\n\n} \n    buildComponent(v)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.checkIfTopologyIsCompatibleWithRestriction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.checkIfTopologyIsCompatibleWithRestriction" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.comparePaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.GHUtility.comparePaths", "com.graphhopper.routing.Path.calcNodes" ],
    "methodSlices" : [ "public static List<String> comparePaths(Path refPath, Path path, int source, int target, long seed) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgesMap.getEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgesMap.getEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.buildEdgeChangesAtRealNodes", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.build", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.build", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.getNumVirtualNodes" ],
    "methodSlices" : [ "public static QueryOverlay build(int firstVirtualNodeId, int firstVirtualEdgeId, boolean is3D, List<Snap> snaps) {\n}", "private QueryOverlay build(List<Snap> resList) {\n    buildEdgeChangesAtRealNodes()\n}", "private void buildEdgeChangesAtRealNodes() {\n    EdgeChangeBuilder.build(queryOverlay.getClosestEdges(), queryOverlay.getVirtualEdges(), firstVirtualNodeId, queryOverlay.getEdgeChangesAtRealNodes())\n}", "/**\n * Builds a mapping between real node ids and the set of changes for their adjacent edges.\n *\n * @param edgeChangesAtRealNodes\n * \t\toutput parameter, you need to pass an empty & modifiable map and the results will\n * \t\tbe added to it\n */\nstatic void build(IntArrayList closestEdges, List<VirtualEdgeIteratorState> virtualEdges, int firstVirtualNodeId, IntObjectMap<QueryOverlay.EdgeChanges> edgeChangesAtRealNodes) {\n    new EdgeChangeBuilder(closestEdges, virtualEdges, firstVirtualNodeId, edgeChangesAtRealNodes).build()\n}", "private void build() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.invert",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.invert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.getToEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.getToEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntSet.add",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntScatterSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntSet.add" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.calculatePriority",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.calculatePriority", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.findAndHandlePrepareShortcuts" ],
    "methodSlices" : [ "@Override\npublic float calculatePriority(int node) {\n    // this node is isolated, maybe it belongs to a removed subnetwork, in any case we can quickly contract it\n// no shortcuts will be introduced\nif (numAllEdges == 0)\n    return Float.NEGATIVE_INFINITY;\n\n    findAndHandlePrepareShortcuts(node, this::countShortcuts, ((int) (meanDegree * params.maxPollFactorHeuristic)), wpsStatsHeur)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.findAndHandlePrepareShortcuts" ],
    "methodSlices" : [ "@Override\npublic IntContainer contractNode(int node) {\n    findAndHandlePrepareShortcuts(node, this::addShortcutsToPrepareGraph, ((int) (meanDegree * params.maxPollFactorContraction)), wpsStatsContr)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongLongHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongLongHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongLongHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongLongHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongLongHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongLongHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongLongHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongLongHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongLongHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongLongHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongLongHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongLongHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.EncodedValueSerializer.serializeEncodedValue",
    "thirdPartyMethod" : "com.fasterxml.jackson.core.JsonProcessingException.getMessage",
    "thirdPartyPackage" : "com.fasterxml.jackson.core",
    "path" : [ "com.graphhopper.routing.ev.EncodedValueSerializer.serializeEncodedValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.EncodedValueSerializer.deserializeEncodedValue",
    "thirdPartyMethod" : "com.fasterxml.jackson.core.JsonProcessingException.getMessage",
    "thirdPartyPackage" : "com.fasterxml.jackson.core",
    "path" : [ "com.graphhopper.routing.ev.EncodedValueSerializer.deserializeEncodedValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.dem.AbstractTiffElevationProvider.getEle",
    "thirdPartyMethod" : "org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam.<init>",
    "thirdPartyPackage" : "org.apache.xmlgraphics.image.codec.tiff",
    "path" : [ "com.graphhopper.reader.dem.AbstractTiffElevationProvider.getEle", "com.graphhopper.reader.dem.GMTEDProvider.readFile" ],
    "methodSlices" : [ "@Override\npublic double getEle(double lat, double lon) {\n    // Return fast, if there is no data available\n    if (isOutsideSupportedArea(lat, lon))\n        return 0;\n\n    lat = ((int) (lat * precision)) / precision;\n    lon = ((int) (lon * precision)) / precision;\n    String name = getFileName(lat, lon);\n    HeightTile demProvider = cacheData.get(name);\n    if (demProvider == null) {\n        if (!cacheDir.exists())\n            cacheDir.mkdirs();\n\n        int minLat = getMinLatForTile(lat);\n        int minLon = getMinLonForTile(lon);\n        // less restrictive against boundary checking\n        demProvider = new HeightTile(minLat, minLon, WIDTH, HEIGHT, LON_DEGREE * precision, LON_DEGREE, LAT_DEGREE);\n        demProvider.setInterpolate(interpolate);\n        cacheData.put(name, demProvider);\n        DataAccess heights = getDirectory().create(name + \".gh\");\n        demProvider.setHeights(heights);\n        boolean loadExisting = false;\n        try {\n            loadExisting = heights.loadExisting();\n        } catch (Exception ex) {\n            logger.warn(((\"cannot load \" + name) + \", error: \") + ex.getMessage());\n        }\n        if (!loadExisting) {\n            File zipFile = new File(cacheDir, new File(getFileNameOfLocalFile(lat, lon)).getName());\n            if (!zipFile.exists())\n                try {\n                    String zippedURL = getDownloadURL(lat, lon);\n                    downloadToFile(zipFile, zippedURL);\n                } catch (SSLException ex) {\n                    throw new IllegalStateException(\"SSL problem with elevation provider \" + getClass().getSimpleName(), ex);\n                } catch (IOException ex) {\n                    demProvider.setSeaLevel(true);\n                    // use small size on disc and in-memory\n                    heights.create(10).flush();\n                    return 0;\n                }\n\n            // short == 2 bytes\n            heights.create((2L * WIDTH) * HEIGHT);\n            Raster raster = readFile(zipFile, name + \".tif\");\n            fillDataAccessWithElevationData(raster, heights, WIDTH);\n        }// loadExisting\n\n    }\n    if (demProvider.isSeaLevel())\n        return 0;\n\n    return demProvider.getHeight(lat, lon);\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntLongHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntLongHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntLongHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntLongHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntLongHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntLongHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntLongHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntLongHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntLongHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntLongHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntLongHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntLongHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.BridgePathFinder.find",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.BridgePathFinder.find" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.close",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.close" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.calculatePriority",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.calculatePriority", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.findAndHandlePrepareShortcuts" ],
    "methodSlices" : [ "@Override\npublic float calculatePriority(int node) {\n    // this node is isolated, maybe it belongs to a removed subnetwork, in any case we can quickly contract it\n// no shortcuts will be introduced\nif (numAllEdges == 0)\n    return Float.NEGATIVE_INFINITY;\n\n    findAndHandlePrepareShortcuts(node, this::countShortcuts, ((int) (meanDegree * params.maxPollFactorHeuristic)), wpsStatsHeur)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.findAndHandlePrepareShortcuts" ],
    "methodSlices" : [ "@Override\npublic IntContainer contractNode(int node) {\n    findAndHandlePrepareShortcuts(node, this::addShortcutsToPrepareGraph, ((int) (meanDegree * params.maxPollFactorContraction)), wpsStatsContr)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.buildEdgeChangesAtRealNodes", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.build", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.<init>" ],
    "methodSlices" : [ "public static QueryOverlay build(int firstVirtualNodeId, int firstVirtualEdgeId, boolean is3D, List<Snap> snaps) {\n}", "private QueryOverlay build(List<Snap> resList) {\n    buildEdgeChangesAtRealNodes()\n}", "private void buildEdgeChangesAtRealNodes() {\n    EdgeChangeBuilder.build(queryOverlay.getClosestEdges(), queryOverlay.getVirtualEdges(), firstVirtualNodeId, queryOverlay.getEdgeChangesAtRealNodes())\n}", "/**\n * Builds a mapping between real node ids and the set of changes for their adjacent edges.\n *\n * @param edgeChangesAtRealNodes\n * \t\toutput parameter, you need to pass an empty & modifiable map and the results will\n * \t\tbe added to it\n */\nstatic void build(IntArrayList closestEdges, List<VirtualEdgeIteratorState> virtualEdges, int firstVirtualNodeId, IntObjectMap<QueryOverlay.EdgeChanges> edgeChangesAtRealNodes) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WaySegmentParser.Pass1Handler.handleWay",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WaySegmentParser.Pass1Handler.handleWay" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionTopologyForGraph",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionTopologyForGraph", "com.graphhopper.reader.osm.OSMRestrictionConverter.extractMembers" ],
    "methodSlices" : [ "/**\n * OSM restriction relations specify turn restrictions between OSM ways (of course). This method rebuilds the\n * topology of such a relation in the graph representation, where the turn restrictions are specified in terms of edge/node IDs instead\n * of OSM IDs.\n *\n * @throws OSMRestrictionException\n * \t\tif the given relation is either not valid in some way and/or cannot be handled and\n * \t\tshall be ignored\n */\npublic static Triple<ReaderRelation, RestrictionTopology, RestrictionMembers> buildRestrictionTopologyForGraph(BaseGraph baseGraph, ReaderRelation relation, LongFunction<Iterator<IntCursor>> edgesByWay) throws OSMRestrictionException {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.RestrictionMembers.getAllWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.RestrictionMembers.getAllWays" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WaySegmentParser.Pass2Handler.handleWay",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WaySegmentParser.Pass2Handler.handleWay" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.ReaderWay.toString",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.ReaderWay.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.extractMembers",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.extractMembers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.getMaxLat",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Envelope.getMaxY",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.getMaxLat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.BBox.fromEnvelope",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Envelope.getMaxY",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.BBox.fromEnvelope" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHObjectIntHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.ObjectIntAssociativeContainer.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHObjectIntHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.calculatePriority",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.calculatePriority", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.findAndHandlePrepareShortcuts" ],
    "methodSlices" : [ "@Override\npublic float calculatePriority(int node) {\n    // this node is isolated, maybe it belongs to a removed subnetwork, in any case we can quickly contract it\n// no shortcuts will be introduced\nif (numAllEdges == 0)\n    return Float.NEGATIVE_INFINITY;\n\n    findAndHandlePrepareShortcuts(node, this::countShortcuts, ((int) (meanDegree * params.maxPollFactorHeuristic)), wpsStatsHeur)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.disconnect",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.disconnect" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.BreadthFirstSearch.start",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.BreadthFirstSearch.start", "com.graphhopper.reader.dem.EdgeElevationInterpolator.checkAdjacent" ],
    "methodSlices" : [ "@Override\npublic void start(EdgeExplorer explorer, int startNode) {\n    SimpleIntDeque fifo = new SimpleIntDeque();\n    GHBitSet visited = createBitSet();\n    visited.add(startNode);\n    fifo.push(startNode);\n    int current;\n    while (!fifo.isEmpty()) {\n        current = fifo.pop();\n        if (!goFurther(current))\n            continue;\n\n        EdgeIterator iter = explorer.setBaseNode(current);\n        while (iter.next()) {\n            int connectedId = iter.getAdjNode();\n            if (checkAdjacent(iter) && (!visited.contains(connectedId))) {\n                visited.add(connectedId);\n                fifo.push(connectedId);\n            }\n        } \n    } \n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.findAndHandlePrepareShortcuts" ],
    "methodSlices" : [ "@Override\npublic IntContainer contractNode(int node) {\n    findAndHandlePrepareShortcuts(node, this::addShortcutsToPrepareGraph, ((int) (meanDegree * params.maxPollFactorContraction)), wpsStatsContr)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.RoundTripRouting.calcPaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.RoundTripRouting.calcPaths", "com.graphhopper.routing.RoundTripRouting.RoundTripCalculator.calcPath" ],
    "methodSlices" : [ "public static Result calcPaths(List<Snap> snaps, FlexiblePathCalculator pathCalculator) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.AlternativeRoute.calcAlternatives",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.AlternativeRoute.calcAlternatives", "com.graphhopper.routing.AlternativeRoute.addToMap" ],
    "methodSlices" : [ "/**\n *\n * @return the information necessary to handle alternative paths. Note that the paths are\nnot yet extracted.\n */\npublic List<AlternativeInfo> calcAlternatives(final Path bestPath, final int maxPaths, double maxWeightFactor, final double weightInfluence, final double maxShareFactor, final double shareInfluence, final double minPlateauFactor, final double plateauInfluence) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.addEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.addEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ViaRouting.calcPaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ViaRouting.calcPaths", "com.graphhopper.routing.ViaRouting.buildEdgeRestrictions" ],
    "methodSlices" : [ "public static Result calcPaths(List<GHPoint> points, QueryGraph queryGraph, List<Snap> snaps, DirectedEdgeFilter directedEdgeFilter, PathCalculator pathCalculator, List<String> curbsides, String curbsideStrictness, List<Double> headings, boolean passThrough) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param excludeSingleNodeComponents\n * \t\tif set to true components that only contain a single node will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponents() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays", "com.graphhopper.reader.osm.WayToEdgeConverter.findEdgeChain" ],
    "methodSlices" : [ "/**\n * Finds the edge IDs associated with the given OSM ways that are adjacent to each other. For example for given\n * from-, via- and to-ways there can be multiple edges associated with each (because each way can be split into\n * multiple edges). We then need to find the from-edge that is connected with one of the via-edges which in turn\n * must be connected with one of the to-edges. We use DFS/backtracking to do this.\n * There can also be *multiple* via-ways, but the concept is the same.\n * Note that there can also be multiple from- or to-*ways*, but only one of each of them should be considered at a\n * time. In contrast to the via-ways there are only multiple from/to-ways, because of restrictions like no_entry or\n * no_exit where there can be multiple from- or to-members. So we need to find one edge-chain for each pair of from-\n * and to-ways.\n * Besides the edge IDs we also return the node IDs that connect the edges, so we can add turn restrictions at these\n * nodes later.\n */\npublic EdgeResult convertForViaWays(LongArrayList fromWays, LongArrayList viaWays, LongArrayList toWays) throws OSMRestrictionException {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgesMap.putIfReserved",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgesMap.putIfReserved" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.EdgeChangeBuilder.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.EdgeChangeBuilder.apply", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.addRemovedEdges" ],
    "methodSlices" : [ "@Override\npublic void apply(int value) {\n    addRemovedEdges(value);\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.findUpperBound",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.findUpperBound" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.withoutConsecutiveDuplicates",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.withoutConsecutiveDuplicates" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.runSearch",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.runSearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.addEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.addEdge", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.addEdge" ],
    "methodSlices" : [ "public void addEdge(int from, int to, int edge, double weightFwd, double weightBwd) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentForEdgeKey", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeTransitionFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForEdgeKey(int p, int adjNode) {\n    // we have to create a new explorer on each iteration because of the nested edge iterations\nfinal int edge = getEdgeFromEdgeKey(p)\n    EdgeExplorer explorer = graph.createEdgeExplorer()\n    EdgeIterator iter = explorer.setBaseNode(adjNode)\n    while (iter.next()) {\n    if (!edgeTransitionFilter.accept(edge, iter))\n        continue;\n\n    int q = createEdgeKey(iter, false);\n    handleNeighbor(p, q, iter.getAdjNode());\n} \n    buildComponent(p)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.TurnCostStorage.sortNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.TurnCostStorage.sortNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.initSearch",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.initSearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForEdgeState", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.startSearch", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param edgeTransitionFilter\n * \t\tOnly edge transitions accepted by this filter will be considered when we explore the graph.\n * \t\tIf a turn is not accepted the corresponding path will be ignored (edges that are only connected\n * \t\tby a path with such a turn will not be considered to belong to the same component)\n * @param excludeSingleEdgeComponents\n * \t\tif set to true components that only contain a single edge will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private ConnectedComponents findComponents() {\n}", "private void findComponentsForEdgeState(EdgeIteratorState edge) {\n    int edgeKeyFwd = createEdgeKey(edge, false)\n    if (!edgeKeyIndex.has(edgeKeyFwd))\n    pushFindComponentForEdgeKey(edgeKeyFwd, edge.getAdjNode());\n\n    startSearch()\n    // We need to start the search for both edge keys of this edge, but its important to check if the second\n// has already been found by the first search. So we cannot simply push them both and start the search once.\nint edgeKeyBwd = createEdgeKey(edge, true)\n    if (!edgeKeyIndex.has(edgeKeyBwd))\n    pushFindComponentForEdgeKey(edgeKeyBwd, edge.getAdjNode());\n\n    startSearch()\n}", "private void startSearch() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.next",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.next" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ViaRouting.lookup",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ViaRouting.lookup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForEdgeState", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.startSearch", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}", "private ConnectedComponents findComponentsForStartEdges(IntContainer startEdges) {\n}", "private void findComponentsForEdgeState(EdgeIteratorState edge) {\n    int edgeKeyFwd = createEdgeKey(edge, false)\n    if (!edgeKeyIndex.has(edgeKeyFwd))\n    pushFindComponentForEdgeKey(edgeKeyFwd, edge.getAdjNode());\n\n    startSearch()\n    // We need to start the search for both edge keys of this edge, but its important to check if the second\n// has already been found by the first search. So we cannot simply push them both and start the search once.\nint edgeKeyBwd = createEdgeKey(edge, true)\n    if (!edgeKeyIndex.has(edgeKeyBwd))\n    pushFindComponentForEdgeKey(edgeKeyBwd, edge.getAdjNode());\n\n    startSearch()\n}", "private void startSearch() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.IndexStructureInfo.create",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.IndexStructureInfo.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.init",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.init" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.calcNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.calcNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentForNode", "com.graphhopper.routing.subnetwork.TarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForNode(int v) {\n    // we have to create a new explorer on each iteration because of the nested edge iterations\nEdgeExplorer explorer = graph.createEdgeExplorer(edgeFilter)\n    EdgeIterator iter = explorer.setBaseNode(v)\n    while (iter.next()) {\n    int w = iter.getAdjNode();\n    if (nodeIndex[w] == (-1)) {\n        findComponentForNode(w);\n        nodeLowLink[v] = Math.min(nodeLowLink[v], nodeLowLink[w]);\n    } else if (nodeOnStack.get(w))\n        nodeLowLink[v] = Math.min(nodeLowLink[v], nodeIndex[w]);\n\n} \n    buildComponent(v)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.subList",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.subList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.comparePaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.GHUtility.comparePaths", "com.graphhopper.routing.Path.calcNodes" ],
    "methodSlices" : [ "public static List<String> comparePaths(Path refPath, Path path, int source, int target, long seed) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.HeadingResolver.getEdgesWithDifferentHeading",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.HeadingResolver.getEdgesWithDifferentHeading" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryOverlayBuilder.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryOverlayBuilder.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.AlternativeRoute.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.AlternativeRoute.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.AbstractBidirAlgo.calcPath",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.AbstractBidirAlgo.calcPath", "com.graphhopper.routing.AbstractBidirAlgo.init", "com.graphhopper.routing.AbstractBidirAlgo.postInit", "com.graphhopper.routing.AbstractBidirAlgo.updateBestPath" ],
    "methodSlices" : [ "@Override\npublic Path calcPath(int from, int to, int fromOutEdge, int toInEdge) {\n    if (((fromOutEdge != ANY_EDGE) || (toInEdge != ANY_EDGE)) && (!traversalMode.isEdgeBased())) {\n    throw new IllegalArgumentException(\"Restricting the start/target edges is only possible for edge-based graph traversal\");\n}\n    init(from, 0, to, 0)\n}", "void init(int from, double fromWeight, int to, double toWeight) {\n    postInit(from, to)\n}", "protected void postInit(int from, int to) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.AlternativeRoute.searchBest",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.AlternativeRoute.searchBest", "com.graphhopper.routing.AbstractBidirAlgo.runAlgo", "com.graphhopper.routing.AbstractNonCHBidirAlgo.fillEdgesFrom", "com.graphhopper.routing.AbstractNonCHBidirAlgo.fillEdges" ],
    "methodSlices" : [ "public Path searchBest(int from, int to) {\n    // init collections and bestPath.getWeight properly\nrunAlgo()\n}", "protected void runAlgo() {\n    while (((!finished()) && (!isMaxVisitedNodesExceeded())) && (!isTimeoutExceeded())) {\n        if (!finishedFrom)\n            finishedFrom = !fillEdgesFrom();\n\n        if (!finishedTo)\n            finishedTo = !fillEdgesTo();\n\n    } \n}", "@Override\nboolean fillEdgesFrom() {\n    while (true) {\n    if (pqOpenSetFrom.isEmpty())\n        return false;\n\n    currFrom = pqOpenSetFrom.poll();\n    if (!currFrom.isDeleted())\n        break;\n\n} \n    if (fromEntryCanBeSkipped()) {\n    return true;\n}\n    if (fwdSearchCanBeStopped()) {\n    return false;\n}\n    fillEdges(currFrom, pqOpenSetFrom, bestWeightMapFrom, false)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Dijkstra.calcPath",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Dijkstra.calcPath", "com.graphhopper.routing.Dijkstra.runAlgo" ],
    "methodSlices" : [ "@Override\npublic Path calcPath(int from, int to) {\n    if (!traversalMode.isEdgeBased())\n    fromMap.put(from, currEdge);\n\n    runAlgo()\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.setBaseNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.setBaseNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.BridgePathFinder.find",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.BridgePathFinder.find" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryGraph.setBaseNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryGraph.setBaseNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.buildEdgeChangesAtRealNodes", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.build", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.build", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.addVirtualEdges" ],
    "methodSlices" : [ "public static QueryOverlay build(int firstVirtualNodeId, int firstVirtualEdgeId, boolean is3D, List<Snap> snaps) {\n}", "private QueryOverlay build(List<Snap> resList) {\n    buildEdgeChangesAtRealNodes()\n}", "private void buildEdgeChangesAtRealNodes() {\n    EdgeChangeBuilder.build(queryOverlay.getClosestEdges(), queryOverlay.getVirtualEdges(), firstVirtualNodeId, queryOverlay.getEdgeChangesAtRealNodes())\n}", "/**\n * Builds a mapping between real node ids and the set of changes for their adjacent edges.\n *\n * @param edgeChangesAtRealNodes\n * \t\toutput parameter, you need to pass an empty & modifiable map and the results will\n * \t\tbe added to it\n */\nstatic void build(IntArrayList closestEdges, List<VirtualEdgeIteratorState> virtualEdges, int firstVirtualNodeId, IntObjectMap<QueryOverlay.EdgeChanges> edgeChangesAtRealNodes) {\n    new EdgeChangeBuilder(closestEdges, virtualEdges, firstVirtualNodeId, edgeChangesAtRealNodes).build()\n}", "private void build() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.EdgeChangeBuilder.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.EdgeChangeBuilder.apply", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.addRemovedEdges" ],
    "methodSlices" : [ "@Override\npublic void apply(int value) {\n    addRemovedEdges(value);\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.getVertices",
    "thirdPartyPackage" : "org.locationtech.jts.triangulate.quadedge",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.addLast",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForEdgeState", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.pushFindComponentForEdgeKey" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}", "private ConnectedComponents findComponentsForStartEdges(IntContainer startEdges) {\n}", "private void findComponentsForEdgeState(EdgeIteratorState edge) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.addLast",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.DepthFirstSearch.start",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.addLast",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.DepthFirstSearch.start" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.addLast",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForEdgeState", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.pushFindComponentForEdgeKey" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param edgeTransitionFilter\n * \t\tOnly edge transitions accepted by this filter will be considered when we explore the graph.\n * \t\tIf a turn is not accepted the corresponding path will be ignored (edges that are only connected\n * \t\tby a path with such a turn will not be considered to belong to the same component)\n * @param excludeSingleEdgeComponents\n * \t\tif set to true components that only contain a single edge will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private ConnectedComponents findComponents() {\n}", "private void findComponentsForEdgeState(EdgeIteratorState edge) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.addLast",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentForNode", "com.graphhopper.routing.subnetwork.TarjanSCC.setupNextNode" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForNode(int v) {\n    setupNextNode(v)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.addLast",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.setupNextNode" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param excludeSingleNodeComponents\n * \t\tif set to true components that only contain a single node will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponents() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.addLast",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentForEdgeKey", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.setupNextEdgeKey" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeTransitionFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForEdgeKey(int p, int adjNode) {\n    setupNextEdgeKey(p)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.dem.AbstractTiffElevationProvider.getEle",
    "thirdPartyMethod" : "org.apache.xmlgraphics.image.codec.util.SeekableStream.wrapInputStream",
    "thirdPartyPackage" : "org.apache.xmlgraphics.image.codec.util",
    "path" : [ "com.graphhopper.reader.dem.AbstractTiffElevationProvider.getEle", "com.graphhopper.reader.dem.GMTEDProvider.readFile" ],
    "methodSlices" : [ "@Override\npublic double getEle(double lat, double lon) {\n    // Return fast, if there is no data available\n    if (isOutsideSupportedArea(lat, lon))\n        return 0;\n\n    lat = ((int) (lat * precision)) / precision;\n    lon = ((int) (lon * precision)) / precision;\n    String name = getFileName(lat, lon);\n    HeightTile demProvider = cacheData.get(name);\n    if (demProvider == null) {\n        if (!cacheDir.exists())\n            cacheDir.mkdirs();\n\n        int minLat = getMinLatForTile(lat);\n        int minLon = getMinLonForTile(lon);\n        // less restrictive against boundary checking\n        demProvider = new HeightTile(minLat, minLon, WIDTH, HEIGHT, LON_DEGREE * precision, LON_DEGREE, LAT_DEGREE);\n        demProvider.setInterpolate(interpolate);\n        cacheData.put(name, demProvider);\n        DataAccess heights = getDirectory().create(name + \".gh\");\n        demProvider.setHeights(heights);\n        boolean loadExisting = false;\n        try {\n            loadExisting = heights.loadExisting();\n        } catch (Exception ex) {\n            logger.warn(((\"cannot load \" + name) + \", error: \") + ex.getMessage());\n        }\n        if (!loadExisting) {\n            File zipFile = new File(cacheDir, new File(getFileNameOfLocalFile(lat, lon)).getName());\n            if (!zipFile.exists())\n                try {\n                    String zippedURL = getDownloadURL(lat, lon);\n                    downloadToFile(zipFile, zippedURL);\n                } catch (SSLException ex) {\n                    throw new IllegalStateException(\"SSL problem with elevation provider \" + getClass().getSimpleName(), ex);\n                } catch (IOException ex) {\n                    demProvider.setSeaLevel(true);\n                    // use small size on disc and in-memory\n                    heights.create(10).flush();\n                    return 0;\n                }\n\n            // short == 2 bytes\n            heights.create((2L * WIDTH) * HEIGHT);\n            Raster raster = readFile(zipFile, name + \".tif\");\n            fillDataAccessWithElevationData(raster, heights, WIDTH);\n        }// loadExisting\n\n    }\n    if (demProvider.isSeaLevel())\n        return 0;\n\n    return demProvider.getHeight(lat, lon);\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.Restriction.toString",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.toString",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.Restriction.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.InMemConstructionIndex.InMemLeafEntry.toString",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.toString",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.InMemConstructionIndex.InMemLeafEntry.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.RoadDensityCalculator.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.RoadDensityCalculator.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanArrayIntSet.contains",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanArrayIntSet.contains" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentForNode" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param excludeSingleNodeComponents\n * \t\tif set to true components that only contain a single node will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.BaseGraphNodesAndEdges.sortEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.BaseGraphNodesAndEdges.sortEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.BaseGraphNodesAndEdges.relabelNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.BaseGraphNodesAndEdges.relabelNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.doWork",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.doWork" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.isPermutation",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.isPermutation" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.setSubnetworks",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.forEach",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.setSubnetworks" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.AlternativeRoute.calcAlternatives",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.forEach",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.AlternativeRoute.calcAlternatives" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.minTo",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntIntScatterMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.minTo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.set",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntIntScatterMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.<init>",
    "thirdPartyMethod" : "org.locationtech.jts.geom.GeometryFactory.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.<init>", "com.graphhopper.util.shapes.Polygon.<clinit>" ],
    "methodSlices" : [ "public Polygon(double[] lats, double[] lons) {\n    if (lats.length != lons.length)\n        throw new IllegalArgumentException(((\"Points must be of equal length but was \" + lats.length) + \" vs. \") + lons.length);\n\n    if (lats.length == 0)\n        throw new IllegalArgumentException(\"Points must not be empty\");\n\n    Coordinate[] coordinates = new Coordinate[lats.length + 1];\n    for (int i = 0; i < lats.length; i++) {\n        coordinates[i] = new Coordinate(lons[i], lats[i]);\n    }\n    coordinates[lats.length] = coordinates[0];\n    this.prepPolygon = new PreparedPolygon(factory.createPolygon(new PackedCoordinateSequence.Double(coordinates, 2)));\n    this.rectangle = prepPolygon.getGeometry().isRectangle();\n    this.envelope = prepPolygon.getGeometry().getEnvelopeInternal();\n    this.bbox = BBox.fromEnvelope(envelope);\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.createCircle",
    "thirdPartyMethod" : "org.locationtech.jts.geom.GeometryFactory.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.GHUtility.createCircle" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.geom.GeometryFactory.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.create",
    "thirdPartyMethod" : "org.locationtech.jts.geom.GeometryFactory.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.create", "com.graphhopper.util.shapes.Polygon.<clinit>" ],
    "methodSlices" : [ "public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n    return new Polygon(new PreparedPolygon(polygon));\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.createRectangle",
    "thirdPartyMethod" : "org.locationtech.jts.geom.GeometryFactory.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.GHUtility.createRectangle" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.contains",
    "thirdPartyMethod" : "org.locationtech.jts.geom.GeometryFactory.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.contains", "com.graphhopper.util.shapes.Polygon.<clinit>" ],
    "methodSlices" : [ "/**\n * Does the point in polygon check.\n *\n * @param lat\n * \t\tLatitude of the point to be checked\n * @param lon\n * \t\tLongitude of the point to be checked\n * @return true if point is inside polygon\n */\npublic boolean contains(double lat, double lon) {\n    return prepPolygon.contains(factory.createPoint(new Coordinate(lon, lat)));\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.AreaIndex.<init>",
    "thirdPartyMethod" : "org.locationtech.jts.geom.GeometryFactory.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.routing.util.AreaIndex.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntSet.contains",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntScatterSet.contains",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntSet.contains" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.triangulate.DelaunayTriangulationBuilder.getSubdivision",
    "thirdPartyPackage" : "org.locationtech.jts.triangulate",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.triangulate.DelaunayTriangulationBuilder.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.triangulate",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntObjectHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntObjectHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntObjectHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntObjectHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntObjectHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntObjectHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.BridgePathFinder.find",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.BridgePathFinder.find" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntObjectHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntObjectHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.<init>", "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.buildVirtualEdgesAtRealNodes" ],
    "methodSlices" : [ "public QueryRoutingCHGraph(RoutingCHGraph routingCHGraph, QueryGraph queryGraph) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.LineIntIndex.query",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.LineIntIndex.query" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.LocationIndexTree.findClosest",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.LocationIndexTree.findClosest" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.RoundTripRouting.calcPaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.RoundTripRouting.calcPaths", "com.graphhopper.routing.RoundTripRouting.RoundTripCalculator.<init>" ],
    "methodSlices" : [ "public static Result calcPaths(List<Snap> snaps, FlexiblePathCalculator pathCalculator) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.ShortestPathTree.getIsochroneEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.ObjectCollection.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.isochrone.algorithm.ShortestPathTree.getIsochroneEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.dem.AbstractTiffElevationProvider.getEle",
    "thirdPartyMethod" : "org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder.decodeAsRaster",
    "thirdPartyPackage" : "org.apache.xmlgraphics.image.codec.tiff",
    "path" : [ "com.graphhopper.reader.dem.AbstractTiffElevationProvider.getEle", "com.graphhopper.reader.dem.GMTEDProvider.readFile" ],
    "methodSlices" : [ "@Override\npublic double getEle(double lat, double lon) {\n    // Return fast, if there is no data available\n    if (isOutsideSupportedArea(lat, lon))\n        return 0;\n\n    lat = ((int) (lat * precision)) / precision;\n    lon = ((int) (lon * precision)) / precision;\n    String name = getFileName(lat, lon);\n    HeightTile demProvider = cacheData.get(name);\n    if (demProvider == null) {\n        if (!cacheDir.exists())\n            cacheDir.mkdirs();\n\n        int minLat = getMinLatForTile(lat);\n        int minLon = getMinLonForTile(lon);\n        // less restrictive against boundary checking\n        demProvider = new HeightTile(minLat, minLon, WIDTH, HEIGHT, LON_DEGREE * precision, LON_DEGREE, LAT_DEGREE);\n        demProvider.setInterpolate(interpolate);\n        cacheData.put(name, demProvider);\n        DataAccess heights = getDirectory().create(name + \".gh\");\n        demProvider.setHeights(heights);\n        boolean loadExisting = false;\n        try {\n            loadExisting = heights.loadExisting();\n        } catch (Exception ex) {\n            logger.warn(((\"cannot load \" + name) + \", error: \") + ex.getMessage());\n        }\n        if (!loadExisting) {\n            File zipFile = new File(cacheDir, new File(getFileNameOfLocalFile(lat, lon)).getName());\n            if (!zipFile.exists())\n                try {\n                    String zippedURL = getDownloadURL(lat, lon);\n                    downloadToFile(zipFile, zippedURL);\n                } catch (SSLException ex) {\n                    throw new IllegalStateException(\"SSL problem with elevation provider \" + getClass().getSimpleName(), ex);\n                } catch (IOException ex) {\n                    demProvider.setSeaLevel(true);\n                    // use small size on disc and in-memory\n                    heights.create(10).flush();\n                    return 0;\n                }\n\n            // short == 2 bytes\n            heights.create((2L * WIDTH) * HEIGHT);\n            Raster raster = readFile(zipFile, name + \".tif\");\n            fillDataAccessWithElevationData(raster, heights, WIDTH);\n        }// loadExisting\n\n    }\n    if (demProvider.isSeaLevel())\n        return 0;\n\n    return demProvider.getHeight(lat, lon);\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentForNode", "com.graphhopper.routing.subnetwork.TarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForNode(int v) {\n    // we have to create a new explorer on each iteration because of the nested edge iterations\nEdgeExplorer explorer = graph.createEdgeExplorer(edgeFilter)\n    EdgeIterator iter = explorer.setBaseNode(v)\n    while (iter.next()) {\n    int w = iter.getAdjNode();\n    if (nodeIndex[w] == (-1)) {\n        findComponentForNode(w);\n        nodeLowLink[v] = Math.min(nodeLowLink[v], nodeLowLink[w]);\n    } else if (nodeOnStack.get(w))\n        nodeLowLink[v] = Math.min(nodeLowLink[v], nodeIndex[w]);\n\n} \n    buildComponent(v)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param excludeSingleNodeComponents\n * \t\tif set to true components that only contain a single node will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponents() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.ExternalBooleanEncodedValue.setBool",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ev.ExternalBooleanEncodedValue.setBool" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions", "com.graphhopper.routing.util.parsers.RestrictionSetter.disableRedundantRestrictions" ],
    "methodSlices" : [ "public void setRestrictions(List<Restriction> restrictions, List<BitSet> encBits) {\n    if (restrictions.size() != encBits.size())\n    throw new IllegalArgumentException(((\"There must be as many encBits as restrictions. Got: \" + encBits.size()) + \" and \") + restrictions.size());\n\n    List<InternalRestriction> internalRestrictions = restrictions.stream().map(this::convertToInternal).toList()\n    disableRedundantRestrictions(internalRestrictions, encBits)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanArrayIntSet.remove",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanArrayIntSet.remove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongObjectHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongObjectHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongObjectHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongObjectHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongObjectHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongObjectHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHLongObjectHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHLongObjectHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.extractMembers",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.extractMembers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.getMinLat",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Envelope.getMinY",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.getMinLat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.BBox.fromEnvelope",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Envelope.getMinY",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.BBox.fromEnvelope" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.triangulate.quadedge.Vertex.setZ",
    "thirdPartyPackage" : "org.locationtech.jts.triangulate.quadedge",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LMApproximator.approximate",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.addAll",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LMApproximator.approximate", "com.graphhopper.routing.lm.LandmarkStorage.chooseActiveLandmarks" ],
    "methodSlices" : [ "@Override\npublic double approximate(final int v) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.isFrameVertex",
    "thirdPartyPackage" : "org.locationtech.jts.triangulate.quadedge",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntSet.remove",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntScatterSet.remove",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntSet.remove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.calculatePriority",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.calculatePriority", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.findAndHandlePrepareShortcuts" ],
    "methodSlices" : [ "@Override\npublic float calculatePriority(int node) {\n    // this node is isolated, maybe it belongs to a removed subnetwork, in any case we can quickly contract it\n// no shortcuts will be introduced\nif (numAllEdges == 0)\n    return Float.NEGATIVE_INFINITY;\n\n    findAndHandlePrepareShortcuts(node, this::countShortcuts, ((int) (meanDegree * params.maxPollFactorHeuristic)), wpsStatsHeur)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.disconnect",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.disconnect" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.clear",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.findAndHandlePrepareShortcuts" ],
    "methodSlices" : [ "@Override\npublic IntContainer contractNode(int node) {\n    findAndHandlePrepareShortcuts(node, this::addShortcutsToPrepareGraph, ((int) (meanDegree * params.maxPollFactorContraction)), wpsStatsContr)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.pbf.PbfBlobDecoder.run",
    "thirdPartyMethod" : "org.openstreetmap.osmosis.osmbinary.Fileformat.Blob.hasRaw",
    "thirdPartyPackage" : "org.openstreetmap.osmosis.osmbinary.Fileformat",
    "path" : [ "com.graphhopper.reader.osm.pbf.PbfBlobDecoder.run", "com.graphhopper.reader.osm.pbf.PbfBlobDecoder.runAndTrapExceptions", "com.graphhopper.reader.osm.pbf.PbfBlobDecoder.readBlobContent" ],
    "methodSlices" : [ "@Override\npublic void run() {\n}", "private void runAndTrapExceptions() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.<init>", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.ConnectedComponents.<init>" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param edgeTransitionFilter\n * \t\tOnly edge transitions accepted by this filter will be considered when we explore the graph.\n * \t\tIf a turn is not accepted the corresponding path will be ignored (edges that are only connected\n * \t\tby a path with such a turn will not be considered to belong to the same component)\n * @param excludeSingleEdgeComponents\n * \t\tif set to true components that only contain a single edge will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private EdgeBasedTarjanSCC(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.<init>", "com.graphhopper.routing.subnetwork.TarjanSCC.ConnectedComponents.<init>" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param excludeSingleNodeComponents\n * \t\tif set to true components that only contain a single node will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private TarjanSCC(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays", "com.graphhopper.reader.osm.WayToEdgeConverter.findEdgeChain", "com.graphhopper.reader.osm.WayToEdgeConverter.listFromIterator" ],
    "methodSlices" : [ "/**\n * Finds the edge IDs associated with the given OSM ways that are adjacent to each other. For example for given\n * from-, via- and to-ways there can be multiple edges associated with each (because each way can be split into\n * multiple edges). We then need to find the from-edge that is connected with one of the via-edges which in turn\n * must be connected with one of the to-edges. We use DFS/backtracking to do this.\n * There can also be *multiple* via-ways, but the concept is the same.\n * Note that there can also be multiple from- or to-*ways*, but only one of each of them should be considered at a\n * time. In contrast to the via-ways there are only multiple from/to-ways, because of restrictions like no_entry or\n * no_exit where there can be multiple from- or to-members. So we need to find one edge-chain for each pair of from-\n * and to-ways.\n * Besides the edge IDs we also return the node IDs that connect the edges, so we can add turn restrictions at these\n * nodes later.\n */\npublic EdgeResult convertForViaWays(LongArrayList fromWays, LongArrayList viaWays, LongArrayList toWays) throws OSMRestrictionException {\n}", "private void findEdgeChain(long fromWay, LongArrayList viaWays, long toWay, List<IntArrayList> solutions) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.ArrayEdgeIntAccess.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ev.ArrayEdgeIntAccess.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ViaRouting.lookup",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ViaRouting.lookup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.<init>", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.ConnectedComponents.<init>" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}", "private EdgeBasedTarjanSCC(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.edgeBased",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.edgeBased", "com.graphhopper.routing.ch.CHPreparationGraph.<init>" ],
    "methodSlices" : [ "public static CHPreparationGraph edgeBased(int nodes, int edges, TurnCostFunction turnCostFunction) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.IndexStructureInfo.create",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.IndexStructureInfo.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.withoutConsecutiveDuplicates",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.withoutConsecutiveDuplicates" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.<init>", "com.graphhopper.routing.subnetwork.TarjanSCC.ConnectedComponents.<init>" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private TarjanSCC(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgesMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgesMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.comparePaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.GHUtility.comparePaths", "com.graphhopper.util.GHUtility.pathsEqualExceptOneEdge" ],
    "methodSlices" : [ "public static List<String> comparePaths(Path refPath, Path path, int source, int target, long seed) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.<init>", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.ConnectedComponents.<init>" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeTransitionFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private EdgeBasedTarjanSCC(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.TurnCostStorage.sortNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.TurnCostStorage.sortNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.DijkstraOneToMany.IntArrayListWithCap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.DijkstraOneToMany.IntArrayListWithCap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.nodeBased",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.nodeBased", "com.graphhopper.routing.ch.CHPreparationGraph.<init>" ],
    "methodSlices" : [ "public static CHPreparationGraph nodeBased(int nodes, int edges) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WaySegmentParser.Pass1Handler.handleWay",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WaySegmentParser.Pass1Handler.handleWay" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionTopologyForGraph",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionTopologyForGraph", "com.graphhopper.reader.osm.OSMRestrictionConverter.membersExist" ],
    "methodSlices" : [ "/**\n * OSM restriction relations specify turn restrictions between OSM ways (of course). This method rebuilds the\n * topology of such a relation in the graph representation, where the turn restrictions are specified in terms of edge/node IDs instead\n * of OSM IDs.\n *\n * @throws OSMRestrictionException\n * \t\tif the given relation is either not valid in some way and/or cannot be handled and\n * \t\tshall be ignored\n */\npublic static Triple<ReaderRelation, RestrictionTopology, RestrictionMembers> buildRestrictionTopologyForGraph(BaseGraph baseGraph, ReaderRelation relation, LongFunction<Iterator<IntCursor>> edgesByWay) throws OSMRestrictionException {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WaySegmentParser.Pass2Handler.handleWay",
    "thirdPartyMethod" : "com.carrotsearch.hppc.LongArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WaySegmentParser.Pass2Handler.handleWay" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.hashCode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.hashCode",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.hashCode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayDeque.removeFirst",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.Triangulation.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.isochrone.algorithm.Triangulation.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.pbf.PbfBlobDecoder.run",
    "thirdPartyMethod" : "org.openstreetmap.osmosis.osmbinary.Fileformat.Blob.hasZlibData",
    "thirdPartyPackage" : "org.openstreetmap.osmosis.osmbinary.Fileformat",
    "path" : [ "com.graphhopper.reader.osm.pbf.PbfBlobDecoder.run", "com.graphhopper.reader.osm.pbf.PbfBlobDecoder.runAndTrapExceptions", "com.graphhopper.reader.osm.pbf.PbfBlobDecoder.readBlobContent" ],
    "methodSlices" : [ "@Override\npublic void run() {\n}", "private void runAndTrapExceptions() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.triangulate.DelaunayTriangulationBuilder.setTolerance",
    "thirdPartyPackage" : "org.locationtech.jts.triangulate",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.getMaxLon",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Envelope.getMaxX",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.getMaxLon" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.BBox.fromEnvelope",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Envelope.getMaxX",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.BBox.fromEnvelope" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.toString",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Geometry.getNumPoints",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.edgeBased",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntScatterSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.edgeBased", "com.graphhopper.routing.ch.CHPreparationGraph.<init>" ],
    "methodSlices" : [ "public static CHPreparationGraph edgeBased(int nodes, int edges, TurnCostFunction turnCostFunction) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.RoadDensityCalculator.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntScatterSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.RoadDensityCalculator.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntScatterSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.nodeBased",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntScatterSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.nodeBased", "com.graphhopper.routing.ch.CHPreparationGraph.<init>" ],
    "methodSlices" : [ "public static CHPreparationGraph nodeBased(int nodes, int edges) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.AbstractBidirAlgo.calcPath",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.AbstractBidirAlgo.calcPath", "com.graphhopper.routing.AbstractBidirAlgo.init", "com.graphhopper.routing.AbstractBidirAlgo.initFrom" ],
    "methodSlices" : [ "@Override\npublic Path calcPath(int from, int to, int fromOutEdge, int toInEdge) {\n    if (((fromOutEdge != ANY_EDGE) || (toInEdge != ANY_EDGE)) && (!traversalMode.isEdgeBased())) {\n    throw new IllegalArgumentException(\"Restricting the start/target edges is only possible for edge-based graph traversal\");\n}\n    init(from, 0, to, 0)\n}", "void init(int from, double fromWeight, int to, double toWeight) {\n    initFrom(from, fromWeight)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.AlternativeRoute.searchBest",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.AlternativeRoute.searchBest", "com.graphhopper.routing.AbstractBidirAlgo.runAlgo", "com.graphhopper.routing.AbstractNonCHBidirAlgo.fillEdgesFrom", "com.graphhopper.routing.AbstractNonCHBidirAlgo.fillEdges" ],
    "methodSlices" : [ "public Path searchBest(int from, int to) {\n    // init collections and bestPath.getWeight properly\nrunAlgo()\n}", "protected void runAlgo() {\n    while (((!finished()) && (!isMaxVisitedNodesExceeded())) && (!isTimeoutExceeded())) {\n        if (!finishedFrom)\n            finishedFrom = !fillEdgesFrom();\n\n        if (!finishedTo)\n            finishedTo = !fillEdgesTo();\n\n    } \n}", "@Override\nboolean fillEdgesFrom() {\n    while (true) {\n    if (pqOpenSetFrom.isEmpty())\n        return false;\n\n    currFrom = pqOpenSetFrom.poll();\n    if (!currFrom.isDeleted())\n        break;\n\n} \n    if (fromEntryCanBeSkipped()) {\n    return true;\n}\n    if (fwdSearchCanBeStopped()) {\n    return false;\n}\n    fillEdges(currFrom, pqOpenSetFrom, bestWeightMapFrom, false)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Dijkstra.calcPath",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Dijkstra.calcPath" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.setStartNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.setStartNode", "com.graphhopper.routing.AbstractBidirAlgo.initTo" ],
    "methodSlices" : [ "public void setStartNode(int startNode) {\n    if (reverse)\n        initTo(startNode, 0);\n    else\n        initFrom(startNode, 0);\n\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryGraph.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryGraph.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.BridgePathFinder.find",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.BridgePathFinder.find" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.buildEdgeChangesAtRealNodes", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.build", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.build", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.addVirtualEdges" ],
    "methodSlices" : [ "public static QueryOverlay build(int firstVirtualNodeId, int firstVirtualEdgeId, boolean is3D, List<Snap> snaps) {\n}", "private QueryOverlay build(List<Snap> resList) {\n    buildEdgeChangesAtRealNodes()\n}", "private void buildEdgeChangesAtRealNodes() {\n    EdgeChangeBuilder.build(queryOverlay.getClosestEdges(), queryOverlay.getVirtualEdges(), firstVirtualNodeId, queryOverlay.getEdgeChangesAtRealNodes())\n}", "/**\n * Builds a mapping between real node ids and the set of changes for their adjacent edges.\n *\n * @param edgeChangesAtRealNodes\n * \t\toutput parameter, you need to pass an empty & modifiable map and the results will\n * \t\tbe added to it\n */\nstatic void build(IntArrayList closestEdges, List<VirtualEdgeIteratorState> virtualEdges, int firstVirtualNodeId, IntObjectMap<QueryOverlay.EdgeChanges> edgeChangesAtRealNodes) {\n    new EdgeChangeBuilder(closestEdges, virtualEdges, firstVirtualNodeId, edgeChangesAtRealNodes).build()\n}", "private void build() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.put",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.weighting.custom.CustomModelParser.createWeightingParameters",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Geometry.getGeometryType",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.routing.weighting.custom.CustomModelParser.createWeightingParameters", "com.graphhopper.routing.weighting.custom.CustomModelParser.createClazz", "com.graphhopper.routing.weighting.custom.CustomModelParser.createClassTemplate" ],
    "methodSlices" : [ "/**\n * This method compiles a new subclass of CustomWeightingHelper composed of the provided CustomModel caches this\n * and returns an instance.\n */\npublic static CustomWeighting.Parameters createWeightingParameters(CustomModel customModel, EncodedValueLookup lookup) {\n}", "/**\n * This method does the following:\n * <ul>\n * <li>\n *     1. parse the value expressions (RHS) to know about additional encoded values ('findVariables')\n *     and check for multiplications with negative values.\n * </li>\n * <li>2. parse conditional expression of priority and speed statements -> done in ConditionalExpressionVisitor (don't parse RHS expressions again)\n * </li>\n * <li>3. create class template as String, inject the created statements and create the Class\n * </li>\n * </ul>\n */\nprivate static Class<?> createClazz(CustomModel customModel, EncodedValueLookup lookup) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.minTo",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntIntScatterMap.getOrDefault",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.minTo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.get",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntIntScatterMap.getOrDefault",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.get" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.readCountries",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.<init>",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.util.GHUtility.readCountries" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.resolveCustomAreas",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.<init>",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.GraphHopper.resolveCustomAreas" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.EncodedValueSerializer.serializeEncodedValue",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.<init>",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.routing.ev.EncodedValueSerializer.serializeEncodedValue", "com.graphhopper.routing.ev.EncodedValueSerializer.<clinit>" ],
    "methodSlices" : [ "public static String serializeEncodedValue(EncodedValue encodedValue) {\n    try {\n        JsonNode tree = MAPPER.valueToTree(encodedValue);\n        return MAPPER.writeValueAsString(tree);\n    } catch (JsonProcessingException e) {\n        throw new IllegalStateException(((\"Could not serialize encoded value: \" + encodedValue) + \", error: \") + e.getMessage());\n    }\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.MaxSpeedCalculator.createLegalDefaultSpeeds",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.<init>",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.routing.util.MaxSpeedCalculator.createLegalDefaultSpeeds" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LMPreparationHandler.init",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.<init>",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.routing.lm.LMPreparationHandler.init", "com.graphhopper.routing.lm.LMPreparationHandler.loadLandmarkSplittingFeatureCollection" ],
    "methodSlices" : [ "public void init(GraphHopperConfig ghConfig) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.EncodedValueSerializer.deserializeEncodedValue",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.<init>",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.routing.ev.EncodedValueSerializer.deserializeEncodedValue", "com.graphhopper.routing.ev.EncodedValueSerializer.<clinit>" ],
    "methodSlices" : [ "public static EncodedValue deserializeEncodedValue(String serializedEncodedValue) {\n    try {\n        JsonNode jsonNode = MAPPER.readTree(serializedEncodedValue);\n        return MAPPER.treeToValue(jsonNode, EncodedValue.class);\n    } catch (JsonProcessingException e) {\n        throw new IllegalStateException(((\"Could not deserialize encoded value: \" + serializedEncodedValue) + \", error: \") + e.getMessage());\n    }\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Router.route",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Router.route" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.init",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.init", "com.graphhopper.routing.ch.NodeBasedWitnessPathSearcher.reset" ],
    "methodSlices" : [ "/**\n * Sets up a search for given start node and an ignored node. The shortest path tree will be re-used for different\n * target nodes until this method is called again.\n */\npublic void init(int startNode, int ignoreNode) {\n    reset()\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryGraph.unfavorVirtualEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryGraph.unfavorVirtualEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions", "com.graphhopper.routing.util.parsers.RestrictionSetter.disableRedundantRestrictions" ],
    "methodSlices" : [ "public void setRestrictions(List<Restriction> restrictions, List<BitSet> encBits) {\n    if (restrictions.size() != encBits.size())\n    throw new IllegalArgumentException(((\"There must be as many encBits as restrictions. Got: \" + encBits.size()) + \" and \") + restrictions.size());\n\n    List<InternalRestriction> internalRestrictions = restrictions.stream().map(this::convertToInternal).toList()\n    disableRedundantRestrictions(internalRestrictions, encBits)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.isPermutation",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.isPermutation" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.RoundTripRouting.calcPaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.RoundTripRouting.calcPaths", "com.graphhopper.routing.RoundTripRouting.RoundTripCalculator.calcPath" ],
    "methodSlices" : [ "public static Result calcPaths(List<Snap> snaps, FlexiblePathCalculator pathCalculator) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHObjectIntHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.ObjectIntHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHObjectIntHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHObjectIntHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.ObjectIntHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHObjectIntHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHObjectIntHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.ObjectIntHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHObjectIntHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHObjectIntHashMap.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.ObjectIntHashMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHObjectIntHashMap.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.has",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntIntScatterMap.containsKey",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.has" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.sorting.IndirectComparator.AscendingIntComparator.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc.sorting.IndirectComparator",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.build" ],
    "methodSlices" : [ "public void prepareForContraction() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.SplitArea.fromJsonFeature",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Geometry.getNumGeometries",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.routing.lm.SplitArea.fromJsonFeature" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.CustomArea.fromJsonFeature",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Geometry.getNumGeometries",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.routing.util.CustomArea.fromJsonFeature" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.toString",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Geometry.getNumGeometries",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.EdgeResult.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.EdgeResult.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays", "com.graphhopper.reader.osm.WayToEdgeConverter.findEdgeChain" ],
    "methodSlices" : [ "/**\n * Finds the edge IDs associated with the given OSM ways that are adjacent to each other. For example for given\n * from-, via- and to-ways there can be multiple edges associated with each (because each way can be split into\n * multiple edges). We then need to find the from-edge that is connected with one of the via-edges which in turn\n * must be connected with one of the to-edges. We use DFS/backtracking to do this.\n * There can also be *multiple* via-ways, but the concept is the same.\n * Note that there can also be multiple from- or to-*ways*, but only one of each of them should be considered at a\n * time. In contrast to the via-ways there are only multiple from/to-ways, because of restrictions like no_entry or\n * no_exit where there can be multiple from- or to-members. So we need to find one edge-chain for each pair of from-\n * and to-ways.\n * Besides the edge IDs we also return the node IDs that connect the edges, so we can add turn restrictions at these\n * nodes later.\n */\npublic EdgeResult convertForViaWays(LongArrayList fromWays, LongArrayList viaWays, LongArrayList toWays) throws OSMRestrictionException {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.<init>", "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.initCollections" ],
    "methodSlices" : [ "public EdgeBasedWitnessPathSearcher(CHPreparationGraph prepareGraph) {\n    initCollections()\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.constant",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.constant" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.zero",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.zero" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.InMemConstructionIndex.InMemLeafEntry.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.InMemConstructionIndex.InMemLeafEntry.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.NodeResult.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.NodeResult.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.calcNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.calcNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.range",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.range" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.subList",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.subList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.HeadingResolver.getEdgesWithDifferentHeading",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.HeadingResolver.getEdgesWithDifferentHeading" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlayBuilder.build", "com.graphhopper.routing.querygraph.QueryOverlay.<init>" ],
    "methodSlices" : [ "public static QueryOverlay build(int firstVirtualNodeId, int firstVirtualEdgeId, boolean is3D, List<Snap> snaps) {\n}", "private QueryOverlay build(List<Snap> resList) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.invert",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.invert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.<init>",
    "thirdPartyMethod" : "org.locationtech.jts.geom.impl.PackedCoordinateSequence.Double.<init>",
    "thirdPartyPackage" : "org.locationtech.jts.geom.impl.PackedCoordinateSequence",
    "path" : [ "com.graphhopper.util.shapes.Polygon.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.<init>", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.ConnectedComponents.<init>" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}", "private EdgeBasedTarjanSCC(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.<init>", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.ConnectedComponents.<init>" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param edgeTransitionFilter\n * \t\tOnly edge transitions accepted by this filter will be considered when we explore the graph.\n * \t\tIf a turn is not accepted the corresponding path will be ignored (edges that are only connected\n * \t\tby a path with such a turn will not be considered to belong to the same component)\n * @param excludeSingleEdgeComponents\n * \t\tif set to true components that only contain a single edge will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private EdgeBasedTarjanSCC(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.<init>" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.<init>" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param excludeSingleNodeComponents\n * \t\tif set to true components that only contain a single node will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.BaseGraphNodesAndEdges.sortEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.BaseGraphNodesAndEdges.sortEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.BaseGraphNodesAndEdges.relabelNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.BaseGraphNodesAndEdges.relabelNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.<init>", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.ConnectedComponents.<init>" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeTransitionFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private EdgeBasedTarjanSCC(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.isPermutation",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.isPermutation" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryGraph.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.contains",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryGraph.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.contains",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.getLast",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.getLast" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.RestrictionTopology.way",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.RestrictionTopology.way", "com.graphhopper.reader.osm.RestrictionTopology.<init>" ],
    "methodSlices" : [ "public static RestrictionTopology way(IntArrayList fromEdges, IntArrayList viaEdges, IntArrayList toEdges, IntArrayList viaNodes) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.calcNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.calcNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.CHPathCalculator.calcPaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.CHPathCalculator.calcPaths" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction", "com.graphhopper.reader.osm.OSMRestrictionConverter.createRestrictionsForViaEdgeOnlyRestriction" ],
    "methodSlices" : [ "/**\n * Converts an OSM restriction to (multiple) single 'no' restrictions to be fed into {@link RestrictionSetter}\n */\npublic static List<RestrictionSetter.Restriction> buildRestrictionsForOSMRestriction(BaseGraph baseGraph, RestrictionTopology topology, RestrictionType type) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.RestrictionTopology.node",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.RestrictionTopology.node", "com.graphhopper.reader.osm.RestrictionTopology.<init>" ],
    "methodSlices" : [ "public static RestrictionTopology node(IntArrayList fromEdges, int viaNode, IntArrayList toEdges) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.calcEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.calcEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.calcPoints",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.calcPoints" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ViaRouting.lookup",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.isEmpty",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ViaRouting.lookup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntScatterSet.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.initForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntSet.<init>" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}", "private ConnectedComponents findComponentsForStartEdges(IntContainer startEdges) {\n    initForStartEdges(startEdges.size())\n}", "private void initForStartEdges(int edges) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.ArrayEdgeIntAccess.setInt",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ev.ArrayEdgeIntAccess.setInt" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.setShortcutForPrepareEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.setShortcutForPrepareEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.range",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.range" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.build", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.buildFirstEdgesByNode" ],
    "methodSlices" : [ "public void prepareForContraction() {\n}", null ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.invert",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.invert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.readCountries",
    "thirdPartyMethod" : "com.bedatadriven.jackson.datatype.jts.JtsModule.<init>",
    "thirdPartyPackage" : "com.bedatadriven.jackson.datatype.jts",
    "path" : [ "com.graphhopper.util.GHUtility.readCountries" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.resolveCustomAreas",
    "thirdPartyMethod" : "com.bedatadriven.jackson.datatype.jts.JtsModule.<init>",
    "thirdPartyPackage" : "com.bedatadriven.jackson.datatype.jts",
    "path" : [ "com.graphhopper.GraphHopper.resolveCustomAreas" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LMPreparationHandler.init",
    "thirdPartyMethod" : "com.bedatadriven.jackson.datatype.jts.JtsModule.<init>",
    "thirdPartyPackage" : "com.bedatadriven.jackson.datatype.jts",
    "path" : [ "com.graphhopper.routing.lm.LMPreparationHandler.init", "com.graphhopper.routing.lm.LMPreparationHandler.loadLandmarkSplittingFeatureCollection" ],
    "methodSlices" : [ "public void init(GraphHopperConfig ghConfig) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.initLandmarkWeights",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.forEach",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.initLandmarkWeights" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryGraph.create",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.forEach",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryGraph.create", "com.graphhopper.routing.querygraph.QueryGraph.<init>", "com.graphhopper.routing.querygraph.QueryGraph.buildVirtualEdgesAtRealNodes" ],
    "methodSlices" : [ "public static QueryGraph create(BaseGraph graph, List<Snap> snaps) {\n    return new QueryGraph(graph, snaps);\n}", "private QueryGraph(BaseGraph graph, List<Snap> snaps) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.forEach",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.<init>", "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.buildVirtualEdgesAtRealNodes" ],
    "methodSlices" : [ "public QueryRoutingCHGraph(RoutingCHGraph routingCHGraph, QueryGraph queryGraph) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate",
    "thirdPartyMethod" : "org.locationtech.jts.triangulate.DelaunayTriangulationBuilder.setSites",
    "thirdPartyPackage" : "org.locationtech.jts.triangulate",
    "path" : [ "com.graphhopper.isochrone.algorithm.JTSTriangulator.triangulate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntIntScatterMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.initForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanHashIntIntMap.<init>" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}", "private ConnectedComponents findComponentsForStartEdges(IntContainer startEdges) {\n    initForStartEdges(startEdges.size())\n}", "private void initForStartEdges(int edges) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.initLandmarkWeights",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.initLandmarkWeights" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryGraph.create",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryGraph.create", "com.graphhopper.routing.querygraph.QueryGraph.<init>", "com.graphhopper.routing.querygraph.QueryGraph.buildVirtualEdgesAtRealNodes" ],
    "methodSlices" : [ "public static QueryGraph create(BaseGraph graph, List<Snap> snaps) {\n    return new QueryGraph(graph, snaps);\n}", "private QueryGraph(BaseGraph graph, List<Snap> snaps) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.<init>", "com.graphhopper.routing.querygraph.QueryRoutingCHGraph.buildVirtualEdgesAtRealNodes" ],
    "methodSlices" : [ "public QueryRoutingCHGraph(RoutingCHGraph routingCHGraph, QueryGraph queryGraph) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectMap.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks", "com.graphhopper.routing.lm.LandmarkStorage.estimateMaxWeight", "com.graphhopper.routing.lm.LandmarkStorage.LandmarkExplorer.getFromCount" ],
    "methodSlices" : [ "/**\n * This method calculates the landmarks and initial weightings to &amp; from them.\n */\npublic void createLandmarks() {\n}", "/**\n * This method returns the maximum weight for the graph starting from the landmarks\n */\nprivate double estimateMaxWeight(List<IntArrayList> graphComponents, EdgeFilter accessFilter) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectScatterMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.BridgePathFinder.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntObjectScatterMap.<init>",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.BridgePathFinder.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntContainer.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.coll.GHIntHashSet.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntContainer.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.coll.GHIntHashSet.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntContainer.size",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.contains",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.RoadDensityCalculator.calcRoadDensity" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.BreadthFirstSearch.start",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.contains",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.BreadthFirstSearch.start", "com.graphhopper.reader.dem.EdgeElevationInterpolator.checkAdjacent" ],
    "methodSlices" : [ "@Override\npublic void start(EdgeExplorer explorer, int startNode) {\n    SimpleIntDeque fifo = new SimpleIntDeque();\n    GHBitSet visited = createBitSet();\n    visited.add(startNode);\n    fifo.push(startNode);\n    int current;\n    while (!fifo.isEmpty()) {\n        current = fifo.pop();\n        if (!goFurther(current))\n            continue;\n\n        EdgeIterator iter = explorer.setBaseNode(current);\n        while (iter.next()) {\n            int connectedId = iter.getAdjNode();\n            if (checkAdjacent(iter) && (!visited.contains(connectedId))) {\n                visited.add(connectedId);\n                fifo.push(connectedId);\n            }\n        } \n    } \n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.AlternativeRoute.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.contains",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.AlternativeRoute.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.weighting.AvoidEdgesWeighting.calcEdgeWeight",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntSet.contains",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.weighting.AvoidEdgesWeighting.calcEdgeWeight" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.Polygon.getMinLon",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Envelope.getMinX",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.Polygon.getMinLon" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.shapes.BBox.fromEnvelope",
    "thirdPartyMethod" : "org.locationtech.jts.geom.Envelope.getMinX",
    "thirdPartyPackage" : "org.locationtech.jts.geom",
    "path" : [ "com.graphhopper.util.shapes.BBox.fromEnvelope" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.<init>",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.toString",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.OSMRestrictionConverter.buildRestrictionsForOSMRestriction" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgeConverter.convertForViaWays", "com.graphhopper.reader.osm.WayToEdgeConverter.buildResult" ],
    "methodSlices" : [ "/**\n * Finds the edge IDs associated with the given OSM ways that are adjacent to each other. For example for given\n * from-, via- and to-ways there can be multiple edges associated with each (because each way can be split into\n * multiple edges). We then need to find the from-edge that is connected with one of the via-edges which in turn\n * must be connected with one of the to-edges. We use DFS/backtracking to do this.\n * There can also be *multiple* via-ways, but the concept is the same.\n * Note that there can also be multiple from- or to-*ways*, but only one of each of them should be considered at a\n * time. In contrast to the via-ways there are only multiple from/to-ways, because of restrictions like no_entry or\n * no_exit where there can be multiple from- or to-members. So we need to find one edge-chain for each pair of from-\n * and to-ways.\n * Besides the edge IDs we also return the node IDs that connect the edges, so we can add turn restrictions at these\n * nodes later.\n */\npublic EdgeResult convertForViaWays(LongArrayList fromWays, LongArrayList viaWays, LongArrayList toWays) throws OSMRestrictionException {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.build", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.buildFirstEdgesByNode" ],
    "methodSlices" : [ "public void prepareForContraction() {\n}", null ]
  }, {
    "entryPoint" : "com.graphhopper.routing.querygraph.EdgeChangeBuilder.apply",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.querygraph.EdgeChangeBuilder.apply", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.addRemovedEdges", "com.graphhopper.routing.querygraph.EdgeChangeBuilder.getClosestEdge" ],
    "methodSlices" : [ "@Override\npublic void apply(int value) {\n    addRemovedEdges(value);\n}", "/**\n * Adds the ids of the removed edges at the real tower nodes. We need to do this such that we cannot 'skip'\n * virtual nodes by just using the original edges and also to prevent u-turns at the real nodes adjacent to the\n * virtual ones.\n */\nprivate void addRemovedEdges(int towerNode) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.LineIntIndex.store",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.LineIntIndex.store", "com.graphhopper.storage.index.LineIntIndex.store" ],
    "methodSlices" : [ "public void store(InMemConstructionIndex inMem) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.next",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.next", "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.hasAccess" ],
    "methodSlices" : [ "@Override\npublic boolean next() {\n    while (true) {\n        index++;\n        if (index >= endEdge)\n            return false;\n\n        if (hasAccess())\n            return true;\n\n    } \n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.weighting.QueryGraphWeighting.calcTurnMillis",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.weighting.QueryGraphWeighting.calcTurnMillis", "com.graphhopper.routing.weighting.QueryGraphWeighting.getMinWeightAndOriginalEdges", "com.graphhopper.routing.weighting.QueryGraphWeighting.getOriginalEdge" ],
    "methodSlices" : [ "@Override\npublic long calcTurnMillis(int inEdge, int viaNode, int outEdge) {\n}", "private Result getMinWeightAndOriginalEdges(int inEdge, int viaNode, int outEdge) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.ArrayEdgeIntAccess.getInt",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ev.ArrayEdgeIntAccess.getInt" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.TurnCostStorage.sortNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.TurnCostStorage.sortNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.finishSearch",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.finishSearch", "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.reset", "com.graphhopper.routing.ch.EdgeBasedWitnessPathSearcher.resetShortestPathTree" ],
    "methodSlices" : [ "public void finishSearch() {\n    reset()\n}", "private void reset() {\n    resetShortestPathTree()\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.getFinalEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.getFinalEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgesMap.next",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgesMap.next" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.getFromEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.getFromEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.getShortcutForPrepareEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.getShortcutForPrepareEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.Path.forEveryEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.Path.forEveryEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.weighting.QueryGraphWeighting.calcTurnWeight",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.weighting.QueryGraphWeighting.calcTurnWeight", "com.graphhopper.routing.weighting.QueryGraphWeighting.getMinWeightAndOriginalEdges", "com.graphhopper.routing.weighting.QueryGraphWeighting.getOriginalEdge" ],
    "methodSlices" : [ "@Override\npublic double calcTurnWeight(int inEdge, int viaNode, int outEdge) {\n}", "private Result getMinWeightAndOriginalEdges(int inEdge, int viaNode, int outEdge) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.getLast",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.getLast" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.subList",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.subList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.getAdjNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.getAdjNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.comparePaths",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.GHUtility.comparePaths", "com.graphhopper.util.GHUtility.pathsEqualExceptOneEdge" ],
    "methodSlices" : [ "public static List<String> comparePaths(Path refPath, Path path, int source, int target, long seed) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.setBaseNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.setBaseNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.reader.osm.WayToEdgesMap.getEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.reader.osm.WayToEdgesMap.getEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.invert",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.invert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.getOrigEdgeKeyFirst",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.OrigEdgeIteratorImpl.getOrigEdgeKeyFirst" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.setRestrictions" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.getToEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntArrayList.get",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.util.parsers.RestrictionSetter.InternalRestriction.getToEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.GHUtility.readCountries",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.registerModule",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.util.GHUtility.readCountries" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.resolveCustomAreas",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.registerModule",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.GraphHopper.resolveCustomAreas" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LMPreparationHandler.init",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.registerModule",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "com.graphhopper.routing.lm.LMPreparationHandler.init", "com.graphhopper.routing.lm.LMPreparationHandler.loadLandmarkSplittingFeatureCollection" ],
    "methodSlices" : [ "public void init(GraphHopperConfig ghConfig) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.calcSortOrder",
    "thirdPartyMethod" : "com.carrotsearch.hppc.sorting.IndirectSort.mergesort",
    "thirdPartyPackage" : "com.carrotsearch.hppc.sorting",
    "path" : [ "com.graphhopper.util.ArrayUtil.calcSortOrder" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction",
    "thirdPartyMethod" : "com.carrotsearch.hppc.sorting.IndirectSort.mergesort",
    "thirdPartyPackage" : "com.carrotsearch.hppc.sorting",
    "path" : [ "com.graphhopper.routing.ch.CHPreparationGraph.prepareForContraction", "com.graphhopper.routing.ch.CHPreparationGraph.OrigGraph.Builder.build" ],
    "methodSlices" : [ "public void prepareForContraction() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve",
    "thirdPartyMethod" : "com.carrotsearch.hppc.sorting.IndirectSort.mergesort",
    "thirdPartyPackage" : "com.carrotsearch.hppc.sorting",
    "path" : [ "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntContainer.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntContainer.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.EdgeBasedNodeContractor.contractNode", "com.graphhopper.routing.ch.EdgeBasedNodeContractor.updateHierarchyDepthsOfNeighbors" ],
    "methodSlices" : [ "@Override\npublic IntContainer contractNode(int node) {\n    IntContainer neighbors = prepareGraph.disconnect(node)\n    updateHierarchyDepthsOfNeighbors(node, neighbors)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ch.PrepareContractionHierarchies.doWork",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntContainer.iterator",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ch.PrepareContractionHierarchies.doWork", "com.graphhopper.routing.ch.PrepareContractionHierarchies.runGraphContraction", "com.graphhopper.routing.ch.PrepareContractionHierarchies.contractNodesUsingHeuristicNodeOrdering" ],
    "methodSlices" : [ "public Result doWork() {\n    if (prepared)\n    throw new IllegalStateException(\"Call doWork only once!\");\n\n    prepared = true\n    if (!graph.isFrozen()) {\n    throw new IllegalStateException(\"Given BaseGraph has not been frozen yet\");\n}\n    if (chStore.getShortcuts() > 0) {\n    throw new IllegalStateException(\"Given CHStore already contains shortcuts\");\n}\n    runGraphContraction()\n}", "private void runGraphContraction() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.index.LineIntIndex.onEdge",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.index.LineIntIndex.onEdge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks",
    "thirdPartyMethod" : "com.carrotsearch.hppc.IntHashSet.add",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks", "com.graphhopper.routing.lm.LandmarkStorage.findBorderEdgeIds" ],
    "methodSlices" : [ "/**\n * This method calculates the landmarks and initial weightings to &amp; from them.\n */\npublic void createLandmarks() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForStartEdges", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForEdgeState", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.startSearch", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Like {@link #findComponents(Graph, EdgeTransitionFilter, boolean)}, but the search only starts at the\n * given edges. This does not mean the search cannot expand to other edges, but this can be controlled by the\n * edgeTransitionFilter. This method does not return single edge components (the excludeSingleEdgeComponents option is\n * set to true).\n */\npublic static ConnectedComponents findComponentsForStartEdges(Graph graph, EdgeTransitionFilter edgeTransitionFilter, IntContainer edges) {\n}", "private ConnectedComponents findComponentsForStartEdges(IntContainer startEdges) {\n}", "private void findComponentsForEdgeState(EdgeIteratorState edge) {\n    int edgeKeyFwd = createEdgeKey(edge, false)\n    if (!edgeKeyIndex.has(edgeKeyFwd))\n    pushFindComponentForEdgeKey(edgeKeyFwd, edge.getAdjNode());\n\n    startSearch()\n    // We need to start the search for both edge keys of this edge, but its important to check if the second\n// has already been found by the first search. So we cannot simply push them both and start the search once.\nint edgeKeyBwd = createEdgeKey(edge, true)\n    if (!edgeKeyIndex.has(edgeKeyBwd))\n    pushFindComponentForEdgeKey(edgeKeyBwd, edge.getAdjNode());\n\n    startSearch()\n}", "private void startSearch() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsForEdgeState", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.startSearch", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param edgeTransitionFilter\n * \t\tOnly edge transitions accepted by this filter will be considered when we explore the graph.\n * \t\tIf a turn is not accepted the corresponding path will be ignored (edges that are only connected\n * \t\tby a path with such a turn will not be considered to belong to the same component)\n * @param excludeSingleEdgeComponents\n * \t\tif set to true components that only contain a single edge will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private ConnectedComponents findComponents() {\n}", "private void findComponentsForEdgeState(EdgeIteratorState edge) {\n    int edgeKeyFwd = createEdgeKey(edge, false)\n    if (!edgeKeyIndex.has(edgeKeyFwd))\n    pushFindComponentForEdgeKey(edgeKeyFwd, edge.getAdjNode());\n\n    startSearch()\n    // We need to start the search for both edge keys of this edge, but its important to check if the second\n// has already been found by the first search. So we cannot simply push them both and start the search once.\nint edgeKeyBwd = createEdgeKey(edge, true)\n    if (!edgeKeyIndex.has(edgeKeyBwd))\n    pushFindComponentForEdgeKey(edgeKeyBwd, edge.getAdjNode());\n\n    startSearch()\n}", "private void startSearch() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponentForNode", "com.graphhopper.routing.subnetwork.TarjanSCC.setupNextNode" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForNode(int v) {\n    setupNextNode(v)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.findComponents", "com.graphhopper.routing.subnetwork.TarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm using an explicit stack.\n *\n * @param excludeSingleNodeComponents\n * \t\tif set to true components that only contain a single node will not be\n * \t\treturned when calling {@link #findComponents} or {@link #findComponentsRecursive()},\n * \t\twhich can be useful to save some memory.\n */\npublic static ConnectedComponents findComponents(Graph graph, EdgeFilter edgeFilter, boolean excludeSingleNodeComponents) {\n}", "private ConnectedComponents findComponents() {\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.storage.BaseGraphNodesAndEdges.sortEdges",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.BaseGraphNodesAndEdges.sortEdges" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.storage.BaseGraphNodesAndEdges.relabelNodes",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.storage.BaseGraphNodesAndEdges.relabelNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.ev.ExternalBooleanEncodedValue.setBool",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.ev.ExternalBooleanEncodedValue.setBool" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentsRecursive", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.findComponentForEdgeKey", "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.buildComponent" ],
    "methodSlices" : [ "/**\n * Runs Tarjan's algorithm in a recursive way. Doing it like this requires a large stack size for large graphs,\n * which can be set like `-Xss1024M`. Usually the version using an explicit stack ({@link #findComponents()}) should be\n * preferred. However, this recursive implementation is easier to understand.\n *\n * @see #findComponents(Graph, EdgeTransitionFilter, boolean)\n */\npublic static ConnectedComponents findComponentsRecursive(Graph graph, EdgeTransitionFilter edgeTransitionFilter, boolean excludeSingleEdgeComponents) {\n}", "private ConnectedComponents findComponentsRecursive() {\n}", "private void findComponentForEdgeKey(int p, int adjNode) {\n    // we have to create a new explorer on each iteration because of the nested edge iterations\nfinal int edge = getEdgeFromEdgeKey(p)\n    EdgeExplorer explorer = graph.createEdgeExplorer()\n    EdgeIterator iter = explorer.setBaseNode(adjNode)\n    while (iter.next()) {\n    if (!edgeTransitionFilter.accept(edge, iter))\n        continue;\n\n    int q = createEdgeKey(iter, false);\n    handleNeighbor(p, q, iter.getAdjNode());\n} \n    buildComponent(p)\n}" ]
  }, {
    "entryPoint" : "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanArrayIntSet.add",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.routing.subnetwork.EdgeBasedTarjanSCC.TarjanArrayIntSet.add" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.GraphHopper.sortGraphAlongHilbertCurve" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "com.graphhopper.util.ArrayUtil.isPermutation",
    "thirdPartyMethod" : "com.carrotsearch.hppc.BitSet.set",
    "thirdPartyPackage" : "com.carrotsearch.hppc",
    "path" : [ "com.graphhopper.util.ArrayUtil.isPermutation" ],
    "methodSlices" : [ ]
  } ]
}