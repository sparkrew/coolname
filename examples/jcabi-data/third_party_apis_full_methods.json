{
  "fullMethodsPaths" : [ {
    "entryPoint" : "com.jcabi.github.mock.JsonNode.json",
    "thirdPartyMethod" : "org.w3c.dom.Node.getNodeName",
    "thirdPartyPackage" : "org.w3c.dom",
    "path" : [ "com.jcabi.github.mock.JsonNode.json" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON\n * @checkstyle MultipleStringLiteralsCheck (30 lines)\n */\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final XML child : this.xml.nodes(\"* \")) {\n        final Node node = child.node();\n        if (child.nodes(\"*\").isEmpty()) {\n            builder.add(node.getNodeName(), node.getTextContent());\n        } else if ((!child.xpath(\"//@array\").isEmpty()) && \"true\".equals(child.xpath(\"//@array\").get(0))) {\n            final JsonArrayBuilder bld = Json.createArrayBuilder();\n            for (final XML item : child.nodes(\"*\")) {\n                bld.add(item.node().getTextContent());\n            }\n            builder.add(node.getNodeName(), bld.build());\n        } else {\n            builder.add(node.getNodeName(), new JsonNode(child).json());\n        }\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.JsonNode.json",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.JsonNode.json" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON\n * @checkstyle MultipleStringLiteralsCheck (30 lines)\n */\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final XML child : this.xml.nodes(\"* \")) {\n        final Node node = child.node();\n        if (child.nodes(\"*\").isEmpty()) {\n            builder.add(node.getNodeName(), node.getTextContent());\n        } else if ((!child.xpath(\"//@array\").isEmpty()) && \"true\".equals(child.xpath(\"//@array\").get(0))) {\n            final JsonArrayBuilder bld = Json.createArrayBuilder();\n            for (final XML item : child.nodes(\"*\")) {\n                bld.add(item.node().getTextContent());\n            }\n            builder.add(node.getNodeName(), bld.build());\n        } else {\n            builder.add(node.getNodeName(), new JsonNode(child).json());\n        }\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.meta",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() {\n    return Json.createObjectBuilder().add(\"hooks\", Json.createArrayBuilder().build()).add(\"git\", Json.createArrayBuilder().build()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.json",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkIssue.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final XML xml = this.storage.xml();\n    final JsonObject obj = new JsonNode(xml.nodes(this.xpath()).get(0)).json();\n    final JsonObjectBuilder json = Json.createObjectBuilder();\n    for (final Map.Entry<String, JsonValue> val : obj.entrySet()) {\n        json.add(val.getKey(), val.getValue());\n    }\n    final JsonArrayBuilder array = Json.createArrayBuilder();\n    for (final Label label : this.labels().iterate()) {\n        array.add(Json.createObjectBuilder().add(\"name\", label.name()).build());\n    }\n    final JsonObjectBuilder res = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    json.add(\"labels\", array).add(\"assignee\", Json.createObjectBuilder().add(\"login\", obj.getString(\"assignee\", \"\")).build());\n    final JsonObjectBuilder pull = Json.createObjectBuilder();\n    final String html = \"html_url\";\n    if (xml.nodes(// @checkstyle LineLengthCheck (1 line)\n    String.format(\"/github/repos/repo[@coords='%s']/pulls/pull/number[text() = '%d']\", this.coords, this.num)).isEmpty()) {\n        pull.addNull(html);\n    } else {\n        pull.add(html, String.format(\"https://%s/pulls/%d\", this.coords, this.num));\n    }\n    return res.add(\"pull_request\", pull.build()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCommitsComparison.json",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkCommitsComparison.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    return // @checkstyle MultipleStringLiterals (3 lines)\n    Json.createObjectBuilder().add(\"status\", \"test-status\").add(\"ahead_by\", 1).add(\"behind_by\", 2).add(\"author\", // @checkstyle MultipleStringLiterals (3 lines)\n    Json.createObjectBuilder().add(\"login\", \"test\").build()).add(\"files\", Json.createArrayBuilder().add(MkCommitsComparison.FILE_JSON).build()).add(\"commits\", Json.createArrayBuilder().build()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "javax.json.Json.createArrayBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.\n *\n * @since 0.4\n */\npublic RtGithub() {\n    this(RtGithub.REQUEST);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.header",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.header" ],
    "fullMethods" : [ "@Override\npublic Request header(final String name, final Object value) {\n    return new SearchRequest(this.request.header(name, value));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.emails",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.emails", "com.jcabi.github.RtUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    return new RtUserEmails(this.ghub.entry());\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n */\nRtUserEmails(final Request req) {\n    this.request = req.header(\"Accept\", \"application/vnd.github.v3\").uri().path(\"/user/emails\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.markdown",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.markdown", "com.jcabi.github.RtMarkdown.<init>" ],
    "fullMethods" : [ "@Override\npublic Markdown markdown() {\n    return new RtMarkdown(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtMarkdown(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"markdown\").back().method(Request.POST);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.star",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.method",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.method" ],
    "fullMethods" : [ "@Override\npublic Request method(final String method) {\n    return new SearchRequest(this.request.method(method));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.clear",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.clear" ],
    "fullMethods" : [ "@Override\npublic void clear() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<ReleaseAsset> iterate() {\n    return new RtPagination<>(this.request.uri().back().method(Request.GET), value -> // @checkstyle MultipleStringLiteralsCheck (1 line)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Content.Smart.decoded",
    "thirdPartyMethod" : "javax.xml.bind.DatatypeConverter.parseBase64Binary",
    "thirdPartyPackage" : "javax.xml.bind",
    "path" : [ "com.jcabi.github.Content.Smart.decoded" ],
    "fullMethods" : [ "/**\n * Get its decoded content.\n *\n * @return Decoded content\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic byte[] decoded() throws IOException {\n    return DatatypeConverter.parseBase64Binary(this.content());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContent.raw",
    "thirdPartyMethod" : "javax.xml.bind.DatatypeConverter.parseBase64Binary",
    "thirdPartyPackage" : "javax.xml.bind",
    "path" : [ "com.jcabi.github.mock.MkContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(DatatypeConverter.parseBase64Binary(this.storage.xml().xpath(String.format(\"%s/content/text()\", this.xpath())).get(0)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.<clinit>",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGit.commits", "com.jcabi.github.RtCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic Commits commits() {\n    return new RtCommits(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/commits\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGistComments.get", "com.jcabi.github.RtGistComment.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComment get(final int number) {\n    return new RtGistComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param gist\n * \t\tGist of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtGistComment(final Request req, final Gist gist, final int number) {\n    this.request = req.uri().path(\"/gists\").path(new Gist.Smart(gist).identifier()).path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = gist;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKey.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param user\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\npublic RtPublicKey(final Request req, final User user, final int number) {\n    this.request = req.uri().path(\"/user\").path(\"/keys\").path(Integer.toString(number)).back();\n    this.owner = user;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.assignees",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.assignees", "com.jcabi.github.RtAssignees.<init>" ],
    "fullMethods" : [ "@Override\npublic Assignees assignees() {\n    return new RtAssignees(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtAssignees(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/assignees\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.markdown",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.markdown", "com.jcabi.github.RtMarkdown.<init>" ],
    "fullMethods" : [ "@Override\npublic Markdown markdown() {\n    return new RtMarkdown(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtMarkdown(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"markdown\").back().method(Request.POST);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTags.get", "com.jcabi.github.RtTag.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag get(final String sha) {\n    return new RtTag(this.entry, this.owner, sha);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe request.\n * @param repo\n * \t\tThe owner repo.\n * @param key\n * \t\tThe sha.\n */\nRtTag(final Request req, final Repo repo, final String key) {\n    this.sha = key;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").path(this.sha).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBranch.commit",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtBranch.commit", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit commit() {\n    return new RtCommit(this.entry, this.owner, this.hash);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.keys",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.keys", "com.jcabi.github.RtDeployKeys.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKeys keys() {\n    return new RtDeployKeys(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\nRtDeployKeys(final Request req, final Repo repo) {\n    this.owner = repo;\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtIssue.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGists.get", "com.jcabi.github.RtGist.<init>" ],
    "fullMethods" : [ "@Override\npublic Gist get(final String name) {\n    return new RtGist(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param name\n * \t\tName of gist\n */\nRtGist(final Github github, final Request req, final String name) {\n    this.ghub = github;\n    this.entry = req;\n    this.gist = name;\n    this.request = req.uri().path(\"/gists\").path(name).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.milestones",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.milestones", "com.jcabi.github.RtMilestones.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestones milestones() {\n    return new RtMilestones(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtMilestones(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabels.get", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label get(final String name) {\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGitignores.<init>" ],
    "fullMethods" : [ "/**\n * Public CTOR.\n *\n * @param github\n * \t\tGithub\n */\npublic RtGitignores(final Github github) {\n    this.ghub = github;\n    this.request = github().entry().uri().path(\"/gitignore/templates\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.references",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGit.references", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic References references() {\n    return new RtReferences(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtNotifications.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtNotifications.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Notification> iterate() {\n    return new RtPagination<>(this.request.uri().queryParam(\"all\", \"true\").queryParam(\"since\", \"1970-01-01T00:00:00Z\").back(), json -> new RtNotification(Long.valueOf(json.getString(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReferences.get", "com.jcabi.github.RtReference.<init>" ],
    "fullMethods" : [ "@Override\npublic Reference get(final String identifier) {\n    return new RtReference(this.entry, this.owner, identifier);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tOwner of this reference.\n * @param ref\n * \t\tThe name of the reference.\n */\nRtReference(final Request req, final Repo repo, final String ref) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(ref).back();\n    this.owner = repo;\n    this.name = ref;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.commits" ],
    "fullMethods" : [ "@Override\npublic Iterable<Commit> commits() {\n    return new RtPagination<>(this.request.uri().path(\"/commits\").back(), object -> new RtCommit(this.entry, this.owner, object.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.tags",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGit.tags", "com.jcabi.github.RtTags.<init>" ],
    "fullMethods" : [ "@Override\npublic Tags tags() {\n    return new RtTags(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtTags(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComments.get", "com.jcabi.github.RtComment.<init>" ],
    "fullMethods" : [ "@Override\npublic Comment get(final long number) {\n    return new RtComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param issue\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtComment(final Request req, final Issue issue, final long number) {\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/comments\").path(Long.toString(number)).back();\n    this.owner = issue;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.statuses",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCommits.statuses", "com.jcabi.github.RtStatuses.<init>" ],
    "fullMethods" : [ "@Override\npublic Statuses statuses(final String ref) {\n    return new RtStatuses(this.entry, this.get(ref));\n}", "/**\n * Create a new status-aware object based on given commit.\n *\n * @param req\n * \t\tHttp request\n * @param commit\n * \t\tSpecific commit\n */\nRtStatuses(final Request req, final Commit commit) {\n    final Coordinates coords = commit.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/statuses\").path(commit.sha()).back();\n    this.cmmt = commit;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.compare",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.compare", "com.jcabi.github.RtCommitsComparison.<init>" ],
    "fullMethods" : [ "@Override\npublic CommitsComparison compare(final String base, final String head) {\n    return new RtCommitsComparison(this.entry, this.owner, base, head);\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n * @param base\n * \t\tSHA of a base commit\n * @param head\n * \t\tSHA of a head commit\n * @checkstyle ParameterNumber (3 lines)\n */\nRtCommitsComparison(final Request req, final Repo repo, final String base, final String head) {\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().toString()).path(\"/compare\").path(String.format(\"%s...%s\", base, head)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.emails",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUser.emails", "com.jcabi.github.RtUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    return new RtUserEmails(this.ghub.entry());\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n */\nRtUserEmails(final Request req) {\n    this.request = req.header(\"Accept\", \"application/vnd.github.v3\").uri().path(\"/user/emails\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComment.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtComment.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.users",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.users", "com.jcabi.github.RtUsers.<init>" ],
    "fullMethods" : [ "@Override\npublic Users users() {\n    return new RtUsers(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtUsers(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/users\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabels.create", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.gists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.gists", "com.jcabi.github.RtGists.<init>" ],
    "fullMethods" : [ "@Override\npublic Gists gists() {\n    return new RtGists(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtGists(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/gists\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchURI.back",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchURI.back" ],
    "fullMethods" : [ "@Override\npublic Request back() {\n    return new SearchRequest(this.address.back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.limits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.limits", "com.jcabi.github.RtLimits.<init>" ],
    "fullMethods" : [ "@Override\npublic Limits limits() {\n    return new RtLimits(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtLimits(final Github github, final Request req) {\n    this.entry = req.uri().path(\"rate_limit\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.get", "com.jcabi.github.RtRepo.<init>" ],
    "fullMethods" : [ "@Override\npublic Repo get(final Coordinates name) {\n    return new RtRepo(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param crd\n * \t\tCoordinate of the repo\n */\nRtRepo(final Github github, final Request req, final Coordinates crd) {\n    this.ghub = github;\n    this.entry = req;\n    this.coords = crd;\n    this.request = this.entry.uri().path(\"/repos\").path(this.coords.user()).path(this.coords.repo()).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.get", "com.jcabi.github.RtRepoCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommit get(final String sha) {\n    return new RtRepoCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtRepoCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stargazers",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.stargazers", "com.jcabi.github.RtStargazers.<init>" ],
    "fullMethods" : [ "@Override\npublic Stargazers stargazers() {\n    return new RtStargazers(this.request);\n}", "/**\n * Public ctor.\n *\n * @param entry\n * \t\tEntry request.\n */\nRtStargazers(final Request entry) {\n    this.request = entry.uri().path(\"stargazers\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.events",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.events" ],
    "fullMethods" : [ "@Override\npublic Iterable<Event> events() {\n    return new RtPagination<>(this.request.uri().path(\"/events\").back(), object -> new RtEvent(this.entry, this.owner, object.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.pulls",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.pulls", "com.jcabi.github.RtPulls.<init>" ],
    "fullMethods" : [ "@Override\npublic Pulls pulls() {\n    return new RtPulls(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtPulls(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.self",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUsers.self", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User self() {\n    return new RtUser(this.ghub, this.entry, \"\");\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserOrganizations.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUserOrganizations.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Organization> iterate() throws IOException {\n    final String login = this.owner.login();\n    return new RtPagination<>(this.entry.uri().path(\"/users\").path(login).path(\"/orgs\").back(), new OrganizationMapping(this.ghub.organizations()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.codes",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.codes", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> codes(final String keywords, final String sort, final Order order) {\n    return // @checkstyle AnonInnerLengthCheck (25 lines)\n    new RtSearchPagination<>(this.request, \"code\", keywords, sort, order.identifier(), object -> {\n        try {\n            // @checkstyle MultipleStringLiteralsCheck (1 line)\n            final URI uri = new URI(object.getString(\"url\"));\n            final String[] parts = RtSearch.SLASH.split(uri.getPath());\n            final String ref = RtSearch.QUERY.split(uri.getQuery())[1];\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).contents().get(object.getString(\"path\"), ref);\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        } catch (final IOException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.issues", "com.jcabi.github.RtIssues.<init>" ],
    "fullMethods" : [ "@Override\npublic Issues issues() {\n    return new RtIssues(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssues(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssues.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Issue> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReferences.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reference> iterate(final String subnamespace) {\n    return new RtPagination<>(this.request.uri().path(subnamespace).back(), object -> this.get(object.getString(RtReferences.REF)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<RepoCommit> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> this.get(value.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.trees",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGit.trees", "com.jcabi.github.RtTrees.<init>" ],
    "fullMethods" : [ "@Override\npublic Trees trees() {\n    return new RtTrees(this.entry, this.repo());\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtTrees(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/trees\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtBlobs.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtBlobs(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPulls.get", "com.jcabi.github.RtPull.<init>" ],
    "fullMethods" : [ "@Override\npublic Pull get(final int number) {\n    return new RtPull(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtPull(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.organizations",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.organizations", "com.jcabi.github.RtOrganizations.<init>" ],
    "fullMethods" : [ "@Override\npublic Organizations organizations() {\n    return new RtOrganizations(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtOrganizations(final Github github, final Request req) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/user\").path(\"/orgs\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issueEvents",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.issueEvents", "com.jcabi.github.RtIssueEvents.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueEvents issueEvents() {\n    return new RtIssueEvents(this.entry, this);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssueEvents(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.files",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.files" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonObject> files() {\n    return new RtPagination<>(this.request.uri().path(\"/files\").back(), RtPagination.COPYING);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKeys.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param user\n * \t\tUser\n */\npublic RtPublicKeys(final Request req, final User user) {\n    this.entry = req;\n    this.owner = user;\n    this.request = this.entry.uri().path(\"/user\").path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtDeployKeys.get", "com.jcabi.github.RtDeployKey.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKey get(final int number) {\n    return new RtDeployKey(this.entry, number, this.owner);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param number\n * \t\tId\n * @param repo\n * \t\tRepository\n */\nRtDeployKey(final Request req, final int number, final Repo repo) {\n    this.key = number;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").path(String.valueOf(number)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAssets.get", "com.jcabi.github.RtReleaseAsset.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset get(final int number) {\n    return new RtReleaseAsset(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful Request\n * @param release\n * \t\tRelease\n * @param number\n * \t\tNumber of the release asset.\n */\nRtReleaseAsset(final Request req, final Release release, final int number) {\n    final Coordinates coords = release.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(\"/assets\").path(Integer.toString(number)).back();\n    this.owner = release;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTags.create", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUser.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.github().entry().uri().path(RtUser.NOTIF_PATH).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtOrganization.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tOrganization login name\n */\npublic RtOrganization(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(login).back();\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.get", "com.jcabi.github.RtPullComment.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComment get(final int number) {\n    return new RtPullComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param pull\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtPullComment(final Request req, final Pull pull, final int number) {\n    final Coordinates coords = pull.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = pull;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtForks.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Fork> iterate(final String sort) {\n    return new RtPagination<>(this.request.uri().queryParam(\"sort\", sort).back(), object -> this.get(object.getInt(ID)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssueEvents.get", "com.jcabi.github.RtEvent.<init>" ],
    "fullMethods" : [ "@Override\npublic Event get(final int number) {\n    return new RtEvent(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtEvent(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssues.get", "com.jcabi.github.RtIssue.<init>" ],
    "fullMethods" : [ "@Override\npublic Issue get(final int number) {\n    return new RtIssue(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtIssue(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleases.get", "com.jcabi.github.RtRelease.<init>" ],
    "fullMethods" : [ "@Override\npublic Release get(final int number) {\n    return new RtRelease(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n * @param nmbr\n * \t\tRelease id\n */\nRtRelease(final Request req, final Repo repo, final int nmbr) {\n    this.entry = req;\n    this.release = nmbr;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").path(String.valueOf(this.release)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.getRec",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTrees.getRec" ],
    "fullMethods" : [ "@Override\npublic Tree getRec(final String sha) {\n    return new RtTree(this.entry.uri().queryParam(\"recursive\", \"1\").back(), this.owner, sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleases.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtReleases(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = this.entry.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtForks.create", "com.jcabi.github.RtForks.get", "com.jcabi.github.RtFork.<init>" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}", "/**\n * Get fork by number.\n *\n * @param number\n * \t\tFork number\n * @return Fork\n */\nprivate RtFork get(final Integer number) {\n    return new RtFork(this.request, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtFork(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/forks\").path(Integer.toString(number)).back();\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtForks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtForks(final Request req, final Repo repo) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"forks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.languages",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.languages" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Iterable<Language> languages() throws IOException {\n    final RtJson json = new RtJson(this.request.uri().path(\"/languages\").back());\n    final JsonObject object = json.fetch();\n    final List<Language> languages = new ArrayList<>(object.size());\n    for (final Map.Entry<String, JsonValue> value : object.entrySet()) {\n        final String name = value.getKey();\n        languages.add(new RtLanguage(name, object.getJsonNumber(name).longValue()));\n    }\n    return languages;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.branches",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.branches", "com.jcabi.github.RtBranches.<init>" ],
    "fullMethods" : [ "@Override\npublic Branches branches() {\n    return new RtBranches(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtBranches(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/branches\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.labels", "com.jcabi.github.RtLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic Labels labels() {\n    return new RtLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepo we're in\n */\nRtLabels(final Request req, final Repo repo) {\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.assets",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRelease.assets", "com.jcabi.github.RtReleaseAssets.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAssets assets() {\n    return new RtReleaseAssets(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param release\n * \t\tIssue\n */\nRtReleaseAssets(final Request req, final Release release) {\n    this.entry = req;\n    final Coordinates coords = release.repo().coordinates();\n    // @checkstyle MultipleStringLiteralsCheck (7 lines)\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(Integer.toString(release.number())).path(\"/assets\").back();\n    this.owner = release;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtContents(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/contents\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestones.get", "com.jcabi.github.RtMilestone.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestone get(final int number) {\n    return new RtMilestone(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtMilestone(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCommits.get", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit get(final String sha) {\n    return new RtCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.commits", "com.jcabi.github.RtRepoCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommits commits() {\n    return new RtRepoCommits(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtRepoCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final RequestURI rep = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo());\n    this.request = rep.path(\"/commits\").back();\n    this.comp = rep.path(\"/compare\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestones.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Milestone> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtHooks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtHooks(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> iterate(final String identifier) {\n    return new RtPagination<>(this.entry.uri().queryParam(\"since\", identifier).back(), object -> this.get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.comments", "com.jcabi.github.RtGistComments.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComments comments() {\n    return new RtGistComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param gist\n * \t\tGist\n */\nRtGistComments(final Request req, final Gist gist) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/gists\").path(gist.identifier()).path(\"/comments\").back();\n    this.owner = gist;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.search",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.search", "com.jcabi.github.RtSearch.<init>" ],
    "fullMethods" : [ "@Override\npublic Search search() {\n    return new RtSearch(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRESTful API entry point\n */\nRtSearch(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"/search\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.repos",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.repos", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> repos(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"repositories\", keywords, sort, order.identifier(), object -> this.github().repos().get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.comments", "com.jcabi.github.RtPullComments.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComments comments() {\n    return new RtPullComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param pull\n * \t\tPull\n */\nRtPullComments(final Request req, final Pull pull) {\n    this.entry = req;\n    this.owner = pull;\n    this.request = // @checkstyle MultipleStringLiterals (8 lines)\n    this.entry.uri().path(\"/repos\").path(pull.repo().coordinates().user()).path(pull.repo().coordinates().repo()).path(\"/pulls\").path(Integer.toString(pull.number())).path(\"/comments\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final int number, final Map<String, String> params) {\n    final Request newreq = this.entry.uri().path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/pulls\").path(String.valueOf(number)).path(\"/comments\").back();\n    return new RtPagination<>(newreq.uri().queryParams(params).back(), value -> this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUsers.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> iterate(final String identifier) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", identifier).back(), object -> this.get(String.valueOf(object.getInt(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.request.uri().path(\"notifications\").back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.collaborators",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.collaborators", "com.jcabi.github.RtCollaborators.<init>" ],
    "fullMethods" : [ "@Override\npublic Collaborators collaborators() {\n    return new RtCollaborators(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtCollaborators(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/collaborators\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtBlobs.get", "com.jcabi.github.RtBlob.<init>" ],
    "fullMethods" : [ "@Override\npublic Blob get(final String sha) {\n    return new RtBlob(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param sha\n * \t\tNumber of the get\n */\nRtBlob(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").path(sha).back();\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.users",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.users", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> users(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"users\", keywords, sort, order.identifier(), object -> this.ghub.users().get(object.getString(\"login\")));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicMembers.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param organ\n * \t\tOrganization\n */\npublic RtPublicMembers(final Request req, final Organization organ) {\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(organ.login()).path(\"public_members\").back();\n    this.organization = organ;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTrees.get", "com.jcabi.github.RtTree.<init>" ],
    "fullMethods" : [ "@Override\npublic Tree get(final String sha) {\n    return new RtTree(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtTree(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/trees\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.labels", "com.jcabi.github.RtIssueLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueLabels labels() {\n    return new RtIssueLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue we're in\n */\nRtIssueLabels(final Request req, final Issue issue) {\n    this.owner = issue;\n    final Coordinates coords = issue.repo().coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPulls.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Pull> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Comment> iterate(final Date since) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", new Github.Time(since)).back(), object -> this.get(object.getJsonNumber(\"id\").longValue()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUsers.get", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User get(final String login) {\n    return new RtUser(this.ghub, this.entry, login);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> // @checkstyle MultipleStringLiterals (3 lines)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.comments", "com.jcabi.github.RtComments.<init>" ],
    "fullMethods" : [ "@Override\npublic Comments comments() {\n    return new RtComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue\n */\nRtComments(final Request req, final Issue issue) {\n    this.entry = req;\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/comments\").back();\n    this.owner = issue;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stars",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.stars", "com.jcabi.github.RtStars.<init>" ],
    "fullMethods" : [ "@Override\npublic Stars stars() {\n    return new RtStars(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtStars(final Request req, final Repo repo) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/user/starred\").path(coords.user()).path(coords.repo()).back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.issues", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (5 lines)\n@Override\npublic Iterable<Issue> issues(final String keywords, final String sort, final Order order, final EnumMap<Qualifier, String> qualifiers) {\n    final StringBuilder keyword = new StringBuilder(keywords);\n    for (final Map.Entry<Qualifier, String> entry : qualifiers.entrySet()) {\n        keyword.append('+').append(entry.getKey().identifier()).append(':').append(entry.getValue());\n    }\n    return new RtSearchPagination<>(this.request, \"issues\", keyword.toString(), sort, order.identifier(), object -> {\n        try {\n            final String[] parts = // @checkstyle MultipleStringLiteralsCheck (1 line)\n            RtSearch.SLASH.split(new URI(object.getString(\"url\")).getPath());\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).issues().get(object.getInt(\"number\"));\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAssets.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<ReleaseAsset> iterate() {\n    return new RtPagination<>(this.request.uri().back().method(Request.GET), value -> // @checkstyle MultipleStringLiteralsCheck (1 line)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.back",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtHooks.get", "com.jcabi.github.RtHook.<init>" ],
    "fullMethods" : [ "@Override\npublic Hook get(final int number) {\n    return new RtHook(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tId of the get\n */\nRtHook(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RepoCommit.Smart.isVerified",
    "thirdPartyMethod" : "javax.json.EmptyObject.getBoolean",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RepoCommit.Smart.isVerified" ],
    "fullMethods" : [ "/**\n * Returns TRUE if the commit is verified.\n *\n * @return TRUE if verified\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 1.1\n */\npublic boolean isVerified() throws IOException {\n    return this.jsn.json().getJsonObject(\"commit\").getJsonObject(\"verification\").getBoolean(\"verified\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.randomRepo",
    "thirdPartyMethod" : "org.apache.commons.lang3.RandomStringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkGithub.randomRepo" ],
    "fullMethods" : [ "/**\n * Create repo with random name.\n *\n * @return Repo\n * @throws IOException\n * \t\tIf fails\n */\npublic Repo randomRepo() throws IOException {\n    return this.repos().create(new Repos.RepoCreate(RandomStringUtils.randomAlphanumeric(Tv.TWENTY), true));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkBlobs.create",
    "thirdPartyMethod" : "org.apache.commons.lang3.RandomStringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkBlobs.create", "com.jcabi.github.mock.MkBlobs.fakeSha" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    this.storage.lock();\n    final String sha = fakeSha();\n    try {\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"blob\").add(\"sha\").set(sha).up().add(\"url\").set(\"http://localhost/1\").up().attr(\"content\", content).attr(\"encoding\", encoding));\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(sha);\n}", "/**\n * Generate a random fake SHA hex string.\n *\n * @return Fake SHA string.\n */\nprivate static String fakeSha() {\n    // @checkstyle MagicNumberCheck (1 line)\n    return RandomStringUtils.random(40, \"0123456789abcdef\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.remove",
    "thirdPartyMethod" : "org.apache.commons.lang3.RandomStringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkContents.remove", "com.jcabi.github.mock.MkContents.commit", "com.jcabi.github.mock.MkContents.fakeSha" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    this.storage.lock();\n    final String path = content.getString(\"path\");\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (content.containsKey(\"ref\")) {\n            branch = content.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"content[path='%s']\", path)).attr(\"ref\", branch).remove());\n        return this.commit(content);\n    } finally {\n        this.storage.unlock();\n    }\n}", "/**\n * XML Directives for commit creation.\n *\n * @param json\n * \t\tSource\n * @return SHA string\n * @throws IOException\n * \t\tIf an IO Exception occurs\n */\nprivate MkRepoCommit commit(final JsonObject json) throws IOException {\n    final String sha = fakeSha();\n    // @checkstyle MultipleStringLiterals (40 lines)\n    final Directives commit = new Directives().xpath(this.commitXpath()).add(\"commit\").add(\"sha\").set(sha).up().add(\"url\").set(\"http://localhost/4\").up().add(\"html_url\").set(\"http://localhost/5\").up().add(\"message\").set(json.getString(\"message\")).up();\n    if (json.containsKey(\"committer\")) {\n        final JsonObject committer = json.getJsonObject(\"committer\");\n        commit.add(\"committer\").add(\"email\").set(committer.getString(\"email\")).up().add(\"name\").set(committer.getString(\"name\")).up();\n    }\n    if (json.containsKey(\"author\")) {\n        final JsonObject author = json.getJsonObject(\"author\");\n        commit.add(\"author\").add(\"email\").set(author.getString(\"email\")).up().add(\"name\").set(author.getString(\"name\")).up();\n    }\n    this.storage.apply(commit);\n    return new MkRepoCommit(this.storage, this.repo(), sha);\n}", "/**\n * Generate a random fake SHA hex string.\n *\n * @return Fake SHA string.\n */\nprivate static String fakeSha() {\n    // @checkstyle MagicNumberCheck (1 line)\n    return RandomStringUtils.random(40, \"0123456789abcdef\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.update",
    "thirdPartyMethod" : "org.apache.commons.lang3.RandomStringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkContents.update", "com.jcabi.github.mock.MkContents.commit", "com.jcabi.github.mock.MkContents.fakeSha" ],
    "fullMethods" : [ "/**\n * Updates a file.\n *\n * @param path\n * \t\tThe content path.\n * @param json\n * \t\tJSON object containing updates to the content.\n * @return Commit related to this update.\n * @throws IOException\n * \t\tIf any I/O problem occurs.\n */\n@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    this.storage.lock();\n    try {\n        final String ref = \"ref\";\n        final String branch;\n        if (json.containsKey(ref)) {\n            branch = json.getString(ref);\n        } else {\n            branch = \"master\";\n        }\n        final String xpath = // @checkstyle LineLengthCheck (1 line)\n        String.format(\"/github/repos/repo[@coords='%s']/contents/content[path='%s' and @ref='%s']\", this.coords, path, branch);\n        new JsonPatch(this.storage).patch(xpath, json);\n        return this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n}", "/**\n * XML Directives for commit creation.\n *\n * @param json\n * \t\tSource\n * @return SHA string\n * @throws IOException\n * \t\tIf an IO Exception occurs\n */\nprivate MkRepoCommit commit(final JsonObject json) throws IOException {\n    final String sha = fakeSha();\n    // @checkstyle MultipleStringLiterals (40 lines)\n    final Directives commit = new Directives().xpath(this.commitXpath()).add(\"commit\").add(\"sha\").set(sha).up().add(\"url\").set(\"http://localhost/4\").up().add(\"html_url\").set(\"http://localhost/5\").up().add(\"message\").set(json.getString(\"message\")).up();\n    if (json.containsKey(\"committer\")) {\n        final JsonObject committer = json.getJsonObject(\"committer\");\n        commit.add(\"committer\").add(\"email\").set(committer.getString(\"email\")).up().add(\"name\").set(committer.getString(\"name\")).up();\n    }\n    if (json.containsKey(\"author\")) {\n        final JsonObject author = json.getJsonObject(\"author\");\n        commit.add(\"author\").add(\"email\").set(author.getString(\"email\")).up().add(\"name\").set(author.getString(\"name\")).up();\n    }\n    this.storage.apply(commit);\n    return new MkRepoCommit(this.storage, this.repo(), sha);\n}", "/**\n * Generate a random fake SHA hex string.\n *\n * @return Fake SHA string.\n */\nprivate static String fakeSha() {\n    // @checkstyle MagicNumberCheck (1 line)\n    return RandomStringUtils.random(40, \"0123456789abcdef\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.create",
    "thirdPartyMethod" : "org.apache.commons.lang3.RandomStringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkContents.create", "com.jcabi.github.mock.MkContents.fakeSha" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject json) throws IOException {\n    this.storage.lock();\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (json.containsKey(\"ref\")) {\n            branch = json.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"content\").attr(\"ref\", branch).add(\"name\").set(json.getString(\"path\")).up().add(\"path\").set(json.getString(\"path\")).up().add(\"content\").set(json.getString(\"content\")).up().add(\"type\").set(\"file\").up().add(\"encoding\").set(\"base64\").up().add(\"sha\").set(fakeSha()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"git_url\").set(\"http://localhost/2\").up().add(\"html_url\").set(\"http://localhost/3\").up());\n        this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n    return new MkContent(this.storage, this.self, this.coords, json.getString(\"path\"), branch);\n}", "/**\n * Generate a random fake SHA hex string.\n *\n * @return Fake SHA string.\n */\nprivate static String fakeSha() {\n    // @checkstyle MagicNumberCheck (1 line)\n    return RandomStringUtils.random(40, \"0123456789abcdef\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.body",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.body" ],
    "fullMethods" : [ "@Override\npublic RequestBody body() {\n    return this.request.body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.commits", "com.jcabi.github.RtCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic Commits commits() {\n    return new RtCommits(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/commits\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.get", "com.jcabi.github.RtGistComment.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComment get(final int number) {\n    return new RtGistComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param gist\n * \t\tGist of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtGistComment(final Request req, final Gist gist, final int number) {\n    this.request = req.uri().path(\"/gists\").path(new Gist.Smart(gist).identifier()).path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = gist;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKey.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param user\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\npublic RtPublicKey(final Request req, final User user, final int number) {\n    this.request = req.uri().path(\"/user\").path(\"/keys\").path(Integer.toString(number)).back();\n    this.owner = user;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.assignees",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.assignees", "com.jcabi.github.RtAssignees.<init>" ],
    "fullMethods" : [ "@Override\npublic Assignees assignees() {\n    return new RtAssignees(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtAssignees(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/assignees\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.markdown",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.markdown", "com.jcabi.github.RtMarkdown.<init>" ],
    "fullMethods" : [ "@Override\npublic Markdown markdown() {\n    return new RtMarkdown(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtMarkdown(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"markdown\").back().method(Request.POST);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtValuePagination.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.entry.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.get", "com.jcabi.github.RtTag.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag get(final String sha) {\n    return new RtTag(this.entry, this.owner, sha);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe request.\n * @param repo\n * \t\tThe owner repo.\n * @param key\n * \t\tThe sha.\n */\nRtTag(final Request req, final Repo repo, final String key) {\n    this.sha = key;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").path(this.sha).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBranch.commit",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBranch.commit", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit commit() {\n    return new RtCommit(this.entry, this.owner, this.hash);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommit.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommit.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.keys",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.keys", "com.jcabi.github.RtDeployKeys.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKeys keys() {\n    return new RtDeployKeys(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\nRtDeployKeys(final Request req, final Repo repo) {\n    this.owner = repo;\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtIssue.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.get", "com.jcabi.github.RtGist.<init>" ],
    "fullMethods" : [ "@Override\npublic Gist get(final String name) {\n    return new RtGist(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param name\n * \t\tName of gist\n */\nRtGist(final Github github, final Request req, final String name) {\n    this.ghub = github;\n    this.entry = req;\n    this.gist = name;\n    this.request = req.uri().path(\"/gists\").path(name).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.milestones",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.milestones", "com.jcabi.github.RtMilestones.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestones milestones() {\n    return new RtMilestones(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtMilestones(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.get", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label get(final String name) {\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.<init>" ],
    "fullMethods" : [ "/**\n * Public CTOR.\n *\n * @param github\n * \t\tGithub\n */\npublic RtGitignores(final Github github) {\n    this.ghub = github;\n    this.request = github().entry().uri().path(\"/gitignore/templates\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.references",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.references", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic References references() {\n    return new RtReferences(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtNotifications.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtNotifications.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Notification> iterate() {\n    return new RtPagination<>(this.request.uri().queryParam(\"all\", \"true\").queryParam(\"since\", \"1970-01-01T00:00:00Z\").back(), json -> new RtNotification(Long.valueOf(json.getString(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.get", "com.jcabi.github.RtReference.<init>" ],
    "fullMethods" : [ "@Override\npublic Reference get(final String identifier) {\n    return new RtReference(this.entry, this.owner, identifier);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tOwner of this reference.\n * @param ref\n * \t\tThe name of the reference.\n */\nRtReference(final Request req, final Repo repo, final String ref) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(ref).back();\n    this.owner = repo;\n    this.name = ref;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.commits" ],
    "fullMethods" : [ "@Override\npublic Iterable<Commit> commits() {\n    return new RtPagination<>(this.request.uri().path(\"/commits\").back(), object -> new RtCommit(this.entry, this.owner, object.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKey.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.tags",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.tags", "com.jcabi.github.RtTags.<init>" ],
    "fullMethods" : [ "@Override\npublic Tags tags() {\n    return new RtTags(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtTags(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.get", "com.jcabi.github.RtComment.<init>" ],
    "fullMethods" : [ "@Override\npublic Comment get(final long number) {\n    return new RtComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param issue\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtComment(final Request req, final Issue issue, final long number) {\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/comments\").path(Long.toString(number)).back();\n    this.owner = issue;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.statuses",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.statuses", "com.jcabi.github.RtStatuses.<init>" ],
    "fullMethods" : [ "@Override\npublic Statuses statuses(final String ref) {\n    return new RtStatuses(this.entry, this.get(ref));\n}", "/**\n * Create a new status-aware object based on given commit.\n *\n * @param req\n * \t\tHttp request\n * @param commit\n * \t\tSpecific commit\n */\nRtStatuses(final Request req, final Commit commit) {\n    final Coordinates coords = commit.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/statuses\").path(commit.sha()).back();\n    this.cmmt = commit;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.compare",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.compare", "com.jcabi.github.RtCommitsComparison.<init>" ],
    "fullMethods" : [ "@Override\npublic CommitsComparison compare(final String base, final String head) {\n    return new RtCommitsComparison(this.entry, this.owner, base, head);\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n * @param base\n * \t\tSHA of a base commit\n * @param head\n * \t\tSHA of a head commit\n * @checkstyle ParameterNumber (3 lines)\n */\nRtCommitsComparison(final Request req, final Repo repo, final String base, final String head) {\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().toString()).path(\"/compare\").path(String.format(\"%s...%s\", base, head)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.emails",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.emails", "com.jcabi.github.RtUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    return new RtUserEmails(this.ghub.entry());\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n */\nRtUserEmails(final Request req) {\n    this.request = req.header(\"Accept\", \"application/vnd.github.v3\").uri().path(\"/user/emails\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtComment.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.users",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.users", "com.jcabi.github.RtUsers.<init>" ],
    "fullMethods" : [ "@Override\npublic Users users() {\n    return new RtUsers(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtUsers(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/users\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.gists",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.gists", "com.jcabi.github.RtGists.<init>" ],
    "fullMethods" : [ "@Override\npublic Gists gists() {\n    return new RtGists(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtGists(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/gists\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommit.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommit.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.limits",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.limits", "com.jcabi.github.RtLimits.<init>" ],
    "fullMethods" : [ "@Override\npublic Limits limits() {\n    return new RtLimits(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtLimits(final Github github, final Request req) {\n    this.entry = req.uri().path(\"rate_limit\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.get", "com.jcabi.github.RtRepo.<init>" ],
    "fullMethods" : [ "@Override\npublic Repo get(final Coordinates name) {\n    return new RtRepo(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param crd\n * \t\tCoordinate of the repo\n */\nRtRepo(final Github github, final Request req, final Coordinates crd) {\n    this.ghub = github;\n    this.entry = req;\n    this.coords = crd;\n    this.request = this.entry.uri().path(\"/repos\").path(this.coords.user()).path(this.coords.repo()).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.get", "com.jcabi.github.RtRepoCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommit get(final String sha) {\n    return new RtRepoCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtRepoCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stargazers",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.stargazers", "com.jcabi.github.RtStargazers.<init>" ],
    "fullMethods" : [ "@Override\npublic Stargazers stargazers() {\n    return new RtStargazers(this.request);\n}", "/**\n * Public ctor.\n *\n * @param entry\n * \t\tEntry request.\n */\nRtStargazers(final Request entry) {\n    this.request = entry.uri().path(\"stargazers\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.events",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.events" ],
    "fullMethods" : [ "@Override\npublic Iterable<Event> events() {\n    return new RtPagination<>(this.request.uri().path(\"/events\").back(), object -> new RtEvent(this.entry, this.owner, object.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.pulls",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.pulls", "com.jcabi.github.RtPulls.<init>" ],
    "fullMethods" : [ "@Override\npublic Pulls pulls() {\n    return new RtPulls(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtPulls(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.self",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.self", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User self() {\n    return new RtUser(this.ghub, this.entry, \"\");\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserOrganizations.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserOrganizations.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Organization> iterate() throws IOException {\n    final String login = this.owner.login();\n    return new RtPagination<>(this.entry.uri().path(\"/users\").path(login).path(\"/orgs\").back(), new OrganizationMapping(this.ghub.organizations()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.codes",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.codes", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> codes(final String keywords, final String sort, final Order order) {\n    return // @checkstyle AnonInnerLengthCheck (25 lines)\n    new RtSearchPagination<>(this.request, \"code\", keywords, sort, order.identifier(), object -> {\n        try {\n            // @checkstyle MultipleStringLiteralsCheck (1 line)\n            final URI uri = new URI(object.getString(\"url\"));\n            final String[] parts = RtSearch.SLASH.split(uri.getPath());\n            final String ref = RtSearch.QUERY.split(uri.getQuery())[1];\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).contents().get(object.getString(\"path\"), ref);\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        } catch (final IOException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.issues", "com.jcabi.github.RtIssues.<init>" ],
    "fullMethods" : [ "@Override\npublic Issues issues() {\n    return new RtIssues(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssues(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Issue> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reference> iterate(final String subnamespace) {\n    return new RtPagination<>(this.request.uri().path(subnamespace).back(), object -> this.get(object.getString(RtReferences.REF)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<RepoCommit> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> this.get(value.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.trees",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.trees", "com.jcabi.github.RtTrees.<init>" ],
    "fullMethods" : [ "@Override\npublic Trees trees() {\n    return new RtTrees(this.entry, this.repo());\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtTrees(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/trees\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtBlobs(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.get", "com.jcabi.github.RtPull.<init>" ],
    "fullMethods" : [ "@Override\npublic Pull get(final int number) {\n    return new RtPull(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtPull(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.organizations",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.organizations", "com.jcabi.github.RtOrganizations.<init>" ],
    "fullMethods" : [ "@Override\npublic Organizations organizations() {\n    return new RtOrganizations(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtOrganizations(final Github github, final Request req) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/user\").path(\"/orgs\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issueEvents",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.issueEvents", "com.jcabi.github.RtIssueEvents.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueEvents issueEvents() {\n    return new RtIssueEvents(this.entry, this);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssueEvents(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.files",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.files" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonObject> files() {\n    return new RtPagination<>(this.request.uri().path(\"/files\").back(), RtPagination.COPYING);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param user\n * \t\tUser\n */\npublic RtPublicKeys(final Request req, final User user) {\n    this.entry = req;\n    this.owner = user;\n    this.request = this.entry.uri().path(\"/user\").path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.get", "com.jcabi.github.RtDeployKey.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKey get(final int number) {\n    return new RtDeployKey(this.entry, number, this.owner);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param number\n * \t\tId\n * @param repo\n * \t\tRepository\n */\nRtDeployKey(final Request req, final int number, final Repo repo) {\n    this.key = number;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").path(String.valueOf(number)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.get", "com.jcabi.github.RtReleaseAsset.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset get(final int number) {\n    return new RtReleaseAsset(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful Request\n * @param release\n * \t\tRelease\n * @param number\n * \t\tNumber of the release asset.\n */\nRtReleaseAsset(final Request req, final Release release, final int number) {\n    final Coordinates coords = release.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(\"/assets\").path(Integer.toString(number)).back();\n    this.owner = release;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.github().entry().uri().path(RtUser.NOTIF_PATH).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtOrganization.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tOrganization login name\n */\npublic RtOrganization(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(login).back();\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.get", "com.jcabi.github.RtPullComment.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComment get(final int number) {\n    return new RtPullComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param pull\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtPullComment(final Request req, final Pull pull, final int number) {\n    final Coordinates coords = pull.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = pull;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Fork> iterate(final String sort) {\n    return new RtPagination<>(this.request.uri().queryParam(\"sort\", sort).back(), object -> this.get(object.getInt(ID)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueEvents.get", "com.jcabi.github.RtEvent.<init>" ],
    "fullMethods" : [ "@Override\npublic Event get(final int number) {\n    return new RtEvent(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtEvent(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.get", "com.jcabi.github.RtIssue.<init>" ],
    "fullMethods" : [ "@Override\npublic Issue get(final int number) {\n    return new RtIssue(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtIssue(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestone.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestone.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.uri",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.uri" ],
    "fullMethods" : [ "@Override\npublic RequestURI uri() {\n    return new SearchURI(this.request.uri());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.get", "com.jcabi.github.RtRelease.<init>" ],
    "fullMethods" : [ "@Override\npublic Release get(final int number) {\n    return new RtRelease(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n * @param nmbr\n * \t\tRelease id\n */\nRtRelease(final Request req, final Repo repo, final int nmbr) {\n    this.entry = req;\n    this.release = nmbr;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").path(String.valueOf(this.release)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueEvents.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.getRec",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.getRec" ],
    "fullMethods" : [ "@Override\npublic Tree getRec(final String sha) {\n    return new RtTree(this.entry.uri().queryParam(\"recursive\", \"1\").back(), this.owner, sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtReleases(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = this.entry.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create", "com.jcabi.github.RtForks.get", "com.jcabi.github.RtFork.<init>" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}", "/**\n * Get fork by number.\n *\n * @param number\n * \t\tFork number\n * @return Fork\n */\nprivate RtFork get(final Integer number) {\n    return new RtFork(this.request, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtFork(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/forks\").path(Integer.toString(number)).back();\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtForks(final Request req, final Repo repo) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"forks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTree.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTree.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.languages",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.languages" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Iterable<Language> languages() throws IOException {\n    final RtJson json = new RtJson(this.request.uri().path(\"/languages\").back());\n    final JsonObject object = json.fetch();\n    final List<Language> languages = new ArrayList<>(object.size());\n    for (final Map.Entry<String, JsonValue> value : object.entrySet()) {\n        final String name = value.getKey();\n        languages.add(new RtLanguage(name, object.getJsonNumber(name).longValue()));\n    }\n    return languages;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.branches",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.branches", "com.jcabi.github.RtBranches.<init>" ],
    "fullMethods" : [ "@Override\npublic Branches branches() {\n    return new RtBranches(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtBranches(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/branches\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.labels", "com.jcabi.github.RtLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic Labels labels() {\n    return new RtLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepo we're in\n */\nRtLabels(final Request req, final Repo repo) {\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.assets",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.assets", "com.jcabi.github.RtReleaseAssets.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAssets assets() {\n    return new RtReleaseAssets(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param release\n * \t\tIssue\n */\nRtReleaseAssets(final Request req, final Release release) {\n    this.entry = req;\n    final Coordinates coords = release.repo().coordinates();\n    // @checkstyle MultipleStringLiteralsCheck (7 lines)\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(Integer.toString(release.number())).path(\"/assets\").back();\n    this.owner = release;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.toString" ],
    "fullMethods" : [ "/**\n * Generate string representation.\n *\n * @return String representation\n */\n@Override\npublic final String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtContents(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/contents\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.get", "com.jcabi.github.RtMilestone.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestone get(final int number) {\n    return new RtMilestone(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtMilestone(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.get", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit get(final String sha) {\n    return new RtCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.commits", "com.jcabi.github.RtRepoCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommits commits() {\n    return new RtRepoCommits(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtRepoCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final RequestURI rep = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo());\n    this.request = rep.path(\"/commits\").back();\n    this.comp = rep.path(\"/compare\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Milestone> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtHooks(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> iterate(final String identifier) {\n    return new RtPagination<>(this.entry.uri().queryParam(\"since\", identifier).back(), object -> this.get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.comments", "com.jcabi.github.RtGistComments.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComments comments() {\n    return new RtGistComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param gist\n * \t\tGist\n */\nRtGistComments(final Request req, final Gist gist) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/gists\").path(gist.identifier()).path(\"/comments\").back();\n    this.owner = gist;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabel.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabel.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtOrganization.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.entry.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.search",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.search", "com.jcabi.github.RtSearch.<init>" ],
    "fullMethods" : [ "@Override\npublic Search search() {\n    return new RtSearch(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRESTful API entry point\n */\nRtSearch(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"/search\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.repos",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.repos", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> repos(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"repositories\", keywords, sort, order.identifier(), object -> this.github().repos().get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtEvent.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtEvent.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.comments", "com.jcabi.github.RtPullComments.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComments comments() {\n    return new RtPullComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param pull\n * \t\tPull\n */\nRtPullComments(final Request req, final Pull pull) {\n    this.entry = req;\n    this.owner = pull;\n    this.request = // @checkstyle MultipleStringLiterals (8 lines)\n    this.entry.uri().path(\"/repos\").path(pull.repo().coordinates().user()).path(pull.repo().coordinates().repo()).path(\"/pulls\").path(Integer.toString(pull.number())).path(\"/comments\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final int number, final Map<String, String> params) {\n    final Request newreq = this.entry.uri().path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/pulls\").path(String.valueOf(number)).path(\"/comments\").back();\n    return new RtPagination<>(newreq.uri().queryParams(params).back(), value -> this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> iterate(final String identifier) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", identifier).back(), object -> this.get(String.valueOf(object.getInt(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.request.uri().path(\"notifications\").back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.collaborators",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.collaborators", "com.jcabi.github.RtCollaborators.<init>" ],
    "fullMethods" : [ "@Override\npublic Collaborators collaborators() {\n    return new RtCollaborators(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtCollaborators(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/collaborators\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommitsComparison.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommitsComparison.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.get", "com.jcabi.github.RtBlob.<init>" ],
    "fullMethods" : [ "@Override\npublic Blob get(final String sha) {\n    return new RtBlob(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param sha\n * \t\tNumber of the get\n */\nRtBlob(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").path(sha).back();\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.users",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.users", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> users(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"users\", keywords, sort, order.identifier(), object -> this.ghub.users().get(object.getString(\"login\")));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param organ\n * \t\tOrganization\n */\npublic RtPublicMembers(final Request req, final Organization organ) {\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(organ.login()).path(\"public_members\").back();\n    this.organization = organ;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.get", "com.jcabi.github.RtTree.<init>" ],
    "fullMethods" : [ "@Override\npublic Tree get(final String sha) {\n    return new RtTree(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtTree(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/trees\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.labels", "com.jcabi.github.RtIssueLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueLabels labels() {\n    return new RtIssueLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue we're in\n */\nRtIssueLabels(final Request req, final Issue issue) {\n    this.owner = issue;\n    final Coordinates coords = issue.repo().coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Pull> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Comment> iterate(final Date since) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", new Github.Time(since)).back(), object -> this.get(object.getJsonNumber(\"id\").longValue()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.get", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User get(final String login) {\n    return new RtUser(this.ghub, this.entry, login);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> // @checkstyle MultipleStringLiterals (3 lines)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.comments", "com.jcabi.github.RtComments.<init>" ],
    "fullMethods" : [ "@Override\npublic Comments comments() {\n    return new RtComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue\n */\nRtComments(final Request req, final Issue issue) {\n    this.entry = req;\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/comments\").back();\n    this.owner = issue;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stars",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.stars", "com.jcabi.github.RtStars.<init>" ],
    "fullMethods" : [ "@Override\npublic Stars stars() {\n    return new RtStars(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtStars(final Request req, final Repo repo) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/user/starred\").path(coords.user()).path(coords.repo()).back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.issues", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (5 lines)\n@Override\npublic Iterable<Issue> issues(final String keywords, final String sort, final Order order, final EnumMap<Qualifier, String> qualifiers) {\n    final StringBuilder keyword = new StringBuilder(keywords);\n    for (final Map.Entry<Qualifier, String> entry : qualifiers.entrySet()) {\n        keyword.append('+').append(entry.getKey().identifier()).append(':').append(entry.getValue());\n    }\n    return new RtSearchPagination<>(this.request, \"issues\", keyword.toString(), sort, order.identifier(), object -> {\n        try {\n            final String[] parts = // @checkstyle MultipleStringLiteralsCheck (1 line)\n            RtSearch.SLASH.split(new URI(object.getString(\"url\")).getPath());\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).issues().get(object.getInt(\"number\"));\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<ReleaseAsset> iterate() {\n    return new RtPagination<>(this.request.uri().back().method(Request.GET), value -> // @checkstyle MultipleStringLiteralsCheck (1 line)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.get", "com.jcabi.github.RtHook.<init>" ],
    "fullMethods" : [ "@Override\npublic Hook get(final int number) {\n    return new RtHook(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tId of the get\n */\nRtHook(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchURI.port",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.port",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchURI.port" ],
    "fullMethods" : [ "@Override\npublic RequestURI port(final int num) {\n    return new SearchURI(this.address.port(num));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.read",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.read",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.RetryCarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.send",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.wire.RetryCarefulWire.send" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    return this.real.send(req, home, method, headers, content, connect, read);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.CarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.send",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.wire.CarefulWire.send" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    final Response resp = this.origin.send(req, home, method, headers, content, connect, read);\n    final int remaining = this.remainingHeader(resp);\n    if (remaining < this.threshold) {\n        final long reset = this.resetHeader(resp);\n        final long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n        if (reset > now) {\n            final long length = reset - now;\n            // @checkstyle LineLength (1 line)\n            Logger.info(this, \"Remaining number of requests per hour is less than %d. Waiting for %d seconds.\", this.threshold, length);\n            try {\n                TimeUnit.SECONDS.sleep(length);\n            } catch (final InterruptedException ex) {\n                Thread.currentThread().interrupt();\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return resp;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.apply",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.toString",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.apply" ],
    "fullMethods" : [ "@Override\npublic void apply(final Iterable<Directive> dirs) throws IOException {\n    synchronized(this.name) {\n        FileUtils.write(new File(this.name), new XMLDocument(new Xembler(dirs).applyQuietly(this.xml().node())).toString(), StandardCharsets.UTF_8);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.FileChange.Smart.patch",
    "thirdPartyMethod" : "com.google.common.base.Optional.fromNullable",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.FileChange.Smart.patch" ],
    "fullMethods" : [ "/**\n * Diff string of the changes to the file. Only available if\n * the file is text (as opposed to binary).\n *\n * @return Diff string\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Optional<String> patch() throws IOException {\n    return Optional.fromNullable(this.json().getString(\"patch\", null));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Status.Smart.targetUrl",
    "thirdPartyMethod" : "com.google.common.base.Optional.fromNullable",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Status.Smart.targetUrl" ],
    "fullMethods" : [ "/**\n * Get URL.\n *\n * @return URL as string.\n * @throws IOException\n * \t\tIf there is an I/O problem\n */\npublic Optional<String> targetUrl() throws IOException {\n    return Optional.fromNullable(this.json().getString(\"target_url\", null));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<init>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<init>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<init>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<init>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<init>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.\n *\n * @since 0.4\n */\npublic RtGithub() {\n    this(RtGithub.REQUEST);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<init>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.Status.Smart.description",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Status.Smart.description" ],
    "fullMethods" : [ "/**\n * Get description.\n *\n * @return Description as string.\n * @throws IOException\n * \t\tIf there is an I/O problem\n */\npublic String description() throws IOException {\n    return this.json().getString(\"description\", \"\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.FileChange.Smart.patch",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.FileChange.Smart.patch" ],
    "fullMethods" : [ "/**\n * Diff string of the changes to the file. Only available if\n * the file is text (as opposed to binary).\n *\n * @return Diff string\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Optional<String> patch() throws IOException {\n    return Optional.fromNullable(this.json().getString(\"patch\", null));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.json",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkIssue.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final XML xml = this.storage.xml();\n    final JsonObject obj = new JsonNode(xml.nodes(this.xpath()).get(0)).json();\n    final JsonObjectBuilder json = Json.createObjectBuilder();\n    for (final Map.Entry<String, JsonValue> val : obj.entrySet()) {\n        json.add(val.getKey(), val.getValue());\n    }\n    final JsonArrayBuilder array = Json.createArrayBuilder();\n    for (final Label label : this.labels().iterate()) {\n        array.add(Json.createObjectBuilder().add(\"name\", label.name()).build());\n    }\n    final JsonObjectBuilder res = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    json.add(\"labels\", array).add(\"assignee\", Json.createObjectBuilder().add(\"login\", obj.getString(\"assignee\", \"\")).build());\n    final JsonObjectBuilder pull = Json.createObjectBuilder();\n    final String html = \"html_url\";\n    if (xml.nodes(// @checkstyle LineLengthCheck (1 line)\n    String.format(\"/github/repos/repo[@coords='%s']/pulls/pull/number[text() = '%d']\", this.coords, this.num)).isEmpty()) {\n        pull.addNull(html);\n    } else {\n        pull.add(html, String.format(\"https://%s/pulls/%d\", this.coords, this.num));\n    }\n    return res.add(\"pull_request\", pull.build()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Status.Smart.targetUrl",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Status.Smart.targetUrl" ],
    "fullMethods" : [ "/**\n * Get URL.\n *\n * @return URL as string.\n * @throws IOException\n * \t\tIf there is an I/O problem\n */\npublic Optional<String> targetUrl() throws IOException {\n    return Optional.fromNullable(this.json().getString(\"target_url\", null));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Milestone.Smart.title",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Milestone.Smart.title" ],
    "fullMethods" : [ "/**\n * Change its title.\n *\n * @param title\n * \t\tTitle of milestone\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void title(final String title) throws IOException {\n    this.milestone.patch(Json.createObjectBuilder().add(TITLE, title).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.assign",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.assign" ],
    "fullMethods" : [ "/**\n * Assign this issue to another user.\n *\n * @param login\n * \t\tLogin of the user to assign to\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void assign(final String login) throws IOException {\n    this.issue.patch(Json.createObjectBuilder().add(\"assignee\", login).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Statuses.StatusCreate.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Statuses.StatusCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"state\", this.state.identifier()).add(\"description\", this.description);\n    if (this.context.isPresent()) {\n        builder.add(\"context\", this.context.get());\n    }\n    if (this.targeturl.isPresent()) {\n        builder.add(\"target_url\", this.targeturl.get());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPullRef.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkPullRef.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final String user = this.repo().coordinates().user();\n    return Json.createObjectBuilder().add(\"ref\", this.ref()).add(\"sha\", this.sha()).add(\"label\", String.format(\"%s:%s\", user, this.ref())).add(\"user\", new MkUser(this.storage, user).json()).add(\"repo\", this.repo().json()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkLimits.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkLimits.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    return // @checkstyle MagicNumber (2 lines)\n    Json.createObjectBuilder().add(\"limit\", 5000).add(\"remaining\", 4999).add(\"reset\", System.currentTimeMillis()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.emojis",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() {\n    return Json.createObjectBuilder().add(\"+1\", \"http://locahost/up\").add(\"-1\", \"http://locahost/down\").build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.write",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGist.write" ],
    "fullMethods" : [ "@Override\npublic void write(final String file, final String content) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"content\", content);\n    final JsonObject json = Json.createObjectBuilder().add(\"files\", Json.createObjectBuilder().add(file, builder)).build();\n    this.patch(json);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.commitish",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.commitish" ],
    "fullMethods" : [ "/**\n * Change its target commitish.\n *\n * @param text\n * \t\tTarget commitish.\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void commitish(final String text) throws IOException {\n    this.release.patch(Json.createObjectBuilder().add(\"target_commitish\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.draft",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.draft" ],
    "fullMethods" : [ "/**\n * Change its status.\n *\n * @param draft\n * \t\tTrue makes the release a draft.\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void draft(final boolean draft) throws IOException {\n    this.release.patch(Json.createObjectBuilder().add(\"draft\", draft).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Comment.Smart.body",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Comment.Smart.body" ],
    "fullMethods" : [ "/**\n * Change comment body.\n *\n * @param text\n * \t\tBody of comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void body(final String text) throws IOException {\n    this.comment.patch(Json.createObjectBuilder().add(\"body\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.milestone",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.milestone" ],
    "fullMethods" : [ "/**\n * Add issueto milestone.\n *\n * @param milestone\n * \t\tMilestone\n * @throws IOException\n * \t\tIf fails\n */\npublic void milestone(final Milestone milestone) throws IOException {\n    this.patch(Json.createObjectBuilder().add(\"milestone\", milestone.number()).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Pull.Smart.state",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Pull.Smart.state" ],
    "fullMethods" : [ "/**\n * Change its state.\n *\n * @param state\n * \t\tState of pull request\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void state(final String state) throws IOException {\n    this.pull.patch(Json.createObjectBuilder().add(\"state\", state).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PullComment.Smart.identifier",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PullComment.Smart.identifier" ],
    "fullMethods" : [ "/**\n * Change its id value.\n *\n * @param value\n * \t\tId of pull comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void identifier(final String value) throws IOException {\n    this.cmnt.patch(Json.createObjectBuilder().add(ID, value).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkEvent.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkEvent.json" ],
    "fullMethods" : [ "/**\n * Describes the event in a JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min When the event has a label, retrieve and include the\nlabel's color too. MkIssueEvents.create() will also need to be\nupdated accordingly.\n */\n@Override\npublic JsonObject json() throws IOException {\n    final JsonObject obj = new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n    JsonObjectBuilder builder = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(\"id\", this.num).add(\"url\", // @checkstyle LineLength (1 line)\n    String.format(\"https://api.jcabi-github.invalid/repos/%s/issues/events/%s\", this.coords, this.num)).add(\"commit_id\", JsonValue.NULL).add(MkEvent.EVENT, obj.getString(MkEvent.EVENT)).add(\"actor\", // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(MkEvent.LOGIN, obj.getString(MkEvent.LOGIN)).build()).add(MkEvent.CREATED_AT, obj.getString(MkEvent.CREATED_AT));\n    final String label = \"label\";\n    if (obj.containsKey(label)) {\n        builder = builder.add(label, Json.createObjectBuilder().add(\"name\", obj.getString(label)).build());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUser.markAsRead",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    final Iterable<XML> ids = this.storage.xml().nodes(this.xpath() + String.format(\"/notifications/notification[date <= %s]/id\", lastread.getTime()));\n    final JsonPatch json = new JsonPatch(this.storage);\n    final JsonObject read = Json.createObjectBuilder().add(\"read\", true).build();\n    for (final XML nid : ids) {\n        json.patch(String.format(this.xpath().concat(\"/notifications/notification[id = %s]\"), nid.xpath(\"text()\").get(0)), read);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Organization.Smart.location",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Organization.Smart.location" ],
    "fullMethods" : [ "/**\n * Change its location.\n *\n * @param location\n * \t\tLocation of organization\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void location(final String location) throws IOException {\n    this.org.patch(Json.createObjectBuilder().add(\"location\", location).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPull.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkPull.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final XML xml = this.storage.xml().nodes(this.xpath()).get(0);\n    final String branch = xml.xpath(\"base/text()\").get(0);\n    final String head = xml.xpath(\"head/text()\").get(0);\n    final String[] parts = head.split(MkPull.USER_BRANCH_SEP, 2);\n    final JsonObject obj = new JsonNode(xml).json();\n    final JsonObjectBuilder json = Json.createObjectBuilder();\n    for (final Map.Entry<String, JsonValue> val : obj.entrySet()) {\n        if (MkPull.NUMBER_PROP.equals(val.getKey())) {\n            json.add(MkPull.NUMBER_PROP, Integer.parseInt(xml.xpath(\"number/text()\").get(0)));\n        } else if (MkPull.USER_PROP.equals(val.getKey())) {\n            json.add(MkPull.USER_PROP, Json.createObjectBuilder().add(\"login\", xml.xpath(\"user/login/text()\").get(0)).build());\n        } else if (MkPull.HEAD_PROP.equals(val.getKey())) {\n            json.add(MkPull.HEAD_PROP, Json.createObjectBuilder().add(MkPull.REF_PROP, parts[1]).add(MkPull.LABEL_PROP, head).build());\n        } else if (MkPull.BASE_PROP.equals(val.getKey())) {\n            json.add(MkPull.BASE_PROP, Json.createObjectBuilder().add(MkPull.REF_PROP, branch).add(MkPull.LABEL_PROP, String.format(\"%s:%s\", this.coords.user(), branch)).build());\n        } else {\n            json.add(val.getKey(), val.getValue());\n        }\n    }\n    json.add(\"comments\", this.storage.xml().nodes(this.comment()).size());\n    return json.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.ReleaseAsset.Smart.name",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.ReleaseAsset.Smart.name" ],
    "fullMethods" : [ "/**\n * Change its name.\n *\n * @param text\n * \t\tName of release asset\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void name(final String text) throws IOException {\n    this.asset.patch(Json.createObjectBuilder().add(\"name\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.DeployKey.Smart.title",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.DeployKey.Smart.title" ],
    "fullMethods" : [ "/**\n * Change its title.\n *\n * @param text\n * \t\tTitle of deploy key\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void title(final String text) throws IOException {\n    this.key.patch(Json.createObjectBuilder().add(\"title\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Milestone.Smart.state",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Milestone.Smart.state" ],
    "fullMethods" : [ "/**\n * Change its state.\n *\n * @param state\n * \t\tState of milestone\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void state(final String state) throws IOException {\n    this.milestone.patch(Json.createObjectBuilder().add(STATE, state).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.title",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.title" ],
    "fullMethods" : [ "/**\n * Change its title.\n *\n * @param text\n * \t\tTitle of issue\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void title(final String text) throws IOException {\n    this.issue.patch(Json.createObjectBuilder().add(\"title\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepoCommits.compare",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkRepoCommits.compare", "com.jcabi.github.mock.MkCommitsComparison.<clinit>" ],
    "fullMethods" : [ "@Override\npublic CommitsComparison compare(final String base, final String head) {\n    return new MkCommitsComparison(this.storage, this.self, this.coords);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.ReleaseAsset.Smart.label",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.ReleaseAsset.Smart.label" ],
    "fullMethods" : [ "/**\n * Change its label.\n *\n * @param text\n * \t\tLabel of release asset\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void label(final String text) throws IOException {\n    this.asset.patch(Json.createObjectBuilder().add(\"label\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.JsonNode.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.JsonNode.json" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON\n * @checkstyle MultipleStringLiteralsCheck (30 lines)\n */\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final XML child : this.xml.nodes(\"* \")) {\n        final Node node = child.node();\n        if (child.nodes(\"*\").isEmpty()) {\n            builder.add(node.getNodeName(), node.getTextContent());\n        } else if ((!child.xpath(\"//@array\").isEmpty()) && \"true\".equals(child.xpath(\"//@array\").get(0))) {\n            final JsonArrayBuilder bld = Json.createArrayBuilder();\n            for (final XML item : child.nodes(\"*\")) {\n                bld.add(item.node().getTextContent());\n            }\n            builder.add(node.getNodeName(), bld.build());\n        } else {\n            builder.add(node.getNodeName(), new JsonNode(child).json());\n        }\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Pull.Smart.title",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Pull.Smart.title" ],
    "fullMethods" : [ "/**\n * Change its title.\n *\n * @param text\n * \t\tTitle of pull request\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void title(final String text) throws IOException {\n    this.pull.patch(Json.createObjectBuilder().add(\"title\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkOrganization.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkOrganization.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    return Json.createObjectBuilder().add(LOGIN_KEY, this.self).add(\"id\", Integer.toString(RAND.nextInt())).add(\"name\", \"github\").add(\"company\", \"GitHub\").add(\"blog\", \"https://github.com/blog\").add(\"location\", \"San Francisco\").add(\"email\", \"octocat@github.com\").add(\"public_repos\", RAND.nextInt()).add(\"public_gists\", RAND.nextInt()).add(\"total_private_repos\", RAND.nextInt()).add(\"owned_private_repos\", RAND.nextInt()).add(\"followers\", RAND.nextInt()).add(\"following\", RAND.nextInt()).add(\"url\", \"https://github.com/orgs/cat\").add(\"repos_url\", \"https://github.com/orgs/cat/repos\").add(\"events_url\", \"https://github.com/orgs/cat/events\").add(\"html_url\", \"https://github.com/cat\").add(\"created_at\", new Github.Time().toString()).add(\"type\", \"Organization\").build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PublicKey.Smart.title",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PublicKey.Smart.title" ],
    "fullMethods" : [ "/**\n * Change its title.\n *\n * @param text\n * \t\tTitle of public key\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void title(final String text) throws IOException {\n    this.key.patch(Json.createObjectBuilder().add(\"title\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.GistComment.Smart.body",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.GistComment.Smart.body" ],
    "fullMethods" : [ "/**\n * Change comment body.\n *\n * @param text\n * \t\tBody of comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void body(final String text) throws IOException {\n    this.comment.patch(Json.createObjectBuilder().add(\"body\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Organization.Smart.billingEmail",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Organization.Smart.billingEmail" ],
    "fullMethods" : [ "/**\n * Change its billingEmail.\n *\n * @param billingemail\n * \t\tBillingEmail of organization\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void billingEmail(final String billingemail) throws IOException {\n    this.org.patch(Json.createObjectBuilder().add(\"billing_email\", billingemail).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Label.Smart.color",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Label.Smart.color" ],
    "fullMethods" : [ "/**\n * Set its color.\n *\n * @param color\n * \t\tColor to set\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void color(final String color) throws IOException {\n    this.label.patch(Json.createObjectBuilder().add(\"color\", color).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.prerelease",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.prerelease" ],
    "fullMethods" : [ "/**\n * Change its prerelease.\n *\n * @param pre\n * \t\tTrue to identify the release as a prerelease.\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void prerelease(final boolean pre) throws IOException {\n    this.release.patch(Json.createObjectBuilder().add(\"prerelease\", pre).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PullComment.Smart.url",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PullComment.Smart.url" ],
    "fullMethods" : [ "/**\n * Change its url value.\n *\n * @param value\n * \t\tUrl of pull comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void url(final String value) throws IOException {\n    this.cmnt.patch(Json.createObjectBuilder().add(URL, value).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PullComment.Smart.commitId",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PullComment.Smart.commitId" ],
    "fullMethods" : [ "/**\n * Change its commit id value.\n *\n * @param value\n * \t\tCommit id of pull comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void commitId(final String value) throws IOException {\n    this.cmnt.patch(Json.createObjectBuilder().add(COMMIT_ID, value).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPullComments.reply",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    this.storage.lock();\n    try {\n        final JsonObject orig = this.get(comment).json();\n        final PullComment reply = this.post(body, orig.getString(\"commit_id\"), orig.getString(\"path\"), comment);\n        reply.patch(Json.createObjectBuilder().add(\"original_position\", String.valueOf(comment)).build());\n        return reply;\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Milestone.Smart.description",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Milestone.Smart.description" ],
    "fullMethods" : [ "/**\n * Change its description.\n *\n * @param description\n * \t\tDescription of milestone\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void description(final String description) throws IOException {\n    this.milestone.patch(Json.createObjectBuilder().add(DESCRIPTION, description).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCommitsComparison.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkCommitsComparison.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    return // @checkstyle MultipleStringLiterals (3 lines)\n    Json.createObjectBuilder().add(\"status\", \"test-status\").add(\"ahead_by\", 1).add(\"behind_by\", 2).add(\"author\", // @checkstyle MultipleStringLiterals (3 lines)\n    Json.createObjectBuilder().add(\"login\", \"test\").build()).add(\"files\", Json.createArrayBuilder().add(MkCommitsComparison.FILE_JSON).build()).add(\"commits\", Json.createArrayBuilder().build()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.name",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.name" ],
    "fullMethods" : [ "/**\n * Change its name.\n *\n * @param text\n * \t\tName of release.\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void name(final String text) throws IOException {\n    this.release.patch(Json.createObjectBuilder().add(\"name\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Organization.Smart.email",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Organization.Smart.email" ],
    "fullMethods" : [ "/**\n * Change its email.\n *\n * @param email\n * \t\tEmail of organization\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void email(final String email) throws IOException {\n    this.org.patch(Json.createObjectBuilder().add(\"email\", email).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repos.RepoCreate.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Repos.RepoCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    JsonObjectBuilder builder = Json.createObjectBuilder().add(\"name\", this.nam).add(\"description\", this.descr).add(\"homepage\", this.home).add(\"private\", this.priv);\n    if (this.init.isPresent()) {\n        builder = builder.add(\"auto_init\", this.init.get());\n    }\n    for (final Map.Entry<String, JsonValue> entry : this.other.entrySet()) {\n        builder.add(entry.getKey(), entry.getValue());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PullComment.Smart.body",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PullComment.Smart.body" ],
    "fullMethods" : [ "/**\n * Change its body value.\n *\n * @param value\n * \t\tUrl of pull comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void body(final String value) throws IOException {\n    this.cmnt.patch(Json.createObjectBuilder().add(BODY, value).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Pull.Smart.body",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Pull.Smart.body" ],
    "fullMethods" : [ "/**\n * Change its body.\n *\n * @param text\n * \t\tBody of pull request\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void body(final String text) throws IOException {\n    this.pull.patch(Json.createObjectBuilder().add(\"body\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkIssue.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final XML xml = this.storage.xml();\n    final JsonObject obj = new JsonNode(xml.nodes(this.xpath()).get(0)).json();\n    final JsonObjectBuilder json = Json.createObjectBuilder();\n    for (final Map.Entry<String, JsonValue> val : obj.entrySet()) {\n        json.add(val.getKey(), val.getValue());\n    }\n    final JsonArrayBuilder array = Json.createArrayBuilder();\n    for (final Label label : this.labels().iterate()) {\n        array.add(Json.createObjectBuilder().add(\"name\", label.name()).build());\n    }\n    final JsonObjectBuilder res = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    json.add(\"labels\", array).add(\"assignee\", Json.createObjectBuilder().add(\"login\", obj.getString(\"assignee\", \"\")).build());\n    final JsonObjectBuilder pull = Json.createObjectBuilder();\n    final String html = \"html_url\";\n    if (xml.nodes(// @checkstyle LineLengthCheck (1 line)\n    String.format(\"/github/repos/repo[@coords='%s']/pulls/pull/number[text() = '%d']\", this.coords, this.num)).isEmpty()) {\n        pull.addNull(html);\n    } else {\n        pull.add(html, String.format(\"https://%s/pulls/%d\", this.coords, this.num));\n    }\n    return res.add(\"pull_request\", pull.build()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Organization.Smart.company",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Organization.Smart.company" ],
    "fullMethods" : [ "/**\n * Change its company.\n *\n * @param company\n * \t\tCompany of organization\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void company(final String company) throws IOException {\n    this.org.patch(Json.createObjectBuilder().add(\"company\", company).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.state",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.state" ],
    "fullMethods" : [ "/**\n * Change its state.\n *\n * @param state\n * \t\tState of issue\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void state(final String state) throws IOException {\n    this.issue.patch(Json.createObjectBuilder().add(\"state\", state).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Organization.Smart.name",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Organization.Smart.name" ],
    "fullMethods" : [ "/**\n * Change its name.\n *\n * @param name\n * \t\tCompany of organization\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void name(final String name) throws IOException {\n    this.org.patch(Json.createObjectBuilder().add(\"name\", name).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Limit.Throttled.json",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Limit.Throttled.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final int limit = new SmartJson(this.origin).number(\"limit\");\n    final int remaining = this.max - (limit - new SmartJson(this.origin).number(\"remaining\"));\n    return Json.createObjectBuilder().add(\"limit\", limit).add(\"remaining\", remaining).add(\"reset\", new SmartJson(this.origin).number(\"reset\")).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.DeployKey.Smart.key",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.DeployKey.Smart.key" ],
    "fullMethods" : [ "/**\n * Change its value.\n *\n * @param value\n * \t\tTitle of deploy key\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void key(final String value) throws IOException {\n    this.key.patch(Json.createObjectBuilder().add(\"key\", value).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.meta",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() {\n    return Json.createObjectBuilder().add(\"hooks\", Json.createArrayBuilder().build()).add(\"git\", Json.createArrayBuilder().build()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Milestone.Smart.dueOn",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Milestone.Smart.dueOn" ],
    "fullMethods" : [ "/**\n * Change milestone due date.\n *\n * @param dueon\n * \t\tNew milestone due date\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void dueOn(final Date dueon) throws IOException {\n    this.milestone.patch(Json.createObjectBuilder().add(DUE_ON, new Github.Time(dueon).toString()).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PublicKey.Smart.key",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PublicKey.Smart.key" ],
    "fullMethods" : [ "/**\n * Change its value.\n *\n * @param value\n * \t\tTitle of public key\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void key(final String value) throws IOException {\n    this.key.patch(Json.createObjectBuilder().add(\"key\", value).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.body",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.body" ],
    "fullMethods" : [ "/**\n * Change its body.\n *\n * @param text\n * \t\tBody of issue\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void body(final String text) throws IOException {\n    this.issue.patch(Json.createObjectBuilder().add(\"body\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.tag",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.tag" ],
    "fullMethods" : [ "/**\n * Change its tag name.\n *\n * @param text\n * \t\tTag name\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void tag(final String text) throws IOException {\n    this.release.patch(Json.createObjectBuilder().add(\"tag_name\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCommitsComparison.files",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkCommitsComparison.files", "com.jcabi.github.mock.MkCommitsComparison.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Iterable<FileChange> files() {\n    return ImmutableList.<FileChange>of(new MkFileChange(MkCommitsComparison.FILE_JSON));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.body",
    "thirdPartyMethod" : "javax.json.Json.createObjectBuilder",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.body" ],
    "fullMethods" : [ "/**\n * Change its body.\n *\n * @param text\n * \t\tText describing the contents of the tag\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void body(final String text) throws IOException {\n    this.release.patch(Json.createObjectBuilder().add(\"body\", text).build());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.apply",
    "thirdPartyMethod" : "org.apache.commons.io.FileUtils.write",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.apply" ],
    "fullMethods" : [ "@Override\npublic void apply(final Iterable<Directive> dirs) throws IOException {\n    synchronized(this.name) {\n        FileUtils.write(new File(this.name), new XMLDocument(new Xembler(dirs).applyQuietly(this.xml().node())).toString(), StandardCharsets.UTF_8);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.<init>",
    "thirdPartyMethod" : "org.apache.commons.io.FileUtils.write",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param file\n * \t\tFile to use\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic InFile(final File file) throws IOException {\n    FileUtils.write(file, \"<github/>\", StandardCharsets.UTF_8);\n    this.name = file.getAbsolutePath();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAsset.raw",
    "thirdPartyMethod" : "com.google.common.base.Charsets.<clinit>",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.mock.MkReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.storage.xml().xpath(String.format(\"%s/content/text()\", this.xpath())).get(0).getBytes(Charsets.UTF_8));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.iterate",
    "thirdPartyMethod" : "javax.json.EmptyArray.getValuesAs",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGitignores.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final List<JsonString> list = response.as(JsonResponse.class).json().readArray().getValuesAs(JsonString.class);\n    final List<String> templates = new ArrayList<>(list.size());\n    for (final JsonString value : list) {\n        templates.add(value.getString());\n    }\n    return templates;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.roLabels",
    "thirdPartyMethod" : "javax.json.EmptyArray.getValuesAs",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.roLabels" ],
    "fullMethods" : [ "/**\n * Get read-only labels.\n *\n * @return Collection of labels\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 0.6.2\n */\npublic IssueLabels roLabels() throws IOException {\n    final Collection<JsonObject> array = this.jsn.value(\"labels\", JsonArray.class).getValuesAs(JsonObject.class);\n    final Collection<Label> labels = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        labels.add(new Label.Unmodified(this.repo(), obj.toString()));\n    }\n    // @checkstyle AnonInnerLength (1 line)\n    return new IssueLabels() {\n        @Override\n        public Issue issue() {\n            return Issue.Smart.this;\n        }\n\n        @Override\n        public void add(final Iterable<String> labels) {\n            throw new UnsupportedOperationException(\"The issue is read-only.\");\n        }\n\n        @Override\n        public void replace(final Iterable<String> labels) {\n            throw new UnsupportedOperationException(\"The issue is read-only.\");\n        }\n\n        @Override\n        public Iterable<Label> iterate() {\n            return labels;\n        }\n\n        @Override\n        public void remove(final String name) {\n            throw new UnsupportedOperationException(\"This issue is read-only.\");\n        }\n\n        @Override\n        public void clear() {\n            throw new UnsupportedOperationException(\"This issue is read-only.\");\n        }\n    };\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommitsComparison.files",
    "thirdPartyMethod" : "javax.json.EmptyArray.getValuesAs",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtCommitsComparison.files", "com.jcabi.github.RtCommitsComparison.FileChanges.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<FileChange> files() throws IOException {\n    return new FileChanges(this.json().getJsonArray(\"files\"));\n}", "/**\n * Ctor.\n *\n * @param files\n * \t\tJsonArray of file change objects\n */\nFileChanges(final JsonArray files) {\n    this.list = files.getValuesAs(JsonObject.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "javax.json.EmptyArray.getValuesAs",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "javax.json.EmptyArray.getValuesAs",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Label.Unmodified.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.append",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Label.Unmodified.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Label label) {\n    return new CompareToBuilder().append(this.repo().coordinates(), label.repo().coordinates()).append(this.obj, label.name()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContent.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.append",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.mock.MkContent.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Content cont) {\n    return new CompareToBuilder().append(this.path(), cont.path()).append(this.repo().coordinates(), cont.repo().coordinates()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepoCommit.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.append",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.mock.MkRepoCommit.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final RepoCommit other) {\n    return new CompareToBuilder().append(this.repo().coordinates(), other.repo().coordinates()).append(this.sha(), other.sha()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Coordinates.Simple.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.append",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Coordinates.Simple.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Coordinates other) {\n    return new CompareToBuilder().append(this.usr, other.user()).append(this.rpo, other.repo()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Coordinates.Https.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.append",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Coordinates.Https.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Coordinates other) {\n    return new CompareToBuilder().append(this.user(), other.user()).append(this.repo(), other.repo()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.apply",
    "thirdPartyMethod" : "org.xembly.Xembler.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.apply" ],
    "fullMethods" : [ "@Override\npublic void apply(final Iterable<Directive> dirs) throws IOException {\n    synchronized(this.name) {\n        FileUtils.write(new File(this.name), new XMLDocument(new Xembler(dirs).applyQuietly(this.xml().node())).toString(), StandardCharsets.UTF_8);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComments.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGists.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestones.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAsset.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommit.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommit.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabel.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabel.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtValuePagination.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.entry.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtOrganization.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.entry.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtDeployKey.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtEvent.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtEvent.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtAssignees.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommit.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCommit.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestone.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestone.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUsers.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGistComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchURI.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchURI.get" ],
    "fullMethods" : [ "@Override\npublic URI get() {\n    return this.address.get();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssueEvents.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabels.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommitsComparison.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCommitsComparison.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKeys.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMarkdown.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssueLabels.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTree.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTree.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPulls.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKey.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssues.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUserEmails.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRelease.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGistComments.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtStatuses.toString" ],
    "fullMethods" : [ "/**\n * Generate string representation.\n *\n * @return String representation\n */\n@Override\npublic final String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUser.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.isPull",
    "thirdPartyMethod" : "javax.json.EmptyObject.isNull",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.isPull" ],
    "fullMethods" : [ "/**\n * Is it a pull request?\n *\n * @return TRUE if it is a pull request\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean isPull() throws IOException {\n    return this.json().containsKey(\"pull_request\") && (!this.jsn.value(\"pull_request\", JsonObject.class).isNull(\"html_url\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Event.Smart.hasAuthor",
    "thirdPartyMethod" : "javax.json.EmptyObject.isNull",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Event.Smart.hasAuthor" ],
    "fullMethods" : [ "/**\n * Does it have an author?\n *\n * @return TRUE if the author exists\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean hasAuthor() throws IOException {\n    return !this.event.json().isNull(\"actor\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.JsonValue.ValueType.equals",
    "thirdPartyPackage" : "javax.json.JsonValue",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.JsonValue.ValueType.equals",
    "thirdPartyPackage" : "javax.json.JsonValue",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.SmartJson.hasNotNull",
    "thirdPartyMethod" : "javax.json.JsonValue.ValueType.equals",
    "thirdPartyPackage" : "javax.json.JsonValue",
    "path" : [ "com.jcabi.github.SmartJson.hasNotNull" ],
    "fullMethods" : [ "/**\n * Checks if a certain key is present\n *  AND its ValueType isn't ValueType.NULL.\n *\n * @param name\n * \t\tName of the key which ValueType should be checked.\n * @return Returns <code>true</code> if key <code>name</code> is present\nand its ValueType isn't ValueType.NULL, <code>false</code> otherwise.\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean hasNotNull(final String name) throws IOException {\n    final JsonValue value = this.object.json().get(name);\n    return (value != null) && (!ValueType.NULL.equals(value.getValueType()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTrees.create",
    "thirdPartyMethod" : "javax.json.JsonObject.containsValue",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkTrees.create" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Tree create(final JsonObject params) throws IOException {\n    final JsonArray trees = params.getJsonArray(\"tree\");\n    for (final JsonValue val : trees) {\n        final JsonObject tree = ((JsonObject) (val));\n        final String sha = tree.getString(\"sha\");\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"tree\");\n        for (final Entry<String, JsonValue> entry : tree.entrySet()) {\n            dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n        }\n        this.storage.apply(dirs);\n        final String ref;\n        if (tree.containsValue(\"name\")) {\n            ref = tree.getString(\"name\");\n        } else {\n            ref = sha;\n        }\n        new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder(\"refs/trees/\").append(ref).toString(), sha);\n    }\n    return this.get(trees.getJsonObject(0).getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComments.iterate",
    "thirdPartyMethod" : "com.google.common.collect.Iterables.transform",
    "thirdPartyPackage" : "com.google.common.collect",
    "path" : [ "com.jcabi.github.safe.SfComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Comment> iterate(final Date since) {\n    return Iterables.transform(this.origin.iterate(since), input -> new SfComment(input));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonNumber",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Organization.Smart.number",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonNumber",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Organization.Smart.number" ],
    "fullMethods" : [ "/**\n * Get this organization's ID.\n *\n * @return Unique organization ID\n * @throws IOException\n * \t\tIf it fails\n */\npublic int number() throws IOException {\n    return this.org.json().getJsonNumber(\"id\").intValue();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.languages",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonNumber",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtRepo.languages" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Iterable<Language> languages() throws IOException {\n    final RtJson json = new RtJson(this.request.uri().path(\"/languages\").back());\n    final JsonObject object = json.fetch();\n    final List<Language> languages = new ArrayList<>(object.size());\n    for (final Map.Entry<String, JsonValue> value : object.entrySet()) {\n        final String name = value.getKey();\n        languages.add(new RtLanguage(name, object.getJsonNumber(name).longValue()));\n    }\n    return languages;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.User.Smart.id",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonNumber",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.User.Smart.id" ],
    "fullMethods" : [ "/**\n * Get his ID.\n *\n * @return Unique user ID\n * @throws IOException\n * \t\tIf it fails\n * @checkstyle MethodName (3 lines)\n */\n@SuppressWarnings(\"PMD.ShortMethodName\")\npublic int id() throws IOException {\n    return this.user.json().getJsonNumber(\"id\").intValue();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.xml",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.<init>",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.xml" ],
    "fullMethods" : [ "@Override\npublic XML xml() throws IOException {\n    synchronized(this.name) {\n        return new XMLDocument(FileUtils.readFileToString(new File(this.name), StandardCharsets.UTF_8));\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.EmptyObject.getValueType",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.EmptyObject.getValueType",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.SmartJson.hasNotNull",
    "thirdPartyMethod" : "javax.json.EmptyObject.getValueType",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.SmartJson.hasNotNull" ],
    "fullMethods" : [ "/**\n * Checks if a certain key is present\n *  AND its ValueType isn't ValueType.NULL.\n *\n * @param name\n * \t\tName of the key which ValueType should be checked.\n * @return Returns <code>true</code> if key <code>name</code> is present\nand its ValueType isn't ValueType.NULL, <code>false</code> otherwise.\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean hasNotNull(final String name) throws IOException {\n    final JsonValue value = this.object.json().get(name);\n    return (value != null) && (!ValueType.NULL.equals(value.getValueType()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.star",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReleaseAsset.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.fetch",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtJson.fetch" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf fails\n */\npublic JsonObject fetch() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.iterate",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGitignores.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final List<JsonString> list = response.as(JsonResponse.class).json().readArray().getValuesAs(JsonString.class);\n    final List<String> templates = new ArrayList<>(list.size());\n    for (final JsonString value : list) {\n        templates.add(value.getString());\n    }\n    return templates;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.starred",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtStars.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.clear",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssueLabels.clear" ],
    "fullMethods" : [ "@Override\npublic void clear() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGistComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.delete",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.unstar",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.Items.hasNext",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtValuePagination.Items.hasNext", "com.jcabi.github.RtValuePagination.Items.fetch" ],
    "fullMethods" : [ "@Override\npublic boolean hasNext() {\n    synchronized(this.mapping) {\n        if (((this.objects == null) || this.objects.isEmpty()) && this.more) {\n            try {\n                this.fetch();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        return !this.objects.isEmpty();\n    }\n}", "/**\n * Fetch the next portion, if available.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@SuppressWarnings(\"unchecked\")\nprivate void fetch() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final WebLinkingResponse.Link link = response.as(WebLinkingResponse.class).links().get(\"next\");\n    if (link == null) {\n        this.more = false;\n    } else {\n        this.request = response.jump(link.uri());\n    }\n    final JsonArray arr = response.as(JsonResponse.class).json().readArray();\n    final Queue<P> list = new LinkedList<>();\n    for (final JsonValue value : arr) {\n        list.add(((P) (value)));\n    }\n    this.objects = list;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.fetch" ],
    "fullMethods" : [ "@Override\npublic Response fetch(final InputStream stream) throws IOException {\n    return new RtSearchPagination.Hidden(this.request.fetch(stream));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Gist.Smart.files",
    "thirdPartyMethod" : "javax.json.JsonObject.values",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Gist.Smart.files" ],
    "fullMethods" : [ "/**\n * Get a list of all file names in the gist.\n *\n * @return File names\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Iterable<String> files() throws IOException {\n    final JsonObject array = this.gist.json().getJsonObject(\"files\");\n    final Collection<String> files = new ArrayList<>(array.size());\n    for (final JsonValue value : array.values()) {\n        files.add(JsonObject.class.cast(value).getString(\"filename\"));\n    }\n    return files;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.through",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.through" ],
    "fullMethods" : [ "@Override\npublic <T extends Wire> Request through(final Class<T> type, final Object... args) {\n    return new SearchRequest(this.request.through(type, args));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.\n *\n * @since 0.4\n */\npublic RtGithub() {\n    this(RtGithub.REQUEST);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.fetch",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtJson.fetch" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf fails\n */\npublic JsonObject fetch() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.Items.hasNext",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtValuePagination.Items.hasNext", "com.jcabi.github.RtValuePagination.Items.fetch" ],
    "fullMethods" : [ "@Override\npublic boolean hasNext() {\n    synchronized(this.mapping) {\n        if (((this.objects == null) || this.objects.isEmpty()) && this.more) {\n            try {\n                this.fetch();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        return !this.objects.isEmpty();\n    }\n}", "/**\n * Fetch the next portion, if available.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@SuppressWarnings(\"unchecked\")\nprivate void fetch() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final WebLinkingResponse.Link link = response.as(WebLinkingResponse.class).links().get(\"next\");\n    if (link == null) {\n        this.more = false;\n    } else {\n        this.request = response.jump(link.uri());\n    }\n    final JsonArray arr = response.as(JsonResponse.class).json().readArray();\n    final Queue<P> list = new LinkedList<>();\n    for (final JsonValue value : arr) {\n        list.add(((P) (value)));\n    }\n    this.objects = list;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.iterate",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGitignores.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final List<JsonString> list = response.as(JsonResponse.class).json().readArray().getValuesAs(JsonString.class);\n    final List<String> templates = new ArrayList<>(list.size());\n    for (final JsonString value : list) {\n        templates.add(value.getString());\n    }\n    return templates;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.json",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.fetch" ],
    "fullMethods" : [ "@Override\npublic Response fetch(final InputStream stream) throws IOException {\n    return new RtSearchPagination.Hidden(this.request.fetch(stream));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Statuses.StatusCreate.json",
    "thirdPartyMethod" : "com.google.common.base.Absent.get",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Statuses.StatusCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"state\", this.state.identifier()).add(\"description\", this.description);\n    if (this.context.isPresent()) {\n        builder.add(\"context\", this.context.get());\n    }\n    if (this.targeturl.isPresent()) {\n        builder.add(\"target_url\", this.targeturl.get());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repos.RepoCreate.json",
    "thirdPartyMethod" : "com.google.common.base.Absent.get",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Repos.RepoCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    JsonObjectBuilder builder = Json.createObjectBuilder().add(\"name\", this.nam).add(\"description\", this.descr).add(\"homepage\", this.home).add(\"private\", this.priv);\n    if (this.init.isPresent()) {\n        builder = builder.add(\"auto_init\", this.init.get());\n    }\n    for (final Map.Entry<String, JsonValue> entry : this.other.entrySet()) {\n        builder.add(entry.getKey(), entry.getValue());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueEvents.create",
    "thirdPartyMethod" : "com.google.common.base.Absent.get",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.mock.MkIssueEvents.create" ],
    "fullMethods" : [ "/**\n * Creates a new issue event.\n * This has no equivalent in GitHub's public API, since GitHub generates\n * events automatically in response to some other API calls.\n *\n * @param type\n * \t\tType of event\n * @param issue\n * \t\tID number of issue the event is regarding\n * @param login\n * \t\tUsername of actor who caused the event\n * @param label\n * \t\tLabel added or removed\n * @return The newly created issue event\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min Make it possible to set the \"assignee\" field for\n\"assigned\"/\"unassigned\" events. Make it possible to set the\n\"milestone\" field for \"milestoned\"/\"demilestoned\" events. Make it\npossible to set the \"rename\" field for \"renamed\" events. Make it\npossible to set the \"commit_id\" field for events related to commits.\nSee https://developer.github.com/v3/issues/events/ for details.\n * @checkstyle ParameterNumberCheck (4 lines)\n */\npublic Event create(final String type, final int issue, final String login, final Optional<String> label) throws IOException {\n    final String created = new Github.Time().toString();\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue-event/number/text()\", this.xpath())).size();\n        Directives directives = new Directives().xpath(this.xpath()).add(\"issue-event\").add(\"issue\").set(Integer.toString(issue)).up().add(\"number\").set(Integer.toString(number)).up().add(\"event\").set(type).up().add(\"created_at\").set(created).up().add(\"login\").set(login).up();\n        if (label.isPresent()) {\n            directives = directives.add(\"label\").set(label.get()).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(MkEvent.class, \"issue event #%d of type %s created in %s for issue #%d by %s\", number, type, this.self, issue, login);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Label.Unmodified.json",
    "thirdPartyMethod" : "javax.json.Json.createReader",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Label.Unmodified.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    return Json.createReader(new StringReader(this.obj)).readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.body",
    "thirdPartyMethod" : "javax.json.Json.createReader",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.body" ],
    "fullMethods" : [ "@Override\npublic String body() {\n    return Json.createReader(new StringReader(this.response.body())).readObject().getJsonArray(\"items\").toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatus.json",
    "thirdPartyMethod" : "javax.json.Json.createReader",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtStatus.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    return Json.createReader(new StringReader(this.jsn)).readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComment.json",
    "thirdPartyMethod" : "com.jcabi.log.Logger.warn",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfComment.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    JsonObject json;\n    try {\n        json = this.origin.json();\n    } catch (final AssertionError ex) {\n        final String author = new Issue.Smart(new SfIssue(this.origin.issue())).author().login();\n        json = new MkGithub(author).randomRepo().issues().create(\"\", \"\").comments().post(\"deleted comment\").json();\n        Logger.warn(this, \"failed to fetch comment: %[exception]s\", ex);\n    }\n    return json;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComment.remove",
    "thirdPartyMethod" : "com.jcabi.log.Logger.warn",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    try {\n        this.origin.remove();\n    } catch (final AssertionError ex) {\n        Logger.warn(this, \"Failed to remove comment: %[exception]s\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfIssue.json",
    "thirdPartyMethod" : "com.jcabi.log.Logger.warn",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfIssue.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    JsonObject json;\n    try {\n        json = this.origin.json();\n    } catch (final AssertionError ex) {\n        json = new MkGithub().randomRepo().issues().create(\"\", \"\").json();\n        Logger.warn(this, \"failed to fetch issue: %[exception]s\", ex);\n    }\n    return json;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComments.post",
    "thirdPartyMethod" : "com.jcabi.log.Logger.warn",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    Comment cmt;\n    try {\n        cmt = this.origin.post(text);\n    } catch (final AssertionError ex) {\n        Logger.warn(this, \"Failed to post to GitHub: %[exception]s\", ex);\n        cmt = new MkGithub().randomRepo().issues().create(\"\", \"\").comments().post(text);\n    }\n    return cmt;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfIssue.patch",
    "thirdPartyMethod" : "com.jcabi.log.Logger.warn",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfIssue.patch" ],
    "fullMethods" : [ "@Override\npublic void patch(final JsonObject json) throws IOException {\n    try {\n        this.origin.patch(json);\n    } catch (final AssertionError ex) {\n        Logger.warn(this, \"failed to patch issue: %[exception]s\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComment.patch",
    "thirdPartyMethod" : "com.jcabi.log.Logger.warn",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfComment.patch" ],
    "fullMethods" : [ "@Override\npublic void patch(final JsonObject json) throws IOException {\n    try {\n        this.origin.patch(json);\n    } catch (final AssertionError ex) {\n        Logger.warn(this, \"Failed to path comment: %[exception]s\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.reset",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.reset" ],
    "fullMethods" : [ "@Override\npublic Request reset(final String name) {\n    return new SearchRequest(this.request.reset(name));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkDeployKey.remove",
    "thirdPartyMethod" : "org.xembly.Directives.strict",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRelease.delete",
    "thirdPartyMethod" : "org.xembly.Directives.strict",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkComment.remove",
    "thirdPartyMethod" : "org.xembly.Directives.strict",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAsset.remove",
    "thirdPartyMethod" : "org.xembly.Directives.strict",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReleaseAsset.remove" ],
    "fullMethods" : [ "/**\n * Remove asset.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Smarts.next",
    "thirdPartyMethod" : "com.jcabi.log.Logger.debug",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.Smarts.next", "com.jcabi.github.Smarts.access", "com.jcabi.github.Smarts.wrap", "com.jcabi.github.Smarts.type" ],
    "fullMethods" : [ "@Override\npublic T next() {\n    return Smarts.<T>wrap(iterator.next());\n}", "{\n    java.lang.Object $stack1, x0;\n\n\n    x0 := @parameter0: java.lang.Object;\n    $stack1 = staticinvoke <com.jcabi.github.Smarts: java.lang.Object wrap(java.lang.Object)>(x0);\n\n    return $stack1;\n}\n", "/**\n * Wrap an object, and make a \"smart\" decorator.\n *\n * @param object\n * \t\tObject to wrap\n * @return Decorator\n * @param <X>\n * \t\tType of result\n */\n@SuppressWarnings(\"unchecked\")\nprivate static <X> X wrap(final Object object) {\n    try {\n        return ((X) (Smarts.type(object).newInstance(object)));\n    } catch (final InvocationTargetException ex) {\n        throw new IllegalStateException(ex);\n    } catch (final InstantiationException ex) {\n        throw new IllegalStateException(ex);\n    } catch (final IllegalAccessException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Find \"smart\" class for the object.\n *\n * @param object\n * \t\tObject to wrap\n * @return Class to use\n */\nprivate static Constructor<?> type(final Object object) {\n    for (final Class<?> iface : object.getClass().getInterfaces()) {\n        try {\n            return Class.forName(String.format(\"%s$Smart\", iface.getName())).getDeclaredConstructor(iface);\n        } catch (final ClassNotFoundException ex) {\n            Logger.debug(Smarts.class, \"%s: %s\", iface.getName(), ex);\n        } catch (final NoSuchMethodException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n    throw new IllegalStateException(String.format(\"can't find Smart decorator for %s\", object.getClass().getName()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGists.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/gist[id='%s']\", this.xpath(), identifier)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStars.unstar",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"star/login[.='%s']\", this.self)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    this.storage.lock();\n    final String path = content.getString(\"path\");\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (content.containsKey(\"ref\")) {\n            branch = content.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"content[path='%s']\", path)).attr(\"ref\", branch).remove());\n        return this.commit(content);\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkHooks.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/hook[id='%d']\", this.xpath(), number)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleases.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.lock();\n    try {\n        this.storage.apply(new Directives().xpath(String.format(\"%s/release[id='%d']\", this.xpath(), number)).remove());\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkMilestones.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/milestone[number='%d']\", this.xpath(), number)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRelease.delete",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepos.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) {\n    try {\n        this.storage.apply(new Directives().xpath(String.format(\"%s/repo[@coords='%s']\", this.xpath(), coords)).remove());\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCollaborators.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/user[login='%s']\", this.xpath(), user)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAsset.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReleaseAsset.remove" ],
    "fullMethods" : [ "/**\n * Remove asset.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPullComments.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/comment[id='%d']\", this.xpath(), number)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkDeployKey.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPublicKeys.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/key[id='%d']\", this.xpath(), number)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUserEmails.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final Directives directives = new Directives();\n    for (final String email : emails) {\n        directives.xpath(String.format(\"%s/email[.='%s']\", this.xpath(), email)).remove();\n    }\n    this.storage.apply(directives);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueLabels.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    if (this.labels().contains(name)) {\n        this.storage.apply(new Directives().xpath(String.format(\"%s/label[.='%s']\", this.xpath(), name)).remove());\n        new MkIssueEvents(this.storage, this.self, this.repo).create(Event.UNLABELED, this.ticket, this.self, Optional.of(name));\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReferences.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/reference[ref='%s']\", this.xpath(), identifier)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkLabels.delete",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"label[name='%s']\", name)).remove().xpath(\"/github/repos\").xpath(String.format(\"repo[@coords='%s']\", this.coords)).xpath(String.format(\"issues/issue/labels/label[.='%s']\", name)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkComment.remove",
    "thirdPartyMethod" : "org.xembly.Directives.remove",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.draft",
    "thirdPartyMethod" : "javax.json.EmptyObject.getBoolean",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.draft" ],
    "fullMethods" : [ "/**\n * Is release draft.\n *\n * @return Returns true if it's draft\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean draft() throws IOException {\n    return this.json().getBoolean(\"draft\", Boolean.FALSE);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.Items.hasNext",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readArray",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtValuePagination.Items.hasNext", "com.jcabi.github.RtValuePagination.Items.fetch" ],
    "fullMethods" : [ "@Override\npublic boolean hasNext() {\n    synchronized(this.mapping) {\n        if (((this.objects == null) || this.objects.isEmpty()) && this.more) {\n            try {\n                this.fetch();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        return !this.objects.isEmpty();\n    }\n}", "/**\n * Fetch the next portion, if available.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@SuppressWarnings(\"unchecked\")\nprivate void fetch() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final WebLinkingResponse.Link link = response.as(WebLinkingResponse.class).links().get(\"next\");\n    if (link == null) {\n        this.more = false;\n    } else {\n        this.request = response.jump(link.uri());\n    }\n    final JsonArray arr = response.as(JsonResponse.class).json().readArray();\n    final Queue<P> list = new LinkedList<>();\n    for (final JsonValue value : arr) {\n        list.add(((P) (value)));\n    }\n    this.objects = list;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.iterate",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readArray",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtGitignores.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final List<JsonString> list = response.as(JsonResponse.class).json().readArray().getValuesAs(JsonString.class);\n    final List<String> templates = new ArrayList<>(list.size());\n    for (final JsonString value : list) {\n        templates.add(value.getString());\n    }\n    return templates;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readArray",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readArray",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readArray",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readArray",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readArray",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchURI.userInfo",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.userInfo",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchURI.userInfo" ],
    "fullMethods" : [ "@Override\npublic RequestURI userInfo(final String info) {\n    return new SearchURI(this.address.userInfo(info));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.star",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.fetch" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf fails\n */\npublic JsonObject fetch() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final List<JsonString> list = response.as(JsonResponse.class).json().readArray().getValuesAs(JsonString.class);\n    final List<String> templates = new ArrayList<>(list.size());\n    for (final JsonString value : list) {\n        templates.add(value.getString());\n    }\n    return templates;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.clear",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.clear" ],
    "fullMethods" : [ "@Override\npublic void clear() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.fetch" ],
    "fullMethods" : [ "/**\n * Hide everything from the body but items.\n *\n * @return Response\n * @throws IOException\n * \t\tIf any I/O problem occurs\n */\n@Override\npublic Response fetch() throws IOException {\n    return new RtSearchPagination.Hidden(this.request.fetch());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.Items.hasNext",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtValuePagination.Items.hasNext", "com.jcabi.github.RtValuePagination.Items.fetch" ],
    "fullMethods" : [ "@Override\npublic boolean hasNext() {\n    synchronized(this.mapping) {\n        if (((this.objects == null) || this.objects.isEmpty()) && this.more) {\n            try {\n                this.fetch();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        return !this.objects.isEmpty();\n    }\n}", "/**\n * Fetch the next portion, if available.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@SuppressWarnings(\"unchecked\")\nprivate void fetch() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final WebLinkingResponse.Link link = response.as(WebLinkingResponse.class).links().get(\"next\");\n    if (link == null) {\n        this.more = false;\n    } else {\n        this.request = response.jump(link.uri());\n    }\n    final JsonArray arr = response.as(JsonResponse.class).json().readArray();\n    final Queue<P> list = new LinkedList<>();\n    for (final JsonValue value : arr) {\n        list.add(((P) (value)));\n    }\n    this.objects = list;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkComments.post",
    "thirdPartyMethod" : "com.jcabi.log.Logger.info",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    this.storage.lock();\n    final long number;\n    try {\n        final String timestamp = new Github.Time().toString();\n        number = 1 + this.storage.xml().nodes(\"//comment/number\").size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"comment\").add(\"number\").set(Long.toString(number)).up().add(\"url\").set(// @checkstyle LineLength (1 line)\n        String.format(\"https://api.jcabi-github.invalid/repos/%s/%s/issues/comments/%d\", this.repo.user(), this.repo.repo(), number)).up().add(\"body\").set(text).up().add(\"user\").add(\"login\").set(this.self).up().up().add(\"created_at\").set(timestamp).up().add(\"updated_at\").set(timestamp));\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"comment #%d posted to issue #%d by %s: %[text]s\", number, this.issue().number(), this.self, text);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssues.create",
    "thirdPartyMethod" : "com.jcabi.log.Logger.info",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue/number/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"issue\").add(\"number\").set(Integer.toString(number)).up().add(\"state\").set(Issue.OPEN_STATE).up().add(\"title\").set(title).up().add(\"body\").set(body).up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"updated_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up().add(\"user\").add(\"login\").set(this.self).up().up());\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"issue #%d created in %s by %s: %[text]s\", number, this.repo().coordinates(), this.self, title);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkForks.create",
    "thirdPartyMethod" : "com.jcabi.log.Logger.info",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String org) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/fork/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"fork\").add(\"id\").set(Integer.toString(number)).up().attr(\"organization\", org));\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"fork %s created inside %s by %s\", this.coords, org, this.self);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueEvents.create",
    "thirdPartyMethod" : "com.jcabi.log.Logger.info",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkIssueEvents.create" ],
    "fullMethods" : [ "/**\n * Creates a new issue event.\n * This has no equivalent in GitHub's public API, since GitHub generates\n * events automatically in response to some other API calls.\n *\n * @param type\n * \t\tType of event\n * @param issue\n * \t\tID number of issue the event is regarding\n * @param login\n * \t\tUsername of actor who caused the event\n * @param label\n * \t\tLabel added or removed\n * @return The newly created issue event\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min Make it possible to set the \"assignee\" field for\n\"assigned\"/\"unassigned\" events. Make it possible to set the\n\"milestone\" field for \"milestoned\"/\"demilestoned\" events. Make it\npossible to set the \"rename\" field for \"renamed\" events. Make it\npossible to set the \"commit_id\" field for events related to commits.\nSee https://developer.github.com/v3/issues/events/ for details.\n * @checkstyle ParameterNumberCheck (4 lines)\n */\npublic Event create(final String type, final int issue, final String login, final Optional<String> label) throws IOException {\n    final String created = new Github.Time().toString();\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue-event/number/text()\", this.xpath())).size();\n        Directives directives = new Directives().xpath(this.xpath()).add(\"issue-event\").add(\"issue\").set(Integer.toString(issue)).up().add(\"number\").set(Integer.toString(number)).up().add(\"event\").set(type).up().add(\"created_at\").set(created).up().add(\"login\").set(login).up();\n        if (label.isPresent()) {\n            directives = directives.add(\"label\").set(label.get()).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(MkEvent.class, \"issue event #%d of type %s created in %s for issue #%d by %s\", number, type, this.self, issue, login);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepos.create",
    "thirdPartyMethod" : "com.jcabi.log.Logger.info",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String owner = this.self;\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        owner = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    final Coordinates coords = new Coordinates.Simple(owner, settings.name());\n    this.storage.apply(new Directives().xpath(this.xpath()).add(\"repo\").attr(\"coords\", coords.toString()).add(\"name\").set(settings.name()).up().add(\"description\").set(\"test repository\").up().add(\"private\").set(settings.isPrivate()).up());\n    final Repo repo = this.get(coords);\n    repo.patch(settings.json());\n    Logger.info(this, \"repository %s created by %s\", coords, owner);\n    return repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.CarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.log.Logger.info",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.wire.CarefulWire.send" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    final Response resp = this.origin.send(req, home, method, headers, content, connect, read);\n    final int remaining = this.remainingHeader(resp);\n    if (remaining < this.threshold) {\n        final long reset = this.resetHeader(resp);\n        final long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n        if (reset > now) {\n            final long length = reset - now;\n            // @checkstyle LineLength (1 line)\n            Logger.info(this, \"Remaining number of requests per hour is less than %d. Waiting for %d seconds.\", this.threshold, length);\n            try {\n                TimeUnit.SECONDS.sleep(length);\n            } catch (final InterruptedException ex) {\n                Thread.currentThread().interrupt();\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return resp;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.Items.hasNext",
    "thirdPartyMethod" : "javax.json.JsonArray.iterator",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtValuePagination.Items.hasNext", "com.jcabi.github.RtValuePagination.Items.fetch" ],
    "fullMethods" : [ "@Override\npublic boolean hasNext() {\n    synchronized(this.mapping) {\n        if (((this.objects == null) || this.objects.isEmpty()) && this.more) {\n            try {\n                this.fetch();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        return !this.objects.isEmpty();\n    }\n}", "/**\n * Fetch the next portion, if available.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@SuppressWarnings(\"unchecked\")\nprivate void fetch() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final WebLinkingResponse.Link link = response.as(WebLinkingResponse.class).links().get(\"next\");\n    if (link == null) {\n        this.more = false;\n    } else {\n        this.request = response.jump(link.uri());\n    }\n    final JsonArray arr = response.as(JsonResponse.class).json().readArray();\n    final Queue<P> list = new LinkedList<>();\n    for (final JsonValue value : arr) {\n        list.add(((P) (value)));\n    }\n    this.objects = list;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.CommitsComparison.Smart.commits",
    "thirdPartyMethod" : "javax.json.JsonArray.iterator",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.CommitsComparison.Smart.commits" ],
    "fullMethods" : [ "/**\n * Get commits.\n *\n * @return Commits\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Iterable<RepoCommit> commits() throws IOException {\n    final JsonArray array = this.comparison.json().getJsonArray(\"commits\");\n    final Collection<RepoCommit> commits = new ArrayList<>(array.size());\n    final RepoCommits repo = this.comparison.repo().commits();\n    for (final JsonValue value : array) {\n        commits.add(repo.get(JsonObject.class.cast(value).getString(\"sha\")));\n    }\n    return commits;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTrees.create",
    "thirdPartyMethod" : "javax.json.JsonArray.iterator",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkTrees.create" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Tree create(final JsonObject params) throws IOException {\n    final JsonArray trees = params.getJsonArray(\"tree\");\n    for (final JsonValue val : trees) {\n        final JsonObject tree = ((JsonObject) (val));\n        final String sha = tree.getString(\"sha\");\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"tree\");\n        for (final Entry<String, JsonValue> entry : tree.entrySet()) {\n            dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n        }\n        this.storage.apply(dirs);\n        final String ref;\n        if (tree.containsValue(\"name\")) {\n            ref = tree.getString(\"name\");\n        } else {\n            ref = sha;\n        }\n        new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder(\"refs/trees/\").append(ref).toString(), sha);\n    }\n    return this.get(trees.getJsonObject(0).getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Statuses.StatusCreate.json",
    "thirdPartyMethod" : "com.google.common.base.Present.isPresent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Statuses.StatusCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"state\", this.state.identifier()).add(\"description\", this.description);\n    if (this.context.isPresent()) {\n        builder.add(\"context\", this.context.get());\n    }\n    if (this.targeturl.isPresent()) {\n        builder.add(\"target_url\", this.targeturl.get());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repos.RepoCreate.json",
    "thirdPartyMethod" : "com.google.common.base.Present.isPresent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Repos.RepoCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    JsonObjectBuilder builder = Json.createObjectBuilder().add(\"name\", this.nam).add(\"description\", this.descr).add(\"homepage\", this.home).add(\"private\", this.priv);\n    if (this.init.isPresent()) {\n        builder = builder.add(\"auto_init\", this.init.get());\n    }\n    for (final Map.Entry<String, JsonValue> entry : this.other.entrySet()) {\n        builder.add(entry.getKey(), entry.getValue());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueEvents.create",
    "thirdPartyMethod" : "com.google.common.base.Present.isPresent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.mock.MkIssueEvents.create" ],
    "fullMethods" : [ "/**\n * Creates a new issue event.\n * This has no equivalent in GitHub's public API, since GitHub generates\n * events automatically in response to some other API calls.\n *\n * @param type\n * \t\tType of event\n * @param issue\n * \t\tID number of issue the event is regarding\n * @param login\n * \t\tUsername of actor who caused the event\n * @param label\n * \t\tLabel added or removed\n * @return The newly created issue event\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min Make it possible to set the \"assignee\" field for\n\"assigned\"/\"unassigned\" events. Make it possible to set the\n\"milestone\" field for \"milestoned\"/\"demilestoned\" events. Make it\npossible to set the \"rename\" field for \"renamed\" events. Make it\npossible to set the \"commit_id\" field for events related to commits.\nSee https://developer.github.com/v3/issues/events/ for details.\n * @checkstyle ParameterNumberCheck (4 lines)\n */\npublic Event create(final String type, final int issue, final String login, final Optional<String> label) throws IOException {\n    final String created = new Github.Time().toString();\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue-event/number/text()\", this.xpath())).size();\n        Directives directives = new Directives().xpath(this.xpath()).add(\"issue-event\").add(\"issue\").set(Integer.toString(issue)).up().add(\"number\").set(Integer.toString(number)).up().add(\"event\").set(type).up().add(\"created_at\").set(created).up().add(\"login\").set(login).up();\n        if (label.isPresent()) {\n            directives = directives.add(\"label\").set(label.get()).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(MkEvent.class, \"issue event #%d of type %s created in %s for issue #%d by %s\", number, type, this.self, issue, login);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.back",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.back",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.back" ],
    "fullMethods" : [ "@Override\npublic Request back() {\n    return new SearchRequest(this.response.back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.star",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.fetch" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf fails\n */\npublic JsonObject fetch() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final List<JsonString> list = response.as(JsonResponse.class).json().readArray().getValuesAs(JsonString.class);\n    final List<String> templates = new ArrayList<>(list.size());\n    for (final JsonString value : list) {\n        templates.add(value.getString());\n    }\n    return templates;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.clear",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.clear" ],
    "fullMethods" : [ "@Override\npublic void clear() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.fetch" ],
    "fullMethods" : [ "/**\n * Hide everything from the body but items.\n *\n * @return Response\n * @throws IOException\n * \t\tIf any I/O problem occurs\n */\n@Override\npublic Response fetch() throws IOException {\n    return new RtSearchPagination.Hidden(this.request.fetch());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.Items.hasNext",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtValuePagination.Items.hasNext", "com.jcabi.github.RtValuePagination.Items.fetch" ],
    "fullMethods" : [ "@Override\npublic boolean hasNext() {\n    synchronized(this.mapping) {\n        if (((this.objects == null) || this.objects.isEmpty()) && this.more) {\n            try {\n                this.fetch();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        return !this.objects.isEmpty();\n    }\n}", "/**\n * Fetch the next portion, if available.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@SuppressWarnings(\"unchecked\")\nprivate void fetch() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final WebLinkingResponse.Link link = response.as(WebLinkingResponse.class).links().get(\"next\");\n    if (link == null) {\n        this.more = false;\n    } else {\n        this.request = response.jump(link.uri());\n    }\n    final JsonArray arr = response.as(JsonResponse.class).json().readArray();\n    final Queue<P> list = new LinkedList<>();\n    for (final JsonValue value : arr) {\n        list.add(((P) (value)));\n    }\n    this.objects = list;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCommitsComparison.files",
    "thirdPartyMethod" : "com.google.common.collect.ImmutableList.of",
    "thirdPartyPackage" : "com.google.common.collect",
    "path" : [ "com.jcabi.github.mock.MkCommitsComparison.files" ],
    "fullMethods" : [ "@Override\npublic Iterable<FileChange> files() {\n    return ImmutableList.<FileChange>of(new MkFileChange(MkCommitsComparison.FILE_JSON));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Label.Unmodified.json",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.Label.Unmodified.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    return Json.createReader(new StringReader(this.obj)).readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.body",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.body" ],
    "fullMethods" : [ "@Override\npublic String body() {\n    return Json.createReader(new StringReader(this.response.body())).readObject().getJsonArray(\"items\").toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.fetch",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtJson.fetch" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf fails\n */\npublic JsonObject fetch() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatus.json",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtStatus.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    return Json.createReader(new StringReader(this.jsn)).readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.readObject",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.getRec",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTrees.getRec" ],
    "fullMethods" : [ "@Override\npublic Tree getRec(final String sha) {\n    return new RtTree(this.entry.uri().queryParam(\"recursive\", \"1\").back(), this.owner, sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.users",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.users", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> users(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"users\", keywords, sort, order.identifier(), object -> this.ghub.users().get(object.getString(\"login\")));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> iterate(final String identifier) {\n    return new RtPagination<>(this.entry.uri().queryParam(\"since\", identifier).back(), object -> this.get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtNotifications.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtNotifications.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Notification> iterate() {\n    return new RtPagination<>(this.request.uri().queryParam(\"all\", \"true\").queryParam(\"since\", \"1970-01-01T00:00:00Z\").back(), json -> new RtNotification(Long.valueOf(json.getString(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Comment> iterate(final Date since) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", new Github.Time(since)).back(), object -> this.get(object.getJsonNumber(\"id\").longValue()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.repos",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.repos", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> repos(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"repositories\", keywords, sort, order.identifier(), object -> this.github().repos().get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.codes",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.codes", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> codes(final String keywords, final String sort, final Order order) {\n    return // @checkstyle AnonInnerLengthCheck (25 lines)\n    new RtSearchPagination<>(this.request, \"code\", keywords, sort, order.identifier(), object -> {\n        try {\n            // @checkstyle MultipleStringLiteralsCheck (1 line)\n            final URI uri = new URI(object.getString(\"url\"));\n            final String[] parts = RtSearch.SLASH.split(uri.getPath());\n            final String ref = RtSearch.QUERY.split(uri.getQuery())[1];\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).contents().get(object.getString(\"path\"), ref);\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        } catch (final IOException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchURI.queryParam",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchURI.queryParam" ],
    "fullMethods" : [ "@Override\npublic RequestURI queryParam(final String name, final Object value) {\n    return new SearchURI(this.address.queryParam(name, value));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtForks.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Fork> iterate(final String sort) {\n    return new RtPagination<>(this.request.uri().queryParam(\"sort\", sort).back(), object -> this.get(object.getInt(ID)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUsers.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> iterate(final String identifier) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", identifier).back(), object -> this.get(String.valueOf(object.getInt(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParam",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.issues", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (5 lines)\n@Override\npublic Iterable<Issue> issues(final String keywords, final String sort, final Order order, final EnumMap<Qualifier, String> qualifiers) {\n    final StringBuilder keyword = new StringBuilder(keywords);\n    for (final Map.Entry<Qualifier, String> entry : qualifiers.entrySet()) {\n        keyword.append('+').append(entry.getKey().identifier()).append(':').append(entry.getValue());\n    }\n    return new RtSearchPagination<>(this.request, \"issues\", keyword.toString(), sort, order.identifier(), object -> {\n        try {\n            final String[] parts = // @checkstyle MultipleStringLiteralsCheck (1 line)\n            RtSearch.SLASH.split(new URI(object.getString(\"url\")).getPath());\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).issues().get(object.getInt(\"number\"));\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.apply",
    "thirdPartyMethod" : "org.apache.commons.io.FileUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.apply" ],
    "fullMethods" : [ "@Override\npublic void apply(final Iterable<Directive> dirs) throws IOException {\n    synchronized(this.name) {\n        FileUtils.write(new File(this.name), new XMLDocument(new Xembler(dirs).applyQuietly(this.xml().node())).toString(), StandardCharsets.UTF_8);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.xml",
    "thirdPartyMethod" : "org.apache.commons.io.FileUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.xml" ],
    "fullMethods" : [ "@Override\npublic XML xml() throws IOException {\n    synchronized(this.name) {\n        return new XMLDocument(FileUtils.readFileToString(new File(this.name), StandardCharsets.UTF_8));\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.<init>",
    "thirdPartyMethod" : "org.apache.commons.io.FileUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param file\n * \t\tFile to use\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic InFile(final File file) throws IOException {\n    FileUtils.write(file, \"<github/>\", StandardCharsets.UTF_8);\n    this.name = file.getAbsolutePath();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGit.commits", "com.jcabi.github.RtCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic Commits commits() {\n    return new RtCommits(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/commits\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGistComments.get", "com.jcabi.github.RtGistComment.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComment get(final int number) {\n    return new RtGistComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param gist\n * \t\tGist of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtGistComment(final Request req, final Gist gist, final int number) {\n    this.request = req.uri().path(\"/gists\").path(new Gist.Smart(gist).identifier()).path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = gist;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKey.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param user\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\npublic RtPublicKey(final Request req, final User user, final int number) {\n    this.request = req.uri().path(\"/user\").path(\"/keys\").path(Integer.toString(number)).back();\n    this.owner = user;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.assignees",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.assignees", "com.jcabi.github.RtAssignees.<init>" ],
    "fullMethods" : [ "@Override\npublic Assignees assignees() {\n    return new RtAssignees(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtAssignees(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/assignees\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.markdown",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.markdown", "com.jcabi.github.RtMarkdown.<init>" ],
    "fullMethods" : [ "@Override\npublic Markdown markdown() {\n    return new RtMarkdown(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtMarkdown(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"markdown\").back().method(Request.POST);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTags.get", "com.jcabi.github.RtTag.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag get(final String sha) {\n    return new RtTag(this.entry, this.owner, sha);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe request.\n * @param repo\n * \t\tThe owner repo.\n * @param key\n * \t\tThe sha.\n */\nRtTag(final Request req, final Repo repo, final String key) {\n    this.sha = key;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").path(this.sha).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBranch.commit",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtBranch.commit", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit commit() {\n    return new RtCommit(this.entry, this.owner, this.hash);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.keys",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.keys", "com.jcabi.github.RtDeployKeys.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKeys keys() {\n    return new RtDeployKeys(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\nRtDeployKeys(final Request req, final Repo repo) {\n    this.owner = repo;\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtIssue.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGists.get", "com.jcabi.github.RtGist.<init>" ],
    "fullMethods" : [ "@Override\npublic Gist get(final String name) {\n    return new RtGist(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param name\n * \t\tName of gist\n */\nRtGist(final Github github, final Request req, final String name) {\n    this.ghub = github;\n    this.entry = req;\n    this.gist = name;\n    this.request = req.uri().path(\"/gists\").path(name).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.milestones",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.milestones", "com.jcabi.github.RtMilestones.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestones milestones() {\n    return new RtMilestones(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtMilestones(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabels.get", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label get(final String name) {\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGitignores.<init>" ],
    "fullMethods" : [ "/**\n * Public CTOR.\n *\n * @param github\n * \t\tGithub\n */\npublic RtGitignores(final Github github) {\n    this.ghub = github;\n    this.request = github().entry().uri().path(\"/gitignore/templates\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.references",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGit.references", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic References references() {\n    return new RtReferences(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReferences.get", "com.jcabi.github.RtReference.<init>" ],
    "fullMethods" : [ "@Override\npublic Reference get(final String identifier) {\n    return new RtReference(this.entry, this.owner, identifier);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tOwner of this reference.\n * @param ref\n * \t\tThe name of the reference.\n */\nRtReference(final Request req, final Repo repo, final String ref) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(ref).back();\n    this.owner = repo;\n    this.name = ref;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.commits" ],
    "fullMethods" : [ "@Override\npublic Iterable<Commit> commits() {\n    return new RtPagination<>(this.request.uri().path(\"/commits\").back(), object -> new RtCommit(this.entry, this.owner, object.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.tags",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGit.tags", "com.jcabi.github.RtTags.<init>" ],
    "fullMethods" : [ "@Override\npublic Tags tags() {\n    return new RtTags(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtTags(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComments.get", "com.jcabi.github.RtComment.<init>" ],
    "fullMethods" : [ "@Override\npublic Comment get(final long number) {\n    return new RtComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param issue\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtComment(final Request req, final Issue issue, final long number) {\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/comments\").path(Long.toString(number)).back();\n    this.owner = issue;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.statuses",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCommits.statuses", "com.jcabi.github.RtStatuses.<init>" ],
    "fullMethods" : [ "@Override\npublic Statuses statuses(final String ref) {\n    return new RtStatuses(this.entry, this.get(ref));\n}", "/**\n * Create a new status-aware object based on given commit.\n *\n * @param req\n * \t\tHttp request\n * @param commit\n * \t\tSpecific commit\n */\nRtStatuses(final Request req, final Commit commit) {\n    final Coordinates coords = commit.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/statuses\").path(commit.sha()).back();\n    this.cmmt = commit;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.compare",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.compare", "com.jcabi.github.RtCommitsComparison.<init>" ],
    "fullMethods" : [ "@Override\npublic CommitsComparison compare(final String base, final String head) {\n    return new RtCommitsComparison(this.entry, this.owner, base, head);\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n * @param base\n * \t\tSHA of a base commit\n * @param head\n * \t\tSHA of a head commit\n * @checkstyle ParameterNumber (3 lines)\n */\nRtCommitsComparison(final Request req, final Repo repo, final String base, final String head) {\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().toString()).path(\"/compare\").path(String.format(\"%s...%s\", base, head)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.emails",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUser.emails", "com.jcabi.github.RtUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    return new RtUserEmails(this.ghub.entry());\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n */\nRtUserEmails(final Request req) {\n    this.request = req.header(\"Accept\", \"application/vnd.github.v3\").uri().path(\"/user/emails\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComment.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtComment.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.users",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.users", "com.jcabi.github.RtUsers.<init>" ],
    "fullMethods" : [ "@Override\npublic Users users() {\n    return new RtUsers(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtUsers(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/users\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabels.create", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.gists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.gists", "com.jcabi.github.RtGists.<init>" ],
    "fullMethods" : [ "@Override\npublic Gists gists() {\n    return new RtGists(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtGists(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/gists\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.limits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.limits", "com.jcabi.github.RtLimits.<init>" ],
    "fullMethods" : [ "@Override\npublic Limits limits() {\n    return new RtLimits(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtLimits(final Github github, final Request req) {\n    this.entry = req.uri().path(\"rate_limit\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.get", "com.jcabi.github.RtRepo.<init>" ],
    "fullMethods" : [ "@Override\npublic Repo get(final Coordinates name) {\n    return new RtRepo(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param crd\n * \t\tCoordinate of the repo\n */\nRtRepo(final Github github, final Request req, final Coordinates crd) {\n    this.ghub = github;\n    this.entry = req;\n    this.coords = crd;\n    this.request = this.entry.uri().path(\"/repos\").path(this.coords.user()).path(this.coords.repo()).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.get", "com.jcabi.github.RtRepoCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommit get(final String sha) {\n    return new RtRepoCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtRepoCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stargazers",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.stargazers", "com.jcabi.github.RtStargazers.<init>" ],
    "fullMethods" : [ "@Override\npublic Stargazers stargazers() {\n    return new RtStargazers(this.request);\n}", "/**\n * Public ctor.\n *\n * @param entry\n * \t\tEntry request.\n */\nRtStargazers(final Request entry) {\n    this.request = entry.uri().path(\"stargazers\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.events",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.events" ],
    "fullMethods" : [ "@Override\npublic Iterable<Event> events() {\n    return new RtPagination<>(this.request.uri().path(\"/events\").back(), object -> new RtEvent(this.entry, this.owner, object.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.pulls",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.pulls", "com.jcabi.github.RtPulls.<init>" ],
    "fullMethods" : [ "@Override\npublic Pulls pulls() {\n    return new RtPulls(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtPulls(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.self",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUsers.self", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User self() {\n    return new RtUser(this.ghub, this.entry, \"\");\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserOrganizations.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUserOrganizations.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Organization> iterate() throws IOException {\n    final String login = this.owner.login();\n    return new RtPagination<>(this.entry.uri().path(\"/users\").path(login).path(\"/orgs\").back(), new OrganizationMapping(this.ghub.organizations()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.codes",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.codes", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> codes(final String keywords, final String sort, final Order order) {\n    return // @checkstyle AnonInnerLengthCheck (25 lines)\n    new RtSearchPagination<>(this.request, \"code\", keywords, sort, order.identifier(), object -> {\n        try {\n            // @checkstyle MultipleStringLiteralsCheck (1 line)\n            final URI uri = new URI(object.getString(\"url\"));\n            final String[] parts = RtSearch.SLASH.split(uri.getPath());\n            final String ref = RtSearch.QUERY.split(uri.getQuery())[1];\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).contents().get(object.getString(\"path\"), ref);\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        } catch (final IOException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.issues", "com.jcabi.github.RtIssues.<init>" ],
    "fullMethods" : [ "@Override\npublic Issues issues() {\n    return new RtIssues(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssues(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReferences.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reference> iterate(final String subnamespace) {\n    return new RtPagination<>(this.request.uri().path(subnamespace).back(), object -> this.get(object.getString(RtReferences.REF)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.trees",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGit.trees", "com.jcabi.github.RtTrees.<init>" ],
    "fullMethods" : [ "@Override\npublic Trees trees() {\n    return new RtTrees(this.entry, this.repo());\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtTrees(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/trees\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtBlobs.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtBlobs(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPulls.get", "com.jcabi.github.RtPull.<init>" ],
    "fullMethods" : [ "@Override\npublic Pull get(final int number) {\n    return new RtPull(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtPull(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.organizations",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.organizations", "com.jcabi.github.RtOrganizations.<init>" ],
    "fullMethods" : [ "@Override\npublic Organizations organizations() {\n    return new RtOrganizations(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtOrganizations(final Github github, final Request req) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/user\").path(\"/orgs\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issueEvents",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.issueEvents", "com.jcabi.github.RtIssueEvents.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueEvents issueEvents() {\n    return new RtIssueEvents(this.entry, this);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssueEvents(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.files",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.files" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonObject> files() {\n    return new RtPagination<>(this.request.uri().path(\"/files\").back(), RtPagination.COPYING);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKeys.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param user\n * \t\tUser\n */\npublic RtPublicKeys(final Request req, final User user) {\n    this.entry = req;\n    this.owner = user;\n    this.request = this.entry.uri().path(\"/user\").path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtDeployKeys.get", "com.jcabi.github.RtDeployKey.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKey get(final int number) {\n    return new RtDeployKey(this.entry, number, this.owner);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param number\n * \t\tId\n * @param repo\n * \t\tRepository\n */\nRtDeployKey(final Request req, final int number, final Repo repo) {\n    this.key = number;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").path(String.valueOf(number)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAssets.get", "com.jcabi.github.RtReleaseAsset.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset get(final int number) {\n    return new RtReleaseAsset(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful Request\n * @param release\n * \t\tRelease\n * @param number\n * \t\tNumber of the release asset.\n */\nRtReleaseAsset(final Request req, final Release release, final int number) {\n    final Coordinates coords = release.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(\"/assets\").path(Integer.toString(number)).back();\n    this.owner = release;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTags.create", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUser.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.github().entry().uri().path(RtUser.NOTIF_PATH).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtOrganization.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tOrganization login name\n */\npublic RtOrganization(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(login).back();\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.get", "com.jcabi.github.RtPullComment.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComment get(final int number) {\n    return new RtPullComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param pull\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtPullComment(final Request req, final Pull pull, final int number) {\n    final Coordinates coords = pull.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = pull;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssueEvents.get", "com.jcabi.github.RtEvent.<init>" ],
    "fullMethods" : [ "@Override\npublic Event get(final int number) {\n    return new RtEvent(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtEvent(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssues.get", "com.jcabi.github.RtIssue.<init>" ],
    "fullMethods" : [ "@Override\npublic Issue get(final int number) {\n    return new RtIssue(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtIssue(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleases.get", "com.jcabi.github.RtRelease.<init>" ],
    "fullMethods" : [ "@Override\npublic Release get(final int number) {\n    return new RtRelease(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n * @param nmbr\n * \t\tRelease id\n */\nRtRelease(final Request req, final Repo repo, final int nmbr) {\n    this.entry = req;\n    this.release = nmbr;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").path(String.valueOf(this.release)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleases.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtReleases(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = this.entry.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.getRec",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTrees.getRec", "com.jcabi.github.RtTree.<init>" ],
    "fullMethods" : [ "@Override\npublic Tree getRec(final String sha) {\n    return new RtTree(this.entry.uri().queryParam(\"recursive\", \"1\").back(), this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtTree(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/trees\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtForks.create", "com.jcabi.github.RtForks.get", "com.jcabi.github.RtFork.<init>" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}", "/**\n * Get fork by number.\n *\n * @param number\n * \t\tFork number\n * @return Fork\n */\nprivate RtFork get(final Integer number) {\n    return new RtFork(this.request, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtFork(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/forks\").path(Integer.toString(number)).back();\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtForks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtForks(final Request req, final Repo repo) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"forks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.languages",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.languages" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Iterable<Language> languages() throws IOException {\n    final RtJson json = new RtJson(this.request.uri().path(\"/languages\").back());\n    final JsonObject object = json.fetch();\n    final List<Language> languages = new ArrayList<>(object.size());\n    for (final Map.Entry<String, JsonValue> value : object.entrySet()) {\n        final String name = value.getKey();\n        languages.add(new RtLanguage(name, object.getJsonNumber(name).longValue()));\n    }\n    return languages;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.branches",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.branches", "com.jcabi.github.RtBranches.<init>" ],
    "fullMethods" : [ "@Override\npublic Branches branches() {\n    return new RtBranches(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtBranches(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/branches\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.labels", "com.jcabi.github.RtLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic Labels labels() {\n    return new RtLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepo we're in\n */\nRtLabels(final Request req, final Repo repo) {\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.assets",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRelease.assets", "com.jcabi.github.RtReleaseAssets.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAssets assets() {\n    return new RtReleaseAssets(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param release\n * \t\tIssue\n */\nRtReleaseAssets(final Request req, final Release release) {\n    this.entry = req;\n    final Coordinates coords = release.repo().coordinates();\n    // @checkstyle MultipleStringLiteralsCheck (7 lines)\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(Integer.toString(release.number())).path(\"/assets\").back();\n    this.owner = release;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtContents(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/contents\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestones.get", "com.jcabi.github.RtMilestone.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestone get(final int number) {\n    return new RtMilestone(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtMilestone(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCommits.get", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit get(final String sha) {\n    return new RtCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.commits", "com.jcabi.github.RtRepoCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommits commits() {\n    return new RtRepoCommits(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtRepoCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final RequestURI rep = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo());\n    this.request = rep.path(\"/commits\").back();\n    this.comp = rep.path(\"/compare\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtHooks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtHooks(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.comments", "com.jcabi.github.RtGistComments.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComments comments() {\n    return new RtGistComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param gist\n * \t\tGist\n */\nRtGistComments(final Request req, final Gist gist) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/gists\").path(gist.identifier()).path(\"/comments\").back();\n    this.owner = gist;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.search",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.search", "com.jcabi.github.RtSearch.<init>" ],
    "fullMethods" : [ "@Override\npublic Search search() {\n    return new RtSearch(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRESTful API entry point\n */\nRtSearch(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"/search\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.repos",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.repos", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> repos(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"repositories\", keywords, sort, order.identifier(), object -> this.github().repos().get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.comments", "com.jcabi.github.RtPullComments.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComments comments() {\n    return new RtPullComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param pull\n * \t\tPull\n */\nRtPullComments(final Request req, final Pull pull) {\n    this.entry = req;\n    this.owner = pull;\n    this.request = // @checkstyle MultipleStringLiterals (8 lines)\n    this.entry.uri().path(\"/repos\").path(pull.repo().coordinates().user()).path(pull.repo().coordinates().repo()).path(\"/pulls\").path(Integer.toString(pull.number())).path(\"/comments\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final int number, final Map<String, String> params) {\n    final Request newreq = this.entry.uri().path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/pulls\").path(String.valueOf(number)).path(\"/comments\").back();\n    return new RtPagination<>(newreq.uri().queryParams(params).back(), value -> this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchURI.path",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchURI.path" ],
    "fullMethods" : [ "@Override\npublic RequestURI path(final String segment) {\n    return new SearchURI(this.address.path(segment));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.request.uri().path(\"notifications\").back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.collaborators",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.collaborators", "com.jcabi.github.RtCollaborators.<init>" ],
    "fullMethods" : [ "@Override\npublic Collaborators collaborators() {\n    return new RtCollaborators(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtCollaborators(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/collaborators\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtBlobs.get", "com.jcabi.github.RtBlob.<init>" ],
    "fullMethods" : [ "@Override\npublic Blob get(final String sha) {\n    return new RtBlob(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param sha\n * \t\tNumber of the get\n */\nRtBlob(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").path(sha).back();\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.users",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.users", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> users(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"users\", keywords, sort, order.identifier(), object -> this.ghub.users().get(object.getString(\"login\")));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicMembers.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param organ\n * \t\tOrganization\n */\npublic RtPublicMembers(final Request req, final Organization organ) {\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(organ.login()).path(\"public_members\").back();\n    this.organization = organ;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTrees.get", "com.jcabi.github.RtTree.<init>" ],
    "fullMethods" : [ "@Override\npublic Tree get(final String sha) {\n    return new RtTree(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtTree(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/trees\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.labels", "com.jcabi.github.RtIssueLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueLabels labels() {\n    return new RtIssueLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue we're in\n */\nRtIssueLabels(final Request req, final Issue issue) {\n    this.owner = issue;\n    final Coordinates coords = issue.repo().coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUsers.get", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User get(final String login) {\n    return new RtUser(this.ghub, this.entry, login);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.comments", "com.jcabi.github.RtComments.<init>" ],
    "fullMethods" : [ "@Override\npublic Comments comments() {\n    return new RtComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue\n */\nRtComments(final Request req, final Issue issue) {\n    this.entry = req;\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/comments\").back();\n    this.owner = issue;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stars",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepo.stars", "com.jcabi.github.RtStars.<init>" ],
    "fullMethods" : [ "@Override\npublic Stars stars() {\n    return new RtStars(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtStars(final Request req, final Repo repo) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/user/starred\").path(coords.user()).path(coords.repo()).back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearch.issues", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (5 lines)\n@Override\npublic Iterable<Issue> issues(final String keywords, final String sort, final Order order, final EnumMap<Qualifier, String> qualifiers) {\n    final StringBuilder keyword = new StringBuilder(keywords);\n    for (final Map.Entry<Qualifier, String> entry : qualifiers.entrySet()) {\n        keyword.append('+').append(entry.getKey().identifier()).append(':').append(entry.getValue());\n    }\n    return new RtSearchPagination<>(this.request, \"issues\", keyword.toString(), sort, order.identifier(), object -> {\n        try {\n            final String[] parts = // @checkstyle MultipleStringLiteralsCheck (1 line)\n            RtSearch.SLASH.split(new URI(object.getString(\"url\")).getPath());\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).issues().get(object.getInt(\"number\"));\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.path",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtHooks.get", "com.jcabi.github.RtHook.<init>" ],
    "fullMethods" : [ "@Override\npublic Hook get(final int number) {\n    return new RtHook(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tId of the get\n */\nRtHook(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.status",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.status",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.status" ],
    "fullMethods" : [ "@Override\npublic int status() {\n    return this.response.status();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<clinit>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<clinit>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<clinit>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<clinit>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<clinit>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.\n *\n * @since 0.4\n */\npublic RtGithub() {\n    this(RtGithub.REQUEST);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.<clinit>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.prerelease",
    "thirdPartyMethod" : "javax.json.JsonValue.<clinit>",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.prerelease" ],
    "fullMethods" : [ "/**\n * Is it prerelease.\n *\n * @return Returns true if it's prerelease\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean prerelease() throws IOException {\n    return Boolean.parseBoolean(this.json().getOrDefault(\"prerelease\", JsonValue.FALSE).toString().replace(\"\\\"\", \"\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repo.Smart.isPrivate",
    "thirdPartyMethod" : "javax.json.JsonValue.<clinit>",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Repo.Smart.isPrivate" ],
    "fullMethods" : [ "/**\n * Is it private?.\n *\n * @return TRUE if it's private\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean isPrivate() throws IOException {\n    return Boolean.parseBoolean(this.json().getOrDefault(\"private\", JsonValue.FALSE).toString().replace(\"\\\"\", \"\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkEvent.json",
    "thirdPartyMethod" : "javax.json.JsonValue.<clinit>",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkEvent.json" ],
    "fullMethods" : [ "/**\n * Describes the event in a JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min When the event has a label, retrieve and include the\nlabel's color too. MkIssueEvents.create() will also need to be\nupdated accordingly.\n */\n@Override\npublic JsonObject json() throws IOException {\n    final JsonObject obj = new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n    JsonObjectBuilder builder = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(\"id\", this.num).add(\"url\", // @checkstyle LineLength (1 line)\n    String.format(\"https://api.jcabi-github.invalid/repos/%s/issues/events/%s\", this.coords, this.num)).add(\"commit_id\", JsonValue.NULL).add(MkEvent.EVENT, obj.getString(MkEvent.EVENT)).add(\"actor\", // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(MkEvent.LOGIN, obj.getString(MkEvent.LOGIN)).build()).add(MkEvent.CREATED_AT, obj.getString(MkEvent.CREATED_AT));\n    final String label = \"label\";\n    if (obj.containsKey(label)) {\n        builder = builder.add(label, Json.createObjectBuilder().add(\"name\", obj.getString(label)).build());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Statuses.StatusCreate.json",
    "thirdPartyMethod" : "com.google.common.base.Present.get",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Statuses.StatusCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"state\", this.state.identifier()).add(\"description\", this.description);\n    if (this.context.isPresent()) {\n        builder.add(\"context\", this.context.get());\n    }\n    if (this.targeturl.isPresent()) {\n        builder.add(\"target_url\", this.targeturl.get());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repos.RepoCreate.json",
    "thirdPartyMethod" : "com.google.common.base.Present.get",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Repos.RepoCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    JsonObjectBuilder builder = Json.createObjectBuilder().add(\"name\", this.nam).add(\"description\", this.descr).add(\"homepage\", this.home).add(\"private\", this.priv);\n    if (this.init.isPresent()) {\n        builder = builder.add(\"auto_init\", this.init.get());\n    }\n    for (final Map.Entry<String, JsonValue> entry : this.other.entrySet()) {\n        builder.add(entry.getKey(), entry.getValue());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueEvents.create",
    "thirdPartyMethod" : "com.google.common.base.Present.get",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.mock.MkIssueEvents.create" ],
    "fullMethods" : [ "/**\n * Creates a new issue event.\n * This has no equivalent in GitHub's public API, since GitHub generates\n * events automatically in response to some other API calls.\n *\n * @param type\n * \t\tType of event\n * @param issue\n * \t\tID number of issue the event is regarding\n * @param login\n * \t\tUsername of actor who caused the event\n * @param label\n * \t\tLabel added or removed\n * @return The newly created issue event\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min Make it possible to set the \"assignee\" field for\n\"assigned\"/\"unassigned\" events. Make it possible to set the\n\"milestone\" field for \"milestoned\"/\"demilestoned\" events. Make it\npossible to set the \"rename\" field for \"renamed\" events. Make it\npossible to set the \"commit_id\" field for events related to commits.\nSee https://developer.github.com/v3/issues/events/ for details.\n * @checkstyle ParameterNumberCheck (4 lines)\n */\npublic Event create(final String type, final int issue, final String login, final Optional<String> label) throws IOException {\n    final String created = new Github.Time().toString();\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue-event/number/text()\", this.xpath())).size();\n        Directives directives = new Directives().xpath(this.xpath()).add(\"issue-event\").add(\"issue\").set(Integer.toString(issue)).up().add(\"number\").set(Integer.toString(number)).up().add(\"event\").set(type).up().add(\"created_at\").set(created).up().add(\"login\").set(login).up();\n        if (label.isPresent()) {\n            directives = directives.add(\"label\").set(label.get()).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(MkEvent.class, \"issue event #%d of type %s created in %s for issue #%d by %s\", number, type, this.self, issue, login);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.headers",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.headers",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.headers" ],
    "fullMethods" : [ "@Override\npublic Map<String, List<String>> headers() {\n    return this.response.headers();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.CarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.headers",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.wire.CarefulWire.send", "com.jcabi.github.wire.CarefulWire.remainingHeader", "com.jcabi.github.wire.CarefulWire.headerOrNull" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    final Response resp = this.origin.send(req, home, method, headers, content, connect, read);\n    final int remaining = this.remainingHeader(resp);\n    if (remaining < this.threshold) {\n        final long reset = this.resetHeader(resp);\n        final long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n        if (reset > now) {\n            final long length = reset - now;\n            // @checkstyle LineLength (1 line)\n            Logger.info(this, \"Remaining number of requests per hour is less than %d. Waiting for %d seconds.\", this.threshold, length);\n            try {\n                TimeUnit.SECONDS.sleep(length);\n            } catch (final InterruptedException ex) {\n                Thread.currentThread().interrupt();\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return resp;\n}", "/**\n * Returns the value of the X-RateLimit-Remaining header.\n * If there is no such header, returns Integer.MAX_VALUE (no rate limit).\n *\n * @param resp\n * \t\tResponse to get header from\n * @return Number of requests remaining before the rate limit will be hit\n */\nprivate int remainingHeader(final Response resp) {\n    final String remainingstr = this.headerOrNull(resp, \"X-RateLimit-Remaining\");\n    int remaining = Integer.MAX_VALUE;\n    if (remainingstr != null) {\n        remaining = Integer.parseInt(remainingstr);\n    }\n    return remaining;\n}", "/**\n * Get the header with the given name from the response.\n * If there is no such header, returns null.\n *\n * @param resp\n * \t\tResponse to get header from\n * @param headername\n * \t\tName of header to get\n * @return The value of the first header with the given name, or null.\n */\nprivate String headerOrNull(final Response resp, final String headername) {\n    final List<String> values = resp.headers().get(headername);\n    String value = null;\n    if ((values != null) && (!values.isEmpty())) {\n        value = values.get(0);\n    }\n    return value;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Statuses.StatusCreate.json",
    "thirdPartyMethod" : "com.google.common.base.Absent.isPresent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Statuses.StatusCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"state\", this.state.identifier()).add(\"description\", this.description);\n    if (this.context.isPresent()) {\n        builder.add(\"context\", this.context.get());\n    }\n    if (this.targeturl.isPresent()) {\n        builder.add(\"target_url\", this.targeturl.get());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repos.RepoCreate.json",
    "thirdPartyMethod" : "com.google.common.base.Absent.isPresent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Repos.RepoCreate.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() {\n    JsonObjectBuilder builder = Json.createObjectBuilder().add(\"name\", this.nam).add(\"description\", this.descr).add(\"homepage\", this.home).add(\"private\", this.priv);\n    if (this.init.isPresent()) {\n        builder = builder.add(\"auto_init\", this.init.get());\n    }\n    for (final Map.Entry<String, JsonValue> entry : this.other.entrySet()) {\n        builder.add(entry.getKey(), entry.getValue());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueEvents.create",
    "thirdPartyMethod" : "com.google.common.base.Absent.isPresent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.mock.MkIssueEvents.create" ],
    "fullMethods" : [ "/**\n * Creates a new issue event.\n * This has no equivalent in GitHub's public API, since GitHub generates\n * events automatically in response to some other API calls.\n *\n * @param type\n * \t\tType of event\n * @param issue\n * \t\tID number of issue the event is regarding\n * @param login\n * \t\tUsername of actor who caused the event\n * @param label\n * \t\tLabel added or removed\n * @return The newly created issue event\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min Make it possible to set the \"assignee\" field for\n\"assigned\"/\"unassigned\" events. Make it possible to set the\n\"milestone\" field for \"milestoned\"/\"demilestoned\" events. Make it\npossible to set the \"rename\" field for \"renamed\" events. Make it\npossible to set the \"commit_id\" field for events related to commits.\nSee https://developer.github.com/v3/issues/events/ for details.\n * @checkstyle ParameterNumberCheck (4 lines)\n */\npublic Event create(final String type, final int issue, final String login, final Optional<String> label) throws IOException {\n    final String created = new Github.Time().toString();\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue-event/number/text()\", this.xpath())).size();\n        Directives directives = new Directives().xpath(this.xpath()).add(\"issue-event\").add(\"issue\").set(Integer.toString(issue)).up().add(\"number\").set(Integer.toString(number)).up().add(\"event\").set(type).up().add(\"created_at\").set(created).up().add(\"login\").set(login).up();\n        if (label.isPresent()) {\n            directives = directives.add(\"label\").set(label.get()).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(MkEvent.class, \"issue event #%d of type %s created in %s for issue #%d by %s\", number, type, this.self, issue, login);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repos.RepoCreate.withAutoInit",
    "thirdPartyMethod" : "com.google.common.base.Optional.of",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Repos.RepoCreate.withAutoInit" ],
    "fullMethods" : [ "/**\n * Returns a RepoCreate with the given auto-init enabledness.\n *\n * @param auto\n * \t\tAuto-init the new repo?\n * @return RepoCreate\n */\npublic RepoCreate withAutoInit(final boolean auto) {\n    return new RepoCreate(this.nam, this.priv, this.descr, this.home, Optional.of(auto), this.organization);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Event.Smart.label",
    "thirdPartyMethod" : "com.google.common.base.Optional.of",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Event.Smart.label" ],
    "fullMethods" : [ "/**\n * Label that was added or removed in this event (if any).\n *\n * @return Label that was added or removed\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 0.24\n */\npublic Optional<Label> label() throws IOException {\n    Optional<Label> lab = Optional.absent();\n    final JsonObject lbl = this.jsn.json().getJsonObject(\"label\");\n    if (lbl != null) {\n        lab = Optional.of(this.event.repo().labels().get(lbl.getString(\"name\")));\n    }\n    return lab;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueLabels.add",
    "thirdPartyMethod" : "com.google.common.base.Optional.of",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.mock.MkIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    final Collection<String> existing = this.labels();\n    final Set<String> added = new HashSet<>();\n    final Directives dirs = new Directives().xpath(this.xpath());\n    for (final String label : labels) {\n        dirs.add(\"label\").set(label).up();\n        if (!existing.contains(label)) {\n            added.add(label);\n        }\n    }\n    this.storage.apply(dirs);\n    if (!added.isEmpty()) {\n        final MkIssueEvents events = new MkIssueEvents(this.storage, this.self, this.repo);\n        for (final String label : added) {\n            events.create(Event.LABELED, this.ticket, this.self, Optional.of(label));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueLabels.remove",
    "thirdPartyMethod" : "com.google.common.base.Optional.of",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.mock.MkIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    if (this.labels().contains(name)) {\n        this.storage.apply(new Directives().xpath(String.format(\"%s/label[.='%s']\", this.xpath(), name)).remove());\n        new MkIssueEvents(this.storage, this.self, this.repo).create(Event.UNLABELED, this.ticket, this.self, Optional.of(name));\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.CommitsComparison.Smart.commits",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonArray",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.CommitsComparison.Smart.commits" ],
    "fullMethods" : [ "/**\n * Get commits.\n *\n * @return Commits\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Iterable<RepoCommit> commits() throws IOException {\n    final JsonArray array = this.comparison.json().getJsonArray(\"commits\");\n    final Collection<RepoCommit> commits = new ArrayList<>(array.size());\n    final RepoCommits repo = this.comparison.repo().commits();\n    for (final JsonValue value : array) {\n        commits.add(repo.get(JsonObject.class.cast(value).getString(\"sha\")));\n    }\n    return commits;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.body",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonArray",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.body" ],
    "fullMethods" : [ "@Override\npublic String body() {\n    return Json.createReader(new StringReader(this.response.body())).readObject().getJsonArray(\"items\").toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommitsComparison.files",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonArray",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtCommitsComparison.files" ],
    "fullMethods" : [ "@Override\npublic Iterable<FileChange> files() throws IOException {\n    return new FileChanges(this.json().getJsonArray(\"files\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonArray",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTrees.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonArray",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkTrees.create" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Tree create(final JsonObject params) throws IOException {\n    final JsonArray trees = params.getJsonArray(\"tree\");\n    for (final JsonValue val : trees) {\n        final JsonObject tree = ((JsonObject) (val));\n        final String sha = tree.getString(\"sha\");\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"tree\");\n        for (final Entry<String, JsonValue> entry : tree.entrySet()) {\n            dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n        }\n        this.storage.apply(dirs);\n        final String ref;\n        if (tree.containsValue(\"name\")) {\n            ref = tree.getString(\"name\");\n        } else {\n            ref = sha;\n        }\n        new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder(\"refs/trees/\").append(ref).toString(), sha);\n    }\n    return this.get(trees.getJsonObject(0).getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.through",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.through" ],
    "fullMethods" : [ "@Override\npublic <T extends Wire> Request through(final Class<T> type, final Object... args) {\n    return new SearchRequest(this.request.through(type, args));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.\n *\n * @since 0.4\n */\npublic RtGithub() {\n    this(RtGithub.REQUEST);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.VerboseReader.close",
    "thirdPartyPackage" : "com.jcabi.http.response.JsonResponse",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.commits", "com.jcabi.github.RtCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic Commits commits() {\n    return new RtCommits(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/commits\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.get", "com.jcabi.github.RtGistComment.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComment get(final int number) {\n    return new RtGistComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param gist\n * \t\tGist of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtGistComment(final Request req, final Gist gist, final int number) {\n    this.request = req.uri().path(\"/gists\").path(new Gist.Smart(gist).identifier()).path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = gist;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKey.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param user\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\npublic RtPublicKey(final Request req, final User user, final int number) {\n    this.request = req.uri().path(\"/user\").path(\"/keys\").path(Integer.toString(number)).back();\n    this.owner = user;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.assignees",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.assignees", "com.jcabi.github.RtAssignees.<init>" ],
    "fullMethods" : [ "@Override\npublic Assignees assignees() {\n    return new RtAssignees(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtAssignees(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/assignees\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.markdown",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.markdown", "com.jcabi.github.RtMarkdown.<init>" ],
    "fullMethods" : [ "@Override\npublic Markdown markdown() {\n    return new RtMarkdown(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtMarkdown(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"markdown\").back().method(Request.POST);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtValuePagination.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.entry.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.get", "com.jcabi.github.RtTag.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag get(final String sha) {\n    return new RtTag(this.entry, this.owner, sha);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe request.\n * @param repo\n * \t\tThe owner repo.\n * @param key\n * \t\tThe sha.\n */\nRtTag(final Request req, final Repo repo, final String key) {\n    this.sha = key;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").path(this.sha).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBranch.commit",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBranch.commit", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit commit() {\n    return new RtCommit(this.entry, this.owner, this.hash);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommit.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommit.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.keys",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.keys", "com.jcabi.github.RtDeployKeys.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKeys keys() {\n    return new RtDeployKeys(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\nRtDeployKeys(final Request req, final Repo repo) {\n    this.owner = repo;\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtIssue.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.get", "com.jcabi.github.RtGist.<init>" ],
    "fullMethods" : [ "@Override\npublic Gist get(final String name) {\n    return new RtGist(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param name\n * \t\tName of gist\n */\nRtGist(final Github github, final Request req, final String name) {\n    this.ghub = github;\n    this.entry = req;\n    this.gist = name;\n    this.request = req.uri().path(\"/gists\").path(name).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.milestones",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.milestones", "com.jcabi.github.RtMilestones.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestones milestones() {\n    return new RtMilestones(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtMilestones(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.get", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label get(final String name) {\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.<init>" ],
    "fullMethods" : [ "/**\n * Public CTOR.\n *\n * @param github\n * \t\tGithub\n */\npublic RtGitignores(final Github github) {\n    this.ghub = github;\n    this.request = github().entry().uri().path(\"/gitignore/templates\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.references",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.references", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic References references() {\n    return new RtReferences(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtNotifications.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtNotifications.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Notification> iterate() {\n    return new RtPagination<>(this.request.uri().queryParam(\"all\", \"true\").queryParam(\"since\", \"1970-01-01T00:00:00Z\").back(), json -> new RtNotification(Long.valueOf(json.getString(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.get", "com.jcabi.github.RtReference.<init>" ],
    "fullMethods" : [ "@Override\npublic Reference get(final String identifier) {\n    return new RtReference(this.entry, this.owner, identifier);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tOwner of this reference.\n * @param ref\n * \t\tThe name of the reference.\n */\nRtReference(final Request req, final Repo repo, final String ref) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(ref).back();\n    this.owner = repo;\n    this.name = ref;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.commits" ],
    "fullMethods" : [ "@Override\npublic Iterable<Commit> commits() {\n    return new RtPagination<>(this.request.uri().path(\"/commits\").back(), object -> new RtCommit(this.entry, this.owner, object.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKey.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.tags",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.tags", "com.jcabi.github.RtTags.<init>" ],
    "fullMethods" : [ "@Override\npublic Tags tags() {\n    return new RtTags(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtTags(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.get", "com.jcabi.github.RtComment.<init>" ],
    "fullMethods" : [ "@Override\npublic Comment get(final long number) {\n    return new RtComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param issue\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtComment(final Request req, final Issue issue, final long number) {\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/comments\").path(Long.toString(number)).back();\n    this.owner = issue;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.statuses",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.statuses", "com.jcabi.github.RtStatuses.<init>" ],
    "fullMethods" : [ "@Override\npublic Statuses statuses(final String ref) {\n    return new RtStatuses(this.entry, this.get(ref));\n}", "/**\n * Create a new status-aware object based on given commit.\n *\n * @param req\n * \t\tHttp request\n * @param commit\n * \t\tSpecific commit\n */\nRtStatuses(final Request req, final Commit commit) {\n    final Coordinates coords = commit.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/statuses\").path(commit.sha()).back();\n    this.cmmt = commit;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.compare",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.compare", "com.jcabi.github.RtCommitsComparison.<init>" ],
    "fullMethods" : [ "@Override\npublic CommitsComparison compare(final String base, final String head) {\n    return new RtCommitsComparison(this.entry, this.owner, base, head);\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n * @param base\n * \t\tSHA of a base commit\n * @param head\n * \t\tSHA of a head commit\n * @checkstyle ParameterNumber (3 lines)\n */\nRtCommitsComparison(final Request req, final Repo repo, final String base, final String head) {\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().toString()).path(\"/compare\").path(String.format(\"%s...%s\", base, head)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.emails",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.emails", "com.jcabi.github.RtUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    return new RtUserEmails(this.ghub.entry());\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n */\nRtUserEmails(final Request req) {\n    this.request = req.header(\"Accept\", \"application/vnd.github.v3\").uri().path(\"/user/emails\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtComment.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.users",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.users", "com.jcabi.github.RtUsers.<init>" ],
    "fullMethods" : [ "@Override\npublic Users users() {\n    return new RtUsers(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtUsers(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/users\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.gists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.gists", "com.jcabi.github.RtGists.<init>" ],
    "fullMethods" : [ "@Override\npublic Gists gists() {\n    return new RtGists(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtGists(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/gists\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommit.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommit.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.limits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.limits", "com.jcabi.github.RtLimits.<init>" ],
    "fullMethods" : [ "@Override\npublic Limits limits() {\n    return new RtLimits(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtLimits(final Github github, final Request req) {\n    this.entry = req.uri().path(\"rate_limit\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.get", "com.jcabi.github.RtRepo.<init>" ],
    "fullMethods" : [ "@Override\npublic Repo get(final Coordinates name) {\n    return new RtRepo(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param crd\n * \t\tCoordinate of the repo\n */\nRtRepo(final Github github, final Request req, final Coordinates crd) {\n    this.ghub = github;\n    this.entry = req;\n    this.coords = crd;\n    this.request = this.entry.uri().path(\"/repos\").path(this.coords.user()).path(this.coords.repo()).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.get", "com.jcabi.github.RtRepoCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommit get(final String sha) {\n    return new RtRepoCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtRepoCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stargazers",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.stargazers", "com.jcabi.github.RtStargazers.<init>" ],
    "fullMethods" : [ "@Override\npublic Stargazers stargazers() {\n    return new RtStargazers(this.request);\n}", "/**\n * Public ctor.\n *\n * @param entry\n * \t\tEntry request.\n */\nRtStargazers(final Request entry) {\n    this.request = entry.uri().path(\"stargazers\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.events",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.events" ],
    "fullMethods" : [ "@Override\npublic Iterable<Event> events() {\n    return new RtPagination<>(this.request.uri().path(\"/events\").back(), object -> new RtEvent(this.entry, this.owner, object.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.pulls",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.pulls", "com.jcabi.github.RtPulls.<init>" ],
    "fullMethods" : [ "@Override\npublic Pulls pulls() {\n    return new RtPulls(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtPulls(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.self",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.self", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User self() {\n    return new RtUser(this.ghub, this.entry, \"\");\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserOrganizations.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserOrganizations.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Organization> iterate() throws IOException {\n    final String login = this.owner.login();\n    return new RtPagination<>(this.entry.uri().path(\"/users\").path(login).path(\"/orgs\").back(), new OrganizationMapping(this.ghub.organizations()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.codes",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.codes", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> codes(final String keywords, final String sort, final Order order) {\n    return // @checkstyle AnonInnerLengthCheck (25 lines)\n    new RtSearchPagination<>(this.request, \"code\", keywords, sort, order.identifier(), object -> {\n        try {\n            // @checkstyle MultipleStringLiteralsCheck (1 line)\n            final URI uri = new URI(object.getString(\"url\"));\n            final String[] parts = RtSearch.SLASH.split(uri.getPath());\n            final String ref = RtSearch.QUERY.split(uri.getQuery())[1];\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).contents().get(object.getString(\"path\"), ref);\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        } catch (final IOException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.issues", "com.jcabi.github.RtIssues.<init>" ],
    "fullMethods" : [ "@Override\npublic Issues issues() {\n    return new RtIssues(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssues(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Issue> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reference> iterate(final String subnamespace) {\n    return new RtPagination<>(this.request.uri().path(subnamespace).back(), object -> this.get(object.getString(RtReferences.REF)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<RepoCommit> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> this.get(value.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.trees",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.trees", "com.jcabi.github.RtTrees.<init>" ],
    "fullMethods" : [ "@Override\npublic Trees trees() {\n    return new RtTrees(this.entry, this.repo());\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtTrees(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/trees\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtBlobs(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.get", "com.jcabi.github.RtPull.<init>" ],
    "fullMethods" : [ "@Override\npublic Pull get(final int number) {\n    return new RtPull(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtPull(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.organizations",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.organizations", "com.jcabi.github.RtOrganizations.<init>" ],
    "fullMethods" : [ "@Override\npublic Organizations organizations() {\n    return new RtOrganizations(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtOrganizations(final Github github, final Request req) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/user\").path(\"/orgs\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issueEvents",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.issueEvents", "com.jcabi.github.RtIssueEvents.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueEvents issueEvents() {\n    return new RtIssueEvents(this.entry, this);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssueEvents(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.files",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.files" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonObject> files() {\n    return new RtPagination<>(this.request.uri().path(\"/files\").back(), RtPagination.COPYING);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param user\n * \t\tUser\n */\npublic RtPublicKeys(final Request req, final User user) {\n    this.entry = req;\n    this.owner = user;\n    this.request = this.entry.uri().path(\"/user\").path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.get", "com.jcabi.github.RtDeployKey.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKey get(final int number) {\n    return new RtDeployKey(this.entry, number, this.owner);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param number\n * \t\tId\n * @param repo\n * \t\tRepository\n */\nRtDeployKey(final Request req, final int number, final Repo repo) {\n    this.key = number;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").path(String.valueOf(number)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.get", "com.jcabi.github.RtReleaseAsset.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset get(final int number) {\n    return new RtReleaseAsset(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful Request\n * @param release\n * \t\tRelease\n * @param number\n * \t\tNumber of the release asset.\n */\nRtReleaseAsset(final Request req, final Release release, final int number) {\n    final Coordinates coords = release.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(\"/assets\").path(Integer.toString(number)).back();\n    this.owner = release;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.github().entry().uri().path(RtUser.NOTIF_PATH).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtOrganization.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tOrganization login name\n */\npublic RtOrganization(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(login).back();\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.get", "com.jcabi.github.RtPullComment.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComment get(final int number) {\n    return new RtPullComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param pull\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtPullComment(final Request req, final Pull pull, final int number) {\n    final Coordinates coords = pull.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = pull;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Fork> iterate(final String sort) {\n    return new RtPagination<>(this.request.uri().queryParam(\"sort\", sort).back(), object -> this.get(object.getInt(ID)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueEvents.get", "com.jcabi.github.RtEvent.<init>" ],
    "fullMethods" : [ "@Override\npublic Event get(final int number) {\n    return new RtEvent(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtEvent(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.get", "com.jcabi.github.RtIssue.<init>" ],
    "fullMethods" : [ "@Override\npublic Issue get(final int number) {\n    return new RtIssue(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtIssue(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestone.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestone.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.uri",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.uri" ],
    "fullMethods" : [ "@Override\npublic RequestURI uri() {\n    return new SearchURI(this.request.uri());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.get", "com.jcabi.github.RtRelease.<init>" ],
    "fullMethods" : [ "@Override\npublic Release get(final int number) {\n    return new RtRelease(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n * @param nmbr\n * \t\tRelease id\n */\nRtRelease(final Request req, final Repo repo, final int nmbr) {\n    this.entry = req;\n    this.release = nmbr;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").path(String.valueOf(this.release)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueEvents.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.getRec",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.getRec" ],
    "fullMethods" : [ "@Override\npublic Tree getRec(final String sha) {\n    return new RtTree(this.entry.uri().queryParam(\"recursive\", \"1\").back(), this.owner, sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtReleases(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = this.entry.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create", "com.jcabi.github.RtForks.get", "com.jcabi.github.RtFork.<init>" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}", "/**\n * Get fork by number.\n *\n * @param number\n * \t\tFork number\n * @return Fork\n */\nprivate RtFork get(final Integer number) {\n    return new RtFork(this.request, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtFork(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/forks\").path(Integer.toString(number)).back();\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtForks(final Request req, final Repo repo) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"forks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTree.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTree.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.languages",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.languages" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Iterable<Language> languages() throws IOException {\n    final RtJson json = new RtJson(this.request.uri().path(\"/languages\").back());\n    final JsonObject object = json.fetch();\n    final List<Language> languages = new ArrayList<>(object.size());\n    for (final Map.Entry<String, JsonValue> value : object.entrySet()) {\n        final String name = value.getKey();\n        languages.add(new RtLanguage(name, object.getJsonNumber(name).longValue()));\n    }\n    return languages;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.branches",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.branches", "com.jcabi.github.RtBranches.<init>" ],
    "fullMethods" : [ "@Override\npublic Branches branches() {\n    return new RtBranches(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtBranches(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/branches\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.labels", "com.jcabi.github.RtLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic Labels labels() {\n    return new RtLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepo we're in\n */\nRtLabels(final Request req, final Repo repo) {\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.assets",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.assets", "com.jcabi.github.RtReleaseAssets.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAssets assets() {\n    return new RtReleaseAssets(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param release\n * \t\tIssue\n */\nRtReleaseAssets(final Request req, final Release release) {\n    this.entry = req;\n    final Coordinates coords = release.repo().coordinates();\n    // @checkstyle MultipleStringLiteralsCheck (7 lines)\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(Integer.toString(release.number())).path(\"/assets\").back();\n    this.owner = release;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.toString" ],
    "fullMethods" : [ "/**\n * Generate string representation.\n *\n * @return String representation\n */\n@Override\npublic final String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtContents(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/contents\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.get", "com.jcabi.github.RtMilestone.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestone get(final int number) {\n    return new RtMilestone(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtMilestone(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.get", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit get(final String sha) {\n    return new RtCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.commits", "com.jcabi.github.RtRepoCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommits commits() {\n    return new RtRepoCommits(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtRepoCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final RequestURI rep = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo());\n    this.request = rep.path(\"/commits\").back();\n    this.comp = rep.path(\"/compare\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Milestone> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtHooks(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> iterate(final String identifier) {\n    return new RtPagination<>(this.entry.uri().queryParam(\"since\", identifier).back(), object -> this.get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.comments", "com.jcabi.github.RtGistComments.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComments comments() {\n    return new RtGistComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param gist\n * \t\tGist\n */\nRtGistComments(final Request req, final Gist gist) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/gists\").path(gist.identifier()).path(\"/comments\").back();\n    this.owner = gist;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabel.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabel.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtOrganization.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.entry.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.search",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.search", "com.jcabi.github.RtSearch.<init>" ],
    "fullMethods" : [ "@Override\npublic Search search() {\n    return new RtSearch(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRESTful API entry point\n */\nRtSearch(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"/search\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.repos",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.repos", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> repos(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"repositories\", keywords, sort, order.identifier(), object -> this.github().repos().get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtEvent.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtEvent.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.comments", "com.jcabi.github.RtPullComments.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComments comments() {\n    return new RtPullComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param pull\n * \t\tPull\n */\nRtPullComments(final Request req, final Pull pull) {\n    this.entry = req;\n    this.owner = pull;\n    this.request = // @checkstyle MultipleStringLiterals (8 lines)\n    this.entry.uri().path(\"/repos\").path(pull.repo().coordinates().user()).path(pull.repo().coordinates().repo()).path(\"/pulls\").path(Integer.toString(pull.number())).path(\"/comments\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final int number, final Map<String, String> params) {\n    final Request newreq = this.entry.uri().path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/pulls\").path(String.valueOf(number)).path(\"/comments\").back();\n    return new RtPagination<>(newreq.uri().queryParams(params).back(), value -> this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> iterate(final String identifier) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", identifier).back(), object -> this.get(String.valueOf(object.getInt(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.request.uri().path(\"notifications\").back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.collaborators",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.collaborators", "com.jcabi.github.RtCollaborators.<init>" ],
    "fullMethods" : [ "@Override\npublic Collaborators collaborators() {\n    return new RtCollaborators(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtCollaborators(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/collaborators\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommitsComparison.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommitsComparison.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.get", "com.jcabi.github.RtBlob.<init>" ],
    "fullMethods" : [ "@Override\npublic Blob get(final String sha) {\n    return new RtBlob(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param sha\n * \t\tNumber of the get\n */\nRtBlob(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").path(sha).back();\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.users",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.users", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> users(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"users\", keywords, sort, order.identifier(), object -> this.ghub.users().get(object.getString(\"login\")));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param organ\n * \t\tOrganization\n */\npublic RtPublicMembers(final Request req, final Organization organ) {\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(organ.login()).path(\"public_members\").back();\n    this.organization = organ;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.get", "com.jcabi.github.RtTree.<init>" ],
    "fullMethods" : [ "@Override\npublic Tree get(final String sha) {\n    return new RtTree(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtTree(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/trees\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.labels", "com.jcabi.github.RtIssueLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueLabels labels() {\n    return new RtIssueLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue we're in\n */\nRtIssueLabels(final Request req, final Issue issue) {\n    this.owner = issue;\n    final Coordinates coords = issue.repo().coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Pull> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Comment> iterate(final Date since) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", new Github.Time(since)).back(), object -> this.get(object.getJsonNumber(\"id\").longValue()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.get", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User get(final String login) {\n    return new RtUser(this.ghub, this.entry, login);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> // @checkstyle MultipleStringLiterals (3 lines)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.comments", "com.jcabi.github.RtComments.<init>" ],
    "fullMethods" : [ "@Override\npublic Comments comments() {\n    return new RtComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue\n */\nRtComments(final Request req, final Issue issue) {\n    this.entry = req;\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/comments\").back();\n    this.owner = issue;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stars",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.stars", "com.jcabi.github.RtStars.<init>" ],
    "fullMethods" : [ "@Override\npublic Stars stars() {\n    return new RtStars(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtStars(final Request req, final Repo repo) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/user/starred\").path(coords.user()).path(coords.repo()).back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.issues", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (5 lines)\n@Override\npublic Iterable<Issue> issues(final String keywords, final String sort, final Order order, final EnumMap<Qualifier, String> qualifiers) {\n    final StringBuilder keyword = new StringBuilder(keywords);\n    for (final Map.Entry<Qualifier, String> entry : qualifiers.entrySet()) {\n        keyword.append('+').append(entry.getKey().identifier()).append(':').append(entry.getValue());\n    }\n    return new RtSearchPagination<>(this.request, \"issues\", keyword.toString(), sort, order.identifier(), object -> {\n        try {\n            final String[] parts = // @checkstyle MultipleStringLiteralsCheck (1 line)\n            RtSearch.SLASH.split(new URI(object.getString(\"url\")).getPath());\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).issues().get(object.getInt(\"number\"));\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<ReleaseAsset> iterate() {\n    return new RtPagination<>(this.request.uri().back().method(Request.GET), value -> // @checkstyle MultipleStringLiteralsCheck (1 line)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.get", "com.jcabi.github.RtHook.<init>" ],
    "fullMethods" : [ "@Override\npublic Hook get(final int number) {\n    return new RtHook(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tId of the get\n */\nRtHook(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.JsonPatch.patch",
    "thirdPartyMethod" : "javax.json.JsonValueImpl.toString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.JsonPatch.patch" ],
    "fullMethods" : [ "/**\n * Patch an XML object/element.\n *\n * @param xpath\n * \t\tXPath to locate the node to patch\n * @param obj\n * \t\tObject to apply\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void patch(final String xpath, final JsonObject obj) throws IOException {\n    final Directives dirs = new Directives().xpath(xpath);\n    for (final Map.Entry<String, JsonValue> entry : obj.entrySet()) {\n        dirs.addIf(entry.getKey()).set(StringUtils.strip(entry.getValue().toString(), \"\\\"\")).up();\n    }\n    this.storage.apply(dirs);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.prerelease",
    "thirdPartyMethod" : "javax.json.JsonValueImpl.toString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.prerelease" ],
    "fullMethods" : [ "/**\n * Is it prerelease.\n *\n * @return Returns true if it's prerelease\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean prerelease() throws IOException {\n    return Boolean.parseBoolean(this.json().getOrDefault(\"prerelease\", JsonValue.FALSE).toString().replace(\"\\\"\", \"\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repo.Smart.isPrivate",
    "thirdPartyMethod" : "javax.json.JsonValueImpl.toString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Repo.Smart.isPrivate" ],
    "fullMethods" : [ "/**\n * Is it private?.\n *\n * @return TRUE if it's private\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean isPrivate() throws IOException {\n    return Boolean.parseBoolean(this.json().getOrDefault(\"private\", JsonValue.FALSE).toString().replace(\"\\\"\", \"\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTags.create",
    "thirdPartyMethod" : "javax.json.JsonValueImpl.toString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Directives dirs = new Directives().xpath(this.xpath()).add(\"tag\");\n    for (final Entry<String, JsonValue> entry : params.entrySet()) {\n        dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n    }\n    this.storage.apply(dirs);\n    new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"name\")).toString(), params.getString(\"sha\"));\n    return this.get(params.getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTrees.create",
    "thirdPartyMethod" : "javax.json.JsonValueImpl.toString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkTrees.create" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Tree create(final JsonObject params) throws IOException {\n    final JsonArray trees = params.getJsonArray(\"tree\");\n    for (final JsonValue val : trees) {\n        final JsonObject tree = ((JsonObject) (val));\n        final String sha = tree.getString(\"sha\");\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"tree\");\n        for (final Entry<String, JsonValue> entry : tree.entrySet()) {\n            dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n        }\n        this.storage.apply(dirs);\n        final String ref;\n        if (tree.containsValue(\"name\")) {\n            ref = tree.getString(\"name\");\n        } else {\n            ref = sha;\n        }\n        new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder(\"refs/trees/\").append(ref).toString(), sha);\n    }\n    return this.get(trees.getJsonObject(0).getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatus.identifier",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtStatus.identifier" ],
    "fullMethods" : [ "@Override\npublic int identifier() {\n    return this.json().getInt(\"id\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.milestone",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.milestone" ],
    "fullMethods" : [ "/**\n * Get milestone for this issue.\n *\n * @return Milestone\n * @throws IOException\n * \t\tIf fails\n */\npublic Milestone milestone() throws IOException {\n    return this.repo().milestones().get(this.jsn.value(\"milestone\", JsonObject.class).getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getInt",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.body",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.body" ],
    "fullMethods" : [ "@Override\npublic String body() {\n    return Json.createReader(new StringReader(this.response.body())).readObject().getJsonArray(\"items\").toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.reason",
    "thirdPartyMethod" : "com.jcabi.http.response.AbstractResponse.reason",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.reason" ],
    "fullMethods" : [ "@Override\npublic String reason() {\n    return this.response.reason();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.through",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.through" ],
    "fullMethods" : [ "@Override\npublic <T extends Wire> Request through(final Class<T> type, final Object... args) {\n    return new SearchRequest(this.request.through(type, args));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.\n *\n * @since 0.4\n */\npublic RtGithub() {\n    this(RtGithub.REQUEST);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.through",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.markdown",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.markdown", "com.jcabi.github.RtMarkdown.<init>" ],
    "fullMethods" : [ "@Override\npublic Markdown markdown() {\n    return new RtMarkdown(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtMarkdown(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"markdown\").back().method(Request.POST);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.star",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.method",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.method" ],
    "fullMethods" : [ "@Override\npublic Request method(final String method) {\n    return new SearchRequest(this.request.method(method));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.clear",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.clear" ],
    "fullMethods" : [ "@Override\npublic void clear() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<ReleaseAsset> iterate() {\n    return new RtPagination<>(this.request.uri().back().method(Request.GET), value -> // @checkstyle MultipleStringLiteralsCheck (1 line)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.\n *\n * @since 0.4\n */\npublic RtGithub() {\n    this(RtGithub.REQUEST);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.header",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.header" ],
    "fullMethods" : [ "@Override\npublic Request header(final String name, final Object value) {\n    return new SearchRequest(this.request.header(name, value));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.emails",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.emails", "com.jcabi.github.RtUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    return new RtUserEmails(this.ghub.entry());\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n */\nRtUserEmails(final Request req) {\n    this.request = req.header(\"Accept\", \"application/vnd.github.v3\").uri().path(\"/user/emails\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Gist.Smart.files",
    "thirdPartyMethod" : "javax.json.JsonObject.size",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Gist.Smart.files" ],
    "fullMethods" : [ "/**\n * Get a list of all file names in the gist.\n *\n * @return File names\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Iterable<String> files() throws IOException {\n    final JsonObject array = this.gist.json().getJsonObject(\"files\");\n    final Collection<String> files = new ArrayList<>(array.size());\n    for (final JsonValue value : array.values()) {\n        files.add(JsonObject.class.cast(value).getString(\"filename\"));\n    }\n    return files;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.languages",
    "thirdPartyMethod" : "javax.json.JsonObject.size",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtRepo.languages" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Iterable<Language> languages() throws IOException {\n    final RtJson json = new RtJson(this.request.uri().path(\"/languages\").back());\n    final JsonObject object = json.fetch();\n    final List<Language> languages = new ArrayList<>(object.size());\n    for (final Map.Entry<String, JsonValue> value : object.entrySet()) {\n        final String name = value.getKey();\n        languages.add(new RtLanguage(name, object.getJsonNumber(name).longValue()));\n    }\n    return languages;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.back",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.back",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.back" ],
    "fullMethods" : [ "@Override\npublic Request back() {\n    return new SearchRequest(this.response.back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Label.Unmodified.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.build",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Label.Unmodified.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Label label) {\n    return new CompareToBuilder().append(this.repo().coordinates(), label.repo().coordinates()).append(this.obj, label.name()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContent.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.build",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.mock.MkContent.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Content cont) {\n    return new CompareToBuilder().append(this.path(), cont.path()).append(this.repo().coordinates(), cont.repo().coordinates()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepoCommit.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.build",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.mock.MkRepoCommit.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final RepoCommit other) {\n    return new CompareToBuilder().append(this.repo().coordinates(), other.repo().coordinates()).append(this.sha(), other.sha()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Coordinates.Simple.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.build",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Coordinates.Simple.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Coordinates other) {\n    return new CompareToBuilder().append(this.usr, other.user()).append(this.rpo, other.repo()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Coordinates.Https.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.build",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Coordinates.Https.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Coordinates other) {\n    return new CompareToBuilder().append(this.user(), other.user()).append(this.repo(), other.repo()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.body",
    "thirdPartyMethod" : "com.jcabi.http.response.JsonResponse.body",
    "thirdPartyPackage" : "com.jcabi.http.response",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.body" ],
    "fullMethods" : [ "@Override\npublic String body() {\n    return Json.createReader(new StringReader(this.response.body())).readObject().getJsonArray(\"items\").toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.JsonValue.ValueType.<clinit>",
    "thirdPartyPackage" : "javax.json.JsonValue",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.JsonValue.ValueType.<clinit>",
    "thirdPartyPackage" : "javax.json.JsonValue",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.SmartJson.hasNotNull",
    "thirdPartyMethod" : "javax.json.JsonValue.ValueType.<clinit>",
    "thirdPartyPackage" : "javax.json.JsonValue",
    "path" : [ "com.jcabi.github.SmartJson.hasNotNull" ],
    "fullMethods" : [ "/**\n * Checks if a certain key is present\n *  AND its ValueType isn't ValueType.NULL.\n *\n * @param name\n * \t\tName of the key which ValueType should be checked.\n * @return Returns <code>true</code> if key <code>name</code> is present\nand its ValueType isn't ValueType.NULL, <code>false</code> otherwise.\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean hasNotNull(final String name) throws IOException {\n    final JsonValue value = this.object.json().get(name);\n    return (value != null) && (!ValueType.NULL.equals(value.getValueType()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchURI.set",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchURI.set" ],
    "fullMethods" : [ "@Override\npublic RequestURI set(final URI uri) {\n    return new SearchURI(this.address.set(uri));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.set",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.\n *\n * @since 0.4\n */\npublic RtGithub() {\n    this(RtGithub.REQUEST);\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.header",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.header" ],
    "fullMethods" : [ "@Override\npublic Request header(final String name, final Object value) {\n    return new SearchRequest(this.request.header(name, value));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.emails",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.emails", "com.jcabi.github.RtUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    return new RtUserEmails(this.ghub.entry());\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n */\nRtUserEmails(final Request req) {\n    this.request = req.header(\"Accept\", \"application/vnd.github.v3\").uri().path(\"/user/emails\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>", "com.jcabi.github.RtGithub.<clinit>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}", "" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.header",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.markdown",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.markdown", "com.jcabi.github.RtMarkdown.<init>" ],
    "fullMethods" : [ "@Override\npublic Markdown markdown() {\n    return new RtMarkdown(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtMarkdown(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"markdown\").back().method(Request.POST);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.star",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.method",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.method" ],
    "fullMethods" : [ "@Override\npublic Request method(final String method) {\n    return new SearchRequest(this.request.method(method));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.clear",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.clear" ],
    "fullMethods" : [ "@Override\npublic void clear() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.method",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<ReleaseAsset> iterate() {\n    return new RtPagination<>(this.request.uri().back().method(Request.GET), value -> // @checkstyle MultipleStringLiteralsCheck (1 line)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.body",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.body" ],
    "fullMethods" : [ "@Override\npublic RequestBody body() {\n    return this.request.body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.commits", "com.jcabi.github.RtCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic Commits commits() {\n    return new RtCommits(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/commits\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.get", "com.jcabi.github.RtGistComment.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComment get(final int number) {\n    return new RtGistComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param gist\n * \t\tGist of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtGistComment(final Request req, final Gist gist, final int number) {\n    this.request = req.uri().path(\"/gists\").path(new Gist.Smart(gist).identifier()).path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = gist;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKey.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param user\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\npublic RtPublicKey(final Request req, final User user, final int number) {\n    this.request = req.uri().path(\"/user\").path(\"/keys\").path(Integer.toString(number)).back();\n    this.owner = user;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.assignees",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.assignees", "com.jcabi.github.RtAssignees.<init>" ],
    "fullMethods" : [ "@Override\npublic Assignees assignees() {\n    return new RtAssignees(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtAssignees(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/assignees\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.markdown",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.markdown", "com.jcabi.github.RtMarkdown.<init>" ],
    "fullMethods" : [ "@Override\npublic Markdown markdown() {\n    return new RtMarkdown(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtMarkdown(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"markdown\").back().method(Request.POST);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtValuePagination.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.entry.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.get", "com.jcabi.github.RtTag.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag get(final String sha) {\n    return new RtTag(this.entry, this.owner, sha);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe request.\n * @param repo\n * \t\tThe owner repo.\n * @param key\n * \t\tThe sha.\n */\nRtTag(final Request req, final Repo repo, final String key) {\n    this.sha = key;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").path(this.sha).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBranch.commit",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBranch.commit", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit commit() {\n    return new RtCommit(this.entry, this.owner, this.hash);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommit.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommit.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.keys",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.keys", "com.jcabi.github.RtDeployKeys.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKeys keys() {\n    return new RtDeployKeys(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\nRtDeployKeys(final Request req, final Repo repo) {\n    this.owner = repo;\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtIssue.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.get", "com.jcabi.github.RtGist.<init>" ],
    "fullMethods" : [ "@Override\npublic Gist get(final String name) {\n    return new RtGist(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param name\n * \t\tName of gist\n */\nRtGist(final Github github, final Request req, final String name) {\n    this.ghub = github;\n    this.entry = req;\n    this.gist = name;\n    this.request = req.uri().path(\"/gists\").path(name).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.milestones",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.milestones", "com.jcabi.github.RtMilestones.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestones milestones() {\n    return new RtMilestones(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtMilestones(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.get", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label get(final String name) {\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.<init>" ],
    "fullMethods" : [ "/**\n * Public CTOR.\n *\n * @param github\n * \t\tGithub\n */\npublic RtGitignores(final Github github) {\n    this.ghub = github;\n    this.request = github().entry().uri().path(\"/gitignore/templates\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.references",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.references", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic References references() {\n    return new RtReferences(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtNotifications.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtNotifications.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Notification> iterate() {\n    return new RtPagination<>(this.request.uri().queryParam(\"all\", \"true\").queryParam(\"since\", \"1970-01-01T00:00:00Z\").back(), json -> new RtNotification(Long.valueOf(json.getString(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.get", "com.jcabi.github.RtReference.<init>" ],
    "fullMethods" : [ "@Override\npublic Reference get(final String identifier) {\n    return new RtReference(this.entry, this.owner, identifier);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tOwner of this reference.\n * @param ref\n * \t\tThe name of the reference.\n */\nRtReference(final Request req, final Repo repo, final String ref) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(ref).back();\n    this.owner = repo;\n    this.name = ref;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.commits" ],
    "fullMethods" : [ "@Override\npublic Iterable<Commit> commits() {\n    return new RtPagination<>(this.request.uri().path(\"/commits\").back(), object -> new RtCommit(this.entry, this.owner, object.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKey.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKey.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.tags",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.tags", "com.jcabi.github.RtTags.<init>" ],
    "fullMethods" : [ "@Override\npublic Tags tags() {\n    return new RtTags(this.entry, this.owner);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tThe entry request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtTags(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/tags\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.get", "com.jcabi.github.RtComment.<init>" ],
    "fullMethods" : [ "@Override\npublic Comment get(final long number) {\n    return new RtComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param issue\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtComment(final Request req, final Issue issue, final long number) {\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/comments\").path(Long.toString(number)).back();\n    this.owner = issue;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.statuses",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.statuses", "com.jcabi.github.RtStatuses.<init>" ],
    "fullMethods" : [ "@Override\npublic Statuses statuses(final String ref) {\n    return new RtStatuses(this.entry, this.get(ref));\n}", "/**\n * Create a new status-aware object based on given commit.\n *\n * @param req\n * \t\tHttp request\n * @param commit\n * \t\tSpecific commit\n */\nRtStatuses(final Request req, final Commit commit) {\n    final Coordinates coords = commit.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/statuses\").path(commit.sha()).back();\n    this.cmmt = commit;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.compare",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.compare", "com.jcabi.github.RtCommitsComparison.<init>" ],
    "fullMethods" : [ "@Override\npublic CommitsComparison compare(final String base, final String head) {\n    return new RtCommitsComparison(this.entry, this.owner, base, head);\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n * @param base\n * \t\tSHA of a base commit\n * @param head\n * \t\tSHA of a head commit\n * @checkstyle ParameterNumber (3 lines)\n */\nRtCommitsComparison(final Request req, final Repo repo, final String base, final String head) {\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().toString()).path(\"/compare\").path(String.format(\"%s...%s\", base, head)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.emails",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.emails", "com.jcabi.github.RtUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    return new RtUserEmails(this.ghub.entry());\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n */\nRtUserEmails(final Request req) {\n    this.request = req.header(\"Accept\", \"application/vnd.github.v3\").uri().path(\"/user/emails\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.reactions",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.reactions" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reaction> reactions() {\n    return new RtPagination<>(this.request.uri().path(\"/reactions\").back(), object -> new Reaction.Simple(object.getString(RtComment.CONTENT)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.users",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.users", "com.jcabi.github.RtUsers.<init>" ],
    "fullMethods" : [ "@Override\npublic Users users() {\n    return new RtUsers(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtUsers(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/users\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create", "com.jcabi.github.RtLabel.<init>" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param name\n * \t\tName of it\n */\nRtLabel(final Request req, final Repo repo, final String name) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").path(name).back();\n    this.owner = repo;\n    this.txt = name;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.gists",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.gists", "com.jcabi.github.RtGists.<init>" ],
    "fullMethods" : [ "@Override\npublic Gists gists() {\n    return new RtGists(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtGists(final Github github, final Request req) {\n    this.entry = req;\n    this.ghub = github;\n    this.request = this.entry.uri().path(\"/gists\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommit.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommit.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.limits",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.limits", "com.jcabi.github.RtLimits.<init>" ],
    "fullMethods" : [ "@Override\npublic Limits limits() {\n    return new RtLimits(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtLimits(final Github github, final Request req) {\n    this.entry = req.uri().path(\"rate_limit\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.get", "com.jcabi.github.RtRepo.<init>" ],
    "fullMethods" : [ "@Override\npublic Repo get(final Coordinates name) {\n    return new RtRepo(this.ghub, this.entry, name);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param crd\n * \t\tCoordinate of the repo\n */\nRtRepo(final Github github, final Request req, final Coordinates crd) {\n    this.ghub = github;\n    this.entry = req;\n    this.coords = crd;\n    this.request = this.entry.uri().path(\"/repos\").path(this.coords.user()).path(this.coords.repo()).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.get", "com.jcabi.github.RtRepoCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommit get(final String sha) {\n    return new RtRepoCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtRepoCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stargazers",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.stargazers", "com.jcabi.github.RtStargazers.<init>" ],
    "fullMethods" : [ "@Override\npublic Stargazers stargazers() {\n    return new RtStargazers(this.request);\n}", "/**\n * Public ctor.\n *\n * @param entry\n * \t\tEntry request.\n */\nRtStargazers(final Request entry) {\n    this.request = entry.uri().path(\"stargazers\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.events",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.events" ],
    "fullMethods" : [ "@Override\npublic Iterable<Event> events() {\n    return new RtPagination<>(this.request.uri().path(\"/events\").back(), object -> new RtEvent(this.entry, this.owner, object.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.pulls",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.pulls", "com.jcabi.github.RtPulls.<init>" ],
    "fullMethods" : [ "@Override\npublic Pulls pulls() {\n    return new RtPulls(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtPulls(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.self",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.self", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User self() {\n    return new RtUser(this.ghub, this.entry, \"\");\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserOrganizations.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserOrganizations.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Organization> iterate() throws IOException {\n    final String login = this.owner.login();\n    return new RtPagination<>(this.entry.uri().path(\"/users\").path(login).path(\"/orgs\").back(), new OrganizationMapping(this.ghub.organizations()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.codes",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.codes", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> codes(final String keywords, final String sort, final Order order) {\n    return // @checkstyle AnonInnerLengthCheck (25 lines)\n    new RtSearchPagination<>(this.request, \"code\", keywords, sort, order.identifier(), object -> {\n        try {\n            // @checkstyle MultipleStringLiteralsCheck (1 line)\n            final URI uri = new URI(object.getString(\"url\"));\n            final String[] parts = RtSearch.SLASH.split(uri.getPath());\n            final String ref = RtSearch.QUERY.split(uri.getQuery())[1];\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).contents().get(object.getString(\"path\"), ref);\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        } catch (final IOException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.issues", "com.jcabi.github.RtIssues.<init>" ],
    "fullMethods" : [ "@Override\npublic Issues issues() {\n    return new RtIssues(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssues(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Issue> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String path, final String ref) {\n    return new RtPagination<>(this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back(), object -> new RtContent(this.entry, this.owner, object.getString(\"path\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Reference> iterate(final String subnamespace) {\n    return new RtPagination<>(this.request.uri().path(subnamespace).back(), object -> this.get(object.getString(RtReferences.REF)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<RepoCommit> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> this.get(value.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGit.trees",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGit.trees", "com.jcabi.github.RtTrees.<init>" ],
    "fullMethods" : [ "@Override\npublic Trees trees() {\n    return new RtTrees(this.entry, this.repo());\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtTrees(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/trees\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtBlobs(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for anonymous access to Github.<br><br>\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param domain\n * \t\tYour domain.\n */\npublic RtGithub(final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.get", "com.jcabi.github.RtPull.<init>" ],
    "fullMethods" : [ "@Override\npublic Pull get(final int number) {\n    return new RtPull(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtPull(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.organizations",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.organizations", "com.jcabi.github.RtOrganizations.<init>" ],
    "fullMethods" : [ "@Override\npublic Organizations organizations() {\n    return new RtOrganizations(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n */\nRtOrganizations(final Github github, final Request req) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/user\").path(\"/orgs\").back();\n    this.ghub = github;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.issueEvents",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.issueEvents", "com.jcabi.github.RtIssueEvents.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueEvents issueEvents() {\n    return new RtIssueEvents(this.entry, this);\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtIssueEvents(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.files",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.files" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonObject> files() {\n    return new RtPagination<>(this.request.uri().path(\"/files\").back(), RtPagination.COPYING);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param user\n * \t\tUser\n */\npublic RtPublicKeys(final Request req, final User user) {\n    this.entry = req;\n    this.owner = user;\n    this.request = this.entry.uri().path(\"/user\").path(\"/keys\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.get", "com.jcabi.github.RtDeployKey.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKey get(final int number) {\n    return new RtDeployKey(this.entry, number, this.owner);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param number\n * \t\tId\n * @param repo\n * \t\tRepository\n */\nRtDeployKey(final Request req, final int number, final Repo repo) {\n    this.key = number;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/keys\").path(String.valueOf(number)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.get", "com.jcabi.github.RtReleaseAsset.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset get(final int number) {\n    return new RtReleaseAsset(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful Request\n * @param release\n * \t\tRelease\n * @param number\n * \t\tNumber of the release asset.\n */\nRtReleaseAsset(final Request req, final Release release, final int number) {\n    final Coordinates coords = release.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(\"/assets\").path(Integer.toString(number)).back();\n    this.owner = release;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create", "com.jcabi.github.RtReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}", "/**\n * Public constructor.\n *\n * @param req\n * \t\tRESTful request.\n * @param repo\n * \t\tThe owner repo.\n */\nRtReferences(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/git\").path(\"/refs\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.github().entry().uri().path(RtUser.NOTIF_PATH).back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtOrganization.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tOrganization login name\n */\npublic RtOrganization(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(login).back();\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.get", "com.jcabi.github.RtPullComment.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComment get(final int number) {\n    return new RtPullComment(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param pull\n * \t\tOwner of this comment\n * @param number\n * \t\tNumber of the get\n */\nRtPullComment(final Request req, final Pull pull, final int number) {\n    final Coordinates coords = pull.repo().coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/pulls\").path(\"/comments\").path(Integer.toString(number)).back();\n    this.owner = pull;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Fork> iterate(final String sort) {\n    return new RtPagination<>(this.request.uri().queryParam(\"sort\", sort).back(), object -> this.get(object.getInt(ID)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueEvents.get", "com.jcabi.github.RtEvent.<init>" ],
    "fullMethods" : [ "@Override\npublic Event get(final int number) {\n    return new RtEvent(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtEvent(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(\"/events\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.get", "com.jcabi.github.RtIssue.<init>" ],
    "fullMethods" : [ "@Override\npublic Issue get(final int number) {\n    return new RtIssue(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtIssue(final Request req, final Repo repo, final int number) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestone.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestone.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.uri",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.uri" ],
    "fullMethods" : [ "@Override\npublic RequestURI uri() {\n    return new SearchURI(this.request.uri());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.get", "com.jcabi.github.RtRelease.<init>" ],
    "fullMethods" : [ "@Override\npublic Release get(final int number) {\n    return new RtRelease(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n * @param nmbr\n * \t\tRelease id\n */\nRtRelease(final Request req, final Repo repo, final int nmbr) {\n    this.entry = req;\n    this.release = nmbr;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").path(String.valueOf(this.release)).back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueEvents.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueEvents.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.getRec",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.getRec" ],
    "fullMethods" : [ "@Override\npublic Tree getRec(final String sha) {\n    return new RtTree(this.entry.uri().queryParam(\"recursive\", \"1\").back(), this.owner, sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtReleases(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = this.entry.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/releases\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create", "com.jcabi.github.RtForks.get", "com.jcabi.github.RtFork.<init>" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}", "/**\n * Get fork by number.\n *\n * @param number\n * \t\tFork number\n * @return Fork\n */\nprivate RtFork get(final Integer number) {\n    return new RtFork(this.request, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtFork(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/forks\").path(Integer.toString(number)).back();\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtForks(final Request req, final Repo repo) {\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"forks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTree.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTree.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.languages",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.languages" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Iterable<Language> languages() throws IOException {\n    final RtJson json = new RtJson(this.request.uri().path(\"/languages\").back());\n    final JsonObject object = json.fetch();\n    final List<Language> languages = new ArrayList<>(object.size());\n    for (final Map.Entry<String, JsonValue> value : object.entrySet()) {\n        final String name = value.getKey();\n        languages.add(new RtLanguage(name, object.getJsonNumber(name).longValue()));\n    }\n    return languages;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.branches",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.branches", "com.jcabi.github.RtBranches.<init>" ],
    "fullMethods" : [ "@Override\npublic Branches branches() {\n    return new RtBranches(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtBranches(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/branches\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.labels", "com.jcabi.github.RtLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic Labels labels() {\n    return new RtLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepo we're in\n */\nRtLabels(final Request req, final Repo repo) {\n    this.owner = repo;\n    final Coordinates coords = repo.coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.assets",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.assets", "com.jcabi.github.RtReleaseAssets.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAssets assets() {\n    return new RtReleaseAssets(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param release\n * \t\tIssue\n */\nRtReleaseAssets(final Request req, final Release release) {\n    this.entry = req;\n    final Coordinates coords = release.repo().coordinates();\n    // @checkstyle MultipleStringLiteralsCheck (7 lines)\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/releases\").path(Integer.toString(release.number())).path(\"/assets\").back();\n    this.owner = release;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.toString" ],
    "fullMethods" : [ "/**\n * Generate string representation.\n *\n * @return String representation\n */\n@Override\npublic final String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComment.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComment.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param repo\n * \t\tRepository\n */\npublic RtContents(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    this.request = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo()).path(\"/contents\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.get", "com.jcabi.github.RtMilestone.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestone get(final int number) {\n    return new RtMilestone(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tNumber of the get\n */\nRtMilestone(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/milestones\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.get", "com.jcabi.github.RtCommit.<init>" ],
    "fullMethods" : [ "@Override\npublic Commit get(final String sha) {\n    return new RtCommit(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this comment\n * @param sha\n * \t\tNumber of the get\n */\nRtCommit(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/commits\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.commits",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.commits", "com.jcabi.github.RtRepoCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommits commits() {\n    return new RtRepoCommits(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tEntry point of API\n * @param repo\n * \t\tRepository\n */\nRtRepoCommits(final Request req, final Repo repo) {\n    this.entry = req;\n    this.owner = repo;\n    final RequestURI rep = req.uri().path(\"/repos\").path(repo.coordinates().user()).path(repo.coordinates().repo());\n    this.request = rep.path(\"/commits\").back();\n    this.comp = rep.path(\"/compare\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Milestone> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\npublic RtHooks(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> iterate(final String identifier) {\n    return new RtPagination<>(this.entry.uri().queryParam(\"since\", identifier).back(), object -> this.get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.comments", "com.jcabi.github.RtGistComments.<init>" ],
    "fullMethods" : [ "@Override\npublic GistComments comments() {\n    return new RtGistComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param gist\n * \t\tGist\n */\nRtGistComments(final Request req, final Gist gist) {\n    this.entry = req;\n    this.request = this.entry.uri().path(\"/gists\").path(gist.identifier()).path(\"/comments\").back();\n    this.owner = gist;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabel.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabel.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtOrganization.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtOrganization.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.entry.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.search",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.search", "com.jcabi.github.RtSearch.<init>" ],
    "fullMethods" : [ "@Override\npublic Search search() {\n    return new RtSearch(this, this.request);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRESTful API entry point\n */\nRtSearch(final Github github, final Request req) {\n    this.ghub = github;\n    this.request = req.uri().path(\"/search\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.repos",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.repos", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Repo> repos(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"repositories\", keywords, sort, order.identifier(), object -> this.github().repos().get(new Coordinates.Simple(object.getString(\"full_name\"))));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtEvent.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtEvent.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.comments", "com.jcabi.github.RtPullComments.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComments comments() {\n    return new RtPullComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param pull\n * \t\tPull\n */\nRtPullComments(final Request req, final Pull pull) {\n    this.entry = req;\n    this.owner = pull;\n    this.request = // @checkstyle MultipleStringLiterals (8 lines)\n    this.entry.uri().path(\"/repos\").path(pull.repo().coordinates().user()).path(pull.repo().coordinates().repo()).path(\"/pulls\").path(Integer.toString(pull.number())).path(\"/comments\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final int number, final Map<String, String> params) {\n    final Request newreq = this.entry.uri().path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/pulls\").path(String.valueOf(number)).path(\"/comments\").back();\n    return new RtPagination<>(newreq.uri().queryParams(params).back(), value -> this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> iterate(final String identifier) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", identifier).back(), object -> this.get(String.valueOf(object.getInt(\"id\"))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.notifications",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.notifications" ],
    "fullMethods" : [ "@Override\npublic Notifications notifications() {\n    return new RtNotifications(this.request.uri().path(\"notifications\").back());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.collaborators",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.collaborators", "com.jcabi.github.RtCollaborators.<init>" ],
    "fullMethods" : [ "@Override\npublic Collaborators collaborators() {\n    return new RtCollaborators(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param repo\n * \t\tRepo\n * @param req\n * \t\tRequest\n */\nRtCollaborators(final Request req, final Repo repo) {\n    this.entry = req;\n    final Coordinates coords = repo.coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/collaborators\").back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommitsComparison.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommitsComparison.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.get", "com.jcabi.github.RtBlob.<init>" ],
    "fullMethods" : [ "@Override\npublic Blob get(final String sha) {\n    return new RtBlob(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param sha\n * \t\tNumber of the get\n */\nRtBlob(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/blobs\").path(sha).back();\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.users",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.users", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<User> users(final String keywords, final String sort, final Order order) {\n    return new RtSearchPagination<>(this.request, \"users\", keywords, sort, order.identifier(), object -> this.ghub.users().get(object.getString(\"login\")));\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.toString",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    return this.request.uri().get().toString();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.<init>",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param organ\n * \t\tOrganization\n */\npublic RtPublicMembers(final Request req, final Organization organ) {\n    this.entry = req;\n    this.request = req.uri().path(\"/orgs\").path(organ.login()).path(\"public_members\").back();\n    this.organization = organ;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.get", "com.jcabi.github.RtTree.<init>" ],
    "fullMethods" : [ "@Override\npublic Tree get(final String sha) {\n    return new RtTree(this.entry, this.owner, sha);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRESTful request\n * @param repo\n * \t\tOwner of this commit\n * @param sha\n * \t\tNumber of the get\n */\nRtTree(final Request req, final Repo repo, final String sha) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/git\").path(\"/trees\").path(sha).back();\n    this.owner = repo;\n    this.hash = sha;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.labels",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.labels", "com.jcabi.github.RtIssueLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueLabels labels() {\n    return new RtIssueLabels(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue we're in\n */\nRtIssueLabels(final Request req, final Issue issue) {\n    this.owner = issue;\n    final Coordinates coords = issue.repo().coordinates();\n    this.entry = req;\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/labels\").back();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Pull> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Comment> iterate(final Date since) {\n    return new RtPagination<>(this.request.uri().queryParam(\"since\", new Github.Time(since)).back(), object -> this.get(object.getJsonNumber(\"id\").longValue()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUsers.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUsers.get", "com.jcabi.github.RtUser.<init>" ],
    "fullMethods" : [ "@Override\npublic User get(final String login) {\n    return new RtUser(this.ghub, this.entry, login);\n}", "/**\n * Public ctor.\n *\n * @param github\n * \t\tGithub\n * @param req\n * \t\tRequest\n * @param login\n * \t\tUser identity/identity\n */\nRtUser(final Github github, final Request req, final String login) {\n    this.ghub = github;\n    if (login.isEmpty()) {\n        this.request = req.uri().path(\"/user\").back();\n    } else {\n        this.request = req.uri().path(\"/users\").path(login).back();\n    }\n    this.self = login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> // @checkstyle MultipleStringLiterals (3 lines)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.comments",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.comments", "com.jcabi.github.RtComments.<init>" ],
    "fullMethods" : [ "@Override\npublic Comments comments() {\n    return new RtComments(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param issue\n * \t\tIssue\n */\nRtComments(final Request req, final Issue issue) {\n    this.entry = req;\n    final Coordinates coords = issue.repo().coordinates();\n    this.request = this.entry.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/issues\").path(Integer.toString(issue.number())).path(\"/comments\").back();\n    this.owner = issue;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.stars",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepo.stars", "com.jcabi.github.RtStars.<init>" ],
    "fullMethods" : [ "@Override\npublic Stars stars() {\n    return new RtStars(this.entry, this);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n */\nRtStars(final Request req, final Repo repo) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/user/starred\").path(coords.user()).path(coords.repo()).back();\n    this.owner = repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearch.issues",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearch.issues", "com.jcabi.github.RtSearchPagination.<init>" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (5 lines)\n@Override\npublic Iterable<Issue> issues(final String keywords, final String sort, final Order order, final EnumMap<Qualifier, String> qualifiers) {\n    final StringBuilder keyword = new StringBuilder(keywords);\n    for (final Map.Entry<Qualifier, String> entry : qualifiers.entrySet()) {\n        keyword.append('+').append(entry.getKey().identifier()).append(':').append(entry.getValue());\n    }\n    return new RtSearchPagination<>(this.request, \"issues\", keyword.toString(), sort, order.identifier(), object -> {\n        try {\n            final String[] parts = // @checkstyle MultipleStringLiteralsCheck (1 line)\n            RtSearch.SLASH.split(new URI(object.getString(\"url\")).getPath());\n            return // @checkstyle MagicNumber (1 line)\n            this.ghub.repos().get(new Coordinates.Simple(parts[2], parts[3])).issues().get(object.getInt(\"number\"));\n        } catch (final URISyntaxException ex) {\n            throw new IllegalStateException(ex);\n        }\n    });\n}", "/**\n * Ctor.\n *\n * @param req\n * \t\tRESTful API entry point\n * @param path\n * \t\tSearch path\n * @param keywords\n * \t\tSearch keywords\n * @param sort\n * \t\tSort field\n * @param order\n * \t\tSort order\n * @param mppng\n * \t\tPagination mapping\n * @checkstyle ParameterNumber (4 lines)\n */\nRtSearchPagination(final Request req, final String path, final String keywords, final String sort, final String order, final RtValuePagination.Mapping<T, JsonObject> mppng) {\n    this.request = req.uri().path(path).queryParam(\"q\", keywords).queryParam(\"sort\", sort).queryParam(\"order\", order).back();\n    this.mapping = mppng;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<ReleaseAsset> iterate() {\n    return new RtPagination<>(this.request.uri().back().method(Request.GET), value -> // @checkstyle MultipleStringLiteralsCheck (1 line)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.get",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.uri",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.get", "com.jcabi.github.RtHook.<init>" ],
    "fullMethods" : [ "@Override\npublic Hook get(final int number) {\n    return new RtHook(this.entry, this.owner, number);\n}", "/**\n * Public ctor.\n *\n * @param req\n * \t\tRequest\n * @param repo\n * \t\tRepository\n * @param number\n * \t\tId of the get\n */\nRtHook(final Request req, final Repo repo, final int number) {\n    final Coordinates coords = repo.coordinates();\n    this.request = req.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/hooks\").path(Integer.toString(number)).back();\n    this.owner = repo;\n    this.num = number;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "javax.xml.bind.DatatypeConverter.printBase64Binary",
    "thirdPartyPackage" : "javax.xml.bind",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * @param user\n * \t\tUser name\n * @param pwd\n * \t\tPassword\n * @since 0.4\n */\npublic RtGithub(final String user, final String pwd) {\n    this(RtGithub.REQUEST.header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAssets.upload",
    "thirdPartyMethod" : "javax.xml.bind.DatatypeConverter.printBase64Binary",
    "thirdPartyPackage" : "javax.xml.bind",
    "path" : [ "com.jcabi.github.mock.MkReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/asset/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"asset\").add(\"id\").set(Integer.toString(number)).up().add(\"name\").set(name).up().add(\"content\").set(DatatypeConverter.printBase64Binary(content)).up().add(\"content_type\").set(type).up().add(\"size\").set(Integer.toString(content.length)).up().add(\"download_count\").set(\"42\").up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"updated_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up());\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.<init>",
    "thirdPartyMethod" : "javax.xml.bind.DatatypeConverter.printBase64Binary",
    "thirdPartyPackage" : "javax.xml.bind",
    "path" : [ "com.jcabi.github.RtGithub.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor, for HTTP Basic Authentication.\n *\n * Use this ctor when you want to access Github's API over a\n * custom domain, other than https//api.github.com.<br><br>\n *\n * For instance, if you have your own instance of Github deployed\n * somewhere.\n *\n * <pre>\n *     final Github myGithub = new RtGithub(\n *         \"john_doe\", \"johnspassword\",\n *         URI.create(\"https://github.mydomain.com\")\n *     );\n * </pre>\n *\n * @param user\n * \t\tUser's username.\n * @param pwd\n * \t\tUser's password.\n * @param domain\n * \t\tYour custom domain.\n */\npublic RtGithub(final String user, final String pwd, final URI domain) {\n    this(RtGithub.REQUEST.uri().set(domain).back().header(HttpHeaders.AUTHORIZATION, String.format(\"Basic %s\", DatatypeConverter.printBase64Binary(String.format(\"%s:%s\", user, pwd).getBytes(StandardCharsets.UTF_8)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.FormEncodedBody.get",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtNotifications.markAsRead",
    "thirdPartyMethod" : "org.apache.commons.lang3.NotImplementedException.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.RtNotifications.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead() {\n    throw new NotImplementedException(\"RtNotifications#markAsRead\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCollaborators.addWithPermission",
    "thirdPartyMethod" : "org.apache.commons.lang3.NotImplementedException.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) {\n    throw new NotImplementedException(\"\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtNotifications.thread",
    "thirdPartyMethod" : "org.apache.commons.lang3.NotImplementedException.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.RtNotifications.thread" ],
    "fullMethods" : [ "@Override\npublic GitHubThread thread(final int number) {\n    throw new NotImplementedException(\"RtNotifications#thread\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkNotifications.thread",
    "thirdPartyMethod" : "org.apache.commons.lang3.NotImplementedException.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkNotifications.thread" ],
    "fullMethods" : [ "@Override\npublic GitHubThread thread(final int number) {\n    throw new NotImplementedException(\"MkNotifications#thread\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkNotifications.markAsRead",
    "thirdPartyMethod" : "org.apache.commons.lang3.NotImplementedException.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkNotifications.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead() {\n    throw new NotImplementedException(\"MkNotifications#markAsRead\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParams",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtIssues.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Issue> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParams",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtMilestones.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Milestone> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParams",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtRepoCommits.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<RepoCommit> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> this.get(value.getString(\"sha\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchURI.queryParams",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParams",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchURI.queryParams" ],
    "fullMethods" : [ "@Override\npublic RequestURI queryParams(final Map<String, String> map) {\n    return new SearchURI(this.address.queryParams(map));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParams",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final int number, final Map<String, String> params) {\n    final Request newreq = this.entry.uri().path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/pulls\").path(String.valueOf(number)).path(\"/comments\").back();\n    return new RtPagination<>(newreq.uri().queryParams(params).back(), value -> this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParams",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPullComments.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<PullComment> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), value -> // @checkstyle MultipleStringLiterals (3 lines)\n    this.get(value.getInt(\"id\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.BaseUri.queryParams",
    "thirdPartyPackage" : "com.jcabi.http.request.BaseRequest",
    "path" : [ "com.jcabi.github.RtPulls.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Pull> iterate(final Map<String, String> params) {\n    return new RtPagination<>(this.request.uri().queryParams(params).back(), object -> this.get(object.getInt(\"number\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.body",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.body" ],
    "fullMethods" : [ "@Override\npublic RequestBody body() {\n    return this.request.body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.body",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RepoCommit.Smart.message",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RepoCommit.Smart.message" ],
    "fullMethods" : [ "/**\n * Get its message.\n *\n * @return Message of repo commit\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic String message() throws IOException {\n    return this.jsn.json().getJsonObject(\"commit\").getString(\"message\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Label.Unmodified.name",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Label.Unmodified.name" ],
    "fullMethods" : [ "@Override\npublic String name() {\n    return this.json().getString(\"name\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Milestone.Smart.creator",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Milestone.Smart.creator" ],
    "fullMethods" : [ "/**\n * Get its creator.\n *\n * @return Creator of milestone (who submitted it)\n * @throws java.io.IOException\n * \t\tIf there is any I/O problem\n */\npublic User creator() throws IOException {\n    return this.milestone.repo().github().users().get(this.jsn.value(\"creator\", JsonObject.class).getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Comment.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Comment.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Author of comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User author() throws IOException {\n    return this.comment.issue().repo().github().users().get(this.comment.json().getJsonObject(\"user\").getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.update",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.update" ],
    "fullMethods" : [ "/**\n * Updates a file.\n *\n * @param path\n * \t\tThe content path.\n * @param json\n * \t\tJSON object containing updates to the content.\n * @return Commit related to this update.\n * @throws IOException\n * \t\tIf any I/O problem occurs.\n */\n@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    this.storage.lock();\n    try {\n        final String ref = \"ref\";\n        final String branch;\n        if (json.containsKey(ref)) {\n            branch = json.getString(ref);\n        } else {\n            branch = \"master\";\n        }\n        final String xpath = // @checkstyle LineLengthCheck (1 line)\n        String.format(\"/github/repos/repo[@coords='%s']/contents/content[path='%s' and @ref='%s']\", this.coords, path, branch);\n        new JsonPatch(this.storage).patch(xpath, json);\n        return this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PullRef.Smart.user",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PullRef.Smart.user" ],
    "fullMethods" : [ "/**\n * Gets the user who owns the repository which its commit is in.\n *\n * @return User\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User user() throws IOException {\n    return this.pullref.repo().github().users().get(this.jsn.value(\"user\", JsonObject.class).getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Commit.Smart.message",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Commit.Smart.message" ],
    "fullMethods" : [ "/**\n * Get its message.\n *\n * @return Message of commit\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic String message() throws IOException {\n    return this.jsn.json().getJsonObject(\"commit\").getString(\"message\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkEvent.json",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkEvent.json" ],
    "fullMethods" : [ "/**\n * Describes the event in a JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min When the event has a label, retrieve and include the\nlabel's color too. MkIssueEvents.create() will also need to be\nupdated accordingly.\n */\n@Override\npublic JsonObject json() throws IOException {\n    final JsonObject obj = new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n    JsonObjectBuilder builder = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(\"id\", this.num).add(\"url\", // @checkstyle LineLength (1 line)\n    String.format(\"https://api.jcabi-github.invalid/repos/%s/issues/events/%s\", this.coords, this.num)).add(\"commit_id\", JsonValue.NULL).add(MkEvent.EVENT, obj.getString(MkEvent.EVENT)).add(\"actor\", // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(MkEvent.LOGIN, obj.getString(MkEvent.LOGIN)).build()).add(MkEvent.CREATED_AT, obj.getString(MkEvent.CREATED_AT));\n    final String label = \"label\";\n    if (obj.containsKey(label)) {\n        builder = builder.add(label, Json.createObjectBuilder().add(\"name\", obj.getString(label)).build());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullRef.sha",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPullRef.sha" ],
    "fullMethods" : [ "@Override\npublic String sha() {\n    return this.jsn.getString(\"sha\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject json) throws IOException {\n    this.storage.lock();\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (json.containsKey(\"ref\")) {\n            branch = json.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"content\").attr(\"ref\", branch).add(\"name\").set(json.getString(\"path\")).up().add(\"path\").set(json.getString(\"path\")).up().add(\"content\").set(json.getString(\"content\")).up().add(\"type\").set(\"file\").up().add(\"encoding\").set(\"base64\").up().add(\"sha\").set(fakeSha()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"git_url\").set(\"http://localhost/2\").up().add(\"html_url\").set(\"http://localhost/3\").up());\n        this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n    return new MkContent(this.storage, this.self, this.coords, json.getString(\"path\"), branch);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullRef.ref",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPullRef.ref" ],
    "fullMethods" : [ "@Override\npublic String ref() {\n    return this.jsn.getString(\"ref\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Event.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Event.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Author of comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User author() throws IOException {\n    return this.event.repo().github().users().get(this.event.json().getJsonObject(\"actor\").getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PullComment.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PullComment.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Pull comment author\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic String author() throws IOException {\n    return this.json().getJsonObject(\"user\").getString(\"login\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCommits.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) {\n    return this.get(params.getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Status.Smart.creator",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Status.Smart.creator" ],
    "fullMethods" : [ "/**\n * Get its creator.\n *\n * @return Creator of the commit status\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User creator() throws IOException {\n    return this.status.commit().repo().github().users().get(this.status.json().getJsonObject(\"creator\").getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Gist.Smart.files",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Gist.Smart.files" ],
    "fullMethods" : [ "/**\n * Get a list of all file names in the gist.\n *\n * @return File names\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Iterable<String> files() throws IOException {\n    final JsonObject array = this.gist.json().getJsonObject(\"files\");\n    final Collection<String> files = new ArrayList<>(array.size());\n    for (final JsonValue value : array.values()) {\n        files.add(JsonObject.class.cast(value).getString(\"filename\"));\n    }\n    return files;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Event.Smart.label",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Event.Smart.label" ],
    "fullMethods" : [ "/**\n * Label that was added or removed in this event (if any).\n *\n * @return Label that was added or removed\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 0.24\n */\npublic Optional<Label> label() throws IOException {\n    Optional<Label> lab = Optional.absent();\n    final JsonObject lbl = this.jsn.json().getJsonObject(\"label\");\n    if (lbl != null) {\n        lab = Optional.of(this.event.repo().labels().get(lbl.getString(\"name\")));\n    }\n    return lab;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RepoCommit.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RepoCommit.Smart.author" ],
    "fullMethods" : [ "/**\n * Returns the login of the author.\n *\n * @return The login\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 1.1\n */\npublic String author() throws IOException {\n    return this.jsn.json().getJsonObject(\"commit\").getJsonObject(\"author\").getString(\"name\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPullComments.reply",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    this.storage.lock();\n    try {\n        final JsonObject orig = this.get(comment).json();\n        final PullComment reply = this.post(body, orig.getString(\"commit_id\"), orig.getString(\"path\"), comment);\n        reply.patch(Json.createObjectBuilder().add(\"original_position\", String.valueOf(comment)).build());\n        return reply;\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.GistComment.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.GistComment.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Author of comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User author() throws IOException {\n    return this.comment.gist().github().users().get(this.comment.json().getJsonObject(\"user\").getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.CommitsComparison.Smart.commits",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.CommitsComparison.Smart.commits" ],
    "fullMethods" : [ "/**\n * Get commits.\n *\n * @return Commits\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Iterable<RepoCommit> commits() throws IOException {\n    final JsonArray array = this.comparison.json().getJsonArray(\"commits\");\n    final Collection<RepoCommit> commits = new ArrayList<>(array.size());\n    final RepoCommits repo = this.comparison.repo().commits();\n    for (final JsonValue value : array) {\n        commits.add(repo.get(JsonObject.class.cast(value).getString(\"sha\")));\n    }\n    return commits;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTags.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Directives dirs = new Directives().xpath(this.xpath()).add(\"tag\");\n    for (final Entry<String, JsonValue> entry : params.entrySet()) {\n        dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n    }\n    this.storage.apply(dirs);\n    new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"name\")).toString(), params.getString(\"sha\"));\n    return this.get(params.getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.pull",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.pull" ],
    "fullMethods" : [ "/**\n * Get pull request.\n *\n * @return Pull request\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Pull pull() throws IOException {\n    final String url = this.jsn.value(\"pull_request\", JsonObject.class).getString(\"html_url\");\n    return this.issue.repo().pulls().get(Integer.parseInt(url.substring(url.lastIndexOf('/') + 1)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTrees.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkTrees.create" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Tree create(final JsonObject params) throws IOException {\n    final JsonArray trees = params.getJsonArray(\"tree\");\n    for (final JsonValue val : trees) {\n        final JsonObject tree = ((JsonObject) (val));\n        final String sha = tree.getString(\"sha\");\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"tree\");\n        for (final Entry<String, JsonValue> entry : tree.entrySet()) {\n            dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n        }\n        this.storage.apply(dirs);\n        final String ref;\n        if (tree.containsValue(\"name\")) {\n            ref = tree.getString(\"name\");\n        } else {\n            ref = sha;\n        }\n        new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder(\"refs/trees/\").append(ref).toString(), sha);\n    }\n    return this.get(trees.getJsonObject(0).getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.login",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtUser.login" ],
    "fullMethods" : [ "@Override\npublic String login() throws IOException {\n    final String login;\n    if (this.self.isEmpty()) {\n        login = this.json().getString(\"login\");\n    } else {\n        login = this.self;\n    }\n    return login;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Pull.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Pull.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Author of pull request (who submitted it)\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User author() throws IOException {\n    return this.pull.repo().github().users().get(this.jsn.value(\"user\", JsonObject.class).getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Author of issue (who submitted it)\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User author() throws IOException {\n    return this.issue.repo().github().users().get(this.jsn.value(\"user\", JsonObject.class).getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.remove",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    this.storage.lock();\n    final String path = content.getString(\"path\");\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (content.containsKey(\"ref\")) {\n            branch = content.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"content[path='%s']\", path)).attr(\"ref\", branch).remove());\n        return this.commit(content);\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullRef.repo",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPullRef.repo" ],
    "fullMethods" : [ "@Override\npublic Repo repo() {\n    return this.github.repos().get(new Coordinates.Simple(this.jsn.getJsonObject(\"repo\").getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserOrganizations.OrganizationMapping.map",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtUserOrganizations.OrganizationMapping.map" ],
    "fullMethods" : [ "@Override\npublic Organization map(final JsonObject object) {\n    return this.organizations.get(object.getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.assignee",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.assignee" ],
    "fullMethods" : [ "/**\n * Get its assignee.\n *\n * @return User Assignee of issue\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User assignee() throws IOException {\n    if (!this.hasAssignee()) {\n        throw new IllegalArgumentException(String.format(\"issue #%d doesn't have an assignee, use hasAssignee()\", this.number()));\n    }\n    return this.issue.repo().github().users().get(this.jsn.value(\"assignee\", JsonObject.class).getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.User.Smart.name",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.User.Smart.name" ],
    "fullMethods" : [ "/**\n * Get his name.\n *\n * @return User name\n * @throws IOException\n * \t\tIf it fails\n */\npublic String name() throws IOException {\n    final JsonObject json = this.json();\n    if (!json.containsKey(\"name\")) {\n        throw new IllegalStateException(// @checkstyle LineLength (1 line)\n        String.format(\"User %s doesn't have a name specified in his/her Github account; use #hasName() first.\", this.login()));\n    }\n    return json.getString(\"name\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatus.url",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtStatus.url" ],
    "fullMethods" : [ "@Override\npublic String url() {\n    return this.json().getString(\"url\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepo.defaultBranch",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtRepo.defaultBranch" ],
    "fullMethods" : [ "@Override\npublic Branch defaultBranch() throws IOException {\n    return new RtBranch(this.request, this, this.json().getString(\"default_branch\"), \"\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkMarkdown.render",
    "thirdPartyMethod" : "javax.json.EmptyObject.getString",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkMarkdown.render" ],
    "fullMethods" : [ "@Override\npublic String render(final JsonObject json) {\n    return json.getString(\"text\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.CommitsComparison.Smart.commits",
    "thirdPartyMethod" : "javax.json.JsonArray.size",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.CommitsComparison.Smart.commits" ],
    "fullMethods" : [ "/**\n * Get commits.\n *\n * @return Commits\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Iterable<RepoCommit> commits() throws IOException {\n    final JsonArray array = this.comparison.json().getJsonArray(\"commits\");\n    final Collection<RepoCommit> commits = new ArrayList<>(array.size());\n    final RepoCommits repo = this.comparison.repo().commits();\n    for (final JsonValue value : array) {\n        commits.add(repo.get(JsonObject.class.cast(value).getString(\"sha\")));\n    }\n    return commits;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.EmptyArray.getValueType",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "javax.json.EmptyArray.getValueType",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.SmartJson.hasNotNull",
    "thirdPartyMethod" : "javax.json.EmptyArray.getValueType",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.SmartJson.hasNotNull" ],
    "fullMethods" : [ "/**\n * Checks if a certain key is present\n *  AND its ValueType isn't ValueType.NULL.\n *\n * @param name\n * \t\tName of the key which ValueType should be checked.\n * @return Returns <code>true</code> if key <code>name</code> is present\nand its ValueType isn't ValueType.NULL, <code>false</code> otherwise.\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean hasNotNull(final String name) throws IOException {\n    final JsonValue value = this.object.json().get(name);\n    return (value != null) && (!ValueType.NULL.equals(value.getValueType()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTree.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkTree.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.iterate",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String pattern, final String ref) throws IOException {\n    final Collection<XML> nodes = this.storage.xml().nodes(String.format(\"%s/content[@ref='%s']\", this.xpath(), ref));\n    final Collection<Content> result = new ArrayList<>(nodes.size());\n    for (final XML node : nodes) {\n        final String path = node.xpath(\"path/text()\").get(0);\n        if (path.startsWith(pattern)) {\n            result.add(this.mkContent(ref, path));\n        }\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.JsonNode.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.JsonNode.json" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON\n * @checkstyle MultipleStringLiteralsCheck (30 lines)\n */\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final XML child : this.xml.nodes(\"* \")) {\n        final Node node = child.node();\n        if (child.nodes(\"*\").isEmpty()) {\n            builder.add(node.getNodeName(), node.getTextContent());\n        } else if ((!child.xpath(\"//@array\").isEmpty()) && \"true\".equals(child.xpath(\"//@array\").get(0))) {\n            final JsonArrayBuilder bld = Json.createArrayBuilder();\n            for (final XML item : child.nodes(\"*\")) {\n                bld.add(item.node().getTextContent());\n            }\n            builder.add(node.getNodeName(), bld.build());\n        } else {\n            builder.add(node.getNodeName(), new JsonNode(child).json());\n        }\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkBranches.get",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkBranches.get" ],
    "fullMethods" : [ "/**\n * Gets a branch by name.\n *\n * @param name\n * \t\tName of branch.\n * @return The branch with the given name\n * @throws IOException\n * \t\tIf there is an I/O problem\n */\npublic Branch get(final String name) throws IOException {\n    return new MkBranch(this.storage, this.self, this.coords, name, this.storage.xml().nodes(String.format(\"%s/branch[@name='%s']\", this.xpath(), name)).get(0).xpath(MkBranches.XPATH_TO_SHA).get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkNotifications.get",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkNotifications.get" ],
    "fullMethods" : [ "@Override\npublic Notification get(final int number) {\n    try {\n        return new MkNotification(this.storage.xml().nodes(this.xpath.concat(String.format(\"[id = %s]\", number))).get(0));\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepos.get",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkRepos.get" ],
    "fullMethods" : [ "@Override\npublic Repo get(final Coordinates coords) {\n    try {\n        final String xpath = String.format(\"%s/repo[@coords='%s']\", this.xpath(), coords);\n        if (this.storage.xml().nodes(xpath).isEmpty()) {\n            throw new IllegalArgumentException(String.format(\"repository %s doesn't exist\", coords));\n        }\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return new MkRepo(this.storage, this.self, coords);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUserEmails.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkUserEmails.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepoCommits.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkRepoCommits.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContent.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkContent.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPullComments.post",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().nodes(String.format(\"%s/comment/id/text()\", this.xpath())).size();\n        this.storage.apply(// @checkstyle MultipleStringLiteralsCheck (4 lines)\n        new Directives().xpath(this.xpath()).add(\"comment\").add(\"id\").set(Integer.toString(number)).up().add(\"url\").set(\"http://localhost/1\").up().add(\"diff_hunk\").set(\"@@ -16,33 +16,40 @@ public...\").up().add(\"path\").set(path).up().add(\"position\").set(Integer.toString(position)).up().add(\"original_position\").set(Integer.toString(number)).up().add(\"commit_id\").set(commit).up().add(\"original_commit_id\").set(commit).up().add(\"body\").set(body).up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"published_at\").set(new Github.Time().toString()).up().add(\"user\").add(\"login\").set(this.self).up().add(\"pull_request_url\").set(\"http://localhost/2\").up());\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAsset.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkReleaseAsset.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkDeployKey.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkDeployKey.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.fork",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    this.storage.lock();\n    final String number;\n    try {\n        final XML xml = this.storage.xml();\n        number = Integer.toString(1 + xml.xpath(\"/github/gists/gist/id/text()\").size());\n        final Directives dirs = new Directives().xpath(\"/github/gists\").add(\"gist\").add(\"id\").set(number).up().add(\"files\");\n        final List<XML> files = xml.nodes(String.format(\"%s/files/file\", this.xpath()));\n        for (final XML file : files) {\n            final String filename = file.xpath(\"filename/text()\").get(0);\n            // @checkstyle MultipleStringLiterals (3 lines)\n            dirs.add(\"file\").add(\"filename\").set(filename).up().add(\"raw_content\").set(this.read(filename)).up().up();\n        }\n        this.storage.apply(dirs);\n    } finally {\n        this.storage.unlock();\n    }\n    return new MkGist(this.storage, this.self, number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkComments.post",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    this.storage.lock();\n    final long number;\n    try {\n        final String timestamp = new Github.Time().toString();\n        number = 1 + this.storage.xml().nodes(\"//comment/number\").size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"comment\").add(\"number\").set(Long.toString(number)).up().add(\"url\").set(// @checkstyle LineLength (1 line)\n        String.format(\"https://api.jcabi-github.invalid/repos/%s/%s/issues/comments/%d\", this.repo.user(), this.repo.repo(), number)).up().add(\"body\").set(text).up().add(\"user\").add(\"login\").set(this.self).up().up().add(\"created_at\").set(timestamp).up().add(\"updated_at\").set(timestamp));\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"comment #%d posted to issue #%d by %s: %[text]s\", number, this.issue().number(), this.self, text);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkFork.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkFork.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIterable.iterator",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkIterable.iterator" ],
    "fullMethods" : [ "@Override\npublic Iterator<T> iterator() {\n    final Iterator<XML> nodes;\n    try {\n        nodes = this.storage.xml().nodes(this.xpath).iterator();\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return new Iterator<T>() {\n        @Override\n        public boolean hasNext() {\n            return nodes.hasNext();\n        }\n\n        @Override\n        public T next() {\n            return MkIterable.this.mapping.map(nodes.next());\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"#remove()\");\n        }\n    };\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkComment.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkComment.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPullComment.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkPullComment.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepos.exists",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String xpath = String.format(\"%s/repo[@coords='%s']\", this.xpath(), coords);\n    return !this.storage.xml().nodes(xpath).isEmpty();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTag.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkTag.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkMilestone.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkMilestone.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkIssue.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final XML xml = this.storage.xml();\n    final JsonObject obj = new JsonNode(xml.nodes(this.xpath()).get(0)).json();\n    final JsonObjectBuilder json = Json.createObjectBuilder();\n    for (final Map.Entry<String, JsonValue> val : obj.entrySet()) {\n        json.add(val.getKey(), val.getValue());\n    }\n    final JsonArrayBuilder array = Json.createArrayBuilder();\n    for (final Label label : this.labels().iterate()) {\n        array.add(Json.createObjectBuilder().add(\"name\", label.name()).build());\n    }\n    final JsonObjectBuilder res = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    json.add(\"labels\", array).add(\"assignee\", Json.createObjectBuilder().add(\"login\", obj.getString(\"assignee\", \"\")).build());\n    final JsonObjectBuilder pull = Json.createObjectBuilder();\n    final String html = \"html_url\";\n    if (xml.nodes(// @checkstyle LineLengthCheck (1 line)\n    String.format(\"/github/repos/repo[@coords='%s']/pulls/pull/number[text() = '%d']\", this.coords, this.num)).isEmpty()) {\n        pull.addNull(html);\n    } else {\n        pull.add(html, String.format(\"https://%s/pulls/%d\", this.coords, this.num));\n    }\n    return res.add(\"pull_request\", pull.build()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkEvent.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkEvent.json" ],
    "fullMethods" : [ "/**\n * Describes the event in a JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min When the event has a label, retrieve and include the\nlabel's color too. MkIssueEvents.create() will also need to be\nupdated accordingly.\n */\n@Override\npublic JsonObject json() throws IOException {\n    final JsonObject obj = new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n    JsonObjectBuilder builder = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(\"id\", this.num).add(\"url\", // @checkstyle LineLength (1 line)\n    String.format(\"https://api.jcabi-github.invalid/repos/%s/issues/events/%s\", this.coords, this.num)).add(\"commit_id\", JsonValue.NULL).add(MkEvent.EVENT, obj.getString(MkEvent.EVENT)).add(\"actor\", // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(MkEvent.LOGIN, obj.getString(MkEvent.LOGIN)).build()).add(MkEvent.CREATED_AT, obj.getString(MkEvent.CREATED_AT));\n    final String label = \"label\";\n    if (obj.containsKey(label)) {\n        builder = builder.add(label, Json.createObjectBuilder().add(\"name\", obj.getString(label)).build());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReference.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkReference.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkHook.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkHook.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(String.format(\"//repo[@coords='%s']/hooks/hook[id='%s']\", this.repo().coordinates(), this.number())).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    final Iterable<XML> ids = this.storage.xml().nodes(this.xpath() + String.format(\"/notifications/notification[date <= %s]/id\", lastread.getTime()));\n    final JsonPatch json = new JsonPatch(this.storage);\n    final JsonObject read = Json.createObjectBuilder().add(\"read\", true).build();\n    for (final XML nid : ids) {\n        json.patch(String.format(this.xpath().concat(\"/notifications/notification[id = %s]\"), nid.xpath(\"text()\").get(0)), read);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepoCommit.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkRepoCommit.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(String.format(\"/github/repos/repo[@coords='%s']/commits/commit[sha='%s']\", this.repo().coordinates(), this.hash)).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkRepo.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkLabel.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkLabel.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPublicKey.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkPublicKey.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPull.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkPull.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final XML xml = this.storage.xml().nodes(this.xpath()).get(0);\n    final String branch = xml.xpath(\"base/text()\").get(0);\n    final String head = xml.xpath(\"head/text()\").get(0);\n    final String[] parts = head.split(MkPull.USER_BRANCH_SEP, 2);\n    final JsonObject obj = new JsonNode(xml).json();\n    final JsonObjectBuilder json = Json.createObjectBuilder();\n    for (final Map.Entry<String, JsonValue> val : obj.entrySet()) {\n        if (MkPull.NUMBER_PROP.equals(val.getKey())) {\n            json.add(MkPull.NUMBER_PROP, Integer.parseInt(xml.xpath(\"number/text()\").get(0)));\n        } else if (MkPull.USER_PROP.equals(val.getKey())) {\n            json.add(MkPull.USER_PROP, Json.createObjectBuilder().add(\"login\", xml.xpath(\"user/login/text()\").get(0)).build());\n        } else if (MkPull.HEAD_PROP.equals(val.getKey())) {\n            json.add(MkPull.HEAD_PROP, Json.createObjectBuilder().add(MkPull.REF_PROP, parts[1]).add(MkPull.LABEL_PROP, head).build());\n        } else if (MkPull.BASE_PROP.equals(val.getKey())) {\n            json.add(MkPull.BASE_PROP, Json.createObjectBuilder().add(MkPull.REF_PROP, branch).add(MkPull.LABEL_PROP, String.format(\"%s:%s\", this.coords.user(), branch)).build());\n        } else {\n            json.add(val.getKey(), val.getValue());\n        }\n    }\n    json.add(\"comments\", this.storage.xml().nodes(this.comment()).size());\n    return json.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCommit.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkCommit.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCheck.successful",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkCheck.successful" ],
    "fullMethods" : [ "@Override\npublic boolean successful() throws IOException {\n    final XML node = this.storage.xml().nodes(this.xpath()).get(0);\n    final Status status = Status.fromString(node.xpath(\"@status\").get(0));\n    final Conclusion conclusion = Conclusion.fromString(node.xpath(\"@conclusion\").get(0));\n    return (status == Status.COMPLETED) && (conclusion == Conclusion.SUCCESS);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkGist.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.read",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final List<XML> files = this.storage.xml().nodes(String.format(\"%s/files/file[filename='%s']\", this.xpath(), file));\n    if (files.isEmpty()) {\n        throw new IOException(String.format(\"Couldn't find file with the name %s.\", file));\n    }\n    final List<String> contents = files.get(0).xpath(\"raw_content/text()\");\n    String content = \"\";\n    if (!contents.isEmpty()) {\n        content = contents.get(0);\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRelease.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkRelease.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUser.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkUser.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.exists",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    return this.storage.xml().nodes(String.format(\"%s/content[path='%s']\", this.xpath(), path)).size() > 0;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkBlob.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.nodes",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkBlob.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    return new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.JsonNode.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.node",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.JsonNode.json" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON\n * @checkstyle MultipleStringLiteralsCheck (30 lines)\n */\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final XML child : this.xml.nodes(\"* \")) {\n        final Node node = child.node();\n        if (child.nodes(\"*\").isEmpty()) {\n            builder.add(node.getNodeName(), node.getTextContent());\n        } else if ((!child.xpath(\"//@array\").isEmpty()) && \"true\".equals(child.xpath(\"//@array\").get(0))) {\n            final JsonArrayBuilder bld = Json.createArrayBuilder();\n            for (final XML item : child.nodes(\"*\")) {\n                bld.add(item.node().getTextContent());\n            }\n            builder.add(node.getNodeName(), bld.build());\n        } else {\n            builder.add(node.getNodeName(), new JsonNode(child).json());\n        }\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.apply",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.node",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.apply" ],
    "fullMethods" : [ "@Override\npublic void apply(final Iterable<Directive> dirs) throws IOException {\n    synchronized(this.name) {\n        FileUtils.write(new File(this.name), new XMLDocument(new Xembler(dirs).applyQuietly(this.xml().node())).toString(), StandardCharsets.UTF_8);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.entry",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.<clinit>",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.mock.MkGithub.entry" ],
    "fullMethods" : [ "@Override\npublic Request entry() {\n    return new FakeRequest().withBody(\"{}\").withStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkChecks.all",
    "thirdPartyMethod" : "com.google.common.collect.ImmutableCollection.<clinit>",
    "thirdPartyPackage" : "com.google.common.collect",
    "path" : [ "com.jcabi.github.mock.MkChecks.all" ],
    "fullMethods" : [ "@Override\npublic Collection<Check> all() throws IOException {\n    return ImmutableList.copyOf(new MkIterable<>(this.storage, String.format(\"%s/check\", this.xpath()), item -> new MkCheck(this.storage, this.coordinates, this.pull, Integer.parseInt(item.xpath(\"@id\").get(0)))));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCommitsComparison.files",
    "thirdPartyMethod" : "com.google.common.collect.ImmutableCollection.<clinit>",
    "thirdPartyPackage" : "com.google.common.collect",
    "path" : [ "com.jcabi.github.mock.MkCommitsComparison.files" ],
    "fullMethods" : [ "@Override\npublic Iterable<FileChange> files() {\n    return ImmutableList.<FileChange>of(new MkFileChange(MkCommitsComparison.FILE_JSON));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComment.json",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfComment.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    JsonObject json;\n    try {\n        json = this.origin.json();\n    } catch (final AssertionError ex) {\n        final String author = new Issue.Smart(new SfIssue(this.origin.issue())).author().login();\n        json = new MkGithub(author).randomRepo().issues().create(\"\", \"\").comments().post(\"deleted comment\").json();\n        Logger.warn(this, \"failed to fetch comment: %[exception]s\", ex);\n    }\n    return json;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComment.remove",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    try {\n        this.origin.remove();\n    } catch (final AssertionError ex) {\n        Logger.warn(this, \"Failed to remove comment: %[exception]s\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Smarts.next",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.Smarts.next", "com.jcabi.github.Smarts.access", "com.jcabi.github.Smarts.wrap", "com.jcabi.github.Smarts.type" ],
    "fullMethods" : [ "@Override\npublic T next() {\n    return Smarts.<T>wrap(iterator.next());\n}", "{\n    java.lang.Object $stack1, x0;\n\n\n    x0 := @parameter0: java.lang.Object;\n    $stack1 = staticinvoke <com.jcabi.github.Smarts: java.lang.Object wrap(java.lang.Object)>(x0);\n\n    return $stack1;\n}\n", "/**\n * Wrap an object, and make a \"smart\" decorator.\n *\n * @param object\n * \t\tObject to wrap\n * @return Decorator\n * @param <X>\n * \t\tType of result\n */\n@SuppressWarnings(\"unchecked\")\nprivate static <X> X wrap(final Object object) {\n    try {\n        return ((X) (Smarts.type(object).newInstance(object)));\n    } catch (final InvocationTargetException ex) {\n        throw new IllegalStateException(ex);\n    } catch (final InstantiationException ex) {\n        throw new IllegalStateException(ex);\n    } catch (final IllegalAccessException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Find \"smart\" class for the object.\n *\n * @param object\n * \t\tObject to wrap\n * @return Class to use\n */\nprivate static Constructor<?> type(final Object object) {\n    for (final Class<?> iface : object.getClass().getInterfaces()) {\n        try {\n            return Class.forName(String.format(\"%s$Smart\", iface.getName())).getDeclaredConstructor(iface);\n        } catch (final ClassNotFoundException ex) {\n            Logger.debug(Smarts.class, \"%s: %s\", iface.getName(), ex);\n        } catch (final NoSuchMethodException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n    throw new IllegalStateException(String.format(\"can't find Smart decorator for %s\", object.getClass().getName()));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfIssue.json",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfIssue.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    JsonObject json;\n    try {\n        json = this.origin.json();\n    } catch (final AssertionError ex) {\n        json = new MkGithub().randomRepo().issues().create(\"\", \"\").json();\n        Logger.warn(this, \"failed to fetch issue: %[exception]s\", ex);\n    }\n    return json;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssues.create",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue/number/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"issue\").add(\"number\").set(Integer.toString(number)).up().add(\"state\").set(Issue.OPEN_STATE).up().add(\"title\").set(title).up().add(\"body\").set(body).up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"updated_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up().add(\"user\").add(\"login\").set(this.self).up().up());\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"issue #%d created in %s by %s: %[text]s\", number, this.repo().coordinates(), this.self, title);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComments.post",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    Comment cmt;\n    try {\n        cmt = this.origin.post(text);\n    } catch (final AssertionError ex) {\n        Logger.warn(this, \"Failed to post to GitHub: %[exception]s\", ex);\n        cmt = new MkGithub().randomRepo().issues().create(\"\", \"\").comments().post(text);\n    }\n    return cmt;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkForks.create",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String org) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/fork/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"fork\").add(\"id\").set(Integer.toString(number)).up().attr(\"organization\", org));\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"fork %s created inside %s by %s\", this.coords, org, this.self);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueEvents.create",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkIssueEvents.create" ],
    "fullMethods" : [ "/**\n * Creates a new issue event.\n * This has no equivalent in GitHub's public API, since GitHub generates\n * events automatically in response to some other API calls.\n *\n * @param type\n * \t\tType of event\n * @param issue\n * \t\tID number of issue the event is regarding\n * @param login\n * \t\tUsername of actor who caused the event\n * @param label\n * \t\tLabel added or removed\n * @return The newly created issue event\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min Make it possible to set the \"assignee\" field for\n\"assigned\"/\"unassigned\" events. Make it possible to set the\n\"milestone\" field for \"milestoned\"/\"demilestoned\" events. Make it\npossible to set the \"rename\" field for \"renamed\" events. Make it\npossible to set the \"commit_id\" field for events related to commits.\nSee https://developer.github.com/v3/issues/events/ for details.\n * @checkstyle ParameterNumberCheck (4 lines)\n */\npublic Event create(final String type, final int issue, final String login, final Optional<String> label) throws IOException {\n    final String created = new Github.Time().toString();\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue-event/number/text()\", this.xpath())).size();\n        Directives directives = new Directives().xpath(this.xpath()).add(\"issue-event\").add(\"issue\").set(Integer.toString(issue)).up().add(\"number\").set(Integer.toString(number)).up().add(\"event\").set(type).up().add(\"created_at\").set(created).up().add(\"login\").set(login).up();\n        if (label.isPresent()) {\n            directives = directives.add(\"label\").set(label.get()).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(MkEvent.class, \"issue event #%d of type %s created in %s for issue #%d by %s\", number, type, this.self, issue, login);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfComment.patch",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfComment.patch" ],
    "fullMethods" : [ "@Override\npublic void patch(final JsonObject json) throws IOException {\n    try {\n        this.origin.patch(json);\n    } catch (final AssertionError ex) {\n        Logger.warn(this, \"Failed to path comment: %[exception]s\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepos.create",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String owner = this.self;\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        owner = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    final Coordinates coords = new Coordinates.Simple(owner, settings.name());\n    this.storage.apply(new Directives().xpath(this.xpath()).add(\"repo\").attr(\"coords\", coords.toString()).add(\"name\").set(settings.name()).up().add(\"description\").set(\"test repository\").up().add(\"private\").set(settings.isPrivate()).up());\n    final Repo repo = this.get(coords);\n    repo.patch(settings.json());\n    Logger.info(this, \"repository %s created by %s\", coords, owner);\n    return repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.CarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.wire.CarefulWire.send" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    final Response resp = this.origin.send(req, home, method, headers, content, connect, read);\n    final int remaining = this.remainingHeader(resp);\n    if (remaining < this.threshold) {\n        final long reset = this.resetHeader(resp);\n        final long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n        if (reset > now) {\n            final long length = reset - now;\n            // @checkstyle LineLength (1 line)\n            Logger.info(this, \"Remaining number of requests per hour is less than %d. Waiting for %d seconds.\", this.threshold, length);\n            try {\n                TimeUnit.SECONDS.sleep(length);\n            } catch (final InterruptedException ex) {\n                Thread.currentThread().interrupt();\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return resp;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkComments.post",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.mock.MkComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    this.storage.lock();\n    final long number;\n    try {\n        final String timestamp = new Github.Time().toString();\n        number = 1 + this.storage.xml().nodes(\"//comment/number\").size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"comment\").add(\"number\").set(Long.toString(number)).up().add(\"url\").set(// @checkstyle LineLength (1 line)\n        String.format(\"https://api.jcabi-github.invalid/repos/%s/%s/issues/comments/%d\", this.repo.user(), this.repo.repo(), number)).up().add(\"body\").set(text).up().add(\"user\").add(\"login\").set(this.self).up().up().add(\"created_at\").set(timestamp).up().add(\"updated_at\").set(timestamp));\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"comment #%d posted to issue #%d by %s: %[text]s\", number, this.issue().number(), this.self, text);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.safe.SfIssue.patch",
    "thirdPartyMethod" : "com.jcabi.log.Logger.<clinit>",
    "thirdPartyPackage" : "com.jcabi.log",
    "path" : [ "com.jcabi.github.safe.SfIssue.patch" ],
    "fullMethods" : [ "@Override\npublic void patch(final JsonObject json) throws IOException {\n    try {\n        this.origin.patch(json);\n    } catch (final AssertionError ex) {\n        Logger.warn(this, \"failed to patch issue: %[exception]s\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Commit.Smart.message",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Commit.Smart.message" ],
    "fullMethods" : [ "/**\n * Get its message.\n *\n * @return Message of commit\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic String message() throws IOException {\n    return this.jsn.json().getJsonObject(\"commit\").getString(\"message\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RepoCommit.Smart.message",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RepoCommit.Smart.message" ],
    "fullMethods" : [ "/**\n * Get its message.\n *\n * @return Message of repo commit\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic String message() throws IOException {\n    return this.jsn.json().getJsonObject(\"commit\").getString(\"message\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLimit.json",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtLimit.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final JsonObject json = new RtJson(this.entry).fetch().getJsonObject(\"resources\");\n    if (!json.containsKey(this.res)) {\n        throw new IllegalStateException(String.format(\"'%s' is absent in JSON: %s\", this.res, json));\n    }\n    return json.getJsonObject(this.res);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.remove",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.remove", "com.jcabi.github.mock.MkContents.commit" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    this.storage.lock();\n    final String path = content.getString(\"path\");\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (content.containsKey(\"ref\")) {\n            branch = content.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"content[path='%s']\", path)).attr(\"ref\", branch).remove());\n        return this.commit(content);\n    } finally {\n        this.storage.unlock();\n    }\n}", "/**\n * XML Directives for commit creation.\n *\n * @param json\n * \t\tSource\n * @return SHA string\n * @throws IOException\n * \t\tIf an IO Exception occurs\n */\nprivate MkRepoCommit commit(final JsonObject json) throws IOException {\n    final String sha = fakeSha();\n    // @checkstyle MultipleStringLiterals (40 lines)\n    final Directives commit = new Directives().xpath(this.commitXpath()).add(\"commit\").add(\"sha\").set(sha).up().add(\"url\").set(\"http://localhost/4\").up().add(\"html_url\").set(\"http://localhost/5\").up().add(\"message\").set(json.getString(\"message\")).up();\n    if (json.containsKey(\"committer\")) {\n        final JsonObject committer = json.getJsonObject(\"committer\");\n        commit.add(\"committer\").add(\"email\").set(committer.getString(\"email\")).up().add(\"name\").set(committer.getString(\"name\")).up();\n    }\n    if (json.containsKey(\"author\")) {\n        final JsonObject author = json.getJsonObject(\"author\");\n        commit.add(\"author\").add(\"email\").set(author.getString(\"email\")).up().add(\"name\").set(author.getString(\"name\")).up();\n    }\n    this.storage.apply(commit);\n    return new MkRepoCommit(this.storage, this.repo(), sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Status.Smart.creator",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Status.Smart.creator" ],
    "fullMethods" : [ "/**\n * Get its creator.\n *\n * @return Creator of the commit status\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User creator() throws IOException {\n    return this.status.commit().repo().github().users().get(this.status.json().getJsonObject(\"creator\").getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Gist.Smart.files",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Gist.Smart.files" ],
    "fullMethods" : [ "/**\n * Get a list of all file names in the gist.\n *\n * @return File names\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic Iterable<String> files() throws IOException {\n    final JsonObject array = this.gist.json().getJsonObject(\"files\");\n    final Collection<String> files = new ArrayList<>(array.size());\n    for (final JsonValue value : array.values()) {\n        files.add(JsonObject.class.cast(value).getString(\"filename\"));\n    }\n    return files;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.base",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPull.base" ],
    "fullMethods" : [ "@Override\npublic PullRef base() throws IOException {\n    return new RtPullRef(this.owner.github(), this.json().getJsonObject(\"base\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Event.Smart.label",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Event.Smart.label" ],
    "fullMethods" : [ "/**\n * Label that was added or removed in this event (if any).\n *\n * @return Label that was added or removed\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 0.24\n */\npublic Optional<Label> label() throws IOException {\n    Optional<Label> lab = Optional.absent();\n    final JsonObject lbl = this.jsn.json().getJsonObject(\"label\");\n    if (lbl != null) {\n        lab = Optional.of(this.event.repo().labels().get(lbl.getString(\"name\")));\n    }\n    return lab;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.create", "com.jcabi.github.mock.MkContents.commit" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject json) throws IOException {\n    this.storage.lock();\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (json.containsKey(\"ref\")) {\n            branch = json.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"content\").attr(\"ref\", branch).add(\"name\").set(json.getString(\"path\")).up().add(\"path\").set(json.getString(\"path\")).up().add(\"content\").set(json.getString(\"content\")).up().add(\"type\").set(\"file\").up().add(\"encoding\").set(\"base64\").up().add(\"sha\").set(fakeSha()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"git_url\").set(\"http://localhost/2\").up().add(\"html_url\").set(\"http://localhost/3\").up());\n        this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n    return new MkContent(this.storage, this.self, this.coords, json.getString(\"path\"), branch);\n}", "/**\n * XML Directives for commit creation.\n *\n * @param json\n * \t\tSource\n * @return SHA string\n * @throws IOException\n * \t\tIf an IO Exception occurs\n */\nprivate MkRepoCommit commit(final JsonObject json) throws IOException {\n    final String sha = fakeSha();\n    // @checkstyle MultipleStringLiterals (40 lines)\n    final Directives commit = new Directives().xpath(this.commitXpath()).add(\"commit\").add(\"sha\").set(sha).up().add(\"url\").set(\"http://localhost/4\").up().add(\"html_url\").set(\"http://localhost/5\").up().add(\"message\").set(json.getString(\"message\")).up();\n    if (json.containsKey(\"committer\")) {\n        final JsonObject committer = json.getJsonObject(\"committer\");\n        commit.add(\"committer\").add(\"email\").set(committer.getString(\"email\")).up().add(\"name\").set(committer.getString(\"name\")).up();\n    }\n    if (json.containsKey(\"author\")) {\n        final JsonObject author = json.getJsonObject(\"author\");\n        commit.add(\"author\").add(\"email\").set(author.getString(\"email\")).up().add(\"name\").set(author.getString(\"name\")).up();\n    }\n    this.storage.apply(commit);\n    return new MkRepoCommit(this.storage, this.repo(), sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RepoCommit.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RepoCommit.Smart.author" ],
    "fullMethods" : [ "/**\n * Returns the login of the author.\n *\n * @return The login\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 1.1\n */\npublic String author() throws IOException {\n    return this.jsn.json().getJsonObject(\"commit\").getJsonObject(\"author\").getString(\"name\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullRef.repo",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPullRef.repo" ],
    "fullMethods" : [ "@Override\npublic Repo repo() {\n    return this.github.repos().get(new Coordinates.Simple(this.jsn.getJsonObject(\"repo\").getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Comment.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Comment.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Author of comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User author() throws IOException {\n    return this.comment.issue().repo().github().users().get(this.comment.json().getJsonObject(\"user\").getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.GistComment.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.GistComment.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Author of comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User author() throws IOException {\n    return this.comment.gist().github().users().get(this.comment.json().getJsonObject(\"user\").getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.head",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtPull.head" ],
    "fullMethods" : [ "@Override\npublic PullRef head() throws IOException {\n    return new RtPullRef(this.owner.github(), this.json().getJsonObject(\"head\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Event.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Event.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Author of comment\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic User author() throws IOException {\n    return this.event.repo().github().users().get(this.event.json().getJsonObject(\"actor\").getString(\"login\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.PullComment.Smart.author",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.PullComment.Smart.author" ],
    "fullMethods" : [ "/**\n * Get its author.\n *\n * @return Pull comment author\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic String author() throws IOException {\n    return this.json().getJsonObject(\"user\").getString(\"login\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.update",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.update", "com.jcabi.github.mock.MkContents.commit" ],
    "fullMethods" : [ "/**\n * Updates a file.\n *\n * @param path\n * \t\tThe content path.\n * @param json\n * \t\tJSON object containing updates to the content.\n * @return Commit related to this update.\n * @throws IOException\n * \t\tIf any I/O problem occurs.\n */\n@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    this.storage.lock();\n    try {\n        final String ref = \"ref\";\n        final String branch;\n        if (json.containsKey(ref)) {\n            branch = json.getString(ref);\n        } else {\n            branch = \"master\";\n        }\n        final String xpath = // @checkstyle LineLengthCheck (1 line)\n        String.format(\"/github/repos/repo[@coords='%s']/contents/content[path='%s' and @ref='%s']\", this.coords, path, branch);\n        new JsonPatch(this.storage).patch(xpath, json);\n        return this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n}", "/**\n * XML Directives for commit creation.\n *\n * @param json\n * \t\tSource\n * @return SHA string\n * @throws IOException\n * \t\tIf an IO Exception occurs\n */\nprivate MkRepoCommit commit(final JsonObject json) throws IOException {\n    final String sha = fakeSha();\n    // @checkstyle MultipleStringLiterals (40 lines)\n    final Directives commit = new Directives().xpath(this.commitXpath()).add(\"commit\").add(\"sha\").set(sha).up().add(\"url\").set(\"http://localhost/4\").up().add(\"html_url\").set(\"http://localhost/5\").up().add(\"message\").set(json.getString(\"message\")).up();\n    if (json.containsKey(\"committer\")) {\n        final JsonObject committer = json.getJsonObject(\"committer\");\n        commit.add(\"committer\").add(\"email\").set(committer.getString(\"email\")).up().add(\"name\").set(committer.getString(\"name\")).up();\n    }\n    if (json.containsKey(\"author\")) {\n        final JsonObject author = json.getJsonObject(\"author\");\n        commit.add(\"author\").add(\"email\").set(author.getString(\"email\")).up().add(\"name\").set(author.getString(\"name\")).up();\n    }\n    this.storage.apply(commit);\n    return new MkRepoCommit(this.storage, this.repo(), sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RepoCommit.Smart.isVerified",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RepoCommit.Smart.isVerified" ],
    "fullMethods" : [ "/**\n * Returns TRUE if the commit is verified.\n *\n * @return TRUE if verified\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 1.1\n */\npublic boolean isVerified() throws IOException {\n    return this.jsn.json().getJsonObject(\"commit\").getJsonObject(\"verification\").getBoolean(\"verified\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "javax.json.EmptyObject.getJsonObject",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.star",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.fetch" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf fails\n */\npublic JsonObject fetch() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final List<JsonString> list = response.as(JsonResponse.class).json().readArray().getValuesAs(JsonString.class);\n    final List<String> templates = new ArrayList<>(list.size());\n    for (final JsonString value : list) {\n        templates.add(value.getString());\n    }\n    return templates;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.clear",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.clear" ],
    "fullMethods" : [ "@Override\npublic void clear() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.Items.hasNext",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtValuePagination.Items.hasNext", "com.jcabi.github.RtValuePagination.Items.fetch" ],
    "fullMethods" : [ "@Override\npublic boolean hasNext() {\n    synchronized(this.mapping) {\n        if (((this.objects == null) || this.objects.isEmpty()) && this.more) {\n            try {\n                this.fetch();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        return !this.objects.isEmpty();\n    }\n}", "/**\n * Fetch the next portion, if available.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@SuppressWarnings(\"unchecked\")\nprivate void fetch() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final WebLinkingResponse.Link link = response.as(WebLinkingResponse.class).links().get(\"next\");\n    if (link == null) {\n        this.more = false;\n    } else {\n        this.request = response.jump(link.uri());\n    }\n    final JsonArray arr = response.as(JsonResponse.class).json().readArray();\n    final Queue<P> list = new LinkedList<>();\n    for (final JsonValue value : arr) {\n        list.add(((P) (value)));\n    }\n    this.objects = list;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.as",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.apply",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.<init>",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.apply" ],
    "fullMethods" : [ "@Override\npublic void apply(final Iterable<Directive> dirs) throws IOException {\n    synchronized(this.name) {\n        FileUtils.write(new File(this.name), new XMLDocument(new Xembler(dirs).applyQuietly(this.xml().node())).toString(), StandardCharsets.UTF_8);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "javax.json.Json.createWriter",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "javax.json.Json.createWriter",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.headers",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.headers",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.headers" ],
    "fullMethods" : [ "@Override\npublic Map<String, List<String>> headers() {\n    return this.response.headers();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.CarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.headers",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.wire.CarefulWire.send", "com.jcabi.github.wire.CarefulWire.remainingHeader", "com.jcabi.github.wire.CarefulWire.headerOrNull" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    final Response resp = this.origin.send(req, home, method, headers, content, connect, read);\n    final int remaining = this.remainingHeader(resp);\n    if (remaining < this.threshold) {\n        final long reset = this.resetHeader(resp);\n        final long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n        if (reset > now) {\n            final long length = reset - now;\n            // @checkstyle LineLength (1 line)\n            Logger.info(this, \"Remaining number of requests per hour is less than %d. Waiting for %d seconds.\", this.threshold, length);\n            try {\n                TimeUnit.SECONDS.sleep(length);\n            } catch (final InterruptedException ex) {\n                Thread.currentThread().interrupt();\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return resp;\n}", "/**\n * Returns the value of the X-RateLimit-Remaining header.\n * If there is no such header, returns Integer.MAX_VALUE (no rate limit).\n *\n * @param resp\n * \t\tResponse to get header from\n * @return Number of requests remaining before the rate limit will be hit\n */\nprivate int remainingHeader(final Response resp) {\n    final String remainingstr = this.headerOrNull(resp, \"X-RateLimit-Remaining\");\n    int remaining = Integer.MAX_VALUE;\n    if (remainingstr != null) {\n        remaining = Integer.parseInt(remainingstr);\n    }\n    return remaining;\n}", "/**\n * Get the header with the given name from the response.\n * If there is no such header, returns null.\n *\n * @param resp\n * \t\tResponse to get header from\n * @param headername\n * \t\tName of header to get\n * @return The value of the first header with the given name, or null.\n */\nprivate String headerOrNull(final Response resp, final String headername) {\n    final List<String> values = resp.headers().get(headername);\n    String value = null;\n    if ((values != null) && (!values.isEmpty())) {\n        value = values.get(0);\n    }\n    return value;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkAssignees.check",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) {\n    try {\n        final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/user/login/text()\", this.xpath()));\n        return this.self.equalsIgnoreCase(login) || ((!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(login, xpath.get(0)));\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepoCommits.patch",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) {\n    return StringUtils.join(String.format(\"From %s Mon Sep 17 00:00:00 2001\\n\", head), \"From: Some Author <some_author@email.com>\\n\", \"Date: Tue, 11 Feb 2014 20:33:49 +0200\\n\", \"Subject: Some subject\\n\", \"\\n\", \"---\\n\", \" .../java/com/jcabi/github/CommitsComparison.java   |   6 +-\\n\", \" src/main/java/com/jcabi/github/RepoCommit.java     | 131 +++++\", \"++++++++++++++++\\n\", \" src/main/java/com/jcabi/github/RepoCommits.java    |  15 +--\\n\", \" src/main/java/com/jcabi/github/RtRepoCommit.java   | 110 +++++\", \"++++++++++++\\n\", \" src/main/java/com/jcabi/github/RtRepoCommits.java  |   6 +-\\n\", \" .../java/com/jcabi/github/mock/MkRepoCommits.java  |   6 +-\\n\", \" src/test/java/com/jcabi/github/RepoCommitTest.java |  84 +++++\", \"++++++++\\n\", \" .../java/com/jcabi/github/RtRepoCommitsITCase.java |   7 +-\\n\", \" 8 files changed, 346 insertions(+), 19 deletions(-)\\n\", \" create mode 100644 src/main/java/com/jcabi/github/\", \"RepoCommit.java\\n\", \" create mode 100644 src/main/java/com/jcabi/github/RtRepoCommit\", \".java\\n\", \" create mode 100644 src/test/java/com/jcabi/github/\", \"RepoCommitTest.java\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.JsonPatch.patch",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.JsonPatch.patch" ],
    "fullMethods" : [ "/**\n * Patch an XML object/element.\n *\n * @param xpath\n * \t\tXPath to locate the node to patch\n * @param obj\n * \t\tObject to apply\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void patch(final String xpath, final JsonObject obj) throws IOException {\n    final Directives dirs = new Directives().xpath(xpath);\n    for (final Map.Entry<String, JsonValue> entry : obj.entrySet()) {\n        dirs.addIf(entry.getKey()).set(StringUtils.strip(entry.getValue().toString(), \"\\\"\")).up();\n    }\n    this.storage.apply(dirs);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.starred",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkGist.starred" ],
    "fullMethods" : [ "/**\n * Checks if starred.\n *\n * @return True if gist is starred\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@Override\npublic boolean starred() throws IOException {\n    final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/@starred\", this.xpath()));\n    return (!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(Boolean.toString(true), xpath.get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStars.starred",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.<clinit>",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkStars.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/star/login/text()\", this.xpath()));\n    return (!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(this.self, xpath.get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.xml",
    "thirdPartyMethod" : "org.apache.commons.io.FileUtils.readFileToString",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.xml" ],
    "fullMethods" : [ "@Override\npublic XML xml() throws IOException {\n    synchronized(this.name) {\n        return new XMLDocument(FileUtils.readFileToString(new File(this.name), StandardCharsets.UTF_8));\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.reset",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.reset" ],
    "fullMethods" : [ "@Override\npublic Request reset(final String name) {\n    return new SearchRequest(this.request.reset(name));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    final JsonObject json = Json.createObjectBuilder().add(\"sha\", sha).add(RtReferences.REF, ref).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(RtReferences.REF));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.replace",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.replace" ],
    "fullMethods" : [ "@Override\npublic void replace(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtAssignees.check",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) throws IOException {\n    return this.request.method(Request.GET).uri().path(login).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic void merge(final String msg) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"commit_message\", msg).build();\n    this.merge(json).assertStatus(HttpURLConnection.HTTP_OK);\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTags.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Tag created = this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n    new RtReferences(this.entry, this.owner).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"tag\")).toString(), created.key());\n    return created;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.reply",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.reply" ],
    "fullMethods" : [ "@Override\npublic PullComment reply(final String body, final int comment) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", body).add(\"in_reply_to\", comment).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssues.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"body\", body).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final String path, final String ref) throws IOException {\n    final RestResponse response = this.request.method(Request.GET).uri().path(path).queryParam(\"ref\", ref).back().fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.uri().path(\"star\").back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.addWithPermission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.addWithPermission" ],
    "fullMethods" : [ "@Override\npublic void addWithPermission(final String user, final Collaborators.Permission permission) throws IOException {\n    final JsonObject obj = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"permission\", permission.toString().toLowerCase()).build();\n    this.request.method(Request.PUT).body().set(obj).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    JsonArrayBuilder builder = Json.createArrayBuilder();\n    for (final String label : labels) {\n        builder = builder.add(label);\n    }\n    final JsonStructure json = builder.build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String uriPath = \"user/repos\";\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        uriPath = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    return this.get(new Coordinates.Simple(// @checkstyle MultipleStringLiterals (1 line)\n    this.entry.uri().path(uriPath).back().method(Request.POST).body().set(settings.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"full_name\")));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (4 line)\n    Json.createObjectBuilder().add(\"body\", body).add(\"commit_id\", commit).add(\"path\", path).add(\"position\", position).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"title\", title).add(\"key\", key).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.publicize",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.star",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleases.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"tag_name\", tag).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGists.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> file : files.entrySet()) {\n        builder = builder.add(file.getKey(), Json.createObjectBuilder().add(\"content\", file.getValue()));\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"files\", builder).add(\"public\", visible).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    this.github().entry().uri().path(RtUser.NOTIF_PATH).queryParam(\"last_read_at\", DateTimeFormatter.ISO_INSTANT.format(lastread.toInstant())).back().method(Request.PUT).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_RESET);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.isLocked",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.isLocked" ],
    "fullMethods" : [ "@Override\npublic boolean isLocked() {\n    boolean locked = false;\n    try {\n        locked ^= this.request.method(Request.PUT).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body().get().isEmpty();\n    } catch (final IOException error) {\n        locked = false;\n    }\n    return locked;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtForks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String organization) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"organization\", organization).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_ACCEPTED).as(JsonResponse.class).json().readObject().getInt(ID));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.exists",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists(final Coordinates coords) throws IOException {\n    final String repo = coords.user().concat(\"/\").concat(coords.repo());\n    final RestResponse response = this.entry.uri().path(\"/repos/\".concat(repo)).back().method(Request.GET).fetch().as(RestResponse.class);\n    return response.status() == HttpURLConnection.HTTP_OK;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.request.method(Request.DELETE).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path, final String ref) throws IOException {\n    return this.content(path, ref);\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.emojis",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.emojis" ],
    "fullMethods" : [ "@Override\npublic JsonObject emojis() throws IOException {\n    return this.request.uri().path(\"emojis\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtDeployKey.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.unlock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.unlock" ],
    "fullMethods" : [ "@Override\npublic void unlock() {\n    try {\n        this.request.method(Request.DELETE).uri().path(\"/lock\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.fetch" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf fails\n */\npublic JsonObject fetch() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPulls.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).add(\"head\", head).add(\"base\", base).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme() throws IOException {\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final List<JsonString> list = response.as(JsonResponse.class).json().readArray().getValuesAs(JsonString.class);\n    final List<String> templates = new ArrayList<>(list.size());\n    for (final JsonString value : list) {\n        templates.add(value.getString());\n    }\n    return templates;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.contains",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.contains" ],
    "fullMethods" : [ "@Override\npublic boolean contains(final User user) throws IOException {\n    return this.request.uri().path(user.login()).back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReferences.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.request.method(Request.DELETE).uri().path(identifier).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    this.request.method(Request.DELETE).uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.fork",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    return new RtGist(this.ghub, this.entry, this.request.uri().path(\"/forks\").back().method(Request.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.lock",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.lock" ],
    "fullMethods" : [ "@Override\npublic void lock(final String reason) {\n    final JsonStructure json = Json.createObjectBuilder().add(\"lock_reason\", reason).build();\n    try {\n        this.request.method(Request.PUT).uri().path(\"/lock\").back().body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n    } catch (final IOException error) {\n        throw new IllegalStateException(error);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.iterate",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> iterate() throws IOException {\n    final List<JsonObject> array = this.request.method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> emails = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        // @checkstyle MultipleStringLiterals (1 line)\n        emails.add(obj.getString(\"email\"));\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGithub.meta",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGithub.meta" ],
    "fullMethods" : [ "@Override\npublic JsonObject meta() throws IOException {\n    return this.request.uri().path(\"meta\").back().fetch().as(JsonResponse.class).json().readObject();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtJson.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtJson.patch" ],
    "fullMethods" : [ "/**\n * Patch it.\n *\n * @param json\n * \t\tJSON to use for patching\n * @throws IOException\n * \t\tIf fails\n */\npublic void patch(final JsonObject json) throws IOException {\n    final StringWriter post = new StringWriter();\n    Json.createWriter(post).writeObject(json);\n    this.request.body().set(post.toString()).back().method(Request.PATCH).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLabels.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    final JsonStructure json = // @checkstyle MultipleStringLiterals (1 line)\n    Json.createObjectBuilder().add(\"name\", name).add(\"color\", color).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json();\n    return new RtLabel(this.entry, this.owner, name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonNumber(\"id\").longValue());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssueLabels.clear",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssueLabels.clear" ],
    "fullMethods" : [ "@Override\npublic void clear() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.get",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.get", "com.jcabi.github.RtContents.content" ],
    "fullMethods" : [ "@Override\npublic Content get(final String path) throws IOException {\n    return this.content(path, this.repo().defaultBranch().name());\n}", "/**\n * Get the contents of a file or symbolic link in a repository.\n *\n * @param path\n * \t\tThe content path\n * @param ref\n * \t\tThe name of the commit/branch/tag.\n * @return Content fetched\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @see <a href=\"https://developer.github.com/v3/repos/contents/#get-contents\">Get contents</a>\n */\nprivate Content content(final String path, final String ref) throws IOException {\n    final String name = \"ref\";\n    RtContent content = null;\n    final JsonStructure structure = this.request.method(Request.GET).uri().path(path).queryParam(name, ref).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().read();\n    if (JsonValue.ValueType.OBJECT.equals(structure.getValueType())) {\n        content = new RtContent(this.entry.uri().queryParam(name, ref).back(), this.owner, ((JsonObject) (structure)).getString(\"path\"));\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.starred",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    return this.request.uri().path(\"star\").back().method(\"GET\").fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_NOT_FOUND))).status() == HttpURLConnection.HTTP_NO_CONTENT;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPull.merge",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPull.merge", "com.jcabi.github.RtPull.merge" ],
    "fullMethods" : [ "@Override\npublic MergeState merge(final String msg, final String sha) throws IOException {\n    final JsonObjectBuilder builder = Json.createObjectBuilder().add(\"commit_message\", msg).add(\"sha\", sha);\n    final RestResponse response = this.merge(builder.build()).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_OK, HttpURLConnection.HTTP_BAD_METHOD, HttpURLConnection.HTTP_CONFLICT)));\n    final MergeState mergeState;\n    switch (response.status()) {\n        case HttpURLConnection.HTTP_OK :\n            mergeState = MergeState.SUCCESS;\n            break;\n        case HttpURLConnection.HTTP_BAD_METHOD :\n            mergeState = MergeState.NOT_MERGEABLE;\n            break;\n        default :\n            mergeState = MergeState.BAD_HEAD;\n            break;\n    }\n    return mergeState;\n}", "/**\n * Helper method for merge operations.\n *\n * @param payload\n * \t\tThe JSON payload for the merge\n * @return Response received from GitHub\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nprivate RestResponse merge(final JsonStructure payload) throws IOException {\n    return this.request.uri().path(\"/merge\").back().body().set(payload).back().method(Request.PUT).fetch().as(RestResponse.class);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.update",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.update" ],
    "fullMethods" : [ "@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    return new RtRepoCommit(this.entry, this.owner, this.request.uri().path(path).back().method(Request.PUT).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    this.request.method(Request.DELETE).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicKeys.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.request.method(Request.PUT).uri().path(user).back().fetch().as(RestResponse.class).assertStatus(Matchers.is(Matchers.oneOf(HttpURLConnection.HTTP_NO_CONTENT, HttpURLConnection.HTTP_CREATED)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCommits.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCommits.create" ],
    "fullMethods" : [ "@Override\npublic Commit create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtBlobs.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(Json.createObjectBuilder().add(\"content\", content).add(\"encoding\", encoding).build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRelease.delete",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStatuses.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStatuses.create" ],
    "fullMethods" : [ "/**\n * Create new status for a commit.\n *\n * @param status\n * \t\tAdd this status\n * @return Returned status\n * @throws IOException\n * \t\tIn case of any I/O problems\n */\n@Override\npublic final Status create(final StatusCreate status) throws IOException {\n    final JsonObject response = this.request.method(Request.POST).body().set(status.json()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject();\n    return new RtStatus(this.cmmt, response);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.fetch" ],
    "fullMethods" : [ "/**\n * Hide everything from the body but items.\n *\n * @return Response\n * @throws IOException\n * \t\tIf any I/O problem occurs\n */\n@Override\npublic Response fetch() throws IOException {\n    return new RtSearchPagination.Hidden(this.request.fetch());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMilestones.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"title\", title).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"number\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.method(Request.DELETE).uri().path(Integer.toString(number)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.readme",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContents.readme" ],
    "fullMethods" : [ "@Override\npublic Content readme(final String branch) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"ref\", branch).build();\n    return new RtContent(this.entry, this.owner, this.entry.uri().path(\"/repos\").path(this.owner.coordinates().user()).path(this.owner.coordinates().repo()).path(\"/readme\").back().method(Request.GET).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtUserEmails.add",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    final JsonArrayBuilder json = Json.createArrayBuilder();\n    for (final String email : emails) {\n        json.add(email);\n    }\n    final List<JsonObject> array = this.request.method(Request.POST).body().set(json.build()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readArray().getValuesAs(JsonObject.class);\n    final Collection<String> result = new ArrayList<>(array.size());\n    for (final JsonObject obj : array) {\n        result.add(obj.getString(\"email\"));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGistComments.post",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGistComments.post" ],
    "fullMethods" : [ "@Override\npublic GistComment post(final String text) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(\"body\", text).build();\n    return this.get(// @checkstyle MultipleStringLiterals (1 line)\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtChecks.all",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtChecks.all" ],
    "fullMethods" : [ "/**\n * Get all checks.\n * JSON schema:\n * <p>{@code {\n *   \"total_count\": 1,\n *   \"check_runs\": [\n *     {\n *       \"id\": 4,\n *       \"status\": \"completed\",\n *       ...\n *     }\n *   ]\n * }}</p>\n *\n * @return Checks.\n * @throws IOException\n * \t\tIf there is any I/O problem.\n */\n@Override\npublic Collection<? extends Check> all() throws IOException {\n    final Coordinates coords = this.pull.repo().coordinates();\n    final RestResponse rest = this.request.uri().path(\"/repos\").path(coords.user()).path(coords.repo()).path(\"/commits\").path(this.pull.head().sha()).path(\"/check-runs\").back().method(Request.GET).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final JsonObject object = rest.as(JsonResponse.class).json().readObject();\n    return Optional.ofNullable(object.getJsonArray(\"check_runs\")).map(obj -> obj.stream().map(RtChecks::check).collect(Collectors.toList())).orElseGet(Collections::emptyList);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.read",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final Response response = this.request.fetch();\n    final String url = response.as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"files\").getJsonObject(file).getString(\"raw_url\");\n    return response.as(RestResponse.class).jump(URI.create(url)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStars.unstar",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPublicMembers.conceal",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.request.uri().path(user.login()).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtStargazers.iterable",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtStargazers.iterable" ],
    "fullMethods" : [ "@Override\npublic Iterable<JsonValue> iterable() throws IOException {\n    final Iterable<JsonValue> res;\n    try (JsonReader json = new JsonResponse(this.request.method(Request.GET).fetch()).json()) {\n        res = json.readArray();\n    }\n    return res;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.react",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtComment.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtIssue.react",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtIssue.react" ],
    "fullMethods" : [ "@Override\npublic void react(final Reaction reaction) throws IOException {\n    final JsonStructure json = Json.createObjectBuilder().add(RtIssue.CONTENT, reaction.type()).build();\n    this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.render",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.render" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String render(final JsonObject json) throws IOException {\n    final StringWriter output = new StringWriter();\n    Json.createWriter(output).writeObject(json);\n    return this.request.body().set(output.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtCollaborators.permission",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtCollaborators.permission" ],
    "fullMethods" : [ "@Override\npublic String permission(final String user) throws IOException {\n    return this.request.method(Request.GET).uri().path(user).path(\"permission\").back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getString(\"permission\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepos.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) throws IOException {\n    this.entry.uri().path(\"/repos\").back().method(Request.DELETE).uri().path(coords.toString()).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtTrees.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtTrees.create" ],
    "fullMethods" : [ "@Override\npublic Tree create(final JsonObject params) throws IOException {\n    return this.get(this.request.method(Request.POST).body().set(params).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtValuePagination.Items.hasNext",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtValuePagination.Items.hasNext", "com.jcabi.github.RtValuePagination.Items.fetch" ],
    "fullMethods" : [ "@Override\npublic boolean hasNext() {\n    synchronized(this.mapping) {\n        if (((this.objects == null) || this.objects.isEmpty()) && this.more) {\n            try {\n                this.fetch();\n            } catch (final IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        return !this.objects.isEmpty();\n    }\n}", "/**\n * Fetch the next portion, if available.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@SuppressWarnings(\"unchecked\")\nprivate void fetch() throws IOException {\n    final RestResponse response = this.request.fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\n    final WebLinkingResponse.Link link = response.as(WebLinkingResponse.class).links().get(\"next\");\n    if (link == null) {\n        this.more = false;\n    } else {\n        this.request = response.jump(link.uri());\n    }\n    final JsonArray arr = response.as(JsonResponse.class).json().readArray();\n    final Queue<P> list = new LinkedList<>();\n    for (final JsonValue value : arr) {\n        list.add(((P) (value)));\n    }\n    this.objects = list;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtPullComments.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.request.uri().path(String.valueOf(number)).back().method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtComment.remove",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.request.method(Request.DELETE).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtHooks.create",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    final JsonObjectBuilder configs = Json.createObjectBuilder();\n    for (final Map.Entry<String, String> entr : config.entrySet()) {\n        configs.add(entr.getKey(), entr.getValue());\n    }\n    final JsonArrayBuilder evnts = Json.createArrayBuilder();\n    for (final Event event : events) {\n        evnts.add(event.toString());\n    }\n    final JsonStructure json = Json.createObjectBuilder().add(\"name\", name).add(\"config\", configs).add(\"active\", active).add(\"events\", evnts).build();\n    return this.get(this.request.method(Request.POST).body().set(json).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGist.star",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGist.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.request.uri().path(\"star\").back().method(\"PUT\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NO_CONTENT);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Label.Unmodified.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Label.Unmodified.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Label label) {\n    return new CompareToBuilder().append(this.repo().coordinates(), label.repo().coordinates()).append(this.obj, label.name()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContent.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.mock.MkContent.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Content cont) {\n    return new CompareToBuilder().append(this.path(), cont.path()).append(this.repo().coordinates(), cont.repo().coordinates()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepoCommit.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.mock.MkRepoCommit.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final RepoCommit other) {\n    return new CompareToBuilder().append(this.repo().coordinates(), other.repo().coordinates()).append(this.sha(), other.sha()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Coordinates.Simple.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Coordinates.Simple.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Coordinates other) {\n    return new CompareToBuilder().append(this.usr, other.user()).append(this.rpo, other.repo()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Coordinates.Https.compareTo",
    "thirdPartyMethod" : "org.apache.commons.lang3.builder.CompareToBuilder.<init>",
    "thirdPartyPackage" : "org.apache.commons.lang3.builder",
    "path" : [ "com.jcabi.github.Coordinates.Https.compareTo" ],
    "fullMethods" : [ "@Override\npublic int compareTo(final Coordinates other) {\n    return new CompareToBuilder().append(this.user(), other.user()).append(this.repo(), other.repo()).build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.patch",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.patch" ],
    "fullMethods" : [ "@Override\npublic String patch(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.patch\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtRepoCommits.diff",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtRepoCommits.diff" ],
    "fullMethods" : [ "@Override\npublic String diff(final String base, final String head) throws IOException {\n    return this.comp.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.diff\").uri().path(String.format(\"%s...%s\", base, head)).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.method(Request.GET).reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    return this.get(this.request.uri().set(URI.create(\"https://uploads.github.com\")).path(\"/repos\").path(this.owner.repo().coordinates().user()).path(this.owner.repo().coordinates().repo()).path(\"/releases\").path(String.valueOf(this.owner.number())).path(\"/assets\").queryParam(\"name\", name).back().method(Request.POST).reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, type).body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getInt(\"id\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtGitignores.template",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtGitignores.template" ],
    "fullMethods" : [ "@Override\npublic String template(final String name) throws IOException {\n    return this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").uri().path(name).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.reset",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.reset" ],
    "fullMethods" : [ "@Override\npublic Request reset(final String name) {\n    return new SearchRequest(this.request.reset(name));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtMarkdown.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtMarkdown.raw" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"unchecked\")\npublic String raw(final String text) throws IOException {\n    return this.request.body().set(text).back().uri().path(\"raw\").back().reset(HttpHeaders.CONTENT_TYPE).header(HttpHeaders.CONTENT_TYPE, MediaType.TEXT_PLAIN).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertHeader(HttpHeaders.CONTENT_TYPE, ((Matcher) (Matchers.everyItem(Matchers.startsWith(MediaType.TEXT_HTML))))).body();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContent.raw",
    "thirdPartyMethod" : "com.jcabi.http.request.FakeRequest.reset",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.request.reset(HttpHeaders.ACCEPT).header(HttpHeaders.ACCEPT, \"application/vnd.github.v3.raw\").fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).binary());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.RetryCarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.send",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.wire.RetryCarefulWire.send" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    return this.real.send(req, home, method, headers, content, connect, read);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.CarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.http.request.ApacheRequest.send",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.wire.CarefulWire.send" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    final Response resp = this.origin.send(req, home, method, headers, content, connect, read);\n    final int remaining = this.remainingHeader(resp);\n    if (remaining < this.threshold) {\n        final long reset = this.resetHeader(resp);\n        final long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n        if (reset > now) {\n            final long length = reset - now;\n            // @checkstyle LineLength (1 line)\n            Logger.info(this, \"Remaining number of requests per hour is less than %d. Waiting for %d seconds.\", this.threshold, length);\n            try {\n                TimeUnit.SECONDS.sleep(length);\n            } catch (final InterruptedException ex) {\n                Thread.currentThread().interrupt();\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return resp;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.iterate",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkContents.iterate" ],
    "fullMethods" : [ "@Override\npublic Iterable<Content> iterate(final String pattern, final String ref) throws IOException {\n    final Collection<XML> nodes = this.storage.xml().nodes(String.format(\"%s/content[@ref='%s']\", this.xpath(), ref));\n    final Collection<Content> result = new ArrayList<>(nodes.size());\n    for (final XML node : nodes) {\n        final String path = node.xpath(\"path/text()\").get(0);\n        if (path.startsWith(pattern)) {\n            result.add(this.mkContent(ref, path));\n        }\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.JsonNode.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.JsonNode.json" ],
    "fullMethods" : [ "/**\n * Fetch JSON object.\n *\n * @return JSON\n * @checkstyle MultipleStringLiteralsCheck (30 lines)\n */\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic JsonObject json() {\n    final JsonObjectBuilder builder = Json.createObjectBuilder();\n    for (final XML child : this.xml.nodes(\"* \")) {\n        final Node node = child.node();\n        if (child.nodes(\"*\").isEmpty()) {\n            builder.add(node.getNodeName(), node.getTextContent());\n        } else if ((!child.xpath(\"//@array\").isEmpty()) && \"true\".equals(child.xpath(\"//@array\").get(0))) {\n            final JsonArrayBuilder bld = Json.createArrayBuilder();\n            for (final XML item : child.nodes(\"*\")) {\n                bld.add(item.node().getTextContent());\n            }\n            builder.add(node.getNodeName(), bld.build());\n        } else {\n            builder.add(node.getNodeName(), new JsonNode(child).json());\n        }\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkNotification.number",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkNotification.number" ],
    "fullMethods" : [ "@Override\npublic long number() {\n    return Long.valueOf(this.data.xpath(\"//id/text()\").get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkMilestones.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final int number;\n    number = 1 + this.storage.xml().xpath(String.format(\"%s/milestone/number/text()\", this.xpath())).size();\n    this.storage.apply(new Directives().xpath(this.xpath()).add(\"milestone\").add(\"number\").set(Integer.toString(number)).up().add(\"title\").set(title).up().add(\"state\").set(Milestone.OPEN_STATE).up().add(\"description\").set(\"mock milestone\").up());\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssues.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue/number/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"issue\").add(\"number\").set(Integer.toString(number)).up().add(\"state\").set(Issue.OPEN_STATE).up().add(\"title\").set(title).up().add(\"body\").set(body).up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"updated_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up().add(\"user\").add(\"login\").set(this.self).up().up());\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"issue #%d created in %s by %s: %[text]s\", number, this.repo().coordinates(), this.self, title);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkBranches.get",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkBranches.get" ],
    "fullMethods" : [ "/**\n * Gets a branch by name.\n *\n * @param name\n * \t\tName of branch.\n * @return The branch with the given name\n * @throws IOException\n * \t\tIf there is an I/O problem\n */\npublic Branch get(final String name) throws IOException {\n    return new MkBranch(this.storage, this.self, this.coords, name, this.storage.xml().nodes(String.format(\"%s/branch[@name='%s']\", this.xpath(), name)).get(0).xpath(MkBranches.XPATH_TO_SHA).get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueEvents.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkIssueEvents.create" ],
    "fullMethods" : [ "/**\n * Creates a new issue event.\n * This has no equivalent in GitHub's public API, since GitHub generates\n * events automatically in response to some other API calls.\n *\n * @param type\n * \t\tType of event\n * @param issue\n * \t\tID number of issue the event is regarding\n * @param login\n * \t\tUsername of actor who caused the event\n * @param label\n * \t\tLabel added or removed\n * @return The newly created issue event\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min Make it possible to set the \"assignee\" field for\n\"assigned\"/\"unassigned\" events. Make it possible to set the\n\"milestone\" field for \"milestoned\"/\"demilestoned\" events. Make it\npossible to set the \"rename\" field for \"renamed\" events. Make it\npossible to set the \"commit_id\" field for events related to commits.\nSee https://developer.github.com/v3/issues/events/ for details.\n * @checkstyle ParameterNumberCheck (4 lines)\n */\npublic Event create(final String type, final int issue, final String login, final Optional<String> label) throws IOException {\n    final String created = new Github.Time().toString();\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue-event/number/text()\", this.xpath())).size();\n        Directives directives = new Directives().xpath(this.xpath()).add(\"issue-event\").add(\"issue\").set(Integer.toString(issue)).up().add(\"number\").set(Integer.toString(number)).up().add(\"event\").set(type).up().add(\"created_at\").set(created).up().add(\"login\").set(login).up();\n        if (label.isPresent()) {\n            directives = directives.add(\"label\").set(label.get()).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(MkEvent.class, \"issue event #%d of type %s created in %s for issue #%d by %s\", number, type, this.self, issue, login);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkAssignees.check",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) {\n    try {\n        final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/user/login/text()\", this.xpath()));\n        return this.self.equalsIgnoreCase(login) || ((!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(login, xpath.get(0)));\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleases.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/release/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"release\").add(\"id\").set(Integer.toString(number)).up().add(\"tag_name\").set(tag).up().add(\"target_commitish\").set(\"master\").up().add(\"name\").set(\"\").up().add(\"body\").set(\"\").up().add(\"draft\").set(\"true\").up().add(\"prerelease\").set(\"false\").up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"published_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up().add(\"assets_url\").set(\"http://localhost/3\").up().add(\"upload_url\").set(\"http://localhost/4\").up());\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.fork",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    this.storage.lock();\n    final String number;\n    try {\n        final XML xml = this.storage.xml();\n        number = Integer.toString(1 + xml.xpath(\"/github/gists/gist/id/text()\").size());\n        final Directives dirs = new Directives().xpath(\"/github/gists\").add(\"gist\").add(\"id\").set(number).up().add(\"files\");\n        final List<XML> files = xml.nodes(String.format(\"%s/files/file\", this.xpath()));\n        for (final XML file : files) {\n            final String filename = file.xpath(\"filename/text()\").get(0);\n            // @checkstyle MultipleStringLiterals (3 lines)\n            dirs.add(\"file\").add(\"filename\").set(filename).up().add(\"raw_content\").set(this.read(filename)).up().up();\n        }\n        this.storage.apply(dirs);\n    } finally {\n        this.storage.unlock();\n    }\n    return new MkGist(this.storage, this.self, number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUserOrganizations.OrganizationMapping.map",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkUserOrganizations.OrganizationMapping.map" ],
    "fullMethods" : [ "@Override\npublic Organization map(final XML xml) {\n    return this.organizations.get(xml.xpath(\"login/text()\").get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPull.head",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkPull.head" ],
    "fullMethods" : [ "@Override\npublic PullRef head() throws IOException {\n    final String userbranch = this.storage.xml().xpath(String.format(\"%s/head/text()\", this.xpath())).get(0);\n    final String[] parts = userbranch.split(MkPull.USER_BRANCH_SEP, 2);\n    if (parts.length != 2) {\n        throw new IllegalStateException(\"Invalid MkPull head\");\n    }\n    final String user = parts[0];\n    final String branch = parts[1];\n    return new MkPullRef(this.storage, new MkBranches(this.storage, this.self, new Coordinates.Simple(user, this.coords.repo())).get(branch));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkHooks.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/hook/id/text()\", this.xpath())).size();\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"hook\").add(\"id\").set(String.valueOf(number)).up().add(\"name\").set(name).up().add(\"active\").set(Boolean.toString(active)).up().add(\"events\");\n        for (final Event event : events) {\n            dirs.add(\"event\").set(event.toString()).up();\n        }\n        dirs.up().add(\"config\");\n        for (final Map.Entry<String, String> entr : config.entrySet()) {\n            dirs.add(entr.getKey()).set(entr.getValue()).up();\n        }\n        this.storage.apply(dirs);\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPull.base",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkPull.base" ],
    "fullMethods" : [ "@Override\npublic PullRef base() throws IOException {\n    return new MkPullRef(this.storage, new MkBranches(this.storage, this.self, this.coords).get(this.storage.xml().xpath(String.format(\"%s/base/text()\", this.xpath())).get(0)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStars.starred",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkStars.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/star/login/text()\", this.xpath()));\n    return (!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(this.self, xpath.get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkDeployKeys.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/deploykey/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"deploykey\").add(\"id\").set(String.valueOf(number)).up().add(\"title\").set(title).up().add(\"key\").set(key));\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContent.raw",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkContent.raw" ],
    "fullMethods" : [ "@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(DatatypeConverter.parseBase64Binary(this.storage.xml().xpath(String.format(\"%s/content/text()\", this.xpath())).get(0)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.MkIssueEventMapping.map",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkIssue.MkIssueEventMapping.map" ],
    "fullMethods" : [ "@Override\npublic Event map(final XML xml) {\n    return this.evts.get(Integer.parseInt(xml.xpath(\"number/text()\").get(0)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAssets.upload",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/asset/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"asset\").add(\"id\").set(Integer.toString(number)).up().add(\"name\").set(name).up().add(\"content\").set(DatatypeConverter.printBase64Binary(content)).up().add(\"content_type\").set(type).up().add(\"size\").set(Integer.toString(content.length)).up().add(\"download_count\").set(\"42\").up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"updated_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up());\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkForks.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String org) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/fork/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"fork\").add(\"id\").set(Integer.toString(number)).up().attr(\"organization\", org));\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"fork %s created inside %s by %s\", this.coords, org, this.self);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAsset.raw",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkReleaseAsset.raw" ],
    "fullMethods" : [ "/**\n * Get raw release asset content.\n *\n * @see <a href=\"https://developer.github.com/v3/repos/releases/\">Releases API</a>\n * @return Stream with content\n * @throws IOException\n * \t\tIf some problem inside.\n */\n@Override\npublic InputStream raw() throws IOException {\n    return new ByteArrayInputStream(this.storage.xml().xpath(String.format(\"%s/content/text()\", this.xpath())).get(0).getBytes(Charsets.UTF_8));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCollaborators.isCollaborator",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkCollaborators.isCollaborator" ],
    "fullMethods" : [ "@Override\npublic boolean isCollaborator(final String user) throws IOException {\n    return !this.storage.xml().xpath(String.format(\"%s/user[login='%s']/text()\", this.xpath(), user)).isEmpty();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUser.markAsRead",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkUser.markAsRead" ],
    "fullMethods" : [ "@Override\npublic void markAsRead(final Date lastread) throws IOException {\n    final Iterable<XML> ids = this.storage.xml().nodes(this.xpath() + String.format(\"/notifications/notification[date <= %s]/id\", lastread.getTime()));\n    final JsonPatch json = new JsonPatch(this.storage);\n    final JsonObject read = Json.createObjectBuilder().add(\"read\", true).build();\n    for (final XML nid : ids) {\n        json.patch(String.format(this.xpath().concat(\"/notifications/notification[id = %s]\"), nid.xpath(\"text()\").get(0)), read);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPull.json",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkPull.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final XML xml = this.storage.xml().nodes(this.xpath()).get(0);\n    final String branch = xml.xpath(\"base/text()\").get(0);\n    final String head = xml.xpath(\"head/text()\").get(0);\n    final String[] parts = head.split(MkPull.USER_BRANCH_SEP, 2);\n    final JsonObject obj = new JsonNode(xml).json();\n    final JsonObjectBuilder json = Json.createObjectBuilder();\n    for (final Map.Entry<String, JsonValue> val : obj.entrySet()) {\n        if (MkPull.NUMBER_PROP.equals(val.getKey())) {\n            json.add(MkPull.NUMBER_PROP, Integer.parseInt(xml.xpath(\"number/text()\").get(0)));\n        } else if (MkPull.USER_PROP.equals(val.getKey())) {\n            json.add(MkPull.USER_PROP, Json.createObjectBuilder().add(\"login\", xml.xpath(\"user/login/text()\").get(0)).build());\n        } else if (MkPull.HEAD_PROP.equals(val.getKey())) {\n            json.add(MkPull.HEAD_PROP, Json.createObjectBuilder().add(MkPull.REF_PROP, parts[1]).add(MkPull.LABEL_PROP, head).build());\n        } else if (MkPull.BASE_PROP.equals(val.getKey())) {\n            json.add(MkPull.BASE_PROP, Json.createObjectBuilder().add(MkPull.REF_PROP, branch).add(MkPull.LABEL_PROP, String.format(\"%s:%s\", this.coords.user(), branch)).build());\n        } else {\n            json.add(val.getKey(), val.getValue());\n        }\n    }\n    json.add(\"comments\", this.storage.xml().nodes(this.comment()).size());\n    return json.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.exists",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkIssue.exists" ],
    "fullMethods" : [ "@Override\npublic boolean exists() throws IOException {\n    return this.storage.xml().xpath(String.format(\"%s/number/text()\", this.xpath())).size() == 1;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCheck.successful",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkCheck.successful" ],
    "fullMethods" : [ "@Override\npublic boolean successful() throws IOException {\n    final XML node = this.storage.xml().nodes(this.xpath()).get(0);\n    final Status status = Status.fromString(node.xpath(\"@status\").get(0));\n    final Conclusion conclusion = Conclusion.fromString(node.xpath(\"@conclusion\").get(0));\n    return (status == Status.COMPLETED) && (conclusion == Conclusion.SUCCESS);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGists.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    this.storage.lock();\n    final String number;\n    try {\n        number = Integer.toString(1 + this.storage.xml().xpath(String.format(\"%s/gist/id/text()\", this.xpath())).size());\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"gist\").add(\"id\").set(number).up().add(\"public\").set(String.valueOf(visible)).up().add(\"files\");\n        for (final Map.Entry<String, String> file : files.entrySet()) {\n            dirs.add(\"file\").add(\"filename\").set(file.getKey()).up().add(\"raw_content\").set(file.getValue()).up().up();\n        }\n        this.storage.apply(dirs);\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPublicKeys.create",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/key/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"key\").add(\"id\").set(String.valueOf(number)).up().add(\"title\").set(title).up().add(\"key\").set(key));\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.read",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkGist.read" ],
    "fullMethods" : [ "@Override\npublic String read(final String file) throws IOException {\n    final List<XML> files = this.storage.xml().nodes(String.format(\"%s/files/file[filename='%s']\", this.xpath(), file));\n    if (files.isEmpty()) {\n        throw new IOException(String.format(\"Couldn't find file with the name %s.\", file));\n    }\n    final List<String> contents = files.get(0).xpath(\"raw_content/text()\");\n    String content = \"\";\n    if (!contents.isEmpty()) {\n        content = contents.get(0);\n    }\n    return content;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.starred",
    "thirdPartyMethod" : "com.jcabi.xml.XMLDocument.xpath",
    "thirdPartyPackage" : "com.jcabi.xml",
    "path" : [ "com.jcabi.github.mock.MkGist.starred" ],
    "fullMethods" : [ "/**\n * Checks if starred.\n *\n * @return True if gist is starred\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@Override\npublic boolean starred() throws IOException {\n    final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/@starred\", this.xpath()));\n    return (!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(Boolean.toString(true), xpath.get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.remove",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtRepoCommit(this.entry, this.owner, this.request.method(Request.DELETE).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).as(JsonResponse.class).json().readObject().getJsonObject(\"commit\").getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtLimit.json",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtLimit.json" ],
    "fullMethods" : [ "@Override\npublic JsonObject json() throws IOException {\n    final JsonObject json = new RtJson(this.entry).fetch().getJsonObject(\"resources\");\n    if (!json.containsKey(this.res)) {\n        throw new IllegalStateException(String.format(\"'%s' is absent in JSON: %s\", this.res, json));\n    }\n    return json.getJsonObject(this.res);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.SmartJson.value",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.SmartJson.value" ],
    "fullMethods" : [ "/**\n * Get its property as custom type.\n *\n * @param name\n * \t\tName of the property\n * @param type\n * \t\tType of result expected\n * @return Value\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @param <T>\n * \t\tType expected\n */\npublic <T> T value(final String name, final Class<T> type) throws IOException {\n    final JsonObject json = this.json();\n    if (!json.containsKey(name)) {\n        throw new IllegalStateException(String.format(\"'%s' is absent in JSON: %s\", name, json));\n    }\n    final JsonValue value = json.get(name);\n    if (value == null) {\n        throw new IllegalStateException(String.format(\"'%s' is NULL in %s\", name, json));\n    }\n    if (value.getClass().isAssignableFrom(type)) {\n        throw new IllegalStateException(String.format(\"'%s' is not of type %s\", name, type));\n    }\n    return type.cast(value);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.remove",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    this.storage.lock();\n    final String path = content.getString(\"path\");\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (content.containsKey(\"ref\")) {\n            branch = content.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"content[path='%s']\", path)).attr(\"ref\", branch).remove());\n        return this.commit(content);\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkEvent.json",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkEvent.json" ],
    "fullMethods" : [ "/**\n * Describes the event in a JSON object.\n *\n * @return JSON object\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min When the event has a label, retrieve and include the\nlabel's color too. MkIssueEvents.create() will also need to be\nupdated accordingly.\n */\n@Override\npublic JsonObject json() throws IOException {\n    final JsonObject obj = new JsonNode(this.storage.xml().nodes(this.xpath()).get(0)).json();\n    JsonObjectBuilder builder = // @checkstyle MultipleStringLiteralsCheck (1 line)\n    // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(\"id\", this.num).add(\"url\", // @checkstyle LineLength (1 line)\n    String.format(\"https://api.jcabi-github.invalid/repos/%s/issues/events/%s\", this.coords, this.num)).add(\"commit_id\", JsonValue.NULL).add(MkEvent.EVENT, obj.getString(MkEvent.EVENT)).add(\"actor\", // @checkstyle MultipleStringLiteralsCheck (1 line)\n    Json.createObjectBuilder().add(MkEvent.LOGIN, obj.getString(MkEvent.LOGIN)).build()).add(MkEvent.CREATED_AT, obj.getString(MkEvent.CREATED_AT));\n    final String label = \"label\";\n    if (obj.containsKey(label)) {\n        builder = builder.add(label, Json.createObjectBuilder().add(\"name\", obj.getString(label)).build());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Issue.Smart.isPull",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Issue.Smart.isPull" ],
    "fullMethods" : [ "/**\n * Is it a pull request?\n *\n * @return TRUE if it is a pull request\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean isPull() throws IOException {\n    return this.json().containsKey(\"pull_request\") && (!this.jsn.value(\"pull_request\", JsonObject.class).isNull(\"html_url\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.update",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.update" ],
    "fullMethods" : [ "/**\n * Updates a file.\n *\n * @param path\n * \t\tThe content path.\n * @param json\n * \t\tJSON object containing updates to the content.\n * @return Commit related to this update.\n * @throws IOException\n * \t\tIf any I/O problem occurs.\n */\n@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    this.storage.lock();\n    try {\n        final String ref = \"ref\";\n        final String branch;\n        if (json.containsKey(ref)) {\n            branch = json.getString(ref);\n        } else {\n            branch = \"master\";\n        }\n        final String xpath = // @checkstyle LineLengthCheck (1 line)\n        String.format(\"/github/repos/repo[@coords='%s']/contents/content[path='%s' and @ref='%s']\", this.coords, path, branch);\n        new JsonPatch(this.storage).patch(xpath, json);\n        return this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.User.Smart.name",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.User.Smart.name" ],
    "fullMethods" : [ "/**\n * Get his name.\n *\n * @return User name\n * @throws IOException\n * \t\tIf it fails\n */\npublic String name() throws IOException {\n    final JsonObject json = this.json();\n    if (!json.containsKey(\"name\")) {\n        throw new IllegalStateException(// @checkstyle LineLength (1 line)\n        String.format(\"User %s doesn't have a name specified in his/her Github account; use #hasName() first.\", this.login()));\n    }\n    return json.getString(\"name\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.User.Smart.hasName",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.User.Smart.hasName" ],
    "fullMethods" : [ "/**\n * Check if user has name.\n *\n * @return True if user has name\n * @throws IOException\n * \t\tIf it fails\n */\npublic boolean hasName() throws IOException {\n    return this.json().containsKey(\"name\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.create",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.mock.MkContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject json) throws IOException {\n    this.storage.lock();\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (json.containsKey(\"ref\")) {\n            branch = json.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"content\").attr(\"ref\", branch).add(\"name\").set(json.getString(\"path\")).up().add(\"path\").set(json.getString(\"path\")).up().add(\"content\").set(json.getString(\"content\")).up().add(\"type\").set(\"file\").up().add(\"encoding\").set(\"base64\").up().add(\"sha\").set(fakeSha()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"git_url\").set(\"http://localhost/2\").up().add(\"html_url\").set(\"http://localhost/3\").up());\n        this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n    return new MkContent(this.storage, this.self, this.coords, json.getString(\"path\"), branch);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtContents.create",
    "thirdPartyMethod" : "javax.json.JsonObject.containsKey",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.RtContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject content) throws IOException {\n    if (!content.containsKey(\"path\")) {\n        throw new IllegalStateException(\"Content should have path parameter\");\n    }\n    final String path = content.getString(\"path\");\n    return new RtContent(this.entry, this.owner, this.request.method(Request.PUT).uri().path(path).back().body().set(content).back().fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_CREATED).as(JsonResponse.class).json().readObject().getJsonObject(\"content\").getString(\"path\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.apply",
    "thirdPartyMethod" : "org.xembly.Xembler.<clinit>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.apply" ],
    "fullMethods" : [ "@Override\npublic void apply(final Iterable<Directive> dirs) throws IOException {\n    synchronized(this.name) {\n        FileUtils.write(new File(this.name), new XMLDocument(new Xembler(dirs).applyQuietly(this.xml().node())).toString(), StandardCharsets.UTF_8);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkAssignees.check",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.equalsIgnoreCase",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkAssignees.check" ],
    "fullMethods" : [ "@Override\npublic boolean check(final String login) {\n    try {\n        final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/user/login/text()\", this.xpath()));\n        return this.self.equalsIgnoreCase(login) || ((!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(login, xpath.get(0)));\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.starred",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.equalsIgnoreCase",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkGist.starred" ],
    "fullMethods" : [ "/**\n * Checks if starred.\n *\n * @return True if gist is starred\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@Override\npublic boolean starred() throws IOException {\n    final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/@starred\", this.xpath()));\n    return (!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(Boolean.toString(true), xpath.get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStars.starred",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.equalsIgnoreCase",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.jcabi.github.mock.MkStars.starred" ],
    "fullMethods" : [ "@Override\npublic boolean starred() throws IOException {\n    final List<String> xpath = this.storage.xml().xpath(String.format(\"%s/star/login/text()\", this.xpath()));\n    return (!xpath.isEmpty()) && StringUtils.equalsIgnoreCase(this.self, xpath.get(0));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkBlobs.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkBlobs.create" ],
    "fullMethods" : [ "@Override\npublic Blob create(final String content, final String encoding) throws IOException {\n    this.storage.lock();\n    final String sha = fakeSha();\n    try {\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"blob\").add(\"sha\").set(sha).up().add(\"url\").set(\"http://localhost/1\").up().attr(\"content\", content).attr(\"encoding\", encoding));\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkMilestones.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkMilestones.create" ],
    "fullMethods" : [ "@Override\npublic Milestone create(final String title) throws IOException {\n    final int number;\n    number = 1 + this.storage.xml().xpath(String.format(\"%s/milestone/number/text()\", this.xpath())).size();\n    this.storage.apply(new Directives().xpath(this.xpath()).add(\"milestone\").add(\"number\").set(Integer.toString(number)).up().add(\"title\").set(title).up().add(\"state\").set(Milestone.OPEN_STATE).up().add(\"description\").set(\"mock milestone\").up());\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssues.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssues.create" ],
    "fullMethods" : [ "@Override\npublic Issue create(final String title, final String body) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue/number/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"issue\").add(\"number\").set(Integer.toString(number)).up().add(\"state\").set(Issue.OPEN_STATE).up().add(\"title\").set(title).up().add(\"body\").set(body).up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"updated_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up().add(\"user\").add(\"login\").set(this.self).up().up());\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"issue #%d created in %s by %s: %[text]s\", number, this.repo().coordinates(), this.self, title);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.comments",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssue.comments", "com.jcabi.github.mock.MkComments.<init>" ],
    "fullMethods" : [ "@Override\npublic Comments comments() {\n    try {\n        return new MkComments(this.storage, this.self, this.coords, this.num);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @param issue\n * \t\tIssue number\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @checkstyle ParameterNumber (5 lines)\n */\nMkComments(final MkStorage stg, final String login, final Coordinates rep, final int issue) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.repo = rep;\n    this.ticket = issue;\n    this.storage.apply(new Directives().xpath(// @checkstyle LineLength (1 line)\n    String.format(\"/github/repos/repo[@coords='%s']/issues/issue[number='%d']\", this.repo, this.ticket)).addIf(\"comments\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUser.emails",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkUser.emails", "com.jcabi.github.mock.MkUserEmails.<init>" ],
    "fullMethods" : [ "@Override\npublic UserEmails emails() {\n    try {\n        return new MkUserEmails(this.storage, this.self);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkUserEmails(final MkStorage stg, final String login) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.storage.apply(new Directives().xpath(this.userXpath()).addIf(\"emails\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGit.trees",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGit.trees", "com.jcabi.github.mock.MkTrees.<init>" ],
    "fullMethods" : [ "@Override\npublic Trees trees() {\n    try {\n        return new MkTrees(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public constructor.\n *\n * @param stg\n * \t\tThe storage.\n * @param login\n * \t\tThe login name.\n * @param rep\n * \t\tRepo's coordinates.\n * @throws IOException\n * \t\tIf something goes wrong.\n */\nMkTrees(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']/git\", this.coords)).addIf(\"trees\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueEvents.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssueEvents.create" ],
    "fullMethods" : [ "/**\n * Creates a new issue event.\n * This has no equivalent in GitHub's public API, since GitHub generates\n * events automatically in response to some other API calls.\n *\n * @param type\n * \t\tType of event\n * @param issue\n * \t\tID number of issue the event is regarding\n * @param login\n * \t\tUsername of actor who caused the event\n * @param label\n * \t\tLabel added or removed\n * @return The newly created issue event\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @todo #1063:30min Make it possible to set the \"assignee\" field for\n\"assigned\"/\"unassigned\" events. Make it possible to set the\n\"milestone\" field for \"milestoned\"/\"demilestoned\" events. Make it\npossible to set the \"rename\" field for \"renamed\" events. Make it\npossible to set the \"commit_id\" field for events related to commits.\nSee https://developer.github.com/v3/issues/events/ for details.\n * @checkstyle ParameterNumberCheck (4 lines)\n */\npublic Event create(final String type, final int issue, final String login, final Optional<String> label) throws IOException {\n    final String created = new Github.Time().toString();\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/issue-event/number/text()\", this.xpath())).size();\n        Directives directives = new Directives().xpath(this.xpath()).add(\"issue-event\").add(\"issue\").set(Integer.toString(issue)).up().add(\"number\").set(Integer.toString(number)).up().add(\"event\").set(type).up().add(\"created_at\").set(created).up().add(\"login\").set(login).up();\n        if (label.isPresent()) {\n            directives = directives.add(\"label\").set(label.get()).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(MkEvent.class, \"issue event #%d of type %s created in %s for issue #%d by %s\", number, type, this.self, issue, login);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepos.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepos.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Coordinates coords) {\n    try {\n        this.storage.apply(new Directives().xpath(String.format(\"%s/repo[@coords='%s']\", this.xpath(), coords)).remove());\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.commits",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.commits", "com.jcabi.github.mock.MkRepoCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic RepoCommits commits() {\n    try {\n        return new MkRepoCommits(this.storage, this.self, this.coordinates());\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param repo\n * \t\tRepository coordinates\n * @throws IOException\n * \t\tIf something goes wrong.\n */\nMkRepoCommits(final MkStorage stg, final String login, final Coordinates repo) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = repo;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"commits\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUsers.add",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkUsers.add" ],
    "fullMethods" : [ "@Override\npublic User add(final String login) {\n    try {\n        this.storage.apply(new Directives().xpath(String.format(\"/github/users[not(user[login='%s'])]\", login)).add(\"user\").add(\"login\").set(login).up().add(\"type\").set(\"User\").up().add(\"name\").set(login).up().add(\"notifications\").up());\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return this.get(login);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRelease.assets",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRelease.assets", "com.jcabi.github.mock.MkReleaseAssets.<init>" ],
    "fullMethods" : [ "@Override\npublic ReleaseAssets assets() {\n    try {\n        return new MkReleaseAssets(this.storage, this.self, this.coords, this.release);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @param number\n * \t\tRelease ID\n * @throws IOException\n * \t\tIf an IO Exception occurs\n * @checkstyle ParameterNumber (7 lines)\n */\nMkReleaseAssets(final MkStorage stg, final String login, final Coordinates rep, final int number) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.rel = number;\n    this.storage.apply(new Directives().xpath(// @checkstyle LineLengthCheck (1 line)\n    String.format(\"/github/repos/repo[@coords='%s']/releases/release[id='%d']\", this.coords, this.rel)).addIf(\"assets\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkOrganizations.get",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkOrganizations.get" ],
    "fullMethods" : [ "@Override\npublic Organization get(final String login) {\n    try {\n        this.storage.apply(new Directives().xpath(String.format(\"/github/orgs[not(org[login='%s'])]\", login)).add(\"org\").add(\"login\").set(login).up().add(\"members\").up());\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return new MkOrganization(this.storage, login);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkComments.post",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkComments.post" ],
    "fullMethods" : [ "@Override\npublic Comment post(final String text) throws IOException {\n    this.storage.lock();\n    final long number;\n    try {\n        final String timestamp = new Github.Time().toString();\n        number = 1 + this.storage.xml().nodes(\"//comment/number\").size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"comment\").add(\"number\").set(Long.toString(number)).up().add(\"url\").set(// @checkstyle LineLength (1 line)\n        String.format(\"https://api.jcabi-github.invalid/repos/%s/%s/issues/comments/%d\", this.repo.user(), this.repo.repo(), number)).up().add(\"body\").set(text).up().add(\"user\").add(\"login\").set(this.self).up().up().add(\"created_at\").set(timestamp).up().add(\"updated_at\").set(timestamp));\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"comment #%d posted to issue #%d by %s: %[text]s\", number, this.issue().number(), this.self, text);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.labels",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssue.labels", "com.jcabi.github.mock.MkIssueLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueLabels labels() {\n    try {\n        return new MkIssueLabels(this.storage, this.self, this.coords, this.num);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tLogin\n * @param rep\n * \t\tRepo\n * @param issue\n * \t\tIssue number\n * @throws IOException\n * \t\tIf fails\n * @checkstyle ParameterNumber (5 lines)\n */\nMkIssueLabels(final MkStorage stg, final String login, final Coordinates rep, final int issue) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.repo = rep;\n    this.ticket = issue;\n    this.storage.apply(new Directives().xpath(// @checkstyle LineLength (1 line)\n    String.format(\"/github/repos/repo[@coords='%s']/issues/issue[number='%d']\", rep, this.ticket)).addIf(\"labels\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUserEmails.add",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkUserEmails.add" ],
    "fullMethods" : [ "@Override\npublic Iterable<String> add(final Iterable<String> emails) throws IOException {\n    this.storage.lock();\n    try {\n        final Directives directives = new Directives().xpath(this.xpath());\n        for (final String email : emails) {\n            directives.add(\"email\").set(email).up();\n        }\n        this.storage.apply(directives);\n    } finally {\n        this.storage.unlock();\n    }\n    return emails;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPublicMembers.conceal",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPublicMembers.conceal" ],
    "fullMethods" : [ "@Override\npublic void conceal(final User user) throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath(user)).set(\"false\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPulls.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPulls.create" ],
    "fullMethods" : [ "@Override\npublic Pull create(final String title, final String head, final String base) throws IOException {\n    if (head.isEmpty()) {\n        throw new IllegalArgumentException(\"head cannot be empty!\");\n    }\n    if (base.isEmpty()) {\n        throw new IllegalArgumentException(\"base cannot be empty!\");\n    }\n    final String canonical;\n    if (head.contains(MkPulls.USER_BRANCH_SEP)) {\n        canonical = head;\n    } else {\n        canonical = String.format(\"%s%s%s\", this.coords.user(), MkPulls.USER_BRANCH_SEP, head);\n    }\n    this.storage.lock();\n    final int number;\n    try {\n        final Issue issue = this.repo().issues().create(title, \"some body\");\n        number = issue.number();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"pull\").add(\"number\").set(Integer.toString(number)).up().add(\"head\").set(canonical).up().add(\"base\").set(base).up().add(\"checks\").up().add(\"user\").add(\"login\").set(this.self).up());\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkHooks.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkHooks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic MkHooks(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"hooks\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.update",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkContents.update", "com.jcabi.github.mock.JsonPatch.patch" ],
    "fullMethods" : [ "/**\n * Updates a file.\n *\n * @param path\n * \t\tThe content path.\n * @param json\n * \t\tJSON object containing updates to the content.\n * @return Commit related to this update.\n * @throws IOException\n * \t\tIf any I/O problem occurs.\n */\n@Override\npublic RepoCommit update(final String path, final JsonObject json) throws IOException {\n    this.storage.lock();\n    try {\n        final String ref = \"ref\";\n        final String branch;\n        if (json.containsKey(ref)) {\n            branch = json.getString(ref);\n        } else {\n            branch = \"master\";\n        }\n        final String xpath = // @checkstyle LineLengthCheck (1 line)\n        String.format(\"/github/repos/repo[@coords='%s']/contents/content[path='%s' and @ref='%s']\", this.coords, path, branch);\n        new JsonPatch(this.storage).patch(xpath, json);\n        return this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n}", "/**\n * Patch an XML object/element.\n *\n * @param xpath\n * \t\tXPath to locate the node to patch\n * @param obj\n * \t\tObject to apply\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void patch(final String xpath, final JsonObject obj) throws IOException {\n    final Directives dirs = new Directives().xpath(xpath);\n    for (final Map.Entry<String, JsonValue> entry : obj.entrySet()) {\n        dirs.addIf(entry.getKey()).set(StringUtils.strip(entry.getValue().toString(), \"\\\"\")).up();\n    }\n    this.storage.apply(dirs);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPull.head",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPull.head", "com.jcabi.github.mock.MkBranches.<init>" ],
    "fullMethods" : [ "@Override\npublic PullRef head() throws IOException {\n    final String userbranch = this.storage.xml().xpath(String.format(\"%s/head/text()\", this.xpath())).get(0);\n    final String[] parts = userbranch.split(MkPull.USER_BRANCH_SEP, 2);\n    if (parts.length != 2) {\n        throw new IllegalStateException(\"Invalid MkPull head\");\n    }\n    final String user = parts[0];\n    final String branch = parts[1];\n    return new MkPullRef(this.storage, new MkBranches(this.storage, this.self, new Coordinates.Simple(user, this.coords.repo())).get(branch));\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUsername\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkBranches(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"branches\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.pulls",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.pulls", "com.jcabi.github.mock.MkPulls.<init>" ],
    "fullMethods" : [ "@Override\npublic Pulls pulls() {\n    try {\n        return new MkPulls(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkPulls(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"pulls\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkLabels.delete",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkLabels.delete" ],
    "fullMethods" : [ "@Override\npublic void delete(final String name) throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"label[name='%s']\", name)).remove().xpath(\"/github/repos\").xpath(String.format(\"repo[@coords='%s']\", this.coords)).xpath(String.format(\"issues/issue/labels/label[.='%s']\", name)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.JsonPatch.patch",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.JsonPatch.patch" ],
    "fullMethods" : [ "/**\n * Patch an XML object/element.\n *\n * @param xpath\n * \t\tXPath to locate the node to patch\n * @param obj\n * \t\tObject to apply\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void patch(final String xpath, final JsonObject obj) throws IOException {\n    final Directives dirs = new Directives().xpath(xpath);\n    for (final Map.Entry<String, JsonValue> entry : obj.entrySet()) {\n        dirs.addIf(entry.getKey()).set(StringUtils.strip(entry.getValue().toString(), \"\\\"\")).up();\n    }\n    this.storage.apply(dirs);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.keys",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.keys", "com.jcabi.github.mock.MkDeployKeys.<init>" ],
    "fullMethods" : [ "@Override\npublic DeployKeys keys() {\n    try {\n        return new MkDeployKeys(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkDeployKeys(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"deploykeys\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReferences.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReferences.create" ],
    "fullMethods" : [ "@Override\npublic Reference create(final String ref, final String sha) throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).add(\"reference\").add(\"ref\").set(ref).up().add(\"sha\").set(sha).up());\n    return this.get(ref);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStars.unstar",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkStars.unstar" ],
    "fullMethods" : [ "@Override\npublic void unstar() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"star/login[.='%s']\", this.self)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.branches",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.branches", "com.jcabi.github.mock.MkBranches.<init>" ],
    "fullMethods" : [ "@Override\npublic Branches branches() {\n    try {\n        return new MkBranches(this.storage, this.self, this.coordinates());\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUsername\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkBranches(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"branches\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkHooks.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkHooks.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/hook[id='%d']\", this.xpath(), number)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.organizations",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGithub.organizations", "com.jcabi.github.mock.MkOrganizations.<init>" ],
    "fullMethods" : [ "@Override\npublic Organizations organizations() {\n    try {\n        return new MkOrganizations(this.storage);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkOrganizations(final MkStorage stg) throws IOException {\n    this.storage = stg;\n    this.storage.apply(new Directives().xpath(\"/github\").addIf(\"orgs\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAssets.upload",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReleaseAssets.upload" ],
    "fullMethods" : [ "@Override\npublic ReleaseAsset upload(final byte[] content, final String type, final String name) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/asset/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"asset\").add(\"id\").set(Integer.toString(number)).up().add(\"name\").set(name).up().add(\"content\").set(DatatypeConverter.printBase64Binary(content)).up().add(\"content_type\").set(type).up().add(\"size\").set(Integer.toString(content.length)).up().add(\"download_count\").set(\"42\").up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"updated_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up());\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRelease.delete",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRelease.delete" ],
    "fullMethods" : [ "@Override\npublic void delete() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.labels",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.labels", "com.jcabi.github.mock.MkLabels.<init>" ],
    "fullMethods" : [ "@Override\npublic Labels labels() {\n    try {\n        return new MkLabels(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkLabels(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"labels\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkContents.create" ],
    "fullMethods" : [ "@Override\npublic Content create(final JsonObject json) throws IOException {\n    this.storage.lock();\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (json.containsKey(\"ref\")) {\n            branch = json.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"content\").attr(\"ref\", branch).add(\"name\").set(json.getString(\"path\")).up().add(\"path\").set(json.getString(\"path\")).up().add(\"content\").set(json.getString(\"content\")).up().add(\"type\").set(\"file\").up().add(\"encoding\").set(\"base64\").up().add(\"sha\").set(fakeSha()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"git_url\").set(\"http://localhost/2\").up().add(\"html_url\").set(\"http://localhost/3\").up());\n        this.commit(json);\n    } finally {\n        this.storage.unlock();\n    }\n    return new MkContent(this.storage, this.self, this.coords, json.getString(\"path\"), branch);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepos.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepos.create" ],
    "fullMethods" : [ "@Override\npublic Repo create(final RepoCreate settings) throws IOException {\n    String owner = this.self;\n    final String org = settings.organization();\n    if ((org != null) && (!org.isEmpty())) {\n        owner = \"/orgs/\".concat(org).concat(\"/repos\");\n    }\n    final Coordinates coords = new Coordinates.Simple(owner, settings.name());\n    this.storage.apply(new Directives().xpath(this.xpath()).add(\"repo\").attr(\"coords\", coords.toString()).add(\"name\").set(settings.name()).up().add(\"description\").set(\"test repository\").up().add(\"private\").set(settings.isPrivate()).up());\n    final Repo repo = this.get(coords);\n    repo.patch(settings.json());\n    Logger.info(this, \"repository %s created by %s\", coords, owner);\n    return repo;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkDeployKey.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkDeployKey.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPublicKeys.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPublicKeys.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic MkPublicKeys(final MkStorage stg, final String login) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.storage.apply(new Directives().xpath(this.userXpath()).addIf(\"keys\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPublicKeys.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPublicKeys.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/key[id='%d']\", this.xpath(), number)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCollaborators.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkCollaborators.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param crds\n * \t\tCoordinates\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic MkCollaborators(final MkStorage stg, final String login, final Coordinates crds) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = crds;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"collaborators\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGists.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGists.create" ],
    "fullMethods" : [ "@Override\npublic Gist create(final Map<String, String> files, final boolean visible) throws IOException {\n    this.storage.lock();\n    final String number;\n    try {\n        number = Integer.toString(1 + this.storage.xml().xpath(String.format(\"%s/gist/id/text()\", this.xpath())).size());\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"gist\").add(\"id\").set(number).up().add(\"public\").set(String.valueOf(visible)).up().add(\"files\");\n        for (final Map.Entry<String, String> file : files.entrySet()) {\n            dirs.add(\"file\").add(\"filename\").set(file.getKey()).up().add(\"raw_content\").set(file.getValue()).up().up();\n        }\n        this.storage.apply(dirs);\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUserOrganizations.iterate",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkUserOrganizations.iterate", "com.jcabi.github.mock.MkOrganizations.<init>" ],
    "fullMethods" : [ "@Override\npublic Iterable<Organization> iterate() throws IOException {\n    return new MkIterable<>(this.storage, \"/github/orgs/org\", new OrganizationMapping(new MkOrganizations(this.storage)));\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkOrganizations(final MkStorage stg) throws IOException {\n    this.storage = stg;\n    this.storage.apply(new Directives().xpath(\"/github\").addIf(\"orgs\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPull.comments",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPull.comments", "com.jcabi.github.mock.MkPullComments.<init>" ],
    "fullMethods" : [ "@Override\npublic PullComments comments() throws IOException {\n    return new MkPullComments(this.storage, this.self, this.coords, this);\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @param pull\n * \t\tPull\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @checkstyle ParameterNumber (5 lines)\n */\nMkPullComments(final MkStorage stg, final String login, final Coordinates rep, final Pull pull) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.repo = rep;\n    this.owner = pull;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']/pulls/pull[number='%d']\", this.repo, this.owner.number())).addIf(\"comments\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGit.tags",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGit.tags", "com.jcabi.github.mock.MkTags.<init>" ],
    "fullMethods" : [ "@Override\npublic Tags tags() {\n    try {\n        return new MkTags(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public constructor.\n *\n * @param stg\n * \t\tThe storage.\n * @param login\n * \t\tThe login name.\n * @param rep\n * \t\tRepo's coordinates.\n * @throws IOException\n * \t\tIf something goes wrong.\n */\nMkTags(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']/git\", this.coords)).addIf(\"tags\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkComment.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkComment.remove" ],
    "fullMethods" : [ "@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.issues",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.issues", "com.jcabi.github.mock.MkIssues.<init>" ],
    "fullMethods" : [ "@Override\npublic Issues issues() {\n    try {\n        return new MkIssues(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkIssues(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"issues\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGists.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGists.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/gist[id='%s']\", this.xpath(), identifier)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkOrganization.addMember",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkOrganization.addMember" ],
    "fullMethods" : [ "/**\n * Add the given user to this organization.\n *\n * @param user\n * \t\tUser to add to the organization\n * @todo #1107:30min Implement the \"Add team membership\" API (see\nhttps://developer.github.com/v3/orgs/teams/#add-team-membership )\n(per https://developer.github.com/v3/orgs/members/#add-a-member ,\nyou can't add a user directly to an org; you instead add them to one\nof that org's teams) and replace uses of this method with uses of that\nAPI (or downgrade this method to a convenience method for unit tests).\n */\npublic void addMember(final User user) {\n    try {\n        this.storage.apply(new Directives().xpath(String.format(\"%s/members\", this.xpath())).add(\"member\").add(LOGIN_KEY).set(user.login()).up().add(\"public\").set(\"false\").up());\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.write",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGist.write" ],
    "fullMethods" : [ "@Override\npublic void write(final String file, final String content) throws IOException {\n    // @checkstyle MultipleStringLiterals (3 lines)\n    this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"files[not(file[filename='%s'])]\", file)).add(\"file\").add(\"filename\").set(file).up().add(\"raw_content\"));\n    this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"files/file[filename='%s']/raw_content\", file)).set(content));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.unstar",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGist.unstar" ],
    "fullMethods" : [ "/**\n * Unstars.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @checkstyle MultipleStringLiterals (10 lines)\n */\n@Override\npublic void unstar() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).attr(\"starred\", Boolean.toString(false)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.star",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGist.star" ],
    "fullMethods" : [ "/**\n * Stars.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @checkstyle MultipleStringLiterals (10 lines)\n */\n@Override\npublic void star() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).attr(\"starred\", Boolean.toString(true)));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.patch",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssue.patch", "com.jcabi.github.mock.JsonPatch.patch" ],
    "fullMethods" : [ "@Override\npublic void patch(final JsonObject json) throws IOException {\n    final Issue.Smart smart = new Issue.Smart(this);\n    final boolean was = smart.isOpen();\n    new JsonPatch(this.storage).patch(this.xpath(), json);\n    final boolean now = smart.isOpen();\n    if (now != was) {\n        final String type;\n        if (now) {\n            type = Event.REOPENED;\n        } else {\n            type = Event.CLOSED;\n        }\n        new MkIssueEvents(this.storage, this.self, this.coords).create(type, this.num, this.self, Optional.<String>absent());\n    }\n}", "/**\n * Patch an XML object/element.\n *\n * @param xpath\n * \t\tXPath to locate the node to patch\n * @param obj\n * \t\tObject to apply\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic void patch(final String xpath, final JsonObject obj) throws IOException {\n    final Directives dirs = new Directives().xpath(xpath);\n    for (final Map.Entry<String, JsonValue> entry : obj.entrySet()) {\n        dirs.addIf(entry.getKey()).set(StringUtils.strip(entry.getValue().toString(), \"\\\"\")).up();\n    }\n    this.storage.apply(dirs);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleases.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReleases.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.lock();\n    try {\n        this.storage.apply(new Directives().xpath(String.format(\"%s/release[id='%d']\", this.xpath(), number)).remove());\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkMilestones.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkMilestones.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/milestone[number='%d']\", this.xpath(), number)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCollaborators.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkCollaborators.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String user) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/user[login='%s']\", this.xpath(), user)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleaseAsset.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReleaseAsset.remove" ],
    "fullMethods" : [ "/**\n * Remove asset.\n *\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\n@Override\npublic void remove() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).strict(1).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.gists",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGithub.gists", "com.jcabi.github.mock.MkGists.<init>" ],
    "fullMethods" : [ "@Override\npublic Gists gists() {\n    try {\n        return new MkGists(this.storage, this.self);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkGists(final MkStorage stg, final String login) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.storage.apply(new Directives().xpath(\"/github\").addIf(\"gists\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPullComments.post",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPullComments.post" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (7 lines)\n@Override\npublic PullComment post(final String body, final String commit, final String path, final int position) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().nodes(String.format(\"%s/comment/id/text()\", this.xpath())).size();\n        this.storage.apply(// @checkstyle MultipleStringLiteralsCheck (4 lines)\n        new Directives().xpath(this.xpath()).add(\"comment\").add(\"id\").set(Integer.toString(number)).up().add(\"url\").set(\"http://localhost/1\").up().add(\"diff_hunk\").set(\"@@ -16,33 +16,40 @@ public...\").up().add(\"path\").set(path).up().add(\"position\").set(Integer.toString(position)).up().add(\"original_position\").set(Integer.toString(number)).up().add(\"commit_id\").set(commit).up().add(\"original_commit_id\").set(commit).up().add(\"body\").set(body).up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"published_at\").set(new Github.Time().toString()).up().add(\"user\").add(\"login\").set(this.self).up().add(\"pull_request_url\").set(\"http://localhost/2\").up());\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleases.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReleases.create" ],
    "fullMethods" : [ "@Override\npublic Release create(final String tag) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/release/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"release\").add(\"id\").set(Integer.toString(number)).up().add(\"tag_name\").set(tag).up().add(\"target_commitish\").set(\"master\").up().add(\"name\").set(\"\").up().add(\"body\").set(\"\").up().add(\"draft\").set(\"true\").up().add(\"prerelease\").set(\"false\").up().add(\"created_at\").set(new Github.Time().toString()).up().add(\"published_at\").set(new Github.Time().toString()).up().add(\"url\").set(\"http://localhost/1\").up().add(\"html_url\").set(\"http://localhost/2\").up().add(\"assets_url\").set(\"http://localhost/3\").up().add(\"upload_url\").set(\"http://localhost/4\").up());\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGist.fork",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGist.fork" ],
    "fullMethods" : [ "@Override\npublic Gist fork() throws IOException {\n    this.storage.lock();\n    final String number;\n    try {\n        final XML xml = this.storage.xml();\n        number = Integer.toString(1 + xml.xpath(\"/github/gists/gist/id/text()\").size());\n        final Directives dirs = new Directives().xpath(\"/github/gists\").add(\"gist\").add(\"id\").set(number).up().add(\"files\");\n        final List<XML> files = xml.nodes(String.format(\"%s/files/file\", this.xpath()));\n        for (final XML file : files) {\n            final String filename = file.xpath(\"filename/text()\").get(0);\n            // @checkstyle MultipleStringLiterals (3 lines)\n            dirs.add(\"file\").add(\"filename\").set(filename).up().add(\"raw_content\").set(this.read(filename)).up().up();\n        }\n        this.storage.apply(dirs);\n    } finally {\n        this.storage.unlock();\n    }\n    return new MkGist(this.storage, this.self, number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGit.commits",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGit.commits", "com.jcabi.github.mock.MkCommits.<init>" ],
    "fullMethods" : [ "@Override\npublic Commits commits() {\n    try {\n        return new MkCommits(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public constructor.\n *\n * @param stg\n * \t\tThe storage.\n * @param login\n * \t\tThe login name.\n * @param rep\n * \t\tRepo's coordinates.\n * @throws IOException\n * \t\tIf something goes wrong.\n */\nMkCommits(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']/git\", this.coords)).addIf(\"commits\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkChecks.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkChecks.create" ],
    "fullMethods" : [ "/**\n * Create check.\n *\n * @param status\n * \t\tStatus.\n * @param conclusion\n * \t\tConclusion.\n * @return Check.\n * @throws IOException\n * \t\tIf fails.\n */\npublic Check create(final Check.Status status, final Check.Conclusion conclusion) throws IOException {\n    final int identifier = new SecureRandom().nextInt();\n    final Directives directives = new Directives().xpath(this.xpath()).add(\"check\").attr(\"id\", identifier).attr(\"status\", status.value()).attr(\"conclusion\", conclusion.value()).up();\n    this.storage.apply(directives);\n    return new MkCheck(this.storage, this.coordinates, this.pull, identifier);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTags.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkTags.create" ],
    "fullMethods" : [ "@Override\npublic Tag create(final JsonObject params) throws IOException {\n    final Directives dirs = new Directives().xpath(this.xpath()).add(\"tag\");\n    for (final Entry<String, JsonValue> entry : params.entrySet()) {\n        dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n    }\n    this.storage.apply(dirs);\n    new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder().append(\"refs/tags/\").append(params.getString(\"name\")).toString(), params.getString(\"sha\"));\n    return this.get(params.getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkBlobs.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkBlobs.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws java.io.IOException\n * \t\tIf there is any I/O problem\n */\npublic MkBlobs(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']/git\", this.coords)).addIf(\"blobs\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGit.references",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGit.references", "com.jcabi.github.mock.MkReferences.<init>" ],
    "fullMethods" : [ "@Override\npublic References references() {\n    try {\n        return new MkReferences(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public constructor.\n *\n * @param stg\n * \t\tStorage.\n * @param login\n * \t\tLogin name.\n * @param rep\n * \t\tRepo coordinates.\n * @throws IOException\n * \t\t- If something goes wrong.\n */\nMkReferences(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']/git\", this.coords)).addIf(\"refs\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkTrees.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkTrees.create" ],
    "fullMethods" : [ "@Override\n@SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\npublic Tree create(final JsonObject params) throws IOException {\n    final JsonArray trees = params.getJsonArray(\"tree\");\n    for (final JsonValue val : trees) {\n        final JsonObject tree = ((JsonObject) (val));\n        final String sha = tree.getString(\"sha\");\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"tree\");\n        for (final Entry<String, JsonValue> entry : tree.entrySet()) {\n            dirs.add(entry.getKey()).set(entry.getValue().toString()).up();\n        }\n        this.storage.apply(dirs);\n        final String ref;\n        if (tree.containsValue(\"name\")) {\n            ref = tree.getString(\"name\");\n        } else {\n            ref = sha;\n        }\n        new MkReferences(this.storage, this.self, this.coords).create(new StringBuilder(\"refs/trees/\").append(ref).toString(), sha);\n    }\n    return this.get(trees.getJsonObject(0).getString(\"sha\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkHooks.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkHooks.create" ],
    "fullMethods" : [ "// @checkstyle ParameterNumberCheck (2 lines)\n@Override\npublic Hook create(final String name, final Map<String, String> config, final Iterable<Event> events, final boolean active) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/hook/id/text()\", this.xpath())).size();\n        final Directives dirs = new Directives().xpath(this.xpath()).add(\"hook\").add(\"id\").set(String.valueOf(number)).up().add(\"name\").set(name).up().add(\"active\").set(Boolean.toString(active)).up().add(\"events\");\n        for (final Event event : events) {\n            dirs.add(\"event\").set(event.toString()).up();\n        }\n        dirs.up().add(\"config\");\n        for (final Map.Entry<String, String> entr : config.entrySet()) {\n            dirs.add(entr.getKey()).set(entr.getValue()).up();\n        }\n        this.storage.apply(dirs);\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReferences.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReferences.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String identifier) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/reference[ref='%s']\", this.xpath(), identifier)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkLabels.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkLabels.create" ],
    "fullMethods" : [ "@Override\npublic Label create(final String name, final String color) throws IOException {\n    if (!color.matches(\"[0-9a-f]{6}\")) {\n        throw new IllegalArgumentException(String.format(\"color '%s' is in wrong format, six hex letters expected\", color));\n    }\n    this.storage.apply(new Directives().xpath(this.xpath()).add(\"label\").add(\"name\").set(name).up().add(\"color\").set(color).up());\n    return this.get(name);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPull.base",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPull.base", "com.jcabi.github.mock.MkBranches.<init>" ],
    "fullMethods" : [ "@Override\npublic PullRef base() throws IOException {\n    return new MkPullRef(this.storage, new MkBranches(this.storage, this.self, this.coords).get(this.storage.xml().xpath(String.format(\"%s/base/text()\", this.xpath())).get(0)));\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUsername\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkBranches(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"branches\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStars.star",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkStars.star" ],
    "fullMethods" : [ "@Override\npublic void star() throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath()).add(\"star\").add(\"login\").set(this.self));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkDeployKeys.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkDeployKeys.create" ],
    "fullMethods" : [ "@Override\npublic DeployKey create(final String title, final String key) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/deploykey/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"deploykey\").add(\"id\").set(String.valueOf(number)).up().add(\"title\").set(title).up().add(\"key\").set(key));\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.repos",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGithub.repos", "com.jcabi.github.mock.MkRepos.<init>" ],
    "fullMethods" : [ "@Override\npublic Repos repos() {\n    try {\n        return new MkRepos(this.storage, this.self);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkRepos(final MkStorage stg, final String login) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.storage.apply(new Directives().xpath(\"/github\").addIf(\"repos\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkContents.remove" ],
    "fullMethods" : [ "@Override\npublic RepoCommit remove(final JsonObject content) throws IOException {\n    this.storage.lock();\n    final String path = content.getString(\"path\");\n    // @checkstyle MultipleStringLiterals (20 lines)\n    final String branch;\n    try {\n        if (content.containsKey(\"ref\")) {\n            branch = content.getString(\"ref\");\n        } else {\n            branch = \"master\";\n        }\n        this.storage.apply(new Directives().xpath(this.xpath()).xpath(String.format(\"content[path='%s']\", path)).attr(\"ref\", branch).remove());\n        return this.commit(content);\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.stars",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.stars", "com.jcabi.github.mock.MkStars.<init>" ],
    "fullMethods" : [ "@Override\npublic Stars stars() {\n    try {\n        return new MkStars(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tThe storage.\n * @param login\n * \t\tThe login name.\n * @param rep\n * \t\tThe Repository.\n * @throws java.io.IOException\n * \t\tIf something goes wrong.\n */\nMkStars(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(\"/github/repos/repo\").addIf(\"stars\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGit.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGit.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic MkGit(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"git\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkForks.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkForks.create" ],
    "fullMethods" : [ "@Override\npublic Fork create(final String org) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/fork/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"fork\").add(\"id\").set(Integer.toString(number)).up().attr(\"organization\", org));\n    } finally {\n        this.storage.unlock();\n    }\n    Logger.info(this, \"fork %s created inside %s by %s\", this.coords, org, this.self);\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPublicMembers.publicize",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPublicMembers.publicize" ],
    "fullMethods" : [ "@Override\npublic void publicize(final User user) throws IOException {\n    this.storage.apply(new Directives().xpath(this.xpath(user)).set(\"true\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueLabels.add",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssueLabels.add" ],
    "fullMethods" : [ "@Override\npublic void add(final Iterable<String> labels) throws IOException {\n    final Collection<String> existing = this.labels();\n    final Set<String> added = new HashSet<>();\n    final Directives dirs = new Directives().xpath(this.xpath());\n    for (final String label : labels) {\n        dirs.add(\"label\").set(label).up();\n        if (!existing.contains(label)) {\n            added.add(label);\n        }\n    }\n    this.storage.apply(dirs);\n    if (!added.isEmpty()) {\n        final MkIssueEvents events = new MkIssueEvents(this.storage, this.self, this.repo);\n        for (final String label : added) {\n            events.create(Event.LABELED, this.ticket, this.self, Optional.of(label));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.issueEvents",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.issueEvents", "com.jcabi.github.mock.MkIssueEvents.<init>" ],
    "fullMethods" : [ "@Override\npublic IssueEvents issueEvents() {\n    try {\n        return new MkIssueEvents(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public constructor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkIssueEvents(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"issue-events\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPullComments.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPullComments.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final int number) throws IOException {\n    this.storage.apply(new Directives().xpath(String.format(\"%s/comment[id='%d']\", this.xpath(), number)).remove());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkContents.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkContents.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic MkContents(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"contents\").up().addIf(\"commits\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkRepo.milestones",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkRepo.milestones", "com.jcabi.github.mock.MkMilestones.<init>" ],
    "fullMethods" : [ "@Override\npublic Milestones milestones() {\n    try {\n        return new MkMilestones(this.storage, this.self, this.coords);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * MkMilestones ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\t- if any I/O problem occurs\n */\nMkMilestones(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"milestones\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkCollaborators.add",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkCollaborators.add" ],
    "fullMethods" : [ "@Override\npublic void add(final String user) throws IOException {\n    this.storage.lock();\n    try {\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"user\").add(\"login\").set(user));\n    } finally {\n        this.storage.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkReleases.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkReleases.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic MkReleases(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"releases\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkPublicKeys.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkPublicKeys.create" ],
    "fullMethods" : [ "@Override\npublic PublicKey create(final String title, final String key) throws IOException {\n    this.storage.lock();\n    final int number;\n    try {\n        number = 1 + this.storage.xml().xpath(String.format(\"%s/key/id/text()\", this.xpath())).size();\n        this.storage.apply(new Directives().xpath(this.xpath()).add(\"key\").add(\"id\").set(String.valueOf(number)).up().add(\"title\").set(title).up().add(\"key\").set(key));\n    } finally {\n        this.storage.unlock();\n    }\n    return this.get(number);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUserEmails.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkUserEmails.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final Iterable<String> emails) throws IOException {\n    final Directives directives = new Directives();\n    for (final String email : emails) {\n        directives.xpath(String.format(\"%s/email[.='%s']\", this.xpath(), email)).remove();\n    }\n    this.storage.apply(directives);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkBranches.create",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkBranches.create" ],
    "fullMethods" : [ "/**\n * Creates a new branch.\n *\n * @param name\n * \t\tName of branch\n * @param sha\n * \t\tCommit SHA\n * @return New branch\n * @throws IOException\n * \t\tif there is an I/O problem\n */\npublic Branch create(final String name, final String sha) throws IOException {\n    final Directives directives = new Directives().xpath(this.xpath()).add(\"branch\").attr(\"name\", name).add(\"sha\").set(sha).up();\n    this.storage.apply(directives);\n    return new MkBranch(this.storage, this.self, this.coords, name, sha);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkUser.organizations",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkUser.organizations", "com.jcabi.github.mock.MkUserOrganizations.<init>" ],
    "fullMethods" : [ "@Override\npublic UserOrganizations organizations() {\n    try {\n        return new MkUserOrganizations(this.storage, this.self);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkUserOrganizations(final MkStorage stg, final String login) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.storage.apply(new Directives().xpath(\"/github\").addIf(\"orgs\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssueLabels.remove",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssueLabels.remove" ],
    "fullMethods" : [ "@Override\npublic void remove(final String name) throws IOException {\n    if (this.labels().contains(name)) {\n        this.storage.apply(new Directives().xpath(String.format(\"%s/label[.='%s']\", this.xpath(), name)).remove());\n        new MkIssueEvents(this.storage, this.self, this.repo).create(Event.UNLABELED, this.ticket, this.self, Optional.of(name));\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkGithub.users",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkGithub.users", "com.jcabi.github.mock.MkUsers.<init>" ],
    "fullMethods" : [ "@Override\npublic Users users() {\n    try {\n        return new MkUsers(this.storage, this.self);\n    } catch (final IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}", "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkUsers(final MkStorage stg, final String login) throws IOException {\n    this.storage = stg;\n    this.himself = login;\n    this.storage.apply(new Directives().xpath(\"/github\").addIf(\"users\"));\n    this.add(login);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.MkIssueEventMapping.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkIssue.MkIssueEventMapping.<init>", "com.jcabi.github.mock.MkIssueEvents.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param issue\n * \t\tMock issue to get events from\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic MkIssueEventMapping(final MkIssue issue) throws IOException {\n    this.evts = new MkIssueEvents(issue.storage, issue.self, issue.coords);\n}", "/**\n * Public constructor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\nMkIssueEvents(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"issue-events\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkForks.<init>",
    "thirdPartyMethod" : "org.xembly.Directives.<init>",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkForks.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stg\n * \t\tStorage\n * @param login\n * \t\tUser to login\n * @param rep\n * \t\tRepo\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic MkForks(final MkStorage stg, final String login, final Coordinates rep) throws IOException {\n    this.storage = stg;\n    this.self = login;\n    this.coords = rep;\n    this.storage.apply(new Directives().xpath(String.format(\"/github/repos/repo[@coords='%s']\", this.coords)).addIf(\"forks\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.reason",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.reason",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.reason" ],
    "fullMethods" : [ "@Override\npublic String reason() {\n    return this.response.reason();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.SearchRequest.fetch",
    "thirdPartyMethod" : "com.jcabi.http.request.BaseRequest.fetch",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.SearchRequest.fetch" ],
    "fullMethods" : [ "@Override\npublic Response fetch(final InputStream stream) throws IOException {\n    return new RtSearchPagination.Hidden(this.request.fetch(stream));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkStorage.InFile.apply",
    "thirdPartyMethod" : "org.xembly.Xembler.applyQuietly",
    "thirdPartyPackage" : "org.xembly",
    "path" : [ "com.jcabi.github.mock.MkStorage.InFile.apply" ],
    "fullMethods" : [ "@Override\npublic void apply(final Iterable<Directive> dirs) throws IOException {\n    synchronized(this.name) {\n        FileUtils.write(new File(this.name), new XMLDocument(new Xembler(dirs).applyQuietly(this.xml().node())).toString(), StandardCharsets.UTF_8);\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Statuses.StatusCreate.<init>",
    "thirdPartyMethod" : "com.google.common.base.Optional.absent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Statuses.StatusCreate.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param stat\n * \t\tState\n */\npublic StatusCreate(final Status.State stat) {\n    this(stat, \"\", Optional.<String>absent(), Optional.<String>absent());\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.mock.MkIssue.patch",
    "thirdPartyMethod" : "com.google.common.base.Optional.absent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.mock.MkIssue.patch" ],
    "fullMethods" : [ "@Override\npublic void patch(final JsonObject json) throws IOException {\n    final Issue.Smart smart = new Issue.Smart(this);\n    final boolean was = smart.isOpen();\n    new JsonPatch(this.storage).patch(this.xpath(), json);\n    final boolean now = smart.isOpen();\n    if (now != was) {\n        final String type;\n        if (now) {\n            type = Event.REOPENED;\n        } else {\n            type = Event.CLOSED;\n        }\n        new MkIssueEvents(this.storage, this.self, this.coords).create(type, this.num, this.self, Optional.<String>absent());\n    }\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Event.Smart.label",
    "thirdPartyMethod" : "com.google.common.base.Optional.absent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Event.Smart.label" ],
    "fullMethods" : [ "/**\n * Label that was added or removed in this event (if any).\n *\n * @return Label that was added or removed\n * @throws IOException\n * \t\tIf there is any I/O problem\n * @since 0.24\n */\npublic Optional<Label> label() throws IOException {\n    Optional<Label> lab = Optional.absent();\n    final JsonObject lbl = this.jsn.json().getJsonObject(\"label\");\n    if (lbl != null) {\n        lab = Optional.of(this.event.repo().labels().get(lbl.getString(\"name\")));\n    }\n    return lab;\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repos.RepoCreate.<init>",
    "thirdPartyMethod" : "com.google.common.base.Optional.absent",
    "thirdPartyPackage" : "com.google.common.base",
    "path" : [ "com.jcabi.github.Repos.RepoCreate.<init>" ],
    "fullMethods" : [ "/**\n * Public ctor.\n *\n * @param nme\n * \t\tName of the new repository. Cannot be empty.\n * @param prvt\n * \t\tWill the new repo be private?\n * \t\tIf not, then it will be public.\n */\npublic RepoCreate(final String nme, final boolean prvt) {\n    this(nme, prvt, \"\", \"\", Optional.<Boolean>absent(), \"\");\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.RtSearchPagination.Hidden.status",
    "thirdPartyMethod" : "com.jcabi.http.request.DefaultResponse.status",
    "thirdPartyPackage" : "com.jcabi.http.request",
    "path" : [ "com.jcabi.github.RtSearchPagination.Hidden.status" ],
    "fullMethods" : [ "@Override\npublic int status() {\n    return this.response.status();\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Release.Smart.prerelease",
    "thirdPartyMethod" : "javax.json.JsonObject.getOrDefault",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Release.Smart.prerelease" ],
    "fullMethods" : [ "/**\n * Is it prerelease.\n *\n * @return Returns true if it's prerelease\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean prerelease() throws IOException {\n    return Boolean.parseBoolean(this.json().getOrDefault(\"prerelease\", JsonValue.FALSE).toString().replace(\"\\\"\", \"\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.Repo.Smart.isPrivate",
    "thirdPartyMethod" : "javax.json.JsonObject.getOrDefault",
    "thirdPartyPackage" : "javax.json",
    "path" : [ "com.jcabi.github.Repo.Smart.isPrivate" ],
    "fullMethods" : [ "/**\n * Is it private?.\n *\n * @return TRUE if it's private\n * @throws IOException\n * \t\tIf there is any I/O problem\n */\npublic boolean isPrivate() throws IOException {\n    return Boolean.parseBoolean(this.json().getOrDefault(\"private\", JsonValue.FALSE).toString().replace(\"\\\"\", \"\"));\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.RetryCarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.http.wire.RetryWire.send",
    "thirdPartyPackage" : "com.jcabi.http.wire",
    "path" : [ "com.jcabi.github.wire.RetryCarefulWire.send" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    return this.real.send(req, home, method, headers, content, connect, read);\n}" ]
  }, {
    "entryPoint" : "com.jcabi.github.wire.CarefulWire.send",
    "thirdPartyMethod" : "com.jcabi.http.wire.RetryWire.send",
    "thirdPartyPackage" : "com.jcabi.http.wire",
    "path" : [ "com.jcabi.github.wire.CarefulWire.send" ],
    "fullMethods" : [ "// @checkstyle ParameterNumber (8 lines)\n@Override\npublic Response send(final Request req, final String home, final String method, final Collection<Map.Entry<String, String>> headers, final InputStream content, final int connect, final int read) throws IOException {\n    final Response resp = this.origin.send(req, home, method, headers, content, connect, read);\n    final int remaining = this.remainingHeader(resp);\n    if (remaining < this.threshold) {\n        final long reset = this.resetHeader(resp);\n        final long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n        if (reset > now) {\n            final long length = reset - now;\n            // @checkstyle LineLength (1 line)\n            Logger.info(this, \"Remaining number of requests per hour is less than %d. Waiting for %d seconds.\", this.threshold, length);\n            try {\n                TimeUnit.SECONDS.sleep(length);\n            } catch (final InterruptedException ex) {\n                Thread.currentThread().interrupt();\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return resp;\n}" ]
  } ]
}