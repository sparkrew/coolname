{
  "entryPointPaths" : [ {
    "entryPoint" : "io.jooby.Jooby.getTmpdir",
    "entryPointBody" : "@Override\npublic Path getTmpdir() {\n    if (tmpdir == null) {\n        tmpdir = Paths.get(getEnvironment().getConfig().getString(AvailableSettings.TMP_DIR)).toAbsolutePath();\n    }\n    return tmpdir;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getString",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Jooby.getTmpdir" ]
  }, {
    "entryPoint" : "io.jooby.Environment.getProperty",
    "entryPointBody" : "/**\n * Get a property under the given key or <code>null</code> when missing.\n *\n * @param key\n * \t\tProperty key.\n * @return Property value or <code>null</code> when missing.\n */\n@Nullable\npublic String getProperty(@NonNull\nString key) {\n    if (hasPath(config, key)) {\n        return config.getString(key);\n    }\n    return null;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getString",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Environment.getProperty" ]
  }, {
    "entryPoint" : "io.jooby.ServerOptions.from",
    "entryPointBody" : "/**\n * Creates server options from config object. The configuration options must provided entries\n * like: <code>server.port</code>, <code>server.ioThreads</code>, etc...\n *\n * @param conf\n * \t\tConfiguration object.\n * @return Server options.\n */\npublic static Optional<ServerOptions> from(@NonNull\nConfig conf) {\n    if (conf.hasPath(\"server\")) {\n        var options = new ServerOptions();\n        if (conf.hasPath(\"server.port\")) {\n            options.setPort(conf.getInt(\"server.port\"));\n        }\n        if (conf.hasPath(\"server.securePort\")) {\n            options.setSecurePort(conf.getInt(\"server.securePort\"));\n        }\n        if (conf.hasPath(\"server.ioThreads\")) {\n            options.setIoThreads(conf.getInt(\"server.ioThreads\"));\n        }\n        if (conf.hasPath(\"server.name\")) {\n            options.setServer(conf.getString(\"server.name\"));\n        }\n        if (conf.hasPath(\"server.output.size\")) {\n            options.output.setSize(conf.getInt(\"server.output.size\"));\n        }\n        if (conf.hasPath(\"server.output.useDirectBuffers\")) {\n            options.output.setDirectBuffers(conf.getBoolean(\"server.output.useDirectBuffers\"));\n        }\n        if (conf.hasPath(\"server.defaultHeaders\")) {\n            options.setDefaultHeaders(conf.getBoolean(\"server.defaultHeaders\"));\n        }\n        if (conf.hasPath(\"server.gzip\")) {\n            throw new UnsupportedOperationException(\"server.gzip was removed, use server.compressionLevel instead.\");\n        }\n        if (conf.hasPath(\"server.compressionLevel\")) {\n            options.setCompressionLevel(conf.getInt(\"server.compressionLevel\"));\n        }\n        if (conf.hasPath(\"server.maxRequestSize\")) {\n            options.setMaxRequestSize(((int) (conf.getMemorySize(\"server.maxRequestSize\").toBytes())));\n        }\n        if (conf.hasPath(\"server.maxFormFields\")) {\n            options.setMaxFormFields(conf.getInt(\"server.maxFormFields\"));\n        }\n        if (conf.hasPath(\"server.workerThreads\")) {\n            options.setWorkerThreads(conf.getInt(\"server.workerThreads\"));\n        }\n        if (conf.hasPath(\"server.host\")) {\n            options.setHost(conf.getString(\"server.host\"));\n        }\n        if (conf.hasPath(\"server.expectContinue\")) {\n            options.setExpectContinue(conf.getBoolean(\"server.expectContinue\"));\n        }\n        // ssl\n        SslOptions.from(conf, \"server.ssl\").ifPresent(options::setSsl);\n        if (conf.hasPath(\"server.httpsOnly\")) {\n            options.httpsOnly = conf.getBoolean(\"server.httpsOnly\");\n        }\n        if (conf.hasPath(\"server.http2\")) {\n            options.setHttp2(conf.getBoolean(\"server.http2\"));\n        }\n        return Optional.of(options);\n    }\n    return Optional.empty();\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getString",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.ServerOptions.from" ]
  }, {
    "entryPoint" : "io.jooby.Environment.loadEnvironment",
    "entryPointBody" : "/**\n * This method search for an application.conf file in three location (first-listed are higher\n * priority):\n *\n * <ul>\n *   <li>${user.dir}/conf: This is a file system location, useful is you want to externalize\n *       configuration (outside of jar file).\n *   <li>${user.dir}: This is a file system location, useful is you want to externalize\n *       configuration (outside of jar file)\n *   <li>classpath:// (root of classpath). No external configuration, configuration file lives\n *       inside the jar file\n * </ul>\n *\n * Property overrides is done in the following order (first-listed are higher priority):\n *\n * <ul>\n *   <li>Program arguments\n *   <li>System properties\n *   <li>Environment variables\n *   <li>Environment property file\n *   <li>Property file\n * </ul>\n *\n * @param options\n * \t\tOptions like basedir, filename, etc.\n * @return A new environment.\n */\n@NonNull\npublic static Environment loadEnvironment(@NonNull\nEnvironmentOptions options) {\n    Config sys = systemProperties().withFallback(systemEnv());\n    List<String> actives = options.getActiveNames();\n    String filename = options.getFilename();\n    String extension;\n    int ext = filename.lastIndexOf('.');\n    if (ext <= 0) {\n        extension = \".conf\";\n    } else {\n        extension = filename.substring(ext);\n        filename = filename.substring(0, ext);\n    }\n    Path userdir = Paths.get(System.getProperty(\"user.dir\"));\n    /**\n     * Application file:\n     */\n    String[] names = new String[actives.size() + 1];\n    for (int i = 0; i < actives.size(); i++) {\n        names[i] = ((filename + \".\") + actives.get(i).trim().toLowerCase()) + extension;\n    }\n    names[actives.size()] = filename + extension;\n    Config application = resolveConfig(options, userdir, names);\n    // check if there is a local env set\n    if (application.hasPath(AvailableSettings.ENV)) {\n        String env = application.getString(AvailableSettings.ENV);\n        // Override environment only if the active environment is set to `dev`\n        if ((!actives.contains(env)) && (actives.contains(\"dev\") && (actives.size() == 1))) {\n            Config envConfig = resolveConfig(options, userdir, ((filename + \".\") + env.toLowerCase()) + extension);\n            if (envConfig != null) {\n                application = envConfig.withFallback(application);\n                actives = Collections.singletonList(env.toLowerCase());\n            }\n        }\n    }\n    Config result = sys.withFallback(application).withFallback(defaults()).resolve();\n    return new Environment(options.getClassLoader(), result, actives);\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getString",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Environment.loadEnvironment" ]
  }, {
    "entryPoint" : "io.jooby.Cookie.create",
    "entryPointBody" : "/**\n * Attempt to create/parse a cookie from application configuration object. The namespace given\n * must be present and must defined a <code>name</code> property.\n *\n * <p>The namespace might optionally defined: value, path, domain, secure, httpOnly and maxAge.\n *\n * @param namespace\n * \t\tCookie namespace/prefix.\n * @param conf\n * \t\tConfiguration object.\n * @return Parsed cookie or empty.\n */\n@NonNull\npublic static Optional<Cookie> create(@NonNull\nString namespace, @NonNull\nConfig conf) {\n    if (conf.hasPath(namespace)) {\n        Cookie cookie = new Cookie(conf.getString(namespace + \".name\"));\n        value(conf, namespace + \".value\", Config::getString, cookie::setValue);\n        value(conf, namespace + \".path\", Config::getString, cookie::setPath);\n        value(conf, namespace + \".domain\", Config::getString, cookie::setDomain);\n        value(conf, namespace + \".secure\", Config::getBoolean, cookie::setSecure);\n        value(conf, namespace + \".httpOnly\", Config::getBoolean, cookie::setHttpOnly);\n        value(conf, namespace + \".maxAge\", (c, path) -> c.getDuration(path, TimeUnit.SECONDS), cookie::setMaxAge);\n        value(conf, namespace + \".sameSite\", (c, path) -> SameSite.of(c.getString(path)), cookie::setSameSite);\n        return Optional.of(cookie);\n    }\n    return Optional.empty();\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getString",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Cookie.create" ]
  }, {
    "entryPoint" : "io.jooby.Environment.getProperty",
    "entryPointBody" : "/**\n * Get a property under the given key or use the given default value when missing.\n *\n * @param key\n * \t\tProperty key.\n * @param defaults\n * \t\tDefault value.\n * @return Property or default value.\n */\n@NonNull\npublic String getProperty(@NonNull\nString key, @NonNull\nString defaults) {\n    if (hasPath(config, key)) {\n        return config.getString(key);\n    }\n    return defaults;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getString",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Environment.getProperty" ]
  }, {
    "entryPoint" : "io.jooby.problem.ProblemDetailsHandler.from",
    "entryPointBody" : "/**\n * Creates a problem handler from configuration.\n *\n * <pre>{@code problem.details {\n *   enable: true\n *   muteCodes: [401, 106]\n *   muteTypes: ['com.example.MyException']\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Problem handler.\n */\npublic static ProblemDetailsHandler from(Config conf) {\n    var handler = new ProblemDetailsHandler();\n    if (conf.hasPath(ROOT_CONFIG_PATH)) {\n        var problemConfig = conf.getConfig(ROOT_CONFIG_PATH);\n        if (problemConfig.hasPath(LOG_4XX_ERRORS_KEY) && problemConfig.getBoolean(LOG_4XX_ERRORS_KEY)) {\n            handler.log4xxErrors();\n        }\n        if (problemConfig.hasPath(MUTE_CODES_KEY)) {\n            problemConfig.getIntList(MUTE_CODES_KEY).forEach(code -> handler.mute(StatusCode.valueOf(code)));\n        }\n        if (problemConfig.hasPath(MUTE_TYPES_KEY)) {\n            var classLoader = ProblemDetailsHandler.class.getClassLoader();\n            problemConfig.getStringList(MUTE_TYPES_KEY).forEach(throwingConsumer(className -> handler.mute(((Class<? extends Exception>) (classLoader.loadClass(className))))));\n        }\n    }\n    return handler;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getConfig",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.problem.ProblemDetailsHandler.from" ]
  }, {
    "entryPoint" : "io.jooby.handler.Cors.from",
    "entryPointBody" : "/**\n * Get cors options from application configuration file.\n *\n * <pre>{@code cors {\n *   origin: *\n *   methods: [GET, POST]\n *   headers: [Custom-Header]\n *   maxAge: 30m\n *   exposesHeaders: [Header]\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Cors options.\n */\npublic static Cors from(@NonNull\nConfig conf) {\n    Config cors = (conf.hasPath(\"cors\")) ? conf.getConfig(\"cors\") : conf;\n    Cors options = new Cors();\n    if (cors.hasPath(\"origin\")) {\n        options.setOrigin(list(cors.getAnyRef(\"origin\")));\n    }\n    if (cors.hasPath(\"credentials\")) {\n        options.setUseCredentials(cors.getBoolean(\"credentials\"));\n    }\n    if (cors.hasPath(\"methods\")) {\n        options.setMethods(list(cors.getAnyRef(\"methods\")));\n    }\n    if (cors.hasPath(\"headers\")) {\n        options.setHeaders(list(cors.getAnyRef(\"headers\")));\n    }\n    if (cors.hasPath(\"maxAge\")) {\n        options.setMaxAge(Duration.ofSeconds(cors.getDuration(\"maxAge\", TimeUnit.SECONDS)));\n    }\n    if (cors.hasPath(\"exposedHeaders\")) {\n        options.setExposedHeaders(list(cors.getAnyRef(\"exposedHeaders\")));\n    }\n    return options;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getConfig",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.handler.Cors.from" ]
  }, {
    "entryPoint" : "io.jooby.Environment.getProperties",
    "entryPointBody" : "/**\n * List all the properties under the given key. Example:\n *\n * <pre>\n * user.name = \"name\"\n * user.password = \"pass\"\n * </pre>\n *\n * A call to <code>getProperties(\"user\", \"u\")</code> give you a map like: <code>\n * {u.name: name, u.password: pass}</code>\n *\n * @param key\n * \t\tKey.\n * @param prefix\n * \t\tPrefix to use or <code>null</code> for none.\n * @return Properties under that key or empty map.\n */\n@NonNull\npublic Map<String, String> getProperties(@NonNull\nString key, @Nullable\nString prefix) {\n    if (hasPath(config, key)) {\n        Map<String, String> settings = new HashMap<>();\n        String p = ((prefix == null) || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        config.getConfig(key).entrySet().forEach(e -> {\n            Object value = e.getValue().unwrapped();\n            if (value instanceof List) {\n                value = ((List) (value)).stream().collect(Collectors.joining(\", \"));\n            }\n            String k = p + e.getKey();\n            settings.put(k, value.toString());\n        });\n        return settings;\n    }\n    return Collections.emptyMap();\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getConfig",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Environment.getProperties" ]
  }, {
    "entryPoint" : "io.jooby.problem.ProblemDetailsHandler.from",
    "entryPointBody" : "/**\n * Creates a problem handler from configuration.\n *\n * <pre>{@code problem.details {\n *   enable: true\n *   muteCodes: [401, 106]\n *   muteTypes: ['com.example.MyException']\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Problem handler.\n */\npublic static ProblemDetailsHandler from(Config conf) {\n    var handler = new ProblemDetailsHandler();\n    if (conf.hasPath(ROOT_CONFIG_PATH)) {\n        var problemConfig = conf.getConfig(ROOT_CONFIG_PATH);\n        if (problemConfig.hasPath(LOG_4XX_ERRORS_KEY) && problemConfig.getBoolean(LOG_4XX_ERRORS_KEY)) {\n            handler.log4xxErrors();\n        }\n        if (problemConfig.hasPath(MUTE_CODES_KEY)) {\n            problemConfig.getIntList(MUTE_CODES_KEY).forEach(code -> handler.mute(StatusCode.valueOf(code)));\n        }\n        if (problemConfig.hasPath(MUTE_TYPES_KEY)) {\n            var classLoader = ProblemDetailsHandler.class.getClassLoader();\n            problemConfig.getStringList(MUTE_TYPES_KEY).forEach(throwingConsumer(className -> handler.mute(((Class<? extends Exception>) (classLoader.loadClass(className))))));\n        }\n    }\n    return handler;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getIntList",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.problem.ProblemDetailsHandler.from" ]
  }, {
    "entryPoint" : "io.jooby.internal.ServiceRegistryImpl.getOrNull",
    "entryPointBody" : "@Nullable\n@Override\npublic <T> T getOrNull(@NonNull\nServiceKey<T> key) {\n    var provider = registry.get(key);\n    if (provider == null) {\n        return null;\n    }\n    return ((T) (provider.get()));\n}",
    "thirdPartyMethod" : "jakarta.inject.Provider.get",
    "thirdPartyPackage" : "jakarta.inject",
    "path" : [ "io.jooby.internal.ServiceRegistryImpl.getOrNull" ]
  }, {
    "entryPoint" : "io.jooby.handler.RateLimitHandler.apply",
    "entryPointBody" : "@Override\npublic void apply(@NonNull\nContext ctx) throws Exception {\n    Bucket bucket = factory.apply(ctx);\n    // tryConsume returns false immediately if no tokens available with the bucket\n    ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n        ctx.setResponseHeader(\"X-Rate-Limit-Remaining\", probe.getRemainingTokens());\n    } else {\n        ctx.setResponseHeader(\"X-Rate-Limit-Retry-After-Milliseconds\", NANOSECONDS.toMillis(probe.getNanosToWaitForRefill()));\n        ctx.send(StatusCode.TOO_MANY_REQUESTS);\n    }\n}",
    "thirdPartyMethod" : "io.github.bucket4j.ConsumptionProbe.getRemainingTokens",
    "thirdPartyPackage" : "io.github.bucket4j",
    "path" : [ "io.jooby.handler.RateLimitHandler.apply" ]
  }, {
    "entryPoint" : "io.jooby.handler.RateLimitHandler.apply",
    "entryPointBody" : "@Override\npublic void apply(@NonNull\nContext ctx) throws Exception {\n    Bucket bucket = factory.apply(ctx);\n    // tryConsume returns false immediately if no tokens available with the bucket\n    ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n        ctx.setResponseHeader(\"X-Rate-Limit-Remaining\", probe.getRemainingTokens());\n    } else {\n        ctx.setResponseHeader(\"X-Rate-Limit-Retry-After-Milliseconds\", NANOSECONDS.toMillis(probe.getNanosToWaitForRefill()));\n        ctx.send(StatusCode.TOO_MANY_REQUESTS);\n    }\n}",
    "thirdPartyMethod" : "io.github.bucket4j.Bucket.tryConsumeAndReturnRemaining",
    "thirdPartyPackage" : "io.github.bucket4j",
    "path" : [ "io.jooby.handler.RateLimitHandler.apply" ]
  }, {
    "entryPoint" : "io.jooby.problem.ProblemDetailsHandler.from",
    "entryPointBody" : "/**\n * Creates a problem handler from configuration.\n *\n * <pre>{@code problem.details {\n *   enable: true\n *   muteCodes: [401, 106]\n *   muteTypes: ['com.example.MyException']\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Problem handler.\n */\npublic static ProblemDetailsHandler from(Config conf) {\n    var handler = new ProblemDetailsHandler();\n    if (conf.hasPath(ROOT_CONFIG_PATH)) {\n        var problemConfig = conf.getConfig(ROOT_CONFIG_PATH);\n        if (problemConfig.hasPath(LOG_4XX_ERRORS_KEY) && problemConfig.getBoolean(LOG_4XX_ERRORS_KEY)) {\n            handler.log4xxErrors();\n        }\n        if (problemConfig.hasPath(MUTE_CODES_KEY)) {\n            problemConfig.getIntList(MUTE_CODES_KEY).forEach(code -> handler.mute(StatusCode.valueOf(code)));\n        }\n        if (problemConfig.hasPath(MUTE_TYPES_KEY)) {\n            var classLoader = ProblemDetailsHandler.class.getClassLoader();\n            problemConfig.getStringList(MUTE_TYPES_KEY).forEach(throwingConsumer(className -> handler.mute(((Class<? extends Exception>) (classLoader.loadClass(className))))));\n        }\n    }\n    return handler;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getStringList",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.problem.ProblemDetailsHandler.from" ]
  }, {
    "entryPoint" : "io.jooby.handler.RateLimitHandler.apply",
    "entryPointBody" : "@Override\npublic void apply(@NonNull\nContext ctx) throws Exception {\n    Bucket bucket = factory.apply(ctx);\n    // tryConsume returns false immediately if no tokens available with the bucket\n    ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n        ctx.setResponseHeader(\"X-Rate-Limit-Remaining\", probe.getRemainingTokens());\n    } else {\n        ctx.setResponseHeader(\"X-Rate-Limit-Retry-After-Milliseconds\", NANOSECONDS.toMillis(probe.getNanosToWaitForRefill()));\n        ctx.send(StatusCode.TOO_MANY_REQUESTS);\n    }\n}",
    "thirdPartyMethod" : "io.github.bucket4j.ConsumptionProbe.isConsumed",
    "thirdPartyPackage" : "io.github.bucket4j",
    "path" : [ "io.jooby.handler.RateLimitHandler.apply" ]
  }, {
    "entryPoint" : "io.jooby.handler.Cors.from",
    "entryPointBody" : "/**\n * Get cors options from application configuration file.\n *\n * <pre>{@code cors {\n *   origin: *\n *   methods: [GET, POST]\n *   headers: [Custom-Header]\n *   maxAge: 30m\n *   exposesHeaders: [Header]\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Cors options.\n */\npublic static Cors from(@NonNull\nConfig conf) {\n    Config cors = (conf.hasPath(\"cors\")) ? conf.getConfig(\"cors\") : conf;\n    Cors options = new Cors();\n    if (cors.hasPath(\"origin\")) {\n        options.setOrigin(list(cors.getAnyRef(\"origin\")));\n    }\n    if (cors.hasPath(\"credentials\")) {\n        options.setUseCredentials(cors.getBoolean(\"credentials\"));\n    }\n    if (cors.hasPath(\"methods\")) {\n        options.setMethods(list(cors.getAnyRef(\"methods\")));\n    }\n    if (cors.hasPath(\"headers\")) {\n        options.setHeaders(list(cors.getAnyRef(\"headers\")));\n    }\n    if (cors.hasPath(\"maxAge\")) {\n        options.setMaxAge(Duration.ofSeconds(cors.getDuration(\"maxAge\", TimeUnit.SECONDS)));\n    }\n    if (cors.hasPath(\"exposedHeaders\")) {\n        options.setExposedHeaders(list(cors.getAnyRef(\"exposedHeaders\")));\n    }\n    return options;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getAnyRef",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.handler.Cors.from" ]
  }, {
    "entryPoint" : "io.jooby.Jooby.ready",
    "entryPointBody" : "/**\n * Callback method that indicates application was successfully started it and listening for\n * connections.\n *\n * @param server\n * \t\tServer.\n * @return This application.\n */\npublic Jooby ready(@NonNull\nServer server) {\n    if (startupSummary == null) {\n        Config config = env.getConfig();\n        if (config.hasPath(AvailableSettings.STARTUP_SUMMARY)) {\n            Object value = config.getAnyRef(AvailableSettings.STARTUP_SUMMARY);\n            List<String> values = (value instanceof List) ? ((List) (value)) : List.of(value.toString());\n            startupSummary = values.stream().map(StartupSummary::create).toList();\n        } else {\n            startupSummary = List.of(StartupSummary.DEFAULT, StartupSummary.ROUTES);\n        }\n    }\n    startupSummary.forEach(summary -> summary.log(this, server));\n    this.readyCallbacks = fire(this.readyCallbacks);\n    return this;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getAnyRef",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Jooby.ready" ]
  }, {
    "entryPoint" : "io.jooby.ServiceRegistry.mapOf",
    "entryPointBody" : "/**\n * Map binder. You can gradually put service of the same type and retrieve them all as map.\n *\n * @param keyType\n * \t\tKey Type.\n * @param valueType\n * \t\tService Type.\n * @return A new map binder.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tService type.\n */\ndefault <K, V> MapBinder<K, V> mapOf(@NonNull\nClass<K> keyType, @NonNull\nClass<V> valueType) {\n    return multiBinder(Reified.map(keyType, valueType), new MapBinder<>());\n}",
    "thirdPartyMethod" : "jakarta.inject.Provider.getClass",
    "thirdPartyPackage" : "jakarta.inject",
    "path" : [ "io.jooby.ServiceRegistry.mapOf", "io.jooby.ServiceRegistry.multiBinder" ]
  }, {
    "entryPoint" : "io.jooby.ServiceRegistry.setOf",
    "entryPointBody" : "/**\n * Set binder. You can gradually add service of the same type and retrieve them all as set.\n *\n * @param type\n * \t\tType.\n * @return A new set binder.\n * @param <T>\n * \t\tService type.\n */\ndefault <T> MultiBinder<T> setOf(@NonNull\nReified<T> type) {\n    return multiBinder(Reified.set(type.getType()), MultiBinder.set());\n}",
    "thirdPartyMethod" : "jakarta.inject.Provider.getClass",
    "thirdPartyPackage" : "jakarta.inject",
    "path" : [ "io.jooby.ServiceRegistry.setOf", "io.jooby.ServiceRegistry.multiBinder" ]
  }, {
    "entryPoint" : "io.jooby.ServiceRegistry.listOf",
    "entryPointBody" : "/**\n * List binder. You can gradually add service of the same type and retrieve them all as list.\n *\n * @param type\n * \t\tType.\n * @return A new list binder.\n * @param <T>\n * \t\tService type.\n */\ndefault <T> MultiBinder<T> listOf(@NonNull\nClass<T> type) {\n    return multiBinder(Reified.list(type), MultiBinder.list());\n}",
    "thirdPartyMethod" : "jakarta.inject.Provider.getClass",
    "thirdPartyPackage" : "jakarta.inject",
    "path" : [ "io.jooby.ServiceRegistry.listOf", "io.jooby.ServiceRegistry.multiBinder" ]
  }, {
    "entryPoint" : "io.jooby.ServiceRegistry.mapOf",
    "entryPointBody" : "/**\n * Map binder. You can gradually put service of the same type and retrieve them all as map.\n *\n * @param keyType\n * \t\tKey Type.\n * @param valueType\n * \t\tService Type.\n * @return A new map binder.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tService type.\n */\ndefault <K, V> MapBinder<K, V> mapOf(@NonNull\nClass<K> keyType, @NonNull\nReified<V> valueType) {\n    return multiBinder(Reified.map(keyType, valueType.getType()), new MapBinder<>());\n}",
    "thirdPartyMethod" : "jakarta.inject.Provider.getClass",
    "thirdPartyPackage" : "jakarta.inject",
    "path" : [ "io.jooby.ServiceRegistry.mapOf", "io.jooby.ServiceRegistry.multiBinder" ]
  }, {
    "entryPoint" : "io.jooby.ServiceRegistry.setOf",
    "entryPointBody" : "/**\n * Set binder. You can gradually add service of the same type and retrieve them all as set.\n *\n * @param type\n * \t\tType.\n * @return A new set binder.\n * @param <T>\n * \t\tService type.\n */\ndefault <T> MultiBinder<T> setOf(@NonNull\nClass<T> type) {\n    return multiBinder(Reified.set(type), MultiBinder.set());\n}",
    "thirdPartyMethod" : "jakarta.inject.Provider.getClass",
    "thirdPartyPackage" : "jakarta.inject",
    "path" : [ "io.jooby.ServiceRegistry.setOf", "io.jooby.ServiceRegistry.multiBinder" ]
  }, {
    "entryPoint" : "io.jooby.ServiceRegistry.listOf",
    "entryPointBody" : "/**\n * List binder. You can gradually add service of the same type and retrieve them all as list.\n *\n * @param type\n * \t\tType.\n * @return A new list binder.\n * @param <T>\n * \t\tService type.\n */\ndefault <T> MultiBinder<T> listOf(@NonNull\nReified<T> type) {\n    return multiBinder(Reified.list(type.getType()), MultiBinder.list());\n}",
    "thirdPartyMethod" : "jakarta.inject.Provider.getClass",
    "thirdPartyPackage" : "jakarta.inject",
    "path" : [ "io.jooby.ServiceRegistry.listOf", "io.jooby.ServiceRegistry.multiBinder" ]
  }, {
    "entryPoint" : "io.jooby.problem.ProblemDetailsHandler.from",
    "entryPointBody" : "/**\n * Creates a problem handler from configuration.\n *\n * <pre>{@code problem.details {\n *   enable: true\n *   muteCodes: [401, 106]\n *   muteTypes: ['com.example.MyException']\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Problem handler.\n */\npublic static ProblemDetailsHandler from(Config conf) {\n    var handler = new ProblemDetailsHandler();\n    if (conf.hasPath(ROOT_CONFIG_PATH)) {\n        var problemConfig = conf.getConfig(ROOT_CONFIG_PATH);\n        if (problemConfig.hasPath(LOG_4XX_ERRORS_KEY) && problemConfig.getBoolean(LOG_4XX_ERRORS_KEY)) {\n            handler.log4xxErrors();\n        }\n        if (problemConfig.hasPath(MUTE_CODES_KEY)) {\n            problemConfig.getIntList(MUTE_CODES_KEY).forEach(code -> handler.mute(StatusCode.valueOf(code)));\n        }\n        if (problemConfig.hasPath(MUTE_TYPES_KEY)) {\n            var classLoader = ProblemDetailsHandler.class.getClassLoader();\n            problemConfig.getStringList(MUTE_TYPES_KEY).forEach(throwingConsumer(className -> handler.mute(((Class<? extends Exception>) (classLoader.loadClass(className))))));\n        }\n    }\n    return handler;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.problem.ProblemDetailsHandler.from" ]
  }, {
    "entryPoint" : "io.jooby.handler.Cors.from",
    "entryPointBody" : "/**\n * Get cors options from application configuration file.\n *\n * <pre>{@code cors {\n *   origin: *\n *   methods: [GET, POST]\n *   headers: [Custom-Header]\n *   maxAge: 30m\n *   exposesHeaders: [Header]\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Cors options.\n */\npublic static Cors from(@NonNull\nConfig conf) {\n    Config cors = (conf.hasPath(\"cors\")) ? conf.getConfig(\"cors\") : conf;\n    Cors options = new Cors();\n    if (cors.hasPath(\"origin\")) {\n        options.setOrigin(list(cors.getAnyRef(\"origin\")));\n    }\n    if (cors.hasPath(\"credentials\")) {\n        options.setUseCredentials(cors.getBoolean(\"credentials\"));\n    }\n    if (cors.hasPath(\"methods\")) {\n        options.setMethods(list(cors.getAnyRef(\"methods\")));\n    }\n    if (cors.hasPath(\"headers\")) {\n        options.setHeaders(list(cors.getAnyRef(\"headers\")));\n    }\n    if (cors.hasPath(\"maxAge\")) {\n        options.setMaxAge(Duration.ofSeconds(cors.getDuration(\"maxAge\", TimeUnit.SECONDS)));\n    }\n    if (cors.hasPath(\"exposedHeaders\")) {\n        options.setExposedHeaders(list(cors.getAnyRef(\"exposedHeaders\")));\n    }\n    return options;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.handler.Cors.from" ]
  }, {
    "entryPoint" : "io.jooby.Jooby.problemDetailsIsEnabled",
    "entryPointBody" : "/**\n * Check if {@link ProblemDetailsHandler} is enabled as a global error handler\n *\n * @return boolean flag\n */\npublic boolean problemDetailsIsEnabled() {\n    var config = getConfig();\n    return config.hasPath(ProblemDetailsHandler.ENABLED_KEY) && config.getBoolean(ProblemDetailsHandler.ENABLED_KEY);\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Jooby.problemDetailsIsEnabled" ]
  }, {
    "entryPoint" : "io.jooby.Environment.getProperty",
    "entryPointBody" : "/**\n * Get a property under the given key or <code>null</code> when missing.\n *\n * @param key\n * \t\tProperty key.\n * @return Property value or <code>null</code> when missing.\n */\n@Nullable\npublic String getProperty(@NonNull\nString key) {\n    if (hasPath(config, key)) {\n        return config.getString(key);\n    }\n    return null;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Environment.getProperty", "io.jooby.Environment.hasPath" ]
  }, {
    "entryPoint" : "io.jooby.ServerOptions.from",
    "entryPointBody" : "/**\n * Creates server options from config object. The configuration options must provided entries\n * like: <code>server.port</code>, <code>server.ioThreads</code>, etc...\n *\n * @param conf\n * \t\tConfiguration object.\n * @return Server options.\n */\npublic static Optional<ServerOptions> from(@NonNull\nConfig conf) {\n    if (conf.hasPath(\"server\")) {\n        var options = new ServerOptions();\n        if (conf.hasPath(\"server.port\")) {\n            options.setPort(conf.getInt(\"server.port\"));\n        }\n        if (conf.hasPath(\"server.securePort\")) {\n            options.setSecurePort(conf.getInt(\"server.securePort\"));\n        }\n        if (conf.hasPath(\"server.ioThreads\")) {\n            options.setIoThreads(conf.getInt(\"server.ioThreads\"));\n        }\n        if (conf.hasPath(\"server.name\")) {\n            options.setServer(conf.getString(\"server.name\"));\n        }\n        if (conf.hasPath(\"server.output.size\")) {\n            options.output.setSize(conf.getInt(\"server.output.size\"));\n        }\n        if (conf.hasPath(\"server.output.useDirectBuffers\")) {\n            options.output.setDirectBuffers(conf.getBoolean(\"server.output.useDirectBuffers\"));\n        }\n        if (conf.hasPath(\"server.defaultHeaders\")) {\n            options.setDefaultHeaders(conf.getBoolean(\"server.defaultHeaders\"));\n        }\n        if (conf.hasPath(\"server.gzip\")) {\n            throw new UnsupportedOperationException(\"server.gzip was removed, use server.compressionLevel instead.\");\n        }\n        if (conf.hasPath(\"server.compressionLevel\")) {\n            options.setCompressionLevel(conf.getInt(\"server.compressionLevel\"));\n        }\n        if (conf.hasPath(\"server.maxRequestSize\")) {\n            options.setMaxRequestSize(((int) (conf.getMemorySize(\"server.maxRequestSize\").toBytes())));\n        }\n        if (conf.hasPath(\"server.maxFormFields\")) {\n            options.setMaxFormFields(conf.getInt(\"server.maxFormFields\"));\n        }\n        if (conf.hasPath(\"server.workerThreads\")) {\n            options.setWorkerThreads(conf.getInt(\"server.workerThreads\"));\n        }\n        if (conf.hasPath(\"server.host\")) {\n            options.setHost(conf.getString(\"server.host\"));\n        }\n        if (conf.hasPath(\"server.expectContinue\")) {\n            options.setExpectContinue(conf.getBoolean(\"server.expectContinue\"));\n        }\n        // ssl\n        SslOptions.from(conf, \"server.ssl\").ifPresent(options::setSsl);\n        if (conf.hasPath(\"server.httpsOnly\")) {\n            options.httpsOnly = conf.getBoolean(\"server.httpsOnly\");\n        }\n        if (conf.hasPath(\"server.http2\")) {\n            options.setHttp2(conf.getBoolean(\"server.http2\"));\n        }\n        return Optional.of(options);\n    }\n    return Optional.empty();\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.ServerOptions.from" ]
  }, {
    "entryPoint" : "io.jooby.Environment.getProperties",
    "entryPointBody" : "/**\n * List all the properties under the given key. Example:\n *\n * <pre>\n * user.name = \"name\"\n * user.password = \"pass\"\n * </pre>\n *\n * A call to <code>getProperties(\"user\", \"u\")</code> give you a map like: <code>\n * {u.name: name, u.password: pass}</code>\n *\n * @param key\n * \t\tKey.\n * @param prefix\n * \t\tPrefix to use or <code>null</code> for none.\n * @return Properties under that key or empty map.\n */\n@NonNull\npublic Map<String, String> getProperties(@NonNull\nString key, @Nullable\nString prefix) {\n    if (hasPath(config, key)) {\n        Map<String, String> settings = new HashMap<>();\n        String p = ((prefix == null) || prefix.isEmpty()) ? \"\" : prefix + \".\";\n        config.getConfig(key).entrySet().forEach(e -> {\n            Object value = e.getValue().unwrapped();\n            if (value instanceof List) {\n                value = ((List) (value)).stream().collect(Collectors.joining(\", \"));\n            }\n            String k = p + e.getKey();\n            settings.put(k, value.toString());\n        });\n        return settings;\n    }\n    return Collections.emptyMap();\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Environment.getProperties", "io.jooby.Environment.hasPath" ]
  }, {
    "entryPoint" : "io.jooby.Environment.loadEnvironment",
    "entryPointBody" : "/**\n * This method search for an application.conf file in three location (first-listed are higher\n * priority):\n *\n * <ul>\n *   <li>${user.dir}/conf: This is a file system location, useful is you want to externalize\n *       configuration (outside of jar file).\n *   <li>${user.dir}: This is a file system location, useful is you want to externalize\n *       configuration (outside of jar file)\n *   <li>classpath:// (root of classpath). No external configuration, configuration file lives\n *       inside the jar file\n * </ul>\n *\n * Property overrides is done in the following order (first-listed are higher priority):\n *\n * <ul>\n *   <li>Program arguments\n *   <li>System properties\n *   <li>Environment variables\n *   <li>Environment property file\n *   <li>Property file\n * </ul>\n *\n * @param options\n * \t\tOptions like basedir, filename, etc.\n * @return A new environment.\n */\n@NonNull\npublic static Environment loadEnvironment(@NonNull\nEnvironmentOptions options) {\n    Config sys = systemProperties().withFallback(systemEnv());\n    List<String> actives = options.getActiveNames();\n    String filename = options.getFilename();\n    String extension;\n    int ext = filename.lastIndexOf('.');\n    if (ext <= 0) {\n        extension = \".conf\";\n    } else {\n        extension = filename.substring(ext);\n        filename = filename.substring(0, ext);\n    }\n    Path userdir = Paths.get(System.getProperty(\"user.dir\"));\n    /**\n     * Application file:\n     */\n    String[] names = new String[actives.size() + 1];\n    for (int i = 0; i < actives.size(); i++) {\n        names[i] = ((filename + \".\") + actives.get(i).trim().toLowerCase()) + extension;\n    }\n    names[actives.size()] = filename + extension;\n    Config application = resolveConfig(options, userdir, names);\n    // check if there is a local env set\n    if (application.hasPath(AvailableSettings.ENV)) {\n        String env = application.getString(AvailableSettings.ENV);\n        // Override environment only if the active environment is set to `dev`\n        if ((!actives.contains(env)) && (actives.contains(\"dev\") && (actives.size() == 1))) {\n            Config envConfig = resolveConfig(options, userdir, ((filename + \".\") + env.toLowerCase()) + extension);\n            if (envConfig != null) {\n                application = envConfig.withFallback(application);\n                actives = Collections.singletonList(env.toLowerCase());\n            }\n        }\n    }\n    Config result = sys.withFallback(application).withFallback(defaults()).resolve();\n    return new Environment(options.getClassLoader(), result, actives);\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Environment.loadEnvironment" ]
  }, {
    "entryPoint" : "io.jooby.Jooby.ready",
    "entryPointBody" : "/**\n * Callback method that indicates application was successfully started it and listening for\n * connections.\n *\n * @param server\n * \t\tServer.\n * @return This application.\n */\npublic Jooby ready(@NonNull\nServer server) {\n    if (startupSummary == null) {\n        Config config = env.getConfig();\n        if (config.hasPath(AvailableSettings.STARTUP_SUMMARY)) {\n            Object value = config.getAnyRef(AvailableSettings.STARTUP_SUMMARY);\n            List<String> values = (value instanceof List) ? ((List) (value)) : List.of(value.toString());\n            startupSummary = values.stream().map(StartupSummary::create).toList();\n        } else {\n            startupSummary = List.of(StartupSummary.DEFAULT, StartupSummary.ROUTES);\n        }\n    }\n    startupSummary.forEach(summary -> summary.log(this, server));\n    this.readyCallbacks = fire(this.readyCallbacks);\n    return this;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Jooby.ready" ]
  }, {
    "entryPoint" : "io.jooby.Cookie.create",
    "entryPointBody" : "/**\n * Attempt to create/parse a cookie from application configuration object. The namespace given\n * must be present and must defined a <code>name</code> property.\n *\n * <p>The namespace might optionally defined: value, path, domain, secure, httpOnly and maxAge.\n *\n * @param namespace\n * \t\tCookie namespace/prefix.\n * @param conf\n * \t\tConfiguration object.\n * @return Parsed cookie or empty.\n */\n@NonNull\npublic static Optional<Cookie> create(@NonNull\nString namespace, @NonNull\nConfig conf) {\n    if (conf.hasPath(namespace)) {\n        Cookie cookie = new Cookie(conf.getString(namespace + \".name\"));\n        value(conf, namespace + \".value\", Config::getString, cookie::setValue);\n        value(conf, namespace + \".path\", Config::getString, cookie::setPath);\n        value(conf, namespace + \".domain\", Config::getString, cookie::setDomain);\n        value(conf, namespace + \".secure\", Config::getBoolean, cookie::setSecure);\n        value(conf, namespace + \".httpOnly\", Config::getBoolean, cookie::setHttpOnly);\n        value(conf, namespace + \".maxAge\", (c, path) -> c.getDuration(path, TimeUnit.SECONDS), cookie::setMaxAge);\n        value(conf, namespace + \".sameSite\", (c, path) -> SameSite.of(c.getString(path)), cookie::setSameSite);\n        return Optional.of(cookie);\n    }\n    return Optional.empty();\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Cookie.create" ]
  }, {
    "entryPoint" : "io.jooby.Environment.getProperty",
    "entryPointBody" : "/**\n * Get a property under the given key or use the given default value when missing.\n *\n * @param key\n * \t\tProperty key.\n * @param defaults\n * \t\tDefault value.\n * @return Property or default value.\n */\n@NonNull\npublic String getProperty(@NonNull\nString key, @NonNull\nString defaults) {\n    if (hasPath(config, key)) {\n        return config.getString(key);\n    }\n    return defaults;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.hasPath",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Environment.getProperty", "io.jooby.Environment.hasPath" ]
  }, {
    "entryPoint" : "io.jooby.handler.RateLimitHandler.apply",
    "entryPointBody" : "@Override\npublic void apply(@NonNull\nContext ctx) throws Exception {\n    Bucket bucket = factory.apply(ctx);\n    // tryConsume returns false immediately if no tokens available with the bucket\n    ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n        ctx.setResponseHeader(\"X-Rate-Limit-Remaining\", probe.getRemainingTokens());\n    } else {\n        ctx.setResponseHeader(\"X-Rate-Limit-Retry-After-Milliseconds\", NANOSECONDS.toMillis(probe.getNanosToWaitForRefill()));\n        ctx.send(StatusCode.TOO_MANY_REQUESTS);\n    }\n}",
    "thirdPartyMethod" : "io.github.bucket4j.ConsumptionProbe.getNanosToWaitForRefill",
    "thirdPartyPackage" : "io.github.bucket4j",
    "path" : [ "io.jooby.handler.RateLimitHandler.apply" ]
  }, {
    "entryPoint" : "io.jooby.problem.ProblemDetailsHandler.from",
    "entryPointBody" : "/**\n * Creates a problem handler from configuration.\n *\n * <pre>{@code problem.details {\n *   enable: true\n *   muteCodes: [401, 106]\n *   muteTypes: ['com.example.MyException']\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Problem handler.\n */\npublic static ProblemDetailsHandler from(Config conf) {\n    var handler = new ProblemDetailsHandler();\n    if (conf.hasPath(ROOT_CONFIG_PATH)) {\n        var problemConfig = conf.getConfig(ROOT_CONFIG_PATH);\n        if (problemConfig.hasPath(LOG_4XX_ERRORS_KEY) && problemConfig.getBoolean(LOG_4XX_ERRORS_KEY)) {\n            handler.log4xxErrors();\n        }\n        if (problemConfig.hasPath(MUTE_CODES_KEY)) {\n            problemConfig.getIntList(MUTE_CODES_KEY).forEach(code -> handler.mute(StatusCode.valueOf(code)));\n        }\n        if (problemConfig.hasPath(MUTE_TYPES_KEY)) {\n            var classLoader = ProblemDetailsHandler.class.getClassLoader();\n            problemConfig.getStringList(MUTE_TYPES_KEY).forEach(throwingConsumer(className -> handler.mute(((Class<? extends Exception>) (classLoader.loadClass(className))))));\n        }\n    }\n    return handler;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getBoolean",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.problem.ProblemDetailsHandler.from" ]
  }, {
    "entryPoint" : "io.jooby.handler.Cors.from",
    "entryPointBody" : "/**\n * Get cors options from application configuration file.\n *\n * <pre>{@code cors {\n *   origin: *\n *   methods: [GET, POST]\n *   headers: [Custom-Header]\n *   maxAge: 30m\n *   exposesHeaders: [Header]\n * }}</pre>\n *\n * @param conf\n * \t\tConfiguration.\n * @return Cors options.\n */\npublic static Cors from(@NonNull\nConfig conf) {\n    Config cors = (conf.hasPath(\"cors\")) ? conf.getConfig(\"cors\") : conf;\n    Cors options = new Cors();\n    if (cors.hasPath(\"origin\")) {\n        options.setOrigin(list(cors.getAnyRef(\"origin\")));\n    }\n    if (cors.hasPath(\"credentials\")) {\n        options.setUseCredentials(cors.getBoolean(\"credentials\"));\n    }\n    if (cors.hasPath(\"methods\")) {\n        options.setMethods(list(cors.getAnyRef(\"methods\")));\n    }\n    if (cors.hasPath(\"headers\")) {\n        options.setHeaders(list(cors.getAnyRef(\"headers\")));\n    }\n    if (cors.hasPath(\"maxAge\")) {\n        options.setMaxAge(Duration.ofSeconds(cors.getDuration(\"maxAge\", TimeUnit.SECONDS)));\n    }\n    if (cors.hasPath(\"exposedHeaders\")) {\n        options.setExposedHeaders(list(cors.getAnyRef(\"exposedHeaders\")));\n    }\n    return options;\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getBoolean",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.handler.Cors.from" ]
  }, {
    "entryPoint" : "io.jooby.Jooby.problemDetailsIsEnabled",
    "entryPointBody" : "/**\n * Check if {@link ProblemDetailsHandler} is enabled as a global error handler\n *\n * @return boolean flag\n */\npublic boolean problemDetailsIsEnabled() {\n    var config = getConfig();\n    return config.hasPath(ProblemDetailsHandler.ENABLED_KEY) && config.getBoolean(ProblemDetailsHandler.ENABLED_KEY);\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getBoolean",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.Jooby.problemDetailsIsEnabled" ]
  }, {
    "entryPoint" : "io.jooby.ServerOptions.from",
    "entryPointBody" : "/**\n * Creates server options from config object. The configuration options must provided entries\n * like: <code>server.port</code>, <code>server.ioThreads</code>, etc...\n *\n * @param conf\n * \t\tConfiguration object.\n * @return Server options.\n */\npublic static Optional<ServerOptions> from(@NonNull\nConfig conf) {\n    if (conf.hasPath(\"server\")) {\n        var options = new ServerOptions();\n        if (conf.hasPath(\"server.port\")) {\n            options.setPort(conf.getInt(\"server.port\"));\n        }\n        if (conf.hasPath(\"server.securePort\")) {\n            options.setSecurePort(conf.getInt(\"server.securePort\"));\n        }\n        if (conf.hasPath(\"server.ioThreads\")) {\n            options.setIoThreads(conf.getInt(\"server.ioThreads\"));\n        }\n        if (conf.hasPath(\"server.name\")) {\n            options.setServer(conf.getString(\"server.name\"));\n        }\n        if (conf.hasPath(\"server.output.size\")) {\n            options.output.setSize(conf.getInt(\"server.output.size\"));\n        }\n        if (conf.hasPath(\"server.output.useDirectBuffers\")) {\n            options.output.setDirectBuffers(conf.getBoolean(\"server.output.useDirectBuffers\"));\n        }\n        if (conf.hasPath(\"server.defaultHeaders\")) {\n            options.setDefaultHeaders(conf.getBoolean(\"server.defaultHeaders\"));\n        }\n        if (conf.hasPath(\"server.gzip\")) {\n            throw new UnsupportedOperationException(\"server.gzip was removed, use server.compressionLevel instead.\");\n        }\n        if (conf.hasPath(\"server.compressionLevel\")) {\n            options.setCompressionLevel(conf.getInt(\"server.compressionLevel\"));\n        }\n        if (conf.hasPath(\"server.maxRequestSize\")) {\n            options.setMaxRequestSize(((int) (conf.getMemorySize(\"server.maxRequestSize\").toBytes())));\n        }\n        if (conf.hasPath(\"server.maxFormFields\")) {\n            options.setMaxFormFields(conf.getInt(\"server.maxFormFields\"));\n        }\n        if (conf.hasPath(\"server.workerThreads\")) {\n            options.setWorkerThreads(conf.getInt(\"server.workerThreads\"));\n        }\n        if (conf.hasPath(\"server.host\")) {\n            options.setHost(conf.getString(\"server.host\"));\n        }\n        if (conf.hasPath(\"server.expectContinue\")) {\n            options.setExpectContinue(conf.getBoolean(\"server.expectContinue\"));\n        }\n        // ssl\n        SslOptions.from(conf, \"server.ssl\").ifPresent(options::setSsl);\n        if (conf.hasPath(\"server.httpsOnly\")) {\n            options.httpsOnly = conf.getBoolean(\"server.httpsOnly\");\n        }\n        if (conf.hasPath(\"server.http2\")) {\n            options.setHttp2(conf.getBoolean(\"server.http2\"));\n        }\n        return Optional.of(options);\n    }\n    return Optional.empty();\n}",
    "thirdPartyMethod" : "com.typesafe.config.Config.getBoolean",
    "thirdPartyPackage" : "com.typesafe.config",
    "path" : [ "io.jooby.ServerOptions.from" ]
  } ]
}