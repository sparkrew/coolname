{
  "slicedPaths" : [ {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.Span.kind",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan", "io.lettuce.core.tracing.BraveTracing.BraveTracer.postProcessSpan" ],
    "methodSlices" : [ "@Override\npublic Span nextSpan() {\n    return postProcessSpan(tracing.tracer().nextSpan());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.Span.kind",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan", "io.lettuce.core.tracing.BraveTracing.BraveTracer.postProcessSpan" ],
    "methodSlices" : [ "@Override\npublic Span nextSpan(TraceContext traceContext) {\n    if (!(traceContext instanceof BraveTraceContext)) {\n        return nextSpan();\n    }\n    BraveTraceContext braveTraceContext = BraveTracing.BraveTraceContext.class.cast(traceContext);\n    if (braveTraceContext.traceContext == null) {\n        return nextSpan();\n    }\n    return postProcessSpan(tracing.tracer().nextSpan(TraceContextOrSamplingFlags.create(braveTraceContext.traceContext)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.MicrometerTracing.MicrometerSpan.start",
    "thirdPartyMethod" : "io.micrometer.observation.Observation.start",
    "thirdPartyPackage" : "io.micrometer.observation",
    "path" : [ "io.lettuce.core.tracing.MicrometerTracing.MicrometerSpan.start" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.next",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.resolveCredentials",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.next",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.resolveCredentials" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.ObjectPoolWrapper.returnObjectAsync",
    "thirdPartyMethod" : "org.apache.commons.pool2.ObjectPool.returnObject",
    "thirdPartyPackage" : "org.apache.commons.pool2",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.ObjectPoolWrapper.returnObjectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.ObjectPoolWrapper.returnObject",
    "thirdPartyMethod" : "org.apache.commons.pool2.ObjectPool.returnObject",
    "thirdPartyPackage" : "org.apache.commons.pool2",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.ObjectPoolWrapper.returnObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.applyTcpUserTimeout",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.resource.EpollProvider.applyTcpUserTimeout" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    DefaultEndpoint endpoint = new DefaultEndpoint(getOptions(), getResources())\n    RedisChannelWriter writer = endpoint\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n    writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n}\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n    writer = new CommandListenerWriter(writer, getCommandListeners());\n}\n    StatefulRedisSentinelConnectionImpl<K, V> connection = newStatefulRedisSentinelConnection(writer, codec, timeout)\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectPubSubToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.cluster.RedisClusterClient.createConnectionBuilder", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), key.nodeId, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), (key.host + \":\") + key.port, getSocketAddressSupplier(key));\n}", "/**\n * Create a pub/sub connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubToNodeAsync(RedisCodec<K, V> codec, String nodeId, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}", "private <K, V> ConnectionBuilder createConnectionBuilder(RedisChannelHandler<K, V> connection, ConnectionState state, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n    ConnectionBuilder connectionBuilder\n    if (connectionSettings.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(connectionSettings);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(socketAddressSupplier, connectionBuilder, connection.getConnectionEvents(), connectionSettings)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.applyTcpUserTimeout",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.applyTcpUserTimeout" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.cluster.RedisClusterClient.createConnectionBuilder", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectToNodeAsync(redisCodec, key.nodeId, null, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectToNodeAsync(redisCodec, (key.host + \":\") + key.port, clusterWriter, getSocketAddressSupplier(key));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}", "private <K, V> ConnectionBuilder createConnectionBuilder(RedisChannelHandler<K, V> connection, ConnectionState state, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n    ConnectionBuilder connectionBuilder\n    if (connectionSettings.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(connectionSettings);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(socketAddressSupplier, connectionBuilder, connection.getConnectionEvents(), connectionSettings)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server that treats keys and values as UTF-8 strings.\n *\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub() {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.cluster.RedisClusterClient.createConnectionBuilder", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "@Override\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNodeAsync(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}", "private <K, V> ConnectionBuilder createConnectionBuilder(RedisChannelHandler<K, V> connection, ConnectionState state, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n    ConnectionBuilder connectionBuilder\n    if (connectionSettings.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(connectionSettings);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(socketAddressSupplier, connectionBuilder, connection.getConnectionEvents(), connectionSettings)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.cluster.RedisClusterClient.createConnectionBuilder", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "@Override\npublic <K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNode(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}", "private <K, V> ConnectionBuilder createConnectionBuilder(RedisChannelHandler<K, V> connection, ConnectionState state, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n    ConnectionBuilder connectionBuilder\n    if (connectionSettings.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(connectionSettings);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(socketAddressSupplier, connectionBuilder, connection.getConnectionEvents(), connectionSettings)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    DefaultEndpoint endpoint = new DefaultEndpoint(getOptions(), getResources())\n    RedisChannelWriter writer = endpoint\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n    writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n}\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n    writer = new CommandListenerWriter(writer, getCommandListeners());\n}\n    StatefulRedisSentinelConnectionImpl<K, V> connection = newStatefulRedisSentinelConnection(writer, codec, timeout)\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    DefaultEndpoint endpoint = new DefaultEndpoint(getOptions(), getResources())\n    RedisChannelWriter writer = endpoint\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n    writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n}\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n    writer = new CommandListenerWriter(writer, getCommandListeners());\n}\n    StatefulRedisSentinelConnectionImpl<K, V> connection = newStatefulRedisSentinelConnection(writer, codec, timeout)\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSubAsync",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.applyKeepAlive",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.applyKeepAlive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.applyKeepAlive",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.applyKeepAlive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    DefaultEndpoint endpoint = new DefaultEndpoint(getOptions(), getResources())\n    RedisChannelWriter writer = endpoint\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n    writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n}\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n    writer = new CommandListenerWriter(writer, getCommandListeners());\n}\n    StatefulRedisSentinelConnectionImpl<K, V> connection = newStatefulRedisSentinelConnection(writer, codec, timeout)\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.applyKeepAlive",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.resource.EpollProvider.applyKeepAlive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.option",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.RedisPooledObjectFactory.validateObject",
    "thirdPartyMethod" : "org.apache.commons.pool2.PooledObject.getObject",
    "thirdPartyPackage" : "org.apache.commons.pool2",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.RedisPooledObjectFactory.validateObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.RedisPooledObjectFactory.destroyObject",
    "thirdPartyMethod" : "org.apache.commons.pool2.PooledObject.getObject",
    "thirdPartyPackage" : "org.apache.commons.pool2",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.RedisPooledObjectFactory.destroyObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.cause",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.doComplete" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void operationComplete(Future<Void> future) {\n    try {\n        doComplete(future);\n    } finally {\n        recycle();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.cause",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.internal.Futures.adapt",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.cause",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.internal.Futures.adapt" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.cause",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.cause",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "/**\n * Shutdown the {@link ClientResources}.\n *\n * @param quietPeriod\n * \t\tthe quiet period as described in the documentation\n * @param timeout\n * \t\tthe maximum amount of time to wait until the executor is shutdown regardless if a task was submitted\n * \t\tduring the quiet period\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}\n * @return eventually the success/failure of the shutdown without errors.\n */\n@SuppressWarnings(\"unchecked\")\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.internal.Futures.toCompletionStage",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.cause",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.internal.Futures.toCompletionStage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RatioDecodeBufferPolicy.afterPartialDecode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.RatioDecodeBufferPolicy.afterPartialDecode", "io.lettuce.core.protocol.RatioDecodeBufferPolicy.discardReadBytesIfNecessary" ],
    "methodSlices" : [ "@Override\npublic void afterPartialDecode(ByteBuf buffer) {\n    discardReadBytesIfNecessary(buffer)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DecodeBufferPolicies.afterPartialDecode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.DecodeBufferPolicies.afterPartialDecode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DecodeBufferPolicies.afterCommandDecoded",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.DecodeBufferPolicies.afterCommandDecoded" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RatioDecodeBufferPolicy.afterDecoding",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.RatioDecodeBufferPolicy.afterDecoding", "io.lettuce.core.protocol.RatioDecodeBufferPolicy.discardReadBytesIfNecessary" ],
    "methodSlices" : [ "@Override\npublic void afterDecoding(ByteBuf buffer) {\n    discardReadBytesIfNecessary(buffer)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DecodeBufferPolicies.afterDecoding",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.DecodeBufferPolicies.afterDecoding" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RatioDecodeBufferPolicy.afterCommandDecoded",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.RatioDecodeBufferPolicy.afterCommandDecoded", "io.lettuce.core.protocol.RatioDecodeBufferPolicy.discardReadBytesIfNecessary" ],
    "methodSlices" : [ "@Override\npublic void afterCommandDecoded(ByteBuf buffer) {\n    discardReadBytesIfNecessary(buffer)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint",
    "thirdPartyMethod" : "zipkin2.Endpoint.ipv4",
    "thirdPartyPackage" : "zipkin2",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.RedisClusterClientCdiBean.create",
    "thirdPartyMethod" : "javax.enterprise.inject.spi.BeanManager.getReference",
    "thirdPartyPackage" : "javax.enterprise.inject.spi",
    "path" : [ "io.lettuce.core.support.RedisClusterClientCdiBean.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.RedisClientCdiBean.create",
    "thirdPartyMethod" : "javax.enterprise.inject.spi.BeanManager.getReference",
    "thirdPartyPackage" : "javax.enterprise.inject.spi",
    "path" : [ "io.lettuce.core.support.RedisClientCdiBean.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.returnObject",
    "thirdPartyMethod" : "org.apache.commons.pool2.impl.SoftReferenceObjectPool.returnObject",
    "thirdPartyPackage" : "org.apache.commons.pool2.impl",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.returnObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.CompletableEventLatchSupport.accept",
    "thirdPartyMethod" : "reactor.util.function.Tuple2.getT1",
    "thirdPartyPackage" : "reactor.util.function",
    "path" : [ "io.lettuce.core.masterreplica.CompletableEventLatchSupport.accept", "io.lettuce.core.masterreplica.Connections.onAccept", "io.lettuce.core.masterreplica.Connections.onAccept" ],
    "methodSlices" : [ "/**\n * Notification callback method accepting a connection for a value. Triggers emission if the gate is open and the current\n * call to this method is the last expected notification.\n */\npublic final void accept(T value) {\n    if (GATE_UPDATER.get(this) == GATE_CLOSED) {\n        onDrop(value);\n        return;\n    }\n    onAccept(value);\n    onNotification();\n}", "@Override\nprotected void onAccept(Tuple2<RedisURI, StatefulRedisConnection<String, String>> value) {\n    if (this.closed) {\n        value.getT2().closeAsync();\n        return;\n    }\n    try {\n        lock.lock();\n        this.connections.put(value.getT1(), value.getT2());\n    } finally {\n        lock.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.run",
    "thirdPartyMethod" : "reactor.util.function.Tuple2.getT1",
    "thirdPartyPackage" : "reactor.util.function",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.run" ],
    "methodSlices" : [ "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter\n * @throws Exception\n * \t\twhen reconnection fails.\n */\npublic void run(int attempt) throws Exception {\n    run(attempt, Duration.ZERO)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.ChannelInitializer.exceptionCaught",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.ChannelInitializer.exceptionCaught",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.bootstrap.BootstrapConfig.group",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect", "io.lettuce.core.protocol.ConnectionWatchdog.isEventLoopGroupActive" ],
    "methodSlices" : [ "/**\n * Schedule reconnect if channel is not available/not active.\n */\npublic void scheduleReconnect() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.run",
    "thirdPartyMethod" : "io.netty.bootstrap.BootstrapConfig.group",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.isEventLoopGroupActive" ],
    "methodSlices" : [ "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter\n * @throws Exception\n * \t\twhen reconnection fails.\n */\npublic void run(int attempt) throws Exception {\n    run(attempt, Duration.ZERO)\n}", "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter.\n * @param delay\n * \t\tretry delay.\n * @throws Exception\n * \t\twhen reconnection fails.\n */\nprivate void run(int attempt, Duration delay) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.json.DefaultJsonParser.fromObject",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.valueToTree",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "io.lettuce.core.json.DefaultJsonParser.fromObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.operationComplete",
    "thirdPartyMethod" : "io.netty.channel.ChannelFuture.cause",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.operationComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.alloc",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.alloc",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.KeyArgument.encode", "io.lettuce.core.protocol.CommandArgs.encode" ],
    "methodSlices" : [ "/**\n * Encode the {@link CommandArgs} and write the arguments to the {@link ByteBuf}.\n *\n * @param buf\n * \t\tthe target buffer.\n */\npublic void encode(ByteBuf buf) {\n    buf.touch(\"CommandArgs.encode()\");\n    for (SingularArgument singularArgument : singularArguments) {\n        singularArgument.encode(buf);\n    }\n}", "@SuppressWarnings(\"unchecked\")\n@Override\nvoid encode(ByteBuf target) {\n    if (codec instanceof ToByteBufEncoder) {\n        CommandArgs.encode(target, ((ToByteBufEncoder<K, K>) (codec)), key, ToByteBufEncoder::encodeKey);\n        return;\n    }\n    ByteBufferArgument.writeByteBuffer(target, codec.encodeKey(key));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.finish",
    "thirdPartyMethod" : "brave.Span.finish",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.finish" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.start",
    "thirdPartyMethod" : "brave.Span.tag",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.start" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.tag",
    "thirdPartyMethod" : "brave.Span.tag",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.tag" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.borrowObject",
    "thirdPartyMethod" : "org.apache.commons.pool2.impl.SoftReferenceObjectPool.borrowObject",
    "thirdPartyPackage" : "org.apache.commons.pool2.impl",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.borrowObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain",
    "thirdPartyMethod" : "org.LatencyUtils.SimplePauseDetector.<init>",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onAskRedirection",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onAskRedirection", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.scheduleRefresh", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.isEventLoopActive" ],
    "methodSlices" : [ "@Override\npublic void onAskRedirection() {\n}", "private boolean indicateTopologyRefreshSignal() {\n}", "private boolean scheduleRefresh() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectPubSubToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), key.nodeId, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), (key.host + \":\") + key.port, getSocketAddressSupplier(key));\n}", "/**\n * Create a pub/sub connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubToNodeAsync(RedisCodec<K, V> codec, String nodeId, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.loadViews",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.loadViews", "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.isEventLoopActive" ],
    "methodSlices" : [ "/**\n * Load partition views from a collection of {@link RedisURI}s and return the view per {@link RedisURI}. Partitions contain\n * an ordered list of {@link RedisClusterNode}s. The sort key is latency. Nodes with lower latency come first.\n *\n * @param seed\n * \t\tcollection of {@link RedisURI}s\n * @param connectTimeout\n * \t\tconnect timeout\n * @param discovery\n * \t\t{@code true} to discover additional nodes\n * @return mapping between {@link RedisURI} and {@link Partitions}\n */\n@Override\npublic CompletionStage<Map<RedisURI, Partitions>> loadViews(Iterable<RedisURI> seed, Duration connectTimeout, boolean discovery) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectToNodeAsync(redisCodec, key.nodeId, null, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectToNodeAsync(redisCodec, (key.host + \":\") + key.port, clusterWriter, getSocketAddressSupplier(key));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server that treats keys and values as UTF-8 strings.\n *\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub() {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic <K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNode(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.run",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.isEventLoopGroupActive", "io.lettuce.core.protocol.ConnectionWatchdog.isEventLoopGroupActive" ],
    "methodSlices" : [ "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter\n * @throws Exception\n * \t\twhen reconnection fails.\n */\npublic void run(int attempt) throws Exception {\n    run(attempt, Duration.ZERO)\n}", "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter.\n * @param delay\n * \t\tretry delay.\n * @throws Exception\n * \t\twhen reconnection fails.\n */\nprivate void run(int attempt, Duration delay) throws Exception {\n}", "private boolean isEventLoopGroupActive() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSubAsync",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect", "io.lettuce.core.protocol.ConnectionWatchdog.isEventLoopGroupActive", "io.lettuce.core.protocol.ConnectionWatchdog.isEventLoopGroupActive" ],
    "methodSlices" : [ "/**\n * Schedule reconnect if channel is not available/not active.\n */\npublic void scheduleReconnect() {\n}", "private boolean isEventLoopGroupActive() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doRelease" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onReconnectAttempt",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onReconnectAttempt", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.scheduleRefresh", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.isEventLoopActive" ],
    "methodSlices" : [ "@Override\npublic void onReconnectAttempt(int attempt) {\n}", "private boolean indicateTopologyRefreshSignal() {\n}", "private boolean scheduleRefresh() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNodeAsync(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUnknownNode",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUnknownNode", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.scheduleRefresh", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.isEventLoopActive" ],
    "methodSlices" : [ "@Override\npublic void onUnknownNode() {\n}", "private boolean indicateTopologyRefreshSignal() {\n}", "private boolean scheduleRefresh() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onMovedRedirection",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onMovedRedirection", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.scheduleRefresh", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.isEventLoopActive" ],
    "methodSlices" : [ "@Override\npublic void onMovedRedirection() {\n}", "private boolean indicateTopologyRefreshSignal() {\n}", "private boolean scheduleRefresh() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUncoveredSlot",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUncoveredSlot", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.scheduleRefresh", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.isEventLoopActive" ],
    "methodSlices" : [ "@Override\npublic void onUncoveredSlot(int slot) {\n}", "private boolean indicateTopologyRefreshSignal() {\n}", "private boolean scheduleRefresh() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doRelease" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.run",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.run", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.isEventLoopActive" ],
    "methodSlices" : [ "@Override\npublic void run() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.isShuttingDown",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3CompletableAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Completable.fromPublisher",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3CompletableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.TraceContextProvider.getTraceContextLater",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.justOrEmpty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.TraceContextProvider.getTraceContextLater" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.write",
    "thirdPartyMethod" : "io.netty.util.Recycler.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.write", "io.lettuce.core.protocol.CommandHandler.writeSingleCommand", "io.lettuce.core.protocol.CommandHandler.addToStack", "io.lettuce.core.protocol.CommandHandler.AddToStack.newInstance" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelDuplexHandler#write(io.netty.channel.ChannelHandlerContext, java.lang.Object,\nio.netty.channel.ChannelPromise)\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n}", "private void writeSingleCommand(ChannelHandlerContext ctx, RedisCommand<?, ?, ?> command, ChannelPromise promise) {\n    if (!isWriteable(command)) {\n    promise.trySuccess();\n    return;\n}\n    addToStack(command, promise)\n}", "private void addToStack(RedisCommand<?, ?, ?> command, ChannelPromise promise) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.util.Recycler.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.writeToChannelAndFlush", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.newInstance" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n}", "private void writeToChannelAndFlush(Channel channel, RedisCommand<?, ?, ?> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onError",
    "thirdPartyMethod" : "io.netty.util.Recycler.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onError", "io.lettuce.core.RedisPublisher.OnComplete.newInstance" ],
    "methodSlices" : [ "@Override\npublic void onError(Throwable t) {\n    executor.execute(OnComplete.newInstance(t, delegate));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.Recycler.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.writeToChannelAndFlush", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.newInstance" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}", "private void writeToChannelAndFlush(Channel channel, RedisCommand<?, ?, ?> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.Recycler.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.writeToChannelAndFlush", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.newInstance" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}", "private void writeToChannelAndFlush(Channel channel, RedisCommand<?, ?, ?> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onNext",
    "thirdPartyMethod" : "io.netty.util.Recycler.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onNext", "io.lettuce.core.RedisPublisher.OnNext.newInstance" ],
    "methodSlices" : [ "@Override\npublic void onNext(T t) {\n    executor.execute(OnNext.newInstance(t, delegate));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onComplete",
    "thirdPartyMethod" : "io.netty.util.Recycler.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onComplete", "io.lettuce.core.RedisPublisher.OnComplete.newInstance" ],
    "methodSlices" : [ "@Override\npublic void onComplete() {\n    executor.execute(OnComplete.newInstance(delegate));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2CompletableAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Completable.fromPublisher",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2CompletableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic <T, R> Flux<R> createDissolvingFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.randomkey",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.randomkey" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, SynUpdateArgs<K, V> args, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictdel(String dict, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasupdate(String alias, String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Map<V, List<V>>> ftSyndump(String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan" ],
    "methodSlices" : [ "@Override\npublic Mono<StreamScanCursor> scan(KeyStreamingChannel<K> channel, ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createMono",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createMono" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query, ExplainArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index, boolean deleteDocumentKeys) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.SentinelConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaTopologyRefresh.getNodes",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaTopologyRefresh.getNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasadd(String alias, String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasdel(String alias) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, boolean skipInitialScan, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan() {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, CreateArgs<K, V> arguments, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictadd(String dict, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "public <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.LettuceObservationContext.<init>",
    "thirdPartyMethod" : "io.micrometer.observation.transport.SenderContext.<init>",
    "thirdPartyPackage" : "io.micrometer.observation.transport",
    "path" : [ "io.lettuce.core.tracing.LettuceObservationContext.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftList() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftDictdump(String dict) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftTagvals(String index, String fieldName) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.apply",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.attr",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.ConnectionBuilder.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.createSoftReferenceObjectPool",
    "thirdPartyMethod" : "org.apache.commons.pool2.BasePooledObjectFactory.<init>",
    "thirdPartyPackage" : "org.apache.commons.pool2",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.createSoftReferenceObjectPool", "io.lettuce.core.support.ConnectionPoolSupport.RedisPooledObjectFactory.<init>" ],
    "methodSlices" : [ "/**\n * Creates a new {@link SoftReferenceObjectPool} using the {@link Supplier}.\n *\n * @param connectionSupplier\n * \t\tmust not be {@code null}.\n * @param wrapConnections\n * \t\t{@code false} to return direct connections that need to be returned to the pool using\n * \t\t{@link ObjectPool#returnObject(Object)}. {@code true} to return wrapped connections that are returned to the pool\n * \t\twhen invoking {@link StatefulConnection#close()}.\n * @param validationPredicate\n * \t\ta {@link Predicate} to help validate connections\n * @param <T>\n * \t\tconnection type.\n * @return the connection pool.\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T extends StatefulConnection<?, ?>> SoftReferenceObjectPool<T> createSoftReferenceObjectPool(Supplier<T> connectionSupplier, boolean wrapConnections, Predicate<T> validationPredicate) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.createGenericObjectPool",
    "thirdPartyMethod" : "org.apache.commons.pool2.BasePooledObjectFactory.<init>",
    "thirdPartyPackage" : "org.apache.commons.pool2",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.createGenericObjectPool", "io.lettuce.core.support.ConnectionPoolSupport.RedisPooledObjectFactory.<init>" ],
    "methodSlices" : [ "/**\n * Creates a new {@link GenericObjectPool} using the {@link Supplier}.\n *\n * @param connectionSupplier\n * \t\tmust not be {@code null}.\n * @param config\n * \t\tmust not be {@code null}.\n * @param wrapConnections\n * \t\t{@code false} to return direct connections that need to be returned to the pool using\n * \t\t{@link ObjectPool#returnObject(Object)}. {@code true} to return wrapped connections that are returned to the pool\n * \t\twhen invoking {@link StatefulConnection#close()}.\n * @param validationPredicate\n * \t\ta {@link Predicate} to help validate connections\n * @param <T>\n * \t\tconnection type.\n * @return the connection pool.\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T extends StatefulConnection<?, ?>> GenericObjectPool<T> createGenericObjectPool(Supplier<T> connectionSupplier, GenericObjectPoolConfig<T> config, boolean wrapConnections, Predicate<T> validationPredicate) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv6SubnetRule.<init>",
    "thirdPartyMethod" : "io.netty.util.NetUtil.isValidIpV6Address",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv6SubnetRule.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv6SubnetRule.isInSubnet",
    "thirdPartyMethod" : "io.netty.util.NetUtil.isValidIpV6Address",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv6SubnetRule.isInSubnet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ReadFrom.subnet",
    "thirdPartyMethod" : "io.netty.util.NetUtil.isValidIpV6Address",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ReadFrom.subnet", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.<init>", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.createSubnetRule" ],
    "methodSlices" : [ "/**\n * Setting to read from any node in the subnets.\n *\n * @param cidrNotations\n * \t\tCIDR-block notation strings, e.g., \"192.168.0.0/16\", \"2001:db8:abcd:0000::/52\". Must not be\n * \t\t{@code null}.\n * @return an instance of {@link ReadFromImpl.ReadFromSubnet}.\n * @since 6.1\n */\npublic static ReadFrom subnet(String... cidrNotations) {\n}", "/**\n *\n * @param cidrNotations\n * \t\tCIDR-block notation strings, e.g., \"192.168.0.0/16\" or \"2001:db8:abcd:0000::/52\".\n */\nReadFromSubnet(String... cidrNotations) {\n    LettuceAssert.notEmpty(cidrNotations, \"CIDR notations must not be empty\");\n    for (String cidrNotation : cidrNotations) {\n        rules.add(createSubnetRule(cidrNotation));\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2SingleAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Single.fromPublisher",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2SingleAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "reactor.util.context.Context.empty",
    "thirdPartyPackage" : "reactor.util.context",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3SingleAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Single.fromPublisher",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3SingleAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.observePatterns",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.create",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.observePatterns" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.observeChannels",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.create",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.observeChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContext",
    "thirdPartyMethod" : "brave.Tracer.currentSpan",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitLast",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelDuplexHandler.channelInactive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.SslOptions.createSslContextBuilder",
    "thirdPartyMethod" : "io.netty.handler.ssl.SslContextBuilder.ciphers",
    "thirdPartyPackage" : "io.netty.handler.ssl",
    "path" : [ "io.lettuce.core.SslOptions.createSslContextBuilder" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.subscribe",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onSubscribe",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.subscribe", "io.lettuce.core.RedisPublisher.RedisSubscription.subscribe", "io.lettuce.core.RedisPublisher.State.subscribe" ],
    "methodSlices" : [ "@Override\npublic void subscribe(Subscriber<? super T> subscriber) {\n    if (this.traceEnabled) {\n    LOG.trace(\"subscribe: {}@{}\", subscriber.getClass().getName(), Objects.hashCode(subscriber));\n}\n    // Reuse the first command but then discard it.\nRedisCommand<K, V, T> command = ref.get()\n    if (command != null) {\n    if (!ref.compareAndSet(command, null)) {\n        command = commandSupplier.get();\n    }\n} else {\n    command = commandSupplier.get();\n}\n    RedisSubscription<T> redisSubscription = new RedisSubscription<>(connection, command, dissolve, executor)\n    redisSubscription.subscribe(subscriber)\n}", "/**\n * Subscription procedure called by a {@link Publisher}\n *\n * @param subscriber\n * \t\tthe subscriber, must not be {@code null}.\n */\nvoid subscribe(Subscriber<? super T> subscriber) {\n    if (subscriber == null) {\n        throw new NullPointerException(\"Subscriber must not be null\");\n    }\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} subscribe: {}@{}\", state, subscriber.getClass().getName(), subscriber.hashCode());\n    }\n    state.subscribe(this, subscriber);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.start",
    "thirdPartyMethod" : "brave.Span.name",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.start" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.name",
    "thirdPartyMethod" : "brave.Span.name",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.name" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.empty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftExplain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftExplain(String index, V query, ExplainArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftList",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftList", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<List<V>> ftList() {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftTagvals", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<List<V>> ftTagvals(String index, String fieldName) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftDictdump(String dict) {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, SynUpdateArgs<K, V> args, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<SpellCheckResult<V>> ftSpellcheck(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictadd", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<Long> ftDictadd(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictdel(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.MovingEvent.from" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftCreate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftCreate(String index, CreateArgs<K, V> arguments, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasupdate(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<Map<V, List<V>>> ftSyndump(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSearch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSearch", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftSynupdate(String index, V synonymGroupId, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAlter",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAlter(String index, boolean skipInitialScan, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftSynupdate(String index, V synonymGroupId, SynUpdateArgs<K, V> args, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictdel", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<Long> ftDictdel(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query, ExplainArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index, boolean deleteDocumentKeys) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftList() {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftDropindex(String index, boolean deleteDocumentKeys) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictdump", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<List<V>> ftDictdump(String dict) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftTagvals(String index, String fieldName) {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasadd(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAggregate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftDropindex(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasdel", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAliasdel(String alias) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasdel(String alias) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, boolean skipInitialScan, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSyndump", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<Map<V, List<V>>> ftSyndump(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftExplain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftExplain(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftCreate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftCreate(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasadd", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAliasadd(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasupdate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAliasupdate(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, CreateArgs<K, V> arguments, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictadd(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAlter",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.error",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAlter(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.channelInactive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisHandshakeHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.channelInactive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.RedisHandshakeHandler.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.channelInactive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.channelInactive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.RedisCommandFactory.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.dynamic.RedisCommandFactory.<init>", "io.lettuce.core.dynamic.RedisCommandFactory.getCommands" ],
    "methodSlices" : [ "/**\n * Create a new {@link CommandFactory} given {@link StatefulConnection} and a {@link List} of {@link RedisCodec}s to use\n *\n * @param connection\n * \t\tmust not be {@code null}.\n * @param redisCodecs\n * \t\tmust not be {@code null}.\n */\npublic RedisCommandFactory(StatefulConnection<?, ?> connection, Iterable<? extends RedisCodec<?, ?>> redisCodecs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisClient.shutdownAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.AbstractRedisClient.shutdownAsync", "io.lettuce.core.AbstractRedisClient.closeResources" ],
    "methodSlices" : [ "/**\n * Shutdown this client and close all open connections asynchronously. Once all connections are closed, the associated\n * {@link ClientResources} are shut down/released gracefully considering quiet time and the shutdown timeout. The client\n * should be discarded after calling shutdown.\n *\n * @param quietPeriod\n * \t\tthe quiet period to allow the executor gracefully shut down.\n * @param timeout\n * \t\tthe maximum amount of time to wait until the backing executor is shutdown regardless if a task was\n * \t\tsubmitted during the quiet period.\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}.\n * @since 4.4\n * @see EventExecutorGroup#shutdownGracefully(long, long, TimeUnit)\n */\npublic CompletableFuture<Void> shutdownAsync(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.suspendTopologyRefresh",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.suspendTopologyRefresh" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.Operators.request",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.Operators.request", "io.lettuce.core.Operators.validate", "io.lettuce.core.Operators.reportBadRequest" ],
    "methodSlices" : [ "/**\n * Concurrent addition bound to Long.MAX_VALUE. Any concurrent write will \"happen before\" this operation.\n *\n * @param <T>\n * \t\tthe parent instance type\n * @param updater\n * \t\tcurrent field updater\n * @param instance\n * \t\tcurrent instance to update\n * @param toAdd\n * \t\tdelta to add\n * @return {@code true} if the operation succeeded.\n * @since 5.0.1\n */\npublic static <T> boolean request(AtomicLongFieldUpdater<T> updater, T instance, long toAdd) {\n}", "/**\n * Evaluate if a request is strictly positive otherwise {@link #reportBadRequest(long)}\n *\n * @param n\n * \t\tthe request value\n * @return true if valid\n */\nstatic boolean validate(long n) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onAskRedirection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onAskRedirection", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.emitAdaptiveRefreshScheduledEvent" ],
    "methodSlices" : [ "@Override\npublic void onAskRedirection() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRegistered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.close",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.close" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @param threadFactoryProvider\n * \t\tprovides a {@link java.util.concurrent.ThreadFactory} to create threads.\n * @return a new instance of default client resources.\n * @since 6.1.1\n */\nstatic ClientResources create(ThreadFactoryProvider threadFactoryProvider) {\n    return DefaultClientResources.builder().threadFactoryProvider(threadFactoryProvider).build();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.closeStaleConnections",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.closeStaleConnections" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(ClientResources clientResources, RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link DefaultClientResources} using default settings.\n *\n * @return a new instance of a default client resources.\n */\npublic static DefaultClientResources create() {\n    return builder().build();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doRelease" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURIs\n * \t\tone or more Redis URI, must not be {@code null} and not empty.\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(Iterable<RedisURI> redisURIs) {\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    return new RedisClusterClient(null, redisURIs);\n}", "/**\n * Initialize the client with a list of cluster URI's. All uris are tried in sequence for connecting initially to the\n * cluster. If any uri is successful for connection, the others are not tried anymore. The initial uri is needed to discover\n * the cluster structure for distributing the requests.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n * @param redisURIs\n * \t\titerable of initial {@link RedisURI cluster URIs}. Must not be {@code null} and not empty.\n */\nprotected RedisClusterClient(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    super(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    this.initialUris = Collections.unmodifiableList(LettuceLists.newList(redisURIs));\n    this.refresh = createTopologyRefresh();\n    setOptions(ClusterClientOptions.create());\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.StatefulRedisConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.StatefulRedisConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURIs\n * \t\tone or more Redis URI, must not be {@code null} and not empty\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    assertNotNull(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    return new RedisClusterClient(clientResources, redisURIs);\n}", "/**\n * Initialize the client with a list of cluster URI's. All uris are tried in sequence for connecting initially to the\n * cluster. If any uri is successful for connection, the others are not tried anymore. The initial uri is needed to discover\n * the cluster structure for distributing the requests.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n * @param redisURIs\n * \t\titerable of initial {@link RedisURI cluster URIs}. Must not be {@code null} and not empty.\n */\nprotected RedisClusterClient(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    super(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    this.initialUris = Collections.unmodifiableList(LettuceLists.newList(redisURIs));\n    this.refresh = createTopologyRefresh();\n    setOptions(ClusterClientOptions.create());\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.closeStaleConnections",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.closeStaleConnections" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUnknownNode",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUnknownNode", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.emitAdaptiveRefreshScheduledEvent" ],
    "methodSlices" : [ "@Override\npublic void onUnknownNode() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @return a new instance of default client resources.\n */\nstatic ClientResources create() {\n    return DefaultClientResources.create();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doRelease" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Shutdown the {@link ClientResources}.\n *\n * @param quietPeriod\n * \t\tthe quiet period as described in the documentation\n * @param timeout\n * \t\tthe maximum amount of time to wait until the executor is shutdown regardless if a task was submitted\n * \t\tduring the quiet period\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}\n * @return eventually the success/failure of the shutdown without errors.\n */\n@SuppressWarnings(\"unchecked\")\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n    logger.debug(\"Initiate shutdown ({}, {}, {})\", quietPeriod, timeout, timeUnit);\n    shutdownCalled = true;\n    DefaultPromise<Void> voidPromise = new DefaultPromise<>(ImmediateEventExecutor.INSTANCE);\n    PromiseCombiner aggregator = new PromiseCombiner(ImmediateEventExecutor.INSTANCE);\n    if (metricEventPublisher != null) {\n        metricEventPublisher.shutdown();\n    }\n    if (!sharedTimer) {\n        timer.stop();\n    }\n    if (!sharedEventLoopGroupProvider) {\n        Future<Boolean> shutdown = eventLoopGroupProvider.shutdown(quietPeriod, timeout, timeUnit);\n        aggregator.add(shutdown);\n    }\n    if (!sharedEventExecutor) {\n        Future<?> shutdown = eventExecutorGroup.shutdownGracefully(quietPeriod, timeout, timeUnit);\n        aggregator.add(shutdown);\n    }\n    if ((!sharedCommandLatencyRecorder) && (commandLatencyRecorder instanceof MetricCollector)) {\n        ((MetricCollector<?>) (commandLatencyRecorder)).shutdown();\n    }\n    aggregator.finish(voidPromise);\n    return PromiseAdapter.toBooleanPromise(voidPromise);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisStateMachine.decode",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.RedisStateMachine.decode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodes",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelUnregistered",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelUnregistered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.connectStandaloneAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.StatefulRedisConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.StatefulRedisConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.builder",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.builder", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns a new {@link DefaultClientResources.Builder} to construct {@link DefaultClientResources}.\n *\n * @return a new {@link DefaultClientResources.Builder} to construct {@link DefaultClientResources}.\n */\npublic static DefaultClientResources.Builder builder() {\n}", "private Builder() {\n}", "private Builder() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.mutate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.mutate", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns a builder to create new {@link DefaultClientResources} whose settings are replicated from the current\n * {@link DefaultClientResources}.\n * <p>\n * Note: The resulting {@link DefaultClientResources} retains shared state for {@link Timer},\n * {@link CommandLatencyRecorder}, {@link EventExecutorGroup}, and {@link EventLoopGroupProvider} if these are left\n * unchanged. Thus, you need only to shut down the last created {@link ClientResources} instances. Shutdown affects any\n * previously created {@link ClientResources}.\n * </p>\n *\n * @return a {@link DefaultClientResources.Builder} to create new {@link DefaultClientResources} whose settings are\nreplicated from the current {@link DefaultClientResources}.\n * @since 5.1\n */\n@Override\npublic DefaultClientResources.Builder mutate() {\n}", "private Builder() {\n}", "private Builder() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Creates a uri-less RedisClient with default {@link ClientResources}. You can connect to different Redis servers but you\n * must supply a {@link RedisURI} on connecting. Methods without having a {@link RedisURI} will fail with a\n * {@link java.lang.IllegalStateException}.\n *\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create() {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.closeAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup" ],
    "methodSlices" : [ "/**\n * Create an instance of a {@link EventExecutorGroup} using the default {@link ThreadFactoryProvider}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n */\npublic static <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.builder",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.builder", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @return a new instance of a default client resources.\n */\nstatic Builder builder() {\n    return DefaultClientResources.builder();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelActive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.Builder.build",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.Builder.build", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return a new instance of {@link DefaultClientResources}.\n */\n@Override\npublic DefaultClientResources build() {\n    DefaultClientResources resources = new DefaultClientResources(this);\n    if (this.afterBuild != null) {\n        this.afterBuild.run();\n    }\n    return resources;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onMovedRedirection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onMovedRedirection", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.emitAdaptiveRefreshScheduledEvent" ],
    "methodSlices" : [ "@Override\npublic void onMovedRedirection() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.exceptionCaught",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "reactor.core.Exceptions.throwIfFatal",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.Operators.onOperatorError" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.debugSegfault",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.debugSegfault" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.subscribe",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.subscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.punsubscribe",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.punsubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.unsubscribe",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.unsubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.ssubscribe",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.ssubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.sunsubscribe",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.sunsubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.cancel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.cancel", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnError", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "@Override\npublic void cancel() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.cancel();\n        CancellationException exception = new CancellationException();\n        doOnError(exception);\n        notifyBiConsumer(consumers, exception);\n    }\n}", "@Override\nprotected void doOnError(Throwable throwable) {\n    onError(throwable);\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.complete",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.complete", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnComplete", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "@Override\npublic void complete() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.complete();\n        doOnComplete();\n        notifyConsumers(consumers);\n    }\n}", "@Override\n@SuppressWarnings({ \"unchecked\", \"CastCanBeRemovedNarrowingVariableType\" })\nprotected void doOnComplete() {\n    if (getOutput() != null) {\n        Object result = getOutput().get();\n        if (getOutput().hasError()) {\n            onError(ExceptionFactory.createExecutionException(getOutput().getError()));\n            return;\n        }\n        if ((!(getOutput() instanceof StreamingOutput<?>)) && (result != null)) {\n            if (dissolve && (result instanceof Collection)) {\n                Collection<T> collection = ((Collection<T>) (result));\n                for (T t : collection) {\n                    if (t != null) {\n                        subscription.onNext(t);\n                    }\n                }\n            } else {\n                subscription.onNext(((T) (result)));\n            }\n        }\n    }\n    subscription.onAllDataRead();\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.request",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.request", "io.lettuce.core.RedisPublisher.State.request", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "/**\n * Signal for data demand.\n *\n * @param n\n * \t\tnumber of requested elements.\n */\n@Override\npublic final void request(long n) {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} request: {}\", state, n);\n    }\n    state.request(this, n);\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.subscribe",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.subscribe", "io.lettuce.core.RedisPublisher.RedisSubscription.subscribe" ],
    "methodSlices" : [ "@Override\npublic void subscribe(Subscriber<? super T> subscriber) {\n    if (this.traceEnabled) {\n    LOG.trace(\"subscribe: {}@{}\", subscriber.getClass().getName(), Objects.hashCode(subscriber));\n}\n    // Reuse the first command but then discard it.\nRedisCommand<K, V, T> command = ref.get()\n    if (command != null) {\n    if (!ref.compareAndSet(command, null)) {\n        command = commandSupplier.get();\n    }\n} else {\n    command = commandSupplier.get();\n}\n    RedisSubscription<T> redisSubscription = new RedisSubscription<>(connection, command, dissolve, executor)\n    redisSubscription.subscribe(subscriber)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.completeExceptionally",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.completeExceptionally", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnError", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "@Override\npublic boolean completeExceptionally(Throwable throwable) {\n    Object[] consumers = ONCOMPLETE.get(this);\n    boolean result = false;\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        result = command.completeExceptionally(throwable);\n        doOnError(throwable);\n        notifyBiConsumer(consumers, throwable);\n    }\n    return result;\n}", "@Override\nprotected void doOnError(Throwable throwable) {\n    onError(throwable);\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.Command.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.Command.encode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.ByteArrayCodec.encodeKey",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.ByteArrayCodec.encodeKey" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue", "io.lettuce.core.codec.CipherCodec.KeyDescriptor.writeTo" ],
    "methodSlices" : [ "@Override\npublic void encodeValue(Object value, ByteBuf target) {\n    ByteBuf serialized;\n    if (delegate instanceof ToByteBufEncoder) {\n        serialized = target.alloc().buffer(estimateSize(value));\n        ((ToByteBufEncoder) (delegate)).encodeKey(value, serialized);\n    } else {\n        ByteBuffer byteBuffer = delegate.encodeValue(value);\n        serialized = target.alloc().buffer(byteBuffer.remaining());\n        serialized.writeBytes(byteBuffer);\n    }\n    try {\n        KeyDescriptor keyDescriptor = this.encrypt.encryptionKey();\n        Cipher cipher = this.encrypt.get(keyDescriptor);\n        keyDescriptor.writeTo(target);\n        doWithCipher(cipher, serialized, target);\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(e);\n    } finally {\n        serialized.release();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.KeyArgument.encode", "io.lettuce.core.protocol.CommandArgs.encode" ],
    "methodSlices" : [ "/**\n * Encode the {@link CommandArgs} and write the arguments to the {@link ByteBuf}.\n *\n * @param buf\n * \t\tthe target buffer.\n */\npublic void encode(ByteBuf buf) {\n    buf.touch(\"CommandArgs.encode()\");\n    for (SingularArgument singularArgument : singularArguments) {\n        singularArgument.encode(buf);\n    }\n}", "@SuppressWarnings(\"unchecked\")\n@Override\nvoid encode(ByteBuf target) {\n    if (codec instanceof ToByteBufEncoder) {\n        CommandArgs.encode(target, ((ToByteBufEncoder<K, K>) (codec)), key, ToByteBufEncoder::encodeKey);\n        return;\n    }\n    ByteBufferArgument.writeByteBuffer(target, codec.encodeKey(key));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic <T, R> Flux<R> createDissolvingFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux" ],
    "methodSlices" : [ "public <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defaultIfEmpty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic <T, R> Flux<R> createDissolvingFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createMono",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defaultIfEmpty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createMono", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "public <T> Mono<T> createMono(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defaultIfEmpty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "public <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.event.DefaultEventBus.<init>",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.many",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.event.DefaultEventBus.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.many",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create", "io.lettuce.authx.TokenBasedRedisCredentialsProvider.<init>" ],
    "methodSlices" : [ "public static TokenBasedRedisCredentialsProvider create(TokenManager tokenManager) {\n    TokenBasedRedisCredentialsProvider credentialManager = new TokenBasedRedisCredentialsProvider(tokenManager);\n    credentialManager.init();\n    return credentialManager;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandEncoder.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.PlatformDependent.directBufferPreferred",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.protocol.CommandEncoder.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2MaybeAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Flowable.singleElement",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2MaybeAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.<init>", "io.lettuce.core.RedisPublisher.<clinit>" ],
    "methodSlices" : [ "/**\n * Creates a new {@link RedisPublisher} for a static command.\n *\n * @param staticCommand\n * \t\tstatic command, must not be {@code null}.\n * @param connection\n * \t\tthe connection, must not be {@code null}.\n * @param dissolve\n * \t\tdissolve collections into particular elements.\n * @param publishOn\n * \t\texecutor to use for publishOn signals.\n */\npublic RedisPublisher(RedisCommand<K, V, T> staticCommand, StatefulConnection<K, V> connection, boolean dissolve, Executor publishOn) {\n    this(() -> staticCommand, connection, dissolve, publishOn);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.message",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.message", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void message(K channel, V message) {\n    notifications.message(getNode(), channel, message);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void notifyChannelActive(Channel channel) {\n    this.logPrefix = null;\n    this.connectionError = null;\n    if (isClosed()) {\n        logger.info(\"{} Closing channel because endpoint is already closed\", logPrefix());\n        channel.close();\n        return;\n    }\n    if (connectionWatchdog != null) {\n        connectionWatchdog.arm();\n    }\n    sharedLock.doExclusive(() -> {\n        this.channel = channel;\n        try {\n            // Move queued commands to buffer before issuing any commands because of connection activation.\n            // That's necessary to prepend queued commands first as some commands might get into the queue\n            // after the connection was disconnected. They need to be prepended to the command buffer\n            if (debugEnabled) {\n                logger.debug(\"{} activateEndpointAndExecuteBufferedCommands {} command(s) buffered\", logPrefix(), disconnectedBuffer.size());\n            }\n            if (debugEnabled) {\n                logger.debug(\"{} activating endpoint\", logPrefix());\n            }\n            try {\n                inActivation = true;\n                connectionFacade.activated();\n            } finally {\n                inActivation = false;\n            }\n            flushCommands(channel, disconnectedBuffer);\n        } catch (Exception e) {\n            if (debugEnabled) {\n                logger.debug(\"{} channelActive() ran into an exception\", logPrefix());\n            }\n            throw e;\n        }\n    });\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.eventLoopGroupClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftDictdump(String dict) {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.support.RedisClientCdiBean.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.support.RedisClientCdiBean.create", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisClient create(CreationalContext<RedisClient> creationalContext) {\n    CreationalContext<RedisURI> uriCreationalContext = beanManager.createCreationalContext(redisURIBean);\n    RedisURI redisURI = ((RedisURI) (beanManager.getReference(redisURIBean, RedisURI.class, uriCreationalContext)));\n    if (clientResourcesBean != null) {\n        ClientResources clientResources = ((ClientResources) (beanManager.getReference(clientResourcesBean, ClientResources.class, uriCreationalContext)));\n        return RedisClient.create(clientResources, redisURI);\n    }\n    return RedisClient.create(redisURI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), getConnectionProvider(), cursor, scanFunction, ((ClusterScanSupport.ScanCursorMapper) (resultMapper)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, SynUpdateArgs<K, V> args, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.unsubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.unsubscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void unsubscribed(RedisClusterNode node, K channel, long count) {\n    if (nodeMessagePropagation) {\n        super.unsubscribed(node, channel, count);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T extends EventLoopGroup> T allocate(Class<T> type) {\n    lock.lock();\n    try {\n        logger.debug(\"Allocating executor {}\", type.getName());\n        return addReference(getOrCreate(type));\n    } finally {\n        lock.unlock();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.iterator",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.iterator", "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Iterator<RedisNodeDescription> iterator() {\n    return knownNodes.iterator();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisClient.shutdownAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.AbstractRedisClient.shutdownAsync", "io.lettuce.core.AbstractRedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Shutdown this client and close all open connections asynchronously. Once all connections are closed, the associated\n * {@link ClientResources} are shut down/released gracefully considering quiet time and the shutdown timeout. The client\n * should be discarded after calling shutdown.\n *\n * @param quietPeriod\n * \t\tthe quiet period to allow the executor gracefully shut down.\n * @param timeout\n * \t\tthe maximum amount of time to wait until the backing executor is shutdown regardless if a task was\n * \t\tsubmitted during the quiet period.\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}.\n * @since 4.4\n * @see EventExecutorGroup#shutdownGracefully(long, long, TimeUnit)\n */\npublic CompletableFuture<Void> shutdownAsync(long quietPeriod, long timeout, TimeUnit timeUnit) {\n    if (shutdown.compareAndSet(false, true)) {\n        logger.debug(\"Initiate shutdown ({}, {}, {})\", quietPeriod, timeout, timeUnit);\n        return closeResources().thenCompose(value -> closeClientResources(quietPeriod, timeout, timeUnit));\n    }\n    return CompletableFuture.completedFuture(null);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.closeStaleConnections",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.closeStaleConnections", "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Close stale connections.\n */\npublic void closeStaleConnections() {\n    logger.debug(\"closeStaleConnections() count before expiring: {}\", getConnectionCount());\n    Set<ConnectionKey> stale = getStaleConnectionKeys();\n    for (ConnectionKey connectionKey : stale) {\n        connectionProvider.close(connectionKey);\n    }\n    logger.debug(\"closeStaleConnections() count after expiring: {}\", getConnectionCount());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisVectorSetCommandBuilder.vlinksWithScores",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisVectorSetCommandBuilder.vlinksWithScores", "io.lettuce.core.output.ValueDoubleMapOutput.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@code VLINKS} command with the WITHSCORES option to get the links of an element along with their scores.\n *\n * @param key\n * \t\tthe key of the vector set, must not be {@code null}\n * @param element\n * \t\tthe name of the element in the vector set, must not be {@code null}\n * @return a new {@link Command} that returns a list of elements with their similarity scores\n * @see <a href=\"https://redis.io/docs/latest/commands/vlinks/\">Redis Documentation: VLINKS</a>\n */\npublic Command<K, V, Map<V, Double>> vlinksWithScores(K key, V element) {\n    notNullKey(key);\n    notNullKey(element);\n    CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key).addValue(element).add(WITHSCORES);\n    return createCommand(VLINKS, new ValueDoubleMapOutput<>(codec), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getNodes",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getNodes", "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic List<RedisNodeDescription> getNodes() {\n    return knownNodes;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.<init>", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "public PooledClusterConnectionProvider(RedisClusterClient redisClusterClient, RedisChannelWriter clusterWriter, RedisCodec<K, V> redisCodec, ClusterEventListener clusterEventListener) {\n    this.redisCodec = redisCodec;\n    this.redisClusterClient = redisClusterClient;\n    this.options = redisClusterClient.getClusterClientOptions();\n    this.clusterWriter = clusterWriter;\n    this.clusterEventListener = clusterEventListener;\n    this.connectionFactory = new NodeConnectionPostProcessor(getConnectionFactory(redisClusterClient));\n    this.connectionProvider = new AsyncConnectionProvider<>(this.connectionFactory);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync", "io.lettuce.core.cluster.ClusterNodeEndpoint.<clinit>" ],
    "methodSlices" : [ "/**\n * Move queued and buffered commands from the inactive connection to the upstream command writer. This is done only if the\n * current connection is disconnected and auto-reconnect is enabled (command-retries). If the connection would be open, we\n * could get into a race that the commands we're moving are right now in processing. Alive connections can handle redirects\n * and retries on their own.\n */\n@Override\npublic CompletableFuture<Void> closeAsync() {\n    logger.debug(\"{} closeAsync()\", logPrefix());\n    if (clusterChannelWriter != null) {\n        retriggerCommands(doExclusive(this::drainCommands));\n    }\n    return super.closeAsync();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link DefaultClientResources} using default settings.\n *\n * @return a new instance of a default client resources.\n */\npublic static DefaultClientResources create() {\n    return builder().build();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.isDomainSocketSupported",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.isDomainSocketSupported", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if a native transport for domain sockets is available.\n */\npublic static boolean isDomainSocketSupported() {\n    return EpollProvider.isAvailable() || KqueueProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.complete",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.complete", "io.lettuce.core.RedisPublisher.RedisSubscription.changeState", "io.lettuce.core.RedisPublisher.RedisSubscription.<clinit>" ],
    "methodSlices" : [ "public boolean complete() {\n    return changeState(State.READING, State.COMPLETED);\n}", "boolean changeState(State oldState, State newState) {\n    return STATE.compareAndSet(this, oldState, newState);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.socketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> socketChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.unsubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.unsubscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void unsubscribed(RedisClusterNode node, K channel, long count) {\n    getListeners().forEach(listener -> listener.unsubscribed(channel, count));\n    clusterListeners.forEach(listener -> listener.unsubscribed(node, channel, count));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURIs\n * \t\tone or more Redis URI, must not be {@code null} and not empty.\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(Iterable<RedisURI> redisURIs) {\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    return new RedisClusterClient(null, redisURIs);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisVectorSetCommandBuilder.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisVectorSetCommandBuilder.vsimWithScoreWithAttribs", "io.lettuce.core.output.VSimScoreAttribsMapOutput.<clinit>" ],
    "methodSlices" : [ "public Command<K, V, Map<V, VSimScoreAttribs>> vsimWithScoreWithAttribs(K key, VSimArgs vSimArgs, Double[] vectors) {\n    notNullKey(key);\n    notEmpty(vectors);\n    CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key);\n    if (vectors.length > 1) {\n        args.add(CommandKeyword.VALUES);\n        args.add(vectors.length);\n        Arrays.stream(vectors).forEach(args::add);\n    } else {\n        args.add(vectors[0]);\n    }\n    args.add(WITHSCORES).add(WITHATTRIBS);\n    if (vSimArgs != null) {\n        vSimArgs.build(args);\n    }\n    return createCommand(VSIM, new VSimScoreAttribsMapOutput<>(codec), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisStateMachine.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.RedisStateMachine.<init>", "io.lettuce.core.protocol.RedisStateMachine.<clinit>" ],
    "methodSlices" : [ "State() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.isClosed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.isClosed", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return true if the connection is closed (final state in the connection lifecyle).\n */\npublic boolean isClosed() {\n    return CLOSED.get(this) == ST_CLOSED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive", "io.lettuce.core.protocol.ConnectionWatchdog.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n    logger.debug(\"{} channelInactive()\", logPrefix());\n    if (!armed) {\n        logger.debug(\"{} ConnectionWatchdog not armed\", logPrefix());\n        return;\n    }\n    channel = null;\n    if (listenOnChannelInactive && (!reconnectionHandler.isReconnectSuspended())) {\n        scheduleReconnect();\n    } else {\n        logger.debug(\"{} Reconnect scheduling disabled\", logPrefix(), ctx);\n    }\n    super.channelInactive(ctx);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.smessage",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.smessage", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void smessage(K shardChannel, V message) {\n    notifications.smessage(getNode(), shardChannel, message);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.closeAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.closeAsync", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * Close the connection (asynchronous).\n *\n * @since 5.1\n */\npublic CompletableFuture<Void> closeAsync() {\n    if (debugEnabled) {\n        logger.debug(\"closeAsync()\");\n    }\n    if (CLOSED.get(this) == ST_CLOSED) {\n        logger.warn(\"Connection is already closed\");\n        return closeFuture;\n    }\n    if (CLOSED.compareAndSet(this, ST_OPEN, ST_CLOSED)) {\n        active = false;\n        CompletableFuture<Void> future = channelWriter.closeAsync();\n        future.whenComplete((v, t) -> {\n            closeEvents.fireEventClosed(this);\n            closeEvents = new CloseEvents();\n            if (t != null) {\n                closeFuture.completeExceptionally(t);\n            } else {\n                closeFuture.complete(v);\n            }\n        });\n    } else {\n        logger.warn(\"Connection is already closed (concurrently)\");\n    }\n    return closeFuture;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query, ExplainArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURIs\n * \t\tone or more Redis URI, must not be {@code null} and not empty\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    assertNotNull(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    return new RedisClusterClient(clientResources, redisURIs);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onReconnectAttempt",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onReconnectAttempt", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.getClusterTopologyRefreshOptions", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void onReconnectAttempt(int attempt) {\n}", "private ClusterTopologyRefreshOptions getClusterTopologyRefreshOptions() {\n    ClientOptions clientOptions = this.clientOptions.get();\n    if (clientOptions instanceof ClusterClientOptions) {\n        return ((ClusterClientOptions) (clientOptions)).getTopologyRefreshOptions();\n    }\n    return FALLBACK_OPTIONS;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.message",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.message", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void message(RedisClusterNode node, K channel, V message) {\n    getListeners().forEach(listener -> listener.message(channel, message));\n    clusterListeners.forEach(listener -> listener.message(node, channel, message));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.getPartitions",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.getPartitions", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Retrieve the cluster view. Partitions are shared amongst all connections opened by this client instance.\n *\n * @return the partitions.\n */\npublic Partitions getPartitions() {\n    if (partitions == null) {\n        get(initializePartitions(), e -> new RedisException(\"Cannot obtain initial Redis Cluster topology\", e));\n    }\n    return partitions;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisAuthenticationHandler.createDefaultAuthenticationHandler",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisAuthenticationHandler.createDefaultAuthenticationHandler", "io.lettuce.core.RedisAuthenticationHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * Creates a new default {@link RedisAuthenticationHandler}.\n * <p/>\n * The default {@link RedisAuthenticationHandler} is used when re-authentication is not supported.\n *\n * @return a new {@link RedisAuthenticationHandler}\n * @since 6.6.0\n * @see RedisCredentialsProvider\n */\npublic static <K, V> RedisAuthenticationHandler<K, V> createDefaultAuthenticationHandler() {\n    return new DisabledAuthenticationHandler<>();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.closeStaleConnections",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.closeStaleConnections", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Close stale connections.\n */\n@Override\npublic void closeStaleConnections() {\n    logger.debug(\"closeStaleConnections() count before expiring: {}\", getConnectionCount());\n    connectionProvider.forEach((key, connection) -> {\n        if (isStale(key)) {\n            connectionProvider.close(key);\n        }\n    });\n    logger.debug(\"closeStaleConnections() count after expiring: {}\", getConnectionCount());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.<init>", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @param writer\n * \t\tthe channel writer\n * @param timeout\n * \t\ttimeout value\n */\npublic RedisChannelHandler(RedisChannelWriter writer, Duration timeout) {\n    this.channelWriter = writer;\n    this.clientResources = writer.getClientResources();\n    this.tracingEnabled = clientResources.tracing().isEnabled();\n    writer.setConnectionFacade(this);\n    setTimeout(timeout);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.unsubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.unsubscribed", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void unsubscribed(K channel, long count) {\n    notifications.unsubscribed(getNode(), channel, count);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNodeAsync(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n    assertNotNull(codec);\n    assertNotEmpty(initialUris);\n    LettuceAssert.notNull(socketAddressSupplier, \"SocketAddressSupplier must not be null\");\n    ClusterNodeEndpoint endpoint = new ClusterNodeEndpoint(getClusterClientOptions(), getResources(), clusterWriter);\n    RedisChannelWriter writer = endpoint;\n    if (CommandExpiryWriter.isSupported(getClusterClientOptions())) {\n        writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getClusterClientOptions(), getResources());\n    }\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n        writer = new CommandListenerWriter(writer, getCommandListeners());\n    }\n    StatefulRedisConnectionImpl<K, V> connection = newStatefulRedisConnection(writer, endpoint, codec, getFirstUri().getTimeout(), getClusterClientOptions().getJsonParser());\n    connection.setAuthenticationHandler(createHandler(connection, getFirstUri().getCredentialsProvider(), false, getOptions()));\n    ConnectionFuture<StatefulRedisConnection<K, V>> connectionFuture = connectStatefulAsync(connection, endpoint, getFirstUri(), socketAddressSupplier, () -> new CommandHandler(getClusterClientOptions(), getResources(), endpoint));\n    return connectionFuture.whenComplete((conn, throwable) -> {\n        if (throwable != null) {\n            connection.closeAsync();\n        }\n    });\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAggregate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplica.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplica.connectAsync", "io.lettuce.core.masterreplica.MasterReplica.connectAsyncSentinelOrStaticSetup" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis Master-Replica server/servers using the supplied {@link RedisURI} and the\n * supplied {@link RedisCodec codec} to encode/decode keys.\n * <p>\n * This {@link MasterReplica} performs auto-discovery of nodes if the URI is a Redis Sentinel URI. Master/Replica URIs will\n * be treated as static topology and no additional hosts are discovered in such case. Redis Standalone Master/Replica will\n * discover the roles of the supplied {@link RedisURI URIs} and issue commands to the appropriate node.\n * </p>\n * <p>\n * When using Redis Sentinel, ensure that {@link Iterable redisURIs} contains only a single entry as only the first URI is\n * considered. {@link RedisURI} pointing to multiple Sentinels can be configured through\n * {@link RedisURI.Builder#withSentinel}.\n * </p>\n *\n * @param redisClient\n * \t\tthe Redis client.\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}.\n * @param redisURIs\n * \t\tthe Redis server(s) to connect to, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return {@link CompletableFuture} that is notified once the connect is finished.\n * @since 6.0\n */\npublic static <K, V> CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsync(RedisClient redisClient, RedisCodec<K, V> codec, Iterable<RedisURI> redisURIs) {\n    return transformAsyncConnectionException(connectAsyncSentinelOrStaticSetup(redisClient, codec, redisURIs), redisURIs);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RediSearchCommandBuilder.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RediSearchCommandBuilder.ftSpellcheck", "io.lettuce.core.search.SpellCheckResultParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Perform spelling correction on a query.\n *\n * @param index\n * \t\tthe index name\n * @param query\n * \t\tthe search query\n * @param args\n * \t\tthe spellcheck arguments\n * @return the result of the spellcheck command\n */\npublic Command<K, V, SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n    LettuceAssert.notNull(index, \"Index must not be null\");\n    LettuceAssert.notNull(query, \"Query must not be null\");\n    CommandArgs<K, V> commandArgs = new CommandArgs<>(codec).add(index).addValue(query);\n    if (args != null) {\n        args.build(commandArgs);\n    }\n    SpellCheckResultParser<K, V> parser = new SpellCheckResultParser<>(codec);\n    return createCommand(FT_SPELLCHECK, new EncodedComplexOutput<>(codec, parser), commandArgs);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.connectionBuilder",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.connectionBuilder", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "public static ConnectionBuilder connectionBuilder() {\n    return new ConnectionBuilder();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, boolean skipInitialScan, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doRelease", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}", "private Future<?> doRelease(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n    logger.debug(\"Release executor {}\", eventLoopGroup);\n    Class<?> key = getKey(release(eventLoopGroup));\n    if (((key == null) && eventLoopGroup.isShuttingDown()) || refCounter.containsKey(eventLoopGroup)) {\n        return new SucceededFuture<>(ImmediateEventExecutor.INSTANCE, true);\n    }\n    if (key != null) {\n        eventLoopGroups.remove(key);\n    }\n    return eventLoopGroup.shutdownGracefully(quietPeriod, timeout, unit);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.findConnectionBySlotReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Flux<K> clusterGetKeysInSlot(int slot, int count) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> findConnectionBySlotReactive(int slot) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSyndump", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<Map<V, List<V>>> ftSyndump(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftExplain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftExplain(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RediSearchCommandBuilder.ftAggregate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RediSearchCommandBuilder.ftAggregate", "io.lettuce.core.search.AggregateReplyParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Run a search query on an index and perform aggregate transformations on the results.\n *\n * @param index\n * \t\tthe index name\n * @param query\n * \t\tthe query\n * @param aggregateArgs\n * \t\tthe aggregate arguments\n * @return the result of the aggregate command\n */\npublic Command<K, V, AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> aggregateArgs) {\n    LettuceAssert.notNull(index, \"Index must not be null\");\n    LettuceAssert.notNull(query, \"Query must not be null\");\n    CommandArgs<K, V> args = new CommandArgs<>(codec).add(index);\n    args.addValue(query);\n    boolean withCursor = false;\n    if (aggregateArgs != null) {\n        aggregateArgs.build(args);\n        withCursor = (aggregateArgs.getWithCursor() != null) && aggregateArgs.getWithCursor().isPresent();\n    }\n    return createCommand(FT_AGGREGATE, new EncodedComplexOutput<>(codec, new AggregateReplyParser<>(codec, withCursor)), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisStateMachine.decode",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.RedisStateMachine.decode", "io.lettuce.core.protocol.RedisStateMachine.<clinit>" ],
    "methodSlices" : [ "/**\n * Attempt to decode a redis response and return a flag indicating whether a complete response was read.\n *\n * @param buffer\n * \t\tBuffer containing data from the server.\n * @param output\n * \t\tCurrent command output.\n * @param errorHandler\n * \t\tthe error handler\n * @return true if a complete response was read.\n */\npublic boolean decode(ByteBuf buffer, CommandOutput<?, ?, ?> output, Consumer<Exception> errorHandler) {\n    buffer.touch(\"RedisStateMachine.decode()\");\n    if (isEmpty(stack)) {\n        addHead(stack);\n    }\n    if (output == null) {\n        return isEmpty(stack);\n    }\n    boolean resp3Indicator = doDecode(buffer, output, errorHandler);\n    if (debugEnabled) {\n        logger.debug(\"Decode done, empty stack: {}\", isEmpty(stack));\n    }\n    if (isDiscoverProtocol()) {\n        if (resp3Indicator) {\n            setProtocolVersion(ProtocolVersion.RESP3);\n        } else {\n            setProtocolVersion(ProtocolVersion.RESP2);\n        }\n    }\n    return isEmpty(stack);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptKill() {\n    Map<String, Publisher<String>> publishers = executeOnNodes(RedisScriptingReactiveCommands::scriptKill, ALL_NODES);\n    return Flux.merge(publishers.values()).onErrorReturn(\"OK\").last();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<Void> shutdown(boolean save) {\n    Map<String, Publisher<Void>> publishers = executeOnNodes(commands -> commands.shutdown(save), ALL_NODES);\n    return Flux.merge(publishers.values()).then();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisAuthenticationHandler.createHandler",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisAuthenticationHandler.createHandler", "io.lettuce.core.RedisAuthenticationHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * Creates a new {@link RedisAuthenticationHandler} if the connection supports re-authentication.\n *\n * @param connection\n * \t\tthe connection to authenticate\n * @param credentialsProvider\n * \t\tthe implementation of {@link RedisCredentialsProvider} to use\n * @param isPubSubConnection\n * \t\t{@code true} if the connection is a pub/sub connection\n * @param options\n * \t\tthe {@link ClientOptions} to use\n * @return a new {@link RedisAuthenticationHandler} if the connection supports re-authentication, otherwise an\nimplementation of the {@link RedisAuthenticationHandler} that does nothing\n * @since 6.6.0\n * @see RedisCredentialsProvider\n */\npublic static <K, V> RedisAuthenticationHandler<K, V> createHandler(StatefulRedisConnectionImpl<K, V> connection, RedisCredentialsProvider credentialsProvider, Boolean isPubSubConnection, ClientOptions options) {\n    if (isSupported(options)) {\n        if (isPubSubConnection && (options.getConfiguredProtocolVersion() == ProtocolVersion.RESP2)) {\n            throw new RedisConnectionException(\"Renewable credentials are not supported with RESP2 protocol on a pub/sub connection.\");\n        }\n        return new RedisAuthenticationHandler<>(connection, credentialsProvider, isPubSubConnection);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object)\n */\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n    ByteBuf input = ((ByteBuf) (msg));\n    input.touch(\"CommandHandler.read()\");\n    if ((!input.isReadable()) || (input.refCnt() == 0)) {\n        logger.warn(\"{} Input not readable {}, {}\", logPrefix(), input.isReadable(), input.refCnt());\n        return;\n    }\n    if (debugEnabled) {\n        logger.debug(\"{} Received: {} bytes, {} commands in the stack\", logPrefix(), input.readableBytes(), stack.size());\n    }\n    try {\n        if ((readBuffer == null) || (readBuffer.refCnt() < 1)) {\n            logger.warn(\"{} Ignoring received data for closed or abandoned connection\", logPrefix());\n            return;\n        }\n        if (debugEnabled && (ctx.channel() != channel)) {\n            logger.debug(\"{} Ignoring data for a non-registered channel {}\", logPrefix(), ctx.channel());\n            return;\n        }\n        if (traceEnabled) {\n            logger.trace(\"{} Buffer: {}\", logPrefix(), input.toString(Charset.defaultCharset()).trim());\n        }\n        readBuffer.touch(\"CommandHandler.read()\");\n        readBuffer.writeBytes(input);\n        decode(ctx, readBuffer);\n    } finally {\n        input.release();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied uri with shared {@link ClientResources}.You need to shut down the\n * {@link ClientResources} upon shutting down your application. You can connect to different Redis servers but you must\n * supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param uri\n * \t\tthe Redis URI, must not be empty or {@code null}.\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(ClientResources clientResources, String uri) {\n    assertNotNull(clientResources);\n    LettuceAssert.notEmpty(uri, \"URI must not be empty\");\n    return create(clientResources, RedisClusterURIUtil.toRedisURIs(URI.create(uri)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getRandomConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getRandomConnectionAsync", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisConnection<K, V>> getRandomConnectionAsync(ConnectionIntent connectionIntent) {\n    if (debugEnabled) {\n        logger.debug((\"getConnection(\" + connectionIntent) + \")\");\n    }\n    // Choose a random master shard first to ensure even distribution across partitions,\n    // then delegate to the slot-based selection to reuse ReadFrom/intent logic and caching.\n    List<RedisClusterNode> masters = partitions.stream().filter(n -> n.is(RedisClusterNode.NodeFlag.UPSTREAM) && (!n.hasNoSlots())).collect(Collectors.toList());\n    if (masters.isEmpty()) {\n        int slot = ThreadLocalRandom.current().nextInt(SlotHash.SLOT_COUNT);\n        return getConnectionAsync(connectionIntent, slot);\n    }\n    RedisClusterNode master = masters.get(ThreadLocalRandom.current().nextInt(masters.size()));\n    List<Integer> masterSlots = master.getSlots();\n    int slot = masterSlots.get(ThreadLocalRandom.current().nextInt(masterSlots.size()));\n    return getConnectionAsync(connectionIntent, slot);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelUnregistered",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelUnregistered", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelUnregistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n    if (debugEnabled) {\n        logger.debug(\"{} channelUnregistered()\", logPrefix());\n    }\n    if ((channel != null) && (ctx.channel() != channel)) {\n        logger.debug(\"{} My channel and ctx.channel mismatch. Propagating event to other listeners\", logPrefix());\n        ctx.fireChannelUnregistered();\n        return;\n    }\n    channel = null;\n    if (readBuffer != null) {\n        readBuffer.release();\n    }\n    if (rsm != null) {\n        rsm.close();\n    }\n    rsm = null;\n    reset();\n    setState(LifecycleState.CLOSED);\n    ctx.fireChannelUnregistered();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.EpollProvider.getResources", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for epoll-backed transport. Check availability with {@link #isAvailable()} prior\n * to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n * @since 6.0\n */\npublic static EventLoopResources getResources() {\n    return EPOLL_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport {@link EventLoopGroup} class.\n * @param domainSocket\n * \t\t{@code true} to indicate Unix Domain Socket usage, {@code false} otherwise.\n * @since 6.3.3\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass(boolean domainSocket) {\n    return (domainSocket && EpollProvider.isAvailable()) && IOUringProvider.isAvailable() ? EpollProvider.getResources().eventLoopGroupClass() : RESOURCES.eventLoopGroupClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.DefaultConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.DefaultConnectionFactory.apply", "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    RedisURI.Builder builder = RedisURI.builder(initialRedisUri).withHost(key.host).withPort(key.port);\n    ConnectionFuture<StatefulRedisConnection<K, V>> connectionFuture = redisClient.connectAsync(redisCodec, builder.build());\n    connectionFuture.thenAccept(connection -> {\n        stateLock.lock();\n        try {\n            connection.setAutoFlushCommands(autoFlushCommands);\n        } finally {\n            stateLock.unlock();\n        }\n    });\n    return connectionFuture;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), key.nodeId, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), (key.host + \":\") + key.port, getSocketAddressSupplier(key));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}", "protected Collection<RedisCommand<K, V, ?>> dispatch(Collection<? extends RedisCommand<K, V, ?>> commands) {\n    if (debugEnabled) {\n        logger.debug(\"dispatching commands {}\", commands);\n    }\n    if (tracingEnabled) {\n        Collection<RedisCommand<K, V, ?>> withTracer = new ArrayList<>(commands.size());\n        for (RedisCommand<K, V, ?> command : commands) {\n            RedisCommand<K, V, ?> commandToUse = command;\n            TraceContextProvider provider = CommandWrapper.unwrap(command, TraceContextProvider.class);\n            if (provider == null) {\n                commandToUse = new TracedCommand<>(command, clientResources.tracing().initialTraceContextProvider().getTraceContext());\n            }\n            withTracer.add(commandToUse);\n        }\n        return channelWriter.write(withTracer);\n    }\n    return channelWriter.write(commands);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return transformAsyncConnectionException(connectStandaloneAsync(codec, redisURI, redisURI.getTimeout()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<SpellCheckResult<V>> ftSpellcheck(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNode(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n    assertNotNull(codec);\n    assertNotEmpty(initialUris);\n    LettuceAssert.notNull(socketAddressSupplier, \"SocketAddressSupplier must not be null\");\n    ClusterNodeEndpoint endpoint = new ClusterNodeEndpoint(getClusterClientOptions(), getResources(), clusterWriter);\n    RedisChannelWriter writer = endpoint;\n    if (CommandExpiryWriter.isSupported(getClusterClientOptions())) {\n        writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getClusterClientOptions(), getResources());\n    }\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n        writer = new CommandListenerWriter(writer, getCommandListeners());\n    }\n    StatefulRedisConnectionImpl<K, V> connection = newStatefulRedisConnection(writer, endpoint, codec, getFirstUri().getTimeout(), getClusterClientOptions().getJsonParser());\n    connection.setAuthenticationHandler(createHandler(connection, getFirstUri().getCredentialsProvider(), false, getOptions()));\n    ConnectionFuture<StatefulRedisConnection<K, V>> connectionFuture = connectStatefulAsync(connection, endpoint, getFirstUri(), socketAddressSupplier, () -> new CommandHandler(getClusterClientOptions(), getResources(), endpoint));\n    return connectionFuture.whenComplete((conn, throwable) -> {\n        if (throwable != null) {\n            connection.closeAsync();\n        }\n    });\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.isAvailable", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if kqueue is available.\n */\npublic static boolean isAvailable() {\n    return KQUEUE_AVAILABLE && KQUEUE_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to\n * encode/decode keys and values. Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()}\n * first, otherwise the connect will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec) {\n    return transformAsyncConnectionException(connectClusterPubSubAsync(codec), getInitialUris());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftCreate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftCreate(String index, CreateArgs<K, V> arguments, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.sunsubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.sunsubscribed", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void sunsubscribed(K channel, long count) {\n    notifications.sunsubscribed(getNode(), channel, count);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasupdate(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.<init>", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * Initialize a new instance that handles commands from the supplied queue.\n *\n * @param clientOptions\n * \t\tclient options for this connection, must not be {@code null}\n * @param clientResources\n * \t\tclient resources for this connection, must not be {@code null}\n * @param endpoint\n * \t\tmust not be {@code null}.\n */\npublic CommandHandler(ClientOptions clientOptions, ClientResources clientResources, Endpoint endpoint) {\n    LettuceAssert.notNull(clientOptions, \"ClientOptions must not be null\");\n    LettuceAssert.notNull(clientResources, \"ClientResources must not be null\");\n    LettuceAssert.notNull(endpoint, \"RedisEndpoint must not be null\");\n    this.clientOptions = clientOptions;\n    this.clientResources = clientResources;\n    this.endpoint = endpoint;\n    this.commandLatencyRecorder = clientResources.commandLatencyRecorder();\n    this.latencyMetricsEnabled = commandLatencyRecorder.isEnabled();\n    this.boundedQueues = clientOptions.getRequestQueueSize() != Integer.MAX_VALUE;\n    this.stack = (clientOptions.isUseHashIndexedQueue()) ? new HashIndexedQueue<>() : new ArrayDeque<>();\n    Tracing tracing = clientResources.tracing();\n    this.tracingEnabled = tracing.isEnabled();\n    this.decodeBufferPolicy = clientOptions.getDecodeBufferPolicy();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplica.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplica.connect", "io.lettuce.core.masterreplica.MasterReplica.connectAsyncSentinelOrStaticSetup" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis Master-Replica server/servers using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n * <p>\n * This {@link MasterReplica} performs auto-discovery of nodes if the URI is a Redis Sentinel URI. Master/Replica URIs will\n * be treated as static topology and no additional hosts are discovered in such case. Redis Standalone Master/Replica will\n * discover the roles of the supplied {@link RedisURI URIs} and issue commands to the appropriate node.\n * </p>\n * <p>\n * When using Redis Sentinel, ensure that {@link Iterable redisURIs} contains only a single entry as only the first URI is\n * considered. {@link RedisURI} pointing to multiple Sentinels can be configured through\n * {@link RedisURI.Builder#withSentinel}.\n * </p>\n *\n * @param redisClient\n * \t\tthe Redis client.\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}.\n * @param redisURIs\n * \t\tthe Redis server(s) to connect to, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new connection.\n * @since 6.0\n */\npublic static <K, V> StatefulRedisMasterReplicaConnection<K, V> connect(RedisClient redisClient, RedisCodec<K, V> codec, Iterable<RedisURI> redisURIs) {\n    return getConnection(connectAsyncSentinelOrStaticSetup(redisClient, codec, redisURIs), redisURIs);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SpellCheckResultParser.SpellCheckResp2Parser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SpellCheckResultParser.SpellCheckResp2Parser.parse", "io.lettuce.core.search.SpellCheckResultParser.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SpellCheckResult<V> parse(ComplexData data) {\n    SpellCheckResult<V> result = new SpellCheckResult<>();\n    List<Object> elements = data.getDynamicList();\n    if ((elements == null) || elements.isEmpty()) {\n        return result;\n    }\n    // Go through each misspelled term, should contain three items itself\n    for (Object element : elements) {\n        List<Object> termContents = ((ComplexData) (element)).getDynamicList();\n        if ((termContents == null) || (termContents.size() != 3)) {\n            LOG.warn(\"Failed while parsing FT.SPELLCHECK: each term element must have 3 parts\");\n            continue;\n        }\n        // First element should be \"TERM\"\n        Object termMarker = termContents.get(0);\n        boolean isValidTermMarker = termKeyword.equals(termMarker) || \"TERM\".equals(termMarker);\n        if (!isValidTermMarker) {\n            LOG.warn(\"Failed while parsing FT.SPELLCHECK: expected 'TERM' marker, got: \" + termMarker);\n            continue;\n        }\n        // Second element is the misspelled term\n        V misspelledTerm = decodeValue(termContents.get(1));\n        // Third element is the suggestions array\n        ComplexData suggestionsObj = ((ComplexData) (termContents.get(2)));\n        List<Object> suggestionsArray = suggestionsObj.getDynamicList();\n        List<SpellCheckResult.Suggestion<V>> suggestions = parseSuggestions(suggestionsArray);\n        result.addMisspelledTerm(new SpellCheckResult.MisspelledTerm<>(misspelledTerm, suggestions));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), getConnectionProvider(), cursor, scanFunction, ((ClusterScanSupport.ScanCursorMapper) (resultMapper)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RediSearchCommandBuilder.ftCursorread",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RediSearchCommandBuilder.ftCursorread", "io.lettuce.core.search.AggregateReplyParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Read next results from an existing cursor.\n *\n * @param index\n * \t\tthe index name\n * @param cursorId\n * \t\tthe cursor id\n * @param count\n * \t\tthe number of results to read\n * @return the result of the cursor read command\n */\npublic Command<K, V, AggregationReply<K, V>> ftCursorread(String index, long cursorId, int count) {\n    LettuceAssert.notNull(index, \"Index must not be null\");\n    CommandArgs<K, V> args = new CommandArgs<>(codec).add(CommandKeyword.READ).add(index);\n    args.add(cursorId);\n    if (count >= 0) {\n        args.add(CommandKeyword.COUNT);\n        args.add(count);\n    }\n    return createCommand(FT_CURSOR, new EncodedComplexOutput<>(codec, new AggregateReplyParser<>(codec, true)), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.sunsubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.sunsubscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void sunsubscribed(RedisClusterNode node, K channel, long count) {\n    getListeners().forEach(listener -> listener.sunsubscribed(channel, count));\n    clusterListeners.forEach(listener -> listener.sunsubscribed(node, channel, count));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.RedisPublisher.RedisSubscription.<clinit>" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index, boolean deleteDocumentKeys) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftList() {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasadd(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ChannelGroupListener.getRedisUri", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}", "private static String getRedisUri(Channel channel) {\n    String redisUri = null;\n    if (channel.hasAttr(ConnectionBuilder.REDIS_URI)) {\n        redisUri = channel.attr(ConnectionBuilder.REDIS_URI).get();\n    }\n    return redisUri;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.Builder.build",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.Builder.build", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return a new instance of {@link DefaultClientResources}.\n */\n@Override\npublic DefaultClientResources build() {\n    DefaultClientResources resources = new DefaultClientResources(this);\n    if (this.afterBuild != null) {\n        this.afterBuild.run();\n    }\n    return resources;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisVectorSetCommandBuilder.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisVectorSetCommandBuilder.vsimWithScoreWithAttribs", "io.lettuce.core.output.VSimScoreAttribsMapOutput.<clinit>" ],
    "methodSlices" : [ "public Command<K, V, Map<V, VSimScoreAttribs>> vsimWithScoreWithAttribs(K key, VSimArgs vSimArgs, Double[] vectors) {\n    notNullKey(key);\n    notEmpty(vectors);\n    CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key);\n    if (vectors.length > 1) {\n        args.add(CommandKeyword.VALUES);\n        args.add(vectors.length);\n        Arrays.stream(vectors).forEach(args::add);\n    } else {\n        args.add(vectors[0]);\n    }\n    args.add(WITHSCORES).add(WITHATTRIBS);\n    if (vSimArgs != null) {\n        vSimArgs.build(args);\n    }\n    return createCommand(VSIM, new VSimScoreAttribsMapOutput<>(codec), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> clientSetname(K name) {\n}", "private Mono<StatefulRedisConnection<K, V>> getStatefulConnection(String nodeId) {\n    return getMono(getConnectionProvider().getConnectionAsync(ConnectionIntent.WRITE, nodeId));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.topology.ClusterTopologyRefresh.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.topology.ClusterTopologyRefresh.create", "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClusterTopologyRefresh} instance.\n *\n * @param nodeConnectionFactory\n * \t\tthe connection factory to open connections to specific cluster nodes\n * @param clientResources\n * \t\tshared client resources\n * @return a new {@link ClusterTopologyRefresh} instance.\n */\nstatic ClusterTopologyRefresh create(NodeConnectionFactory nodeConnectionFactory, ClientResources clientResources) {\n    return new DefaultClusterTopologyRefresh(nodeConnectionFactory, clientResources);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUncoveredSlot",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUncoveredSlot", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void onUncoveredSlot(int slot) {\n}", "private boolean indicateTopologyRefreshSignal() {\n    logger.debug(\"ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal()\");\n    if (!acquireTimeout()) {\n        return false;\n    }\n    return scheduleRefresh();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.exceptionCaught",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.exceptionCaught", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    InternalLogLevel logLevel = InternalLogLevel.WARN;\n    if (!stack.isEmpty()) {\n        RedisCommand<?, ?, ?> command = stack.poll();\n        if (debugEnabled) {\n            logger.debug(\"{} Storing exception in {}\", logPrefix(), command);\n        }\n        logLevel = InternalLogLevel.DEBUG;\n        try {\n            command.completeExceptionally(cause);\n        } catch (Exception ex) {\n            logger.warn(\"{} Unexpected exception during command completion exceptionally: {}\", logPrefix, ex.toString(), ex);\n        }\n    }\n    if (((channel == null) || (!channel.isActive())) || (!isConnected())) {\n        if (debugEnabled) {\n            logger.debug(\"{} Storing exception in connectionError\", logPrefix());\n        }\n        logLevel = InternalLogLevel.DEBUG;\n        endpoint.notifyException(cause);\n    }\n    if ((cause instanceof IOException) && (logLevel.ordinal() > InternalLogLevel.INFO.ordinal())) {\n        logLevel = InternalLogLevel.INFO;\n        if (SUPPRESS_IO_EXCEPTION_MESSAGES.contains(cause.getMessage())) {\n            logLevel = InternalLogLevel.DEBUG;\n        }\n    }\n    logger.log(logLevel, \"{} Unexpected exception during request: {}\", logPrefix, cause.toString(), cause);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n    LettuceAssert.notNull(command, \"Command must not be null\");\n    RedisException validation = validateWrite(1);\n    if (validation != null) {\n        command.completeExceptionally(validation);\n        return command;\n    }\n    try {\n        sharedLock.incrementWriters();\n        if (inActivation) {\n            command = processActivationCommand(command);\n        }\n        if (autoFlushCommands) {\n            Channel channel = this.channel;\n            if (isConnected(channel)) {\n                writeToChannelAndFlush(channel, command);\n            } else {\n                writeToDisconnectedBuffer(command);\n            }\n        } else {\n            writeToBuffer(command);\n        }\n    } finally {\n        sharedLock.decrementWriters();\n        if (debugEnabled) {\n            logger.debug(\"{} write() done\", logPrefix());\n        }\n    }\n    return command;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}", "protected Collection<RedisCommand<K, V, ?>> dispatch(Collection<? extends RedisCommand<K, V, ?>> commands) {\n    if (debugEnabled) {\n        logger.debug(\"dispatching commands {}\", commands);\n    }\n    if (tracingEnabled) {\n        Collection<RedisCommand<K, V, ?>> withTracer = new ArrayList<>(commands.size());\n        for (RedisCommand<K, V, ?> command : commands) {\n            RedisCommand<K, V, ?> commandToUse = command;\n            TraceContextProvider provider = CommandWrapper.unwrap(command, TraceContextProvider.class);\n            if (provider == null) {\n                commandToUse = new TracedCommand<>(command, clientResources.tracing().initialTraceContextProvider().getTraceContext());\n            }\n            withTracer.add(commandToUse);\n        }\n        return channelWriter.write(withTracer);\n    }\n    return channelWriter.write(commands);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.refreshPartitions",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.refreshPartitions", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Refresh partitions and re-initialize the routing table.\n *\n * @since 6.0\n */\npublic void refreshPartitions() {\n    get(refreshPartitionsAsync().toCompletableFuture(), e -> new RedisException(\"Cannot reload Redis Cluster topology\", e));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.domainSocketChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport domain socket {@link Channel} class.\n */\npublic static Class<? extends Channel> domainSocketChannelClass() {\n    assertDomainSocketAvailable();\n    return EpollProvider.isAvailable() && IOUringProvider.isAvailable() ? EpollProvider.getResources().domainSocketChannelClass() : RESOURCES.domainSocketChannelClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftCreate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftCreate(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec, RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return getConnection(connectPubSubAsync(codec, redisURI, redisURI.getTimeout()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.userEventTriggered",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.userEventTriggered", "io.lettuce.core.protocol.CommandHandler.reset", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#userEventTriggered(io.netty.channel.ChannelHandlerContext, Object)\n */\n@Override\npublic void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n}", "private void reset() {\n    resetInternals();\n    cancelCommands(\"Reset\", drainCommands(stack));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "private <T extends ScanCursor> RedisFuture<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyAsyncCommands<K, V>, ScanCursor, RedisFuture<T>> scanFunction, ScanCursorMapper<RedisFuture<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), cursor, scanFunction, resultMapper);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisVectorSetCommandBuilder.vsimWithScore",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisVectorSetCommandBuilder.vsimWithScore", "io.lettuce.core.output.ValueDoubleMapOutput.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@code VSIM} command with the WITHSCORES option to find the most similar vectors to the given query vector\n * with additional options and return them with their similarity scores.\n *\n * @param key\n * \t\tthe key of the vector set, must not be {@code null}\n * @param vSimArgs\n * \t\tthe additional arguments for the VSIM command\n * @param vectors\n * \t\tthe query vector values as floating point numbers, must not be empty\n * @return a new {@link Command} that returns a map of elements to their similarity scores\n * @see <a href=\"https://redis.io/docs/latest/commands/vsim/\">Redis Documentation: VSIM</a>\n */\npublic Command<K, V, Map<V, Double>> vsimWithScore(K key, VSimArgs vSimArgs, Double[] vectors) {\n    notNullKey(key);\n    notEmpty(vectors);\n    CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key);\n    if (vectors.length > 1) {\n        args.add(CommandKeyword.VALUES);\n        args.add(vectors.length);\n        Arrays.stream(vectors).forEach(args::add);\n    } else {\n        args.add(vectors[0]);\n    }\n    args.add(WITHSCORES);\n    if (vSimArgs != null) {\n        vSimArgs.build(args);\n    }\n    return createCommand(VSIM, new ValueDoubleMapOutput<>(codec), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return new RedisClient(null, redisURI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.AggregateReplyParser.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.AggregateReplyParser.<init>", "io.lettuce.core.search.SearchReplyParser.<clinit>" ],
    "methodSlices" : [ "public AggregateReplyParser(RedisCodec<K, V> codec, boolean withCursor) {\n    this.searchReplyParser = new SearchReplyParser<>(codec);\n    this.withCursor = withCursor;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.subscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.subscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void subscribed(RedisClusterNode node, K channel, long count) {\n    if (nodeMessagePropagation) {\n        super.subscribed(node, channel, count);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onAskRedirection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onAskRedirection", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void onAskRedirection() {\n}", "private boolean indicateTopologyRefreshSignal() {\n    logger.debug(\"ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal()\");\n    if (!acquireTimeout()) {\n        return false;\n    }\n    return scheduleRefresh();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.socketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> socketChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueSocketChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRegistered", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelRegistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n    if (isClosed()) {\n        logger.debug(\"{} Dropping register for a closed channel\", logPrefix());\n    }\n    channel = ctx.channel();\n    if (debugEnabled) {\n        logPrefix = null;\n        logger.debug(\"{} channelRegistered()\", logPrefix());\n    }\n    logPrefix = null;\n    pristine = true;\n    fallbackCommand = null;\n    setState(LifecycleState.REGISTERED);\n    readBuffer = ctx.alloc().buffer(8192 * 8);\n    rsm = new RedisStateMachine();\n    ctx.fireChannelRegistered();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.EpollProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.EpollProvider.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if epoll is available.\n */\npublic static boolean isAvailable() {\n    return EpollProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RediSearchCommandBuilder.ftSugget",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RediSearchCommandBuilder.ftSugget", "io.lettuce.core.search.SuggestionParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Get completion suggestions for a prefix.\n *\n * @param key\n * \t\tthe suggestion dictionary key\n * @param prefix\n * \t\tthe prefix to complete on\n * @param args\n * \t\tthe suggestion get arguments\n * @return the result of the sugget command\n */\npublic Command<K, V, List<Suggestion<V>>> ftSugget(K key, V prefix, SugGetArgs<K, V> args) {\n    notNullKey(key);\n    LettuceAssert.notNull(prefix, \"Prefix must not be null\");\n    CommandArgs<K, V> commandArgs = new CommandArgs<>(codec).addKey(key).addValue(prefix);\n    boolean withScores = false;\n    boolean withPayloads = false;\n    if (args != null) {\n        withScores = args.isWithScores();\n        withPayloads = args.isWithPayloads();\n        args.build(commandArgs);\n    }\n    SuggestionParser<V> parser = new SuggestionParser<>(withScores, withPayloads);\n    return createCommand(FT_SUGGET, new ComplexOutput<>(codec, parser), commandArgs);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.event.jfr.EventRecorder.getInstance",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.event.jfr.EventRecorder.getInstance", "io.lettuce.core.event.jfr.EventRecorderHolder.<clinit>" ],
    "methodSlices" : [ "/**\n * Obtain an instance of the {@link EventRecorder}.\n *\n * @return an instance of the {@link EventRecorder}.\n */\nstatic EventRecorder getInstance() {\n    return EventRecorderHolder.EVENT_RECORDER;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @param threadFactoryProvider\n * \t\tprovides a {@link java.util.concurrent.ThreadFactory} to create threads.\n * @return a new instance of default client resources.\n * @since 6.1.1\n */\nstatic ClientResources create(ThreadFactoryProvider threadFactoryProvider) {\n    return DefaultClientResources.builder().threadFactoryProvider(threadFactoryProvider).build();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSubAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return transformAsyncConnectionException(connectPubSubAsync(codec, redisURI, redisURI.getTimeout()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect", "io.lettuce.core.protocol.ConnectionWatchdog.<clinit>" ],
    "methodSlices" : [ "/**\n * Schedule reconnect if channel is not available/not active.\n */\npublic void scheduleReconnect() {\n    logger.debug(\"{} scheduleReconnect()\", logPrefix());\n    if (!isEventLoopGroupActive()) {\n        logger.debug(\"isEventLoopGroupActive() == false\");\n        return;\n    }\n    if (!isListenOnChannelInactive()) {\n        logger.debug(\"Skip reconnect scheduling, listener disabled\");\n        return;\n    }\n    if (((channel == null) || (!channel.isActive())) && reconnectSchedulerSync.compareAndSet(false, true)) {\n        attempts++;\n        final int attempt = attempts;\n        Duration delay = reconnectDelay.createDelay(attempt);\n        int timeout = ((int) (delay.toMillis()));\n        logger.debug(\"{} Reconnect attempt {}, delay {}ms\", logPrefix(), attempt, timeout);\n        this.reconnectScheduleTimeout = timer.newTimeout(it -> {\n            reconnectScheduleTimeout = null;\n            if (!isEventLoopGroupActive()) {\n                logger.warn(\"Cannot execute scheduled reconnect timer, reconnect workers are terminated\");\n                return;\n            }\n            reconnectWorkers.submit(() -> {\n                this.run(attempt, delay);\n                return null;\n            });\n        }, timeout, TimeUnit.MILLISECONDS);\n        // Set back to null when ConnectionWatchdog#run runs earlier than reconnectScheduleTimeout's assignment.\n        if (!reconnectSchedulerSync.get()) {\n            reconnectScheduleTimeout = null;\n        }\n    } else {\n        logger.debug(\"{} Skipping scheduleReconnect() because I have an active channel\", logPrefix());\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.isClosed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.isClosed", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "public boolean isClosed() {\n    return STATUS.get(this) == ST_CLOSED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.KqueueProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.KqueueProvider.isAvailable", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if kqueue is available.\n */\npublic static boolean isAvailable() {\n    return KqueueProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.ValueDoubleMapOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.ValueDoubleMapOutput.set", "io.lettuce.core.output.ValueDoubleMapOutput.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void set(ByteBuffer bytes) {\n    if (outputError) {\n        return;\n    }\n    if (!hasKey) {\n        key = (bytes == null) ? null : codec.decodeValue(bytes);\n        hasKey = true;\n        return;\n    }\n    // RESP2 does not have a double type, so we are assuming we are parsing it now\n    try {\n        Double value = Double.parseDouble(decodeString(bytes));\n        output.put(key, value);\n        key = null;\n        hasKey = false;\n    } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to fallback to parsing double from string, discarding the result\");\n        output = new HashMap<>(0);\n        outputError = true;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.punsubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.punsubscribed", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void punsubscribed(K pattern, long count) {\n    notifications.punsubscribed(getNode(), pattern, count);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SearchReplyParser.Resp2SearchResultsParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SearchReplyParser.Resp2SearchResultsParser.parse", "io.lettuce.core.search.SearchReplyParser.Resp2SearchResultsParser.parseResults", "io.lettuce.core.search.SearchReplyParser.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SearchReply<K, V> parse(ComplexData data) {\n    final SearchReply<K, V> searchReply = new SearchReply<>();\n    final List<Object> resultsList = data.getDynamicList();\n    if ((resultsList == null) || resultsList.isEmpty()) {\n        return searchReply;\n    }\n    // Check if this is a cursor response (has 2 elements: results array and cursor id)\n    if ((resultsList.size() == 2) && (resultsList.get(1) instanceof Long)) {\n        // This is a cursor response: [results_array, cursor_id]\n        List<Object> actualResults = ((ComplexData) (resultsList.get(0))).getDynamicList();\n        Long cursorId = ((Long) (resultsList.get(1)));\n        searchReply.setCursorId(cursorId);\n        if ((actualResults == null) || actualResults.isEmpty()) {\n            return searchReply;\n        }\n        searchReply.setCount(((Long) (actualResults.get(0))));\n        if (actualResults.size() == 1) {\n            return searchReply;\n        }\n        // Parse the actual results\n        parseResults(searchReply, actualResults);\n    } else {\n        // Regular search response\n        searchReply.setCount(((Long) (resultsList.get(0))));\n        if (resultsList.size() == 1) {\n            return searchReply;\n        }\n        // Parse the results\n        parseResults(searchReply, resultsList);\n    }\n    return searchReply;\n}", "private void parseResults(SearchReply<K, V> searchReply, List<Object> resultsList) {\n    for (int i = 1; i < resultsList.size();) {\n        K id = codec.decodeKey(StringCodec.UTF8.encodeKey(\"0\"));\n        if (withIds) {\n            id = codec.decodeKey(((ByteBuffer) (resultsList.get(i))));\n            i++;\n        }\n        final SearchReply.SearchResult<K, V> searchResult = new SearchReply.SearchResult<>(id);\n        if (withScores) {\n            searchResult.setScore(Double.parseDouble(StringCodec.UTF8.decodeKey(((ByteBuffer) (resultsList.get(i))))));\n            i++;\n        }\n        if (withContent) {\n            ComplexData resultData = ((ComplexData) (resultsList.get(i)));\n            List<Object> resultEntries = resultData.getDynamicList();\n            Map<K, V> resultEntriesProcessed = IntStream.range(0, resultEntries.size() / 2).boxed().collect(Collectors.toMap(idx -> codec.decodeKey(((ByteBuffer) (resultEntries.get(idx * 2)))), idx -> codec.decodeValue(((ByteBuffer) (resultEntries.get((idx * 2) + 1))))));\n            searchResult.addFields(resultEntriesProcessed);\n            i++;\n        }\n        searchReply.addResult(searchResult);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.eventLoopGroupClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    checkForKqueueLibrary();\n    // Return the new recommended class, but keep backward compatibility\n    return MultiThreadIoEventLoopGroup.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictdel", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<Long> ftDictdel(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "private <T extends ScanCursor> RedisFuture<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyAsyncCommands<K, V>, ScanCursor, RedisFuture<T>> scanFunction, ScanCursorMapper<RedisFuture<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), cursor, scanFunction, resultMapper);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.checkForRedisURI", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec) {\n    checkForRedisURI();\n    return getConnection(connectStandaloneAsync(codec, this.redisURI, this.redisURI.getTimeout()));\n}", "private void checkForRedisURI() {\n    LettuceAssert.assertState(this.redisURI != EMPTY_URI, \"RedisURI is not available. Use RedisClient(Host), RedisClient(Host, Port) or RedisClient(RedisURI) to construct your client.\");\n    checkValidRedisURI(this.redisURI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.datagramChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link DatagramChannel} for socket (network/UDP) transport.\n */\npublic static Class<? extends DatagramChannel> datagramChannelClass() {\n    if (NativeTransports.isAvailable()) {\n        return NativeTransports.datagramChannelClass();\n    }\n    return NioDatagramChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.withSocketAddress",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.withSocketAddress", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "/**\n * Create an updated {@link SslChannelInitializer} with the new {@link SocketAddress} in place.\n *\n * @param handler\n * @param socketAddress\n * @return  * @since 6.0.8\n */\npublic static ChannelHandler withSocketAddress(ChannelHandler handler, SocketAddress socketAddress) {\n    LettuceAssert.assertState(isSslChannelInitializer(handler), \"handler must be SslChannelInitializer\");\n    return ((SslChannelInitializer) (handler)).withHostAndPort(toHostAndPort(socketAddress));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodes",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodes", "io.lettuce.core.masterreplica.ReplicaTopologyProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic List<RedisNodeDescription> getNodes() {\n    logger.debug(\"Performing topology lookup\");\n    String info = connection.sync().info(\"replication\");\n    try {\n        return getNodesFromInfo(info);\n    } catch (RuntimeException e) {\n        throw Exceptions.bubble(e);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return getConnection(connectSentinelAsync(newStringStringCodec(), redisURI, redisURI.getTimeout()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), getConnectionProvider(), cursor, scanFunction, ((ClusterScanSupport.ScanCursorMapper) (resultMapper)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.run",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.run", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void run() {\n    logger.debug(\"ClusterTopologyRefreshScheduler.run()\");\n    if (isEventLoopActive()) {\n        if (!clientOptions.get().isRefreshClusterView()) {\n            logger.debug(\"Periodic ClusterTopologyRefresh is disabled\");\n            return;\n        }\n    } else {\n        logger.debug(\"Periodic ClusterTopologyRefresh is disabled\");\n        return;\n    }\n    clientResources.eventExecutorGroup().submit(clusterTopologyRefreshTask);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.assertDomainSocketAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.assertDomainSocketAvailable", "io.lettuce.core.resource.Transports.NativeTransports.<clinit>" ],
    "methodSlices" : [ "public static void assertDomainSocketAvailable() {\n    LettuceAssert.assertState(NativeTransports.isDomainSocketSupported(), \"A unix domain socket connection requires epoll or kqueue and neither is available\");\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Shutdown the {@link ClientResources}.\n *\n * @param quietPeriod\n * \t\tthe quiet period as described in the documentation\n * @param timeout\n * \t\tthe maximum amount of time to wait until the executor is shutdown regardless if a task was submitted\n * \t\tduring the quiet period\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}\n * @return eventually the success/failure of the shutdown without errors.\n */\n@SuppressWarnings(\"unchecked\")\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n    logger.debug(\"Initiate shutdown ({}, {}, {})\", quietPeriod, timeout, timeUnit);\n    shutdownCalled = true;\n    DefaultPromise<Void> voidPromise = new DefaultPromise<>(ImmediateEventExecutor.INSTANCE);\n    PromiseCombiner aggregator = new PromiseCombiner(ImmediateEventExecutor.INSTANCE);\n    if (metricEventPublisher != null) {\n        metricEventPublisher.shutdown();\n    }\n    if (!sharedTimer) {\n        timer.stop();\n    }\n    if (!sharedEventLoopGroupProvider) {\n        Future<Boolean> shutdown = eventLoopGroupProvider.shutdown(quietPeriod, timeout, timeUnit);\n        aggregator.add(shutdown);\n    }\n    if (!sharedEventExecutor) {\n        Future<?> shutdown = eventExecutorGroup.shutdownGracefully(quietPeriod, timeout, timeUnit);\n        aggregator.add(shutdown);\n    }\n    if ((!sharedCommandLatencyRecorder) && (commandLatencyRecorder instanceof MetricCollector)) {\n        ((MetricCollector<?>) (commandLatencyRecorder)).shutdown();\n    }\n    aggregator.finish(voidPromise);\n    return PromiseAdapter.toBooleanPromise(voidPromise);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.message",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.message", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void message(RedisClusterNode node, K pattern, K channel, V message) {\n    getListeners().forEach(listener -> listener.message(pattern, channel, message));\n    clusterListeners.forEach(listener -> listener.message(node, pattern, channel, message));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.subscribe",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.subscribe", "io.lettuce.core.RedisPublisher.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void subscribe(Subscriber<? super T> subscriber) {\n    if (this.traceEnabled) {\n        LOG.trace(\"subscribe: {}@{}\", subscriber.getClass().getName(), Objects.hashCode(subscriber));\n    }\n    // Reuse the first command but then discard it.\n    RedisCommand<K, V, T> command = ref.get();\n    if (command != null) {\n        if (!ref.compareAndSet(command, null)) {\n            command = commandSupplier.get();\n        }\n    } else {\n        command = commandSupplier.get();\n    }\n    RedisSubscription<T> redisSubscription = new RedisSubscription<>(connection, command, dissolve, executor);\n    redisSubscription.subscribe(subscriber);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "private <T extends ScanCursor> RedisFuture<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyAsyncCommands<K, V>, ScanCursor, RedisFuture<T>> scanFunction, ScanCursorMapper<RedisFuture<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), cursor, scanFunction, resultMapper);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n    if ((((ctx.channel() != null) && ctx.channel().isActive()) && ctx.channel().hasAttr(REBIND_ATTRIBUTE)) && (ctx.channel().attr(REBIND_ATTRIBUTE).get() == RebindState.COMPLETED)) {\n        logger.debug(\"[{}]  Disconnecting at {}\", ChannelLogDescriptor.logDescriptor(channel), LocalTime.now());\n        ctx.channel().close().awaitUninterruptibly();\n        notifyRebindCompleted();\n    }\n    super.channelReadComplete(ctx);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RoundRobinSocketAddressSupplier.get",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RoundRobinSocketAddressSupplier.get", "io.lettuce.core.cluster.RoundRobinSocketAddressSupplier.getSocketAddress", "io.lettuce.core.cluster.RoundRobinSocketAddressSupplier.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SocketAddress get() {\n}", "protected SocketAddress getSocketAddress(RedisClusterNode redisClusterNode) {\n    SocketAddress resolvedAddress = clientResources.socketAddressResolver().resolve(redisClusterNode.getUri());\n    logger.debug(\"Resolved SocketAddress {} using for Cluster node {}\", resolvedAddress, redisClusterNode.getNodeId());\n    return resolvedAddress;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.PubSubEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.pubsub.PubSubEndpoint.write", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <K1, V1, T> RedisCommand<K1, V1, T> write(RedisCommand<K1, V1, T> command) {\n    if (isSubscribed() && (!isAllowed(command))) {\n        rejectCommand(command);\n        return command;\n    }\n    if ((!subscribeWritten) && SUBSCRIBE_COMMANDS.contains(command.getType().toString())) {\n        subscribeWritten = true;\n    }\n    return super.write(command);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.support.RedisClusterClientCdiBean.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.support.RedisClusterClientCdiBean.create", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisClusterClient create(CreationalContext<RedisClusterClient> creationalContext) {\n    CreationalContext<RedisURI> uriCreationalContext = beanManager.createCreationalContext(redisURIBean);\n    RedisURI redisURI = ((RedisURI) (beanManager.getReference(redisURIBean, RedisURI.class, uriCreationalContext)));\n    if (clientResourcesBean != null) {\n        ClientResources clientResources = ((ClientResources) (beanManager.getReference(clientResourcesBean, ClientResources.class, uriCreationalContext)));\n        return RedisClusterClient.create(clientResources, redisURI);\n    }\n    return RedisClusterClient.create(redisURI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.EpollProvider.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if epoll is available.\n */\npublic static boolean isAvailable() {\n    return EPOLL_AVAILABLE && EPOLL_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.subscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.subscribed", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void subscribed(K channel, long count) {\n    notifications.subscribed(getNode(), channel, count);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void requestMore() {\n    if (isConnected() && (!isClosed())) {\n        if (!channel.config().isAutoRead()) {\n            channel.pipeline().fireUserEventTriggered(EnableAutoRead.INSTANCE);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftTagvals", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<List<V>> ftTagvals(String index, String fieldName) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.loadViews",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.loadViews", "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.<clinit>" ],
    "methodSlices" : [ "/**\n * Load partition views from a collection of {@link RedisURI}s and return the view per {@link RedisURI}. Partitions contain\n * an ordered list of {@link RedisClusterNode}s. The sort key is latency. Nodes with lower latency come first.\n *\n * @param seed\n * \t\tcollection of {@link RedisURI}s\n * @param connectTimeout\n * \t\tconnect timeout\n * @param discovery\n * \t\t{@code true} to discover additional nodes\n * @return mapping between {@link RedisURI} and {@link Partitions}\n */\n@Override\npublic CompletionStage<Map<RedisURI, Partitions>> loadViews(Iterable<RedisURI> seed, Duration connectTimeout, boolean discovery) {\n    if (!isEventLoopActive()) {\n        return CompletableFuture.completedFuture(Collections.emptyMap());\n    }\n    long commandTimeoutNs = getCommandTimeoutNs(seed);\n    ConnectionTracker tracker = new ConnectionTracker();\n    long connectionTimeout = commandTimeoutNs + connectTimeout.toNanos();\n    openConnections(tracker, seed, connectionTimeout, TimeUnit.NANOSECONDS);\n    CompletableFuture<NodeTopologyViews> composition = tracker.whenComplete(map -> {\n        return new Connections(clientResources, map);\n    }).thenCompose(connections -> {\n        Requests requestedTopology = connections.requestTopology(commandTimeoutNs, TimeUnit.NANOSECONDS);\n        Requests requestedInfo = connections.requestInfo(commandTimeoutNs, TimeUnit.NANOSECONDS);\n        return CompletableFuture.allOf(requestedTopology.allCompleted(), requestedInfo.allCompleted()).thenApplyAsync(ignore -> getNodeSpecificViews(requestedTopology, requestedInfo), clientResources.eventExecutorGroup()).thenCompose(views -> {\n            if (discovery && isEventLoopActive()) {\n                Set<RedisURI> allKnownUris = views.getClusterNodes();\n                Set<RedisURI> discoveredNodes = difference(allKnownUris, toSet(seed));\n                if (discoveredNodes.isEmpty()) {\n                    return CompletableFuture.completedFuture(views);\n                }\n                openConnections(tracker, discoveredNodes, connectionTimeout, TimeUnit.NANOSECONDS);\n                return tracker.whenComplete(map -> {\n                    return new Connections(clientResources, map).retainAll(discoveredNodes);\n                }).thenCompose(newConnections -> {\n                    Requests additionalTopology = newConnections.requestTopology(commandTimeoutNs, TimeUnit.NANOSECONDS).mergeWith(requestedTopology);\n                    Requests additionalInfo = newConnections.requestInfo(commandTimeoutNs, TimeUnit.NANOSECONDS).mergeWith(requestedInfo);\n                    return CompletableFuture.allOf(additionalTopology.allCompleted(), additionalInfo.allCompleted()).thenApplyAsync(ignore2 -> getNodeSpecificViews(additionalTopology, additionalInfo), clientResources.eventExecutorGroup());\n                });\n            }\n            return CompletableFuture.completedFuture(views);\n        }).whenComplete((ignore, throwable) -> {\n            if (throwable != null) {\n                try {\n                    tracker.close();\n                } catch (Exception e) {\n                    logger.debug(\"Cannot close ClusterTopologyRefresh connections\", e);\n                }\n            }\n        }).thenCompose(it -> tracker.close().thenApply(ignore -> it)).thenCompose(it -> {\n            if (it.isEmpty()) {\n                Exception exception = tryFail(requestedTopology, tracker, seed);\n                return Futures.failed(exception);\n            }\n            return CompletableFuture.completedFuture(it);\n        });\n    });\n    return composition.thenApply(NodeTopologyViews::toMap);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictdel(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SocketAddress newSocketAddress(String socketPath) {\n    checkForKqueueLibrary();\n    return new DomainSocketAddress(socketPath);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.getResources", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for kqueue-backed transport. Check availability with {@link #isAvailable()} prior\n * to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n * @since 6.0\n */\npublic static EventLoopResources getResources() {\n    return KQUEUE_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.request",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.request", "io.lettuce.core.RedisPublisher.RedisSubscription.<clinit>" ],
    "methodSlices" : [ "/**\n * Signal for data demand.\n *\n * @param n\n * \t\tnumber of requested elements.\n */\n@Override\npublic final void request(long n) {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} request: {}\", state, n);\n    }\n    state.request(this, n);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftSynupdate(String index, V synonymGroupId, SynUpdateArgs<K, V> args, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.message",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.message", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void message(RedisClusterNode node, K channel, V message) {\n    if (nodeMessagePropagation) {\n        super.message(node, channel, message);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    ctx.channel().attr(INIT_FAILURE).set(cause);\n    super.exceptionCaught(ctx, cause);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), getConnectionProvider(), cursor, scanFunction, ((ClusterScanSupport.ScanCursorMapper) (resultMapper)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.RedisCommandFactory.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.dynamic.RedisCommandFactory.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.StatefulRedisConnectionImpl.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.StatefulRedisConnectionImpl.<init>", "io.lettuce.core.RedisAuthenticationHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * Initialize a new connection.\n *\n * @param writer\n * \t\tthe channel writer.\n * @param pushHandler\n * \t\tthe handler for push notifications.\n * @param codec\n * \t\tCodec used to encode/decode keys and values.\n * @param timeout\n * \t\tMaximum time to wait for a response.\n * @param parser\n * \t\tthe parser to use for JSON commands.\n */\npublic StatefulRedisConnectionImpl(RedisChannelWriter writer, PushHandler pushHandler, RedisCodec<K, V> codec, Duration timeout, Supplier<JsonParser> parser) {\n    super(writer, timeout);\n    this.pushHandler = pushHandler;\n    this.codec = codec;\n    this.parser = parser;\n    this.async = newRedisAsyncCommandsImpl();\n    this.sync = newRedisSyncCommandsImpl();\n    this.reactive = newRedisReactiveCommandsImpl();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return transformAsyncConnectionException(connectSentinelAsync(codec, redisURI, redisURI.getTimeout()), redisURI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return getConnection(connectStandaloneAsync(newStringStringCodec(), redisURI, redisURI.getTimeout()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync", "io.lettuce.core.masterreplica.ReplicaTopologyProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<List<RedisNodeDescription>> getNodesAsync() {\n    logger.debug(\"Performing topology lookup\");\n    RedisFuture<String> info = connection.async().info(\"replication\");\n    try {\n        return Mono.fromCompletionStage(info).timeout(redisURI.getTimeout()).map(this::getNodesFromInfo).toFuture();\n    } catch (RuntimeException e) {\n        throw Exceptions.bubble(e);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync", "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Retrieve a {@link StatefulRedisConnection} by the intent. {@link ConnectionIntent#WRITE} intentions use the master\n * connection, {@link ConnectionIntent#READ} intentions lookup one or more read candidates using the {@link ReadFrom}\n * setting.\n *\n * @param intent\n * \t\tcommand intent\n * @return the connection.\n * @throws RedisException\n * \t\tif the host is not part of the cluster\n */\npublic CompletableFuture<StatefulRedisConnection<K, V>> getConnectionAsync(ConnectionIntent intent) {\n    if (debugEnabled) {\n        logger.debug((\"getConnectionAsync(\" + intent) + \")\");\n    }\n    if ((readFrom != null) && (intent == ConnectionIntent.READ)) {\n        List<RedisNodeDescription> selection = readFrom.select(new ReadFrom.Nodes() {\n            @Override\n            public List<RedisNodeDescription> getNodes() {\n                return knownNodes;\n            }\n\n            @Override\n            public Iterator<RedisNodeDescription> iterator() {\n                return knownNodes.iterator();\n            }\n        });\n        if (selection.isEmpty()) {\n            throw new RedisException(String.format(\"Cannot determine a node to read (Known nodes: %s) with setting %s\", knownNodes, readFrom));\n        }\n        try {\n            Flux<StatefulRedisConnection<K, V>> connections = Flux.empty();\n            for (RedisNodeDescription node : selection) {\n                connections = connections.concatWith(Mono.fromFuture(getConnection(node)));\n            }\n            if (OrderingReadFromAccessor.isOrderSensitive(readFrom) || (selection.size() == 1)) {\n                return connections.filter(StatefulConnection::isOpen).next().switchIfEmpty(connections.next()).toFuture();\n            }\n            return connections.filter(StatefulConnection::isOpen).collectList().filter(it -> !it.isEmpty()).map(it -> {\n                int index = ThreadLocalRandom.current().nextInt(it.size());\n                return it.get(index);\n            }).switchIfEmpty(connections.next()).toFuture();\n        } catch (RuntimeException e) {\n            throw Exceptions.bubble(e);\n        }\n    }\n    return getConnection(getMaster());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.support.LettuceCdiExtension.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.support.LettuceCdiExtension.<init>", "io.lettuce.core.support.LettuceCdiExtension.<clinit>" ],
    "methodSlices" : [ "public LettuceCdiExtension() {\n    LOGGER.info(\"Activating CDI extension for lettuce.\");\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SocketAddress newSocketAddress(String socketPath) {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> dbsize() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.checkForRedisURI", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel that treats keys and use the supplied {@link RedisCodec codec} to encode/decode\n * keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Sentinel connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec) {\n    checkForRedisURI();\n    return getConnection(connectSentinelAsync(codec, this.redisURI, this.redisURI.getTimeout()));\n}", "private void checkForRedisURI() {\n    LettuceAssert.assertState(this.redisURI != EMPTY_URI, \"RedisURI is not available. Use RedisClient(Host), RedisClient(Host, Port) or RedisClient(RedisURI) to construct your client.\");\n    checkValidRedisURI(this.redisURI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied uri with default {@link ClientResources}. You can connect to different\n * Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param uri\n * \t\tthe Redis URI, must not be empty or {@code null}.\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(String uri) {\n    LettuceAssert.notEmpty(uri, \"URI must not be empty\");\n    return create(RedisClusterURIUtil.toRedisURIs(URI.create(uri)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.punsubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.punsubscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void punsubscribed(RedisClusterNode node, K pattern, long count) {\n    if (nodeMessagePropagation) {\n        super.punsubscribed(node, pattern, count);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyRefresh.TopologyRefreshMessagePredicate.test",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyRefresh.TopologyRefreshMessagePredicate.test", "io.lettuce.core.masterreplica.SentinelTopologyRefresh.<clinit>" ],
    "methodSlices" : [ "@Override\npublic boolean test(String channel, String message) {\n    // trailing spaces after the master name are not bugs\n    if (channel.equals(\"+elected-leader\") || channel.equals(\"+reset-master\")) {\n        if (message.startsWith(String.format(\"master %s \", masterId))) {\n            return true;\n        }\n    }\n    if (TOPOLOGY_CHANGE_CHANNELS.contains(channel)) {\n        if (message.contains(String.format(\"@ %s \", masterId))) {\n            return true;\n        }\n    }\n    if (channel.equals(\"+switch-master\")) {\n        if (message.startsWith(String.format(\"%s \", masterId))) {\n            return true;\n        }\n    }\n    return PROCESSING_CHANNELS.contains(channel);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplica.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplica.connect", "io.lettuce.core.masterreplica.MasterReplica.connectAsyncSentinelOrAutodiscovery", "io.lettuce.core.masterreplica.SentinelConnector.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis Master-Replica server/servers using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n * <p>\n * This {@link MasterReplica} performs auto-discovery of nodes using either Redis Sentinel or Master/Replica. A\n * {@link RedisURI} can point to either a master or a replica host.\n * </p>\n *\n * @param redisClient\n * \t\tthe Redis client.\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}.\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new connection.\n */\npublic static <K, V> StatefulRedisMasterReplicaConnection<K, V> connect(RedisClient redisClient, RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private static <K, V> CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsyncSentinelOrAutodiscovery(RedisClient redisClient, RedisCodec<K, V> codec, RedisURI redisURI) {\n    LettuceAssert.notNull(redisClient, \"RedisClient must not be null\");\n    LettuceAssert.notNull(codec, \"RedisCodec must not be null\");\n    LettuceAssert.notNull(redisURI, \"RedisURI must not be null\");\n    if (isSentinel(redisURI)) {\n        return new SentinelConnector<>(redisClient, codec, redisURI).connectAsync();\n    }\n    return new AutodiscoveryConnector<>(redisClient, codec, redisURI).connectAsync();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync", "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsync() {\n    Map<RedisURI, StatefulRedisConnection<K, V>> initialConnections = new HashMap<>();\n    TopologyProvider topologyProvider = new StaticMasterReplicaTopologyProvider(redisClient, redisURIs);\n    RedisURI seedNode = redisURIs.iterator().next();\n    MasterReplicaTopologyRefresh refresh = new MasterReplicaTopologyRefresh(redisClient, topologyProvider);\n    MasterReplicaConnectionProvider<K, V> connectionProvider = new MasterReplicaConnectionProvider<>(redisClient, codec, seedNode, initialConnections);\n    return refresh.getNodes(seedNode).flatMap(nodes -> {\n        EventRecorder.getInstance().record(new MasterReplicaTopologyChangedEvent(seedNode, nodes));\n        if (nodes.isEmpty()) {\n            return Mono.error(new RedisException(String.format(\"Cannot determine topology from %s\", redisURIs)));\n        }\n        return initializeConnection(codec, seedNode, connectionProvider, nodes);\n    }).onErrorMap(ExecutionException.class, Throwable::getCause).toFuture();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisConnection<K, V>> getConnectionAsync(ConnectionIntent connectionIntent, String nodeId) {\n    if (debugEnabled) {\n        logger.debug((((\"getConnection(\" + connectionIntent) + \", \") + nodeId) + \")\");\n    }\n    return getConnectionAsync(new ConnectionKey(connectionIntent, nodeId)).toCompletableFuture();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandEncoder.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandEncoder.<init>", "io.lettuce.core.protocol.CommandEncoder.<clinit>" ],
    "methodSlices" : [ "public CommandEncoder(boolean preferDirect) {\n    super(preferDirect);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied uri with shared {@link ClientResources}.You need to shut down the\n * {@link ClientResources} upon shutting down your application. You can connect to different Redis servers but you must\n * supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param uri\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(ClientResources clientResources, String uri) {\n    assertNotNull(clientResources);\n    LettuceAssert.notEmpty(uri, \"URI must not be empty\");\n    return create(clientResources, RedisURI.create(uri));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<KeyScanCursor<K>> scan() {\n}", "private <T extends ScanCursor> RedisFuture<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyAsyncCommands<K, V>, ScanCursor, RedisFuture<T>> scanFunction, ScanCursorMapper<RedisFuture<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), cursor, scanFunction, resultMapper);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server that treats keys and values as UTF-8 strings.\n *\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub() {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n    assertNotNull(codec);\n    checkValidRedisURI(redisURI);\n    PubSubEndpoint<K, V> endpoint = new PubSubEndpoint<>(getOptions(), getResources());\n    RedisChannelWriter writer = endpoint;\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n        writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n    }\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n        writer = new CommandListenerWriter(writer, getCommandListeners());\n    }\n    StatefulRedisPubSubConnectionImpl<K, V> connection = newStatefulRedisPubSubConnection(endpoint, writer, codec, timeout);\n    ConnectionFuture<StatefulRedisPubSubConnection<K, V>> future = connectStatefulAsync(connection, endpoint, redisURI, () -> new PubSubCommandHandler<>(getOptions(), getResources(), codec, endpoint), true);\n    return future.whenComplete((conn, throwable) -> {\n        if (throwable != null) {\n            conn.close();\n        }\n    });\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ChannelGroupListener.getRedisUri", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}", "private static String getRedisUri(Channel channel) {\n    String redisUri = null;\n    if (channel.hasAttr(ConnectionBuilder.REDIS_URI)) {\n        redisUri = channel.attr(ConnectionBuilder.REDIS_URI).get();\n    }\n    return redisUri;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return getConnection(connectStandaloneAsync(codec, redisURI, redisURI.getTimeout()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SuggestionParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SuggestionParser.parse", "io.lettuce.core.search.SuggestionParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Parse the output of the Redis FT.SUGGET command and convert it to a list of {@link Suggestion} objects.\n * <p>\n * The parsing logic depends on the options used with the FT.SUGGET command:\n * </p>\n * <ul>\n * <li><strong>No options:</strong> Each element is a suggestion string</li>\n * <li><strong>WITHSCORES only:</strong> Elements alternate between suggestion string and score</li>\n * <li><strong>WITHPAYLOADS only:</strong> Elements alternate between suggestion string and payload</li>\n * <li><strong>Both WITHSCORES and WITHPAYLOADS:</strong> Elements are in groups of 3: suggestion, score, payload</li>\n * </ul>\n *\n * @param data\n * \t\toutput of FT.SUGGET command\n * @return a list of {@link Suggestion} objects\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Suggestion<V>> parse(ComplexData data) {\n    List<Suggestion<V>> suggestions = new ArrayList<>();\n    if (data == null) {\n        return suggestions;\n    }\n    List<Object> elements = data.getDynamicList();\n    if ((elements == null) || elements.isEmpty()) {\n        return suggestions;\n    }\n    int divisor = 1;\n    divisor += (withScores) ? 1 : 0;\n    divisor += (withPayloads) ? 1 : 0;\n    if ((elements.size() % divisor) != 0) {\n        LOG.warn(\"Failed while parsing FT.SUGGET: expected elements to be dividable by {}\", divisor);\n        return suggestions;\n    }\n    for (int i = 0; i < elements.size();) {\n        V value = ((V) (elements.get(i++)));\n        Suggestion<V> suggestion = new Suggestion<>(value);\n        if (withScores && ((i + 1) <= elements.size())) {\n            Double score = parseScore(elements.get(i++));\n            suggestion.setScore(score);\n        }\n        if (withPayloads && ((i + 1) <= elements.size())) {\n            V payload = ((V) (elements.get(i++)));\n            suggestion.setPayload(payload);\n        }\n        suggestions.add(suggestion);\n    }\n    return suggestions;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), getConnectionProvider(), cursor, scanFunction, ((ClusterScanSupport.ScanCursorMapper) (resultMapper)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.run",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.<clinit>" ],
    "methodSlices" : [ "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter\n * @throws Exception\n * \t\twhen reconnection fails.\n */\npublic void run(int attempt) throws Exception {\n    run(attempt, Duration.ZERO)\n}", "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter.\n * @param delay\n * \t\tretry delay.\n * @throws Exception\n * \t\twhen reconnection fails.\n */\nprivate void run(int attempt, Duration delay) throws Exception {\n    reconnectSchedulerSync.set(false);\n    reconnectScheduleTimeout = null;\n    if (!isEventLoopGroupActive()) {\n        logger.debug(\"isEventLoopGroupActive() == false\");\n        return;\n    }\n    if (!isListenOnChannelInactive()) {\n        logger.debug(\"Skip reconnect scheduling, listener disabled\");\n        return;\n    }\n    if (isReconnectSuspended()) {\n        logger.debug(\"Skip reconnect scheduling, reconnect is suspended\");\n        return;\n    }\n    boolean shouldLog = shouldLog();\n    InternalLogLevel infoLevel = InternalLogLevel.INFO;\n    InternalLogLevel warnLevel = InternalLogLevel.WARN;\n    if (shouldLog) {\n        lastReconnectionLogging = System.currentTimeMillis();\n    } else {\n        warnLevel = InternalLogLevel.DEBUG;\n        infoLevel = InternalLogLevel.DEBUG;\n    }\n    InternalLogLevel warnLevelToUse = warnLevel;\n    try {\n        reconnectionListener.onReconnectAttempt(new ConnectionEvents.Reconnect(attempt));\n        eventBus.publish(new ReconnectAttemptEvent(redisUri, epid, LocalAddress.ANY, remoteAddress, attempt, delay));\n        logger.log(infoLevel, \"Reconnecting, last destination was {}\", remoteAddress);\n        Tuple2<CompletableFuture<Channel>, CompletableFuture<SocketAddress>> tuple = reconnectionHandler.reconnect();\n        CompletableFuture<Channel> future = tuple.getT1();\n        future.whenComplete((c, t) -> {\n            if ((c != null) && (t == null)) {\n                return;\n            }\n            CompletableFuture<SocketAddress> remoteAddressFuture = tuple.getT2();\n            SocketAddress remote = remoteAddress;\n            if ((remoteAddressFuture.isDone() && (!remoteAddressFuture.isCompletedExceptionally())) && (!remoteAddressFuture.isCancelled())) {\n                remote = remoteAddressFuture.join();\n            }\n            String message = String.format(\"Cannot reconnect to [%s]: %s\", remote, t.getMessage() != null ? t.getMessage() : t.toString());\n            if (ReconnectionHandler.isExecutionException(t)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(message, t);\n                } else {\n                    logger.log(warnLevelToUse, message);\n                }\n            } else {\n                logger.log(warnLevelToUse, message, t);\n            }\n            eventBus.publish(new ReconnectFailedEvent(redisUri, epid, LocalAddress.ANY, remote, t, attempt));\n            if (!isReconnectSuspended()) {\n                scheduleReconnect();\n            }\n        });\n    } catch (Exception e) {\n        logger.log(warnLevel, \"Cannot reconnect: {}\", e.toString());\n        eventBus.publish(new ReconnectFailedEvent(redisUri, epid, LocalAddress.ANY, remoteAddress, e, attempt));\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.NumberListOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.NumberListOutput.set", "io.lettuce.core.output.NumberListOutput.parseNumber", "io.lettuce.core.output.NumberListOutput.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void set(ByteBuffer bytes) {\n    output.add(bytes != null ? parseNumber(bytes) : null);\n}", "private Number parseNumber(ByteBuffer bytes) {\n    Number result = 0;\n    try {\n        result = NumberFormat.getNumberInstance().parse(decodeString(bytes));\n    } catch (ParseException e) {\n        LOG.warn(\"Failed to parse \" + bytes, e);\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n    String mType = message.getType();\n    if (REBIND_MESSAGE_TYPE.equals(mType)) {\n        logger.debug(\"Rebind requested\");\n        final MovingEvent movingEvent = MovingEvent.from(message);\n        if (movingEvent != null) {\n            if (null == movingEvent.getEndpoint()) {\n                logger.debug(\"[channel={}] Deferred Rebind requested. Rebinding to current endpoint after '{}'\", channel.id(), movingEvent.getTime());\n                channel.eventLoop().schedule(() -> rebind(movingEvent), movingEvent.getTime().toMillis() / 2, TimeUnit.MILLISECONDS);\n            } else {\n                rebind(movingEvent);\n            }\n        }\n    } else if (MIGRATING_MESSAGE_TYPE.equals(mType)) {\n        logger.debug(\"[{}] Shard migration started\", ChannelLogDescriptor.logDescriptor(channel));\n        notifyMigrateStarted(getMigratingShards(message));\n    } else if (MIGRATED_MESSAGE_TYPE.equals(mType)) {\n        logger.debug(\"[{}] Shard migration completed\", ChannelLogDescriptor.logDescriptor(channel));\n        notifyMigrateCompleted(getMigratedShards(message));\n    } else if (FAILING_OVER_MESSAGE_TYPE.equals(mType)) {\n        logger.debug(\"[{}] Failover started\", ChannelLogDescriptor.logDescriptor(channel));\n        notifyFailoverStarted(getFailingOverShards(message));\n    } else if (FAILED_OVER_MESSAGE_TYPE.equals(mType)) {\n        logger.debug(\"[{}] Failover completed\", ChannelLogDescriptor.logDescriptor(channel));\n        notifyFailoverCompleted(getFailedOverShards(message));\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.close",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.close", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "/**\n * Close the connection.\n */\n@Override\npublic void close() {\n    if (debugEnabled) {\n        logger.debug(\"{} close()\", logPrefix());\n    }\n    closeAsync().join();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.write",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.write", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelDuplexHandler#write(io.netty.channel.ChannelHandlerContext, java.lang.Object,\nio.netty.channel.ChannelPromise)\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n    if (debugEnabled) {\n        logger.debug(\"{} write(ctx, {}, promise)\", logPrefix(), msg);\n    }\n    if (msg instanceof RedisCommand) {\n        writeSingleCommand(ctx, ((RedisCommand<?, ?, ?>) (msg)), promise);\n        return;\n    }\n    if (msg instanceof List) {\n        List<RedisCommand<?, ?, ?>> batch = ((List<RedisCommand<?, ?, ?>>) (msg));\n        if (batch.size() == 1) {\n            writeSingleCommand(ctx, batch.get(0), promise);\n            return;\n        }\n        writeBatch(ctx, batch, promise);\n        return;\n    }\n    if (msg instanceof Collection) {\n        writeBatch(ctx, ((Collection<RedisCommand<?, ?, ?>>) (msg)), promise);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap", "io.lettuce.core.resource.Transports.NativeTransports.<clinit>" ],
    "methodSlices" : [ "/**\n * Initialize the {@link Bootstrap}.\n *\n * @since 6.1\n */\npublic void configureBootstrap(boolean domainSocket, Function<Class<? extends EventLoopGroup>, EventLoopGroup> eventLoopGroupProvider) {\n    LettuceAssert.assertState(bootstrap != null, \"Bootstrap must be set\");\n    LettuceAssert.assertState(clientOptions != null, \"ClientOptions must be set\");\n    Class<? extends EventLoopGroup> eventLoopGroupClass = Transports.eventLoopGroupClass();\n    Class<? extends Channel> channelClass = Transports.socketChannelClass();\n    if (domainSocket) {\n        Transports.NativeTransports.assertDomainSocketAvailable();\n        eventLoopGroupClass = Transports.NativeTransports.eventLoopGroupClass(true);\n        channelClass = Transports.NativeTransports.domainSocketChannelClass();\n    } else {\n        bootstrap.resolver(clientResources.addressResolverGroup());\n    }\n    SocketOptions options = clientOptions.getSocketOptions();\n    EventLoopGroup eventLoopGroup = eventLoopGroupProvider.apply(eventLoopGroupClass);\n    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.toIntExact(options.getConnectTimeout().toMillis()));\n    if (!domainSocket) {\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, options.isKeepAlive());\n        bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());\n        if (options.isEnableTcpUserTimeout()) {\n            SocketOptions.TcpUserTimeoutOptions tcpUserTimeoutOptions = options.getTcpUserTimeout();\n            boolean applied = false;\n            if (IOUringProvider.isAvailable()) {\n                IOUringProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            } else if (EpollProvider.isAvailable()) {\n                EpollProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            }\n            LettuceAssert.assertState(applied, \"TCP User Timeout options could not be applied. Native transports (io_uring or epoll) are required.\");\n        }\n    }\n    bootstrap.channel(channelClass).group(eventLoopGroup);\n    if (options.isKeepAlive() && options.isExtendedKeepAlive()) {\n        SocketOptions.KeepAliveOptions keepAlive = options.getKeepAlive();\n        boolean applied = false;\n        if (IOUringProvider.isAvailable()) {\n            IOUringProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (EpollProvider.isAvailable()) {\n            EpollProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (ExtendedNioSocketOptions.isAvailable() && (!KqueueProvider.isAvailable())) {\n            ExtendedNioSocketOptions.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        }\n        LettuceAssert.assertState(applied, \"Extended TCP keepalive options could not be applied. Native transports (io_uring or epoll) or a compatible NIO transport are required.\");\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSearch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSearch", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied uri with default {@link ClientResources}. You can connect to different\n * Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param uri\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(String uri) {\n    LettuceAssert.notEmpty(uri, \"URI must not be empty\");\n    return new RedisClient(null, RedisURI.create(uri));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.sentinel.StatefulRedisSentinelConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}", "protected <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {\n    if (debugEnabled) {\n        logger.debug(\"dispatching command {}\", cmd);\n    }\n    if (tracingEnabled) {\n        RedisCommand<K, V, T> commandToSend = cmd;\n        TraceContextProvider provider = CommandWrapper.unwrap(cmd, TraceContextProvider.class);\n        if (provider == null) {\n            commandToSend = new TracedCommand<>(cmd, clientResources.tracing().initialTraceContextProvider().getTraceContext());\n        }\n        return channelWriter.write(commandToSend);\n    }\n    return channelWriter.write(cmd);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyException",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyException", "io.lettuce.core.protocol.DefaultEndpoint.isConnected", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void notifyException(Throwable t) {\n}", "private boolean isConnected(Channel channel) {\n    if ((channel == null) || (!channel.isActive())) {\n        return false;\n    }\n    if (channel.hasAttr(REBIND_ATTRIBUTE)) {\n        return channel.attr(REBIND_ATTRIBUTE).get() != RebindState.STARTED;\n    }\n    return true;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.findConnectionBySlotReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> clusterCountKeysInSlot(int slot) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> findConnectionBySlotReactive(int slot) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SearchReplyParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SearchReplyParser.parse", "io.lettuce.core.search.SearchReplyParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Parses Redis Search command response data into a structured {@link SearchReply} object. This method automatically detects\n * the Redis protocol version (RESP2 or RESP3) and uses the appropriate parsing strategy.\n *\n * @param data\n * \t\tthe complex data structure returned by Redis containing the search results. Must not be {@code null}.\n * @return a {@link SearchReply} containing the parsed search results. Never {@code null}. Returns an empty\n{@link SearchReply} if parsing fails.\n */\n@Override\npublic SearchReply<K, V> parse(ComplexData data) {\n    try {\n        if (data.isList()) {\n            return new Resp2SearchResultsParser().parse(data);\n        }\n        return new Resp3SearchResultsParser().parse(data);\n    } catch (Exception e) {\n        LOG.warn(\"Unable to parse the result from Redis\", e);\n        return new SearchReply<>();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.StatefulRedisConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.StatefulRedisConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}", "protected Collection<RedisCommand<K, V, ?>> dispatch(Collection<? extends RedisCommand<K, V, ?>> commands) {\n    if (debugEnabled) {\n        logger.debug(\"dispatching commands {}\", commands);\n    }\n    if (tracingEnabled) {\n        Collection<RedisCommand<K, V, ?>> withTracer = new ArrayList<>(commands.size());\n        for (RedisCommand<K, V, ?> command : commands) {\n            RedisCommand<K, V, ?> commandToUse = command;\n            TraceContextProvider provider = CommandWrapper.unwrap(command, TraceContextProvider.class);\n            if (provider == null) {\n                commandToUse = new TracedCommand<>(command, clientResources.tracing().initialTraceContextProvider().getTraceContext());\n            }\n            withTracer.add(commandToUse);\n        }\n        return channelWriter.write(withTracer);\n    }\n    return channelWriter.write(commands);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.doComplete", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void operationComplete(Future<Void> future) {\n    try {\n        doComplete(future);\n    } finally {\n        recycle();\n    }\n}", "private void doComplete(Future<Void> future) {\n    Throwable cause = future.cause();\n    boolean success = future.isSuccess();\n    dequeue();\n    if (success) {\n        return;\n    }\n    if (((cause instanceof EncoderException) || (cause instanceof Error)) || (cause.getCause() instanceof Error)) {\n        complete(cause);\n        return;\n    }\n    Channel channel = endpoint.channel;\n    // Capture values before recycler clears these.\n    RedisCommand<?, ?, ?> sentCommand = this.sentCommand;\n    Collection<? extends RedisCommand<?, ?, ?>> sentCommands = this.sentCommands;\n    potentiallyRequeueCommands(channel, sentCommand, sentCommands);\n    if (!(cause instanceof ClosedChannelException)) {\n        String message = \"Unexpected exception during request: {}\";\n        InternalLogLevel logLevel = InternalLogLevel.WARN;\n        if ((cause instanceof IOException) && SUPPRESS_IO_EXCEPTION_MESSAGES.contains(cause.getMessage())) {\n            logLevel = InternalLogLevel.DEBUG;\n        }\n        logger.log(logLevel, message, cause.toString(), cause);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyDrainQueuedCommands",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyDrainQueuedCommands", "io.lettuce.core.protocol.DefaultEndpoint.isClosed", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void notifyDrainQueuedCommands(HasQueuedCommands queuedCommands) {\n}", "public boolean isClosed() {\n    return STATUS.get(this) == ST_CLOSED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisConnection<K, V>> getConnectionAsync(ConnectionIntent connectionIntent, int slot) {\n    if (debugEnabled) {\n        logger.debug((((\"getConnection(\" + connectionIntent) + \", \") + slot) + \")\");\n    }\n    if (((connectionIntent == ConnectionIntent.READ) && (readFrom != null)) && (readFrom != ReadFrom.UPSTREAM)) {\n        return getReadConnection(slot);\n    }\n    return getWriteConnection(slot).toCompletableFuture();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.VSimScoreAttribsMapOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.VSimScoreAttribsMapOutput.set", "io.lettuce.core.output.VSimScoreAttribsMapOutput.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void set(ByteBuffer bytes) {\n    if (outputError) {\n        return;\n    }\n    switch (state) {\n        case KEY :\n            pendingKey = (bytes == null) ? null : codec.decodeValue(bytes);\n            state = State.SCORE;\n            return;\n        case SCORE :\n            try {\n                pendingScore = (bytes == null) ? null : Double.parseDouble(decodeString(bytes));\n                state = State.ATTRIBS;\n            } catch (NumberFormatException e) {\n                LOG.warn(\"Expected double as string for score, skipping this entry\");\n                // Consume the next ATTRIBS token without emitting an entry\n                skipCurrentEntry = true;\n                pendingScore = null;\n                state = State.ATTRIBS;\n            }\n            return;\n        case ATTRIBS :\n            pendingAttribs = (bytes == null) ? null : decodeString(bytes);\n            if (skipCurrentEntry) {\n                // skip this malformed entry\n                resetEntryState();\n            } else {\n                putAndReset();\n            }\n            return;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Creates a uri-less RedisClient with shared {@link ClientResources}. You need to shut down the {@link ClientResources}\n * upon shutting down your application. You can connect to different Redis servers but you must supply a {@link RedisURI} on\n * connecting. Methods without having a {@link RedisURI} will fail with a {@link java.lang.IllegalStateException}.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(ClientResources clientResources) {\n    assertNotNull(clientResources);\n    return new RedisClient(clientResources, EMPTY_URI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync", "io.lettuce.core.cluster.PooledClusterConnectionProvider.beforeGetConnection", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisConnection<K, V>> getConnectionAsync(ConnectionIntent connectionIntent, String host, int port) {\n}", "private void beforeGetConnection(ConnectionIntent connectionIntent, String host, int port) {\n    if (debugEnabled) {\n        logger.debug((((((\"getConnection(\" + connectionIntent) + \", \") + host) + \", \") + port) + \")\");\n    }\n    RedisClusterNode redisClusterNode = partitions.getPartition(host, port);\n    if (redisClusterNode == null) {\n        clusterEventListener.onUnknownNode();\n        if (validateClusterNodeMembership()) {\n            HostAndPort hostAndPort = HostAndPort.of(host, port);\n            throw connectionAttemptRejected(hostAndPort.toString());\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.getRedisUri", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}", "private static String getRedisUri(Channel channel) {\n    String redisUri = null;\n    if (channel.hasAttr(ConnectionBuilder.REDIS_URI)) {\n        redisUri = channel.attr(ConnectionBuilder.REDIS_URI).get();\n    }\n    return redisUri;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport {@link EventLoopGroup} class. Defaults to TCP sockets. See\n{@link #eventLoopGroupClass(boolean)} to request a specific EventLoopGroup for Domain Socket usage.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    return eventLoopGroupClass(false);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftDropindex(String index, boolean deleteDocumentKeys) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.run",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.run", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.<clinit>" ],
    "methodSlices" : [ "public void run() {\n    if (compareAndSet(false, true)) {\n        doRun();\n        return;\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"ClusterTopologyRefreshTask already in progress\");\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.matches",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.matches", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic boolean matches(Class<? extends EventExecutorGroup> type) {\n    checkForKqueueLibrary();\n    return false;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "private <T extends ScanCursor> RedisFuture<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyAsyncCommands<K, V>, ScanCursor, RedisFuture<T>> scanFunction, ScanCursorMapper<RedisFuture<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), cursor, scanFunction, resultMapper);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftTagvals(String index, String fieldName) {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.activated",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.activated", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * Notification when the connection becomes active (connected).\n */\npublic void activated() {\n    active = true;\n    CLOSED.set(this, ST_OPEN);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.sslConnectionBuilder",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.sslConnectionBuilder", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "public static SslConnectionBuilder sslConnectionBuilder() {\n    return new SslConnectionBuilder();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.psubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.psubscribed", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void psubscribed(K pattern, long count) {\n    notifications.psubscribed(getNode(), pattern, count);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUnknownNode",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUnknownNode", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void onUnknownNode() {\n}", "private boolean indicateTopologyRefreshSignal() {\n    logger.debug(\"ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal()\");\n    if (!acquireTimeout()) {\n        return false;\n    }\n    return scheduleRefresh();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.ValueDoubleMapOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.ValueDoubleMapOutput.set", "io.lettuce.core.output.ValueDoubleMapOutput.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void set(double number) {\n    if (outputError) {\n        return;\n    }\n    if (hasKey) {\n        output.put(key, number);\n        key = null;\n        hasKey = false;\n        return;\n    }\n    LOG.warn(\"Expected bytes but got double, discarding the result\");\n    output = new HashMap<>(0);\n    outputError = true;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RediSearchCommandBuilder.ftSearch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RediSearchCommandBuilder.ftSearch", "io.lettuce.core.search.SearchReplyParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Search the index with the given name using the specified query and search arguments.\n *\n * @param index\n * \t\tthe index name\n * @param query\n * \t\tthe query\n * @param searchArgs\n * \t\tthe search arguments\n * @return the result of the search command\n */\npublic Command<K, V, SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> searchArgs) {\n    LettuceAssert.notNull(index, \"Index must not be null\");\n    LettuceAssert.notNull(query, \"Query must not be null\");\n    CommandArgs<K, V> args = new CommandArgs<>(codec).add(index);\n    args.addValue(query);\n    if (searchArgs != null) {\n        searchArgs.build(args);\n    }\n    return createCommand(FT_SEARCH, new EncodedComplexOutput<>(codec, new SearchReplyParser<>(codec, searchArgs)), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return getConnection(connectSentinelAsync(codec, redisURI, redisURI.getTimeout()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushall() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnection", "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Retrieve a {@link StatefulRedisConnection} by the intent. {@link ConnectionIntent#WRITE} intentions use the master\n * connection, {@link ConnectionIntent#READ} intentions lookup one or more read candidates using the {@link ReadFrom}\n * setting.\n *\n * @param intent\n * \t\tcommand intent\n * @return the connection.\n */\npublic StatefulRedisConnection<K, V> getConnection(ConnectionIntent intent) {\n    if (debugEnabled) {\n        logger.debug((\"getConnection(\" + intent) + \")\");\n    }\n    try {\n        return getConnectionAsync(intent).get();\n    } catch (Exception e) {\n        throw Exceptions.bubble(e);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "/**\n * Find all keys matching the given pattern (legacy overload).\n *\n * @param channel\n * \t\tthe channel.\n * @param pattern\n * \t\tthe pattern.\n * @return Long array-reply list of keys matching {@code pattern}.\n * @deprecated Use {@link #keys(String)} instead. This legacy overload will be removed in a later version.\n */\n@Deprecated\n@Override\npublic Mono<Long> keysLegacy(KeyStreamingChannel<K> channel, K pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.ssubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.ssubscribed", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void ssubscribed(K channel, long count) {\n    notifications.ssubscribed(getNode(), channel, count);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptLoad(byte[] script) {\n    Map<String, Publisher<String>> publishers = executeOnNodes(commands -> commands.scriptLoad(script), ALL_NODES);\n    return Flux.merge(publishers.values()).last();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasadd", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAliasadd(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createFlux",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.RedisPublisher.<clinit>" ],
    "methodSlices" : [ "public <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n    if (tracingEnabled) {\n        return withTraceContext().flatMapMany(it -> Flux.from(new RedisPublisher<>(decorate(commandSupplier, it), connection, dissolve, getScheduler().next())));\n    }\n    return Flux.from(new RedisPublisher<>(commandSupplier, connection, dissolve, getScheduler().next()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.build",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.build", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "@Override\npublic ChannelInitializer<Channel> build(SocketAddress socketAddress) {\n    return new SslChannelInitializer(this::buildHandlers, toHostAndPort(socketAddress), redisURI.getVerifyMode(), redisURI.isStartTls(), clientResources(), clientOptions().getSslOptions());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n    if (debugEnabled) {\n        logger.debug(\"{} flushCommands()\", logPrefix());\n    }\n    if (isConnected(channel)) {\n        List<RedisCommand<?, ?, ?>> commands = sharedLock.doExclusive(() -> {\n            if (queue.isEmpty()) {\n                return Collections.emptyList();\n            }\n            return drainCommands(queue);\n        });\n        if (debugEnabled) {\n            logger.debug(\"{} flushCommands() Flushing {} commands\", logPrefix(), commands.size());\n        }\n        if (!commands.isEmpty()) {\n            writeToChannelAndFlush(channel, commands);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic <K, V> Collection<RedisCommand<K, V, ?>> write(Collection<? extends RedisCommand<K, V, ?>> commands) {\n    LettuceAssert.notNull(commands, \"Commands must not be null\");\n    RedisException validation = validateWrite(commands.size());\n    if (validation != null) {\n        commands.forEach(it -> it.completeExceptionally(validation));\n        return ((Collection<RedisCommand<K, V, ?>>) (commands));\n    }\n    try {\n        sharedLock.incrementWriters();\n        if (inActivation) {\n            commands = processActivationCommands(commands);\n        }\n        if (autoFlushCommands) {\n            Channel channel = this.channel;\n            if (isConnected(channel)) {\n                writeToChannelAndFlush(channel, commands);\n            } else {\n                writeToDisconnectedBuffer(commands);\n            }\n        } else {\n            writeToBuffer(commands);\n        }\n    } finally {\n        sharedLock.decrementWriters();\n        if (debugEnabled) {\n            logger.debug(\"{} write() done\", logPrefix());\n        }\n    }\n    return ((Collection<RedisCommand<K, V, ?>>) (commands));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.apply",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.apply", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "/**\n * Apply settings from {@link RedisURI}\n *\n * @param redisURI\n */\npublic void apply(RedisURI redisURI) {\n    this.redisURI = redisURI;\n    timeout(redisURI.getTimeout());\n    bootstrap.attr(REDIS_URI, redisURI.toString());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive", "io.lettuce.core.protocol.ConnectionWatchdog.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n    CommandHandler commandHandler = ctx.pipeline().get(CommandHandler.class);\n    reconnectSchedulerSync.set(false);\n    channel = ctx.channel();\n    reconnectScheduleTimeout = null;\n    logPrefix = null;\n    remoteAddress = channel.remoteAddress();\n    attempts = 0;\n    resetReconnectDelay();\n    logPrefix = null;\n    logger.debug(\"{} channelActive()\", logPrefix());\n    super.channelActive(ctx);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.randomkey",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.randomkey", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<K> randomkey() {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String nodeId) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, nodeId)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return create(Collections.singleton(redisURI));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.domainSocketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> domainSocketChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueDomainSocketChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.cancel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.cancel", "io.lettuce.core.RedisPublisher.RedisSubscription.<clinit>" ],
    "methodSlices" : [ "/**\n * Cancels a command.\n */\n@Override\npublic final void cancel() {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} cancel\", state);\n    }\n    state.cancel(this);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisAuthenticationHandler.subscribe",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisAuthenticationHandler.subscribe", "io.lettuce.core.RedisAuthenticationHandler.isSupportedConnection", "io.lettuce.core.RedisAuthenticationHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * This method subscribes to a stream of credentials provided by the `StreamingCredentialsProvider`.\n * <p>\n * Each time new credentials are received, the client is re-authenticated. The previous subscription, if any, is disposed of\n * before setting the new subscription.\n */\npublic void subscribe() {\n}", "boolean isSupportedConnection() {\n    if (isPubSubConnection && (ProtocolVersion.RESP2 == connection.getConnectionState().getNegotiatedProtocolVersion())) {\n        log.warn(\"Renewable credentials are not supported with RESP2 protocol on a pub/sub connection.\");\n        return false;\n    }\n    return true;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.ssubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.ssubscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void ssubscribed(RedisClusterNode node, K channel, long count) {\n    getListeners().forEach(listener -> listener.ssubscribed(channel, count));\n    clusterListeners.forEach(listener -> listener.ssubscribed(node, channel, count));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<StreamScanCursor> scan(KeyStreamingChannel<K> channel, ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), getConnectionProvider(), cursor, scanFunction, ((ClusterScanSupport.ScanCursorMapper) (resultMapper)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyRefresh.message",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyRefresh.message", "io.lettuce.core.masterreplica.SentinelTopologyRefresh.<clinit>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link EventLoopGroup} for socket transport that is compatible with {@link #socketChannelClass()}.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    if (NativeTransports.isAvailable()) {\n        return NativeTransports.eventLoopGroupClass();\n    }\n    return NioEventLoopGroup.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.getResources", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for io_uring-backed transport. Check availability with {@link #isAvailable()}\n * prior to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n */\npublic static EventLoopResources getResources() {\n    return IOURING_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushallAsync() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAlter",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAlter(String index, boolean skipInitialScan, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.psubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.psubscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void psubscribed(RedisClusterNode node, K pattern, long count) {\n    getListeners().forEach(listener -> listener.psubscribed(pattern, count));\n    clusterListeners.forEach(listener -> listener.psubscribed(node, pattern, count));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync", "io.lettuce.core.masterreplica.SentinelTopologyProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<List<RedisNodeDescription>> getNodesAsync() {\n    logger.debug(\"lookup topology for masterId {}\", masterId);\n    Mono<StatefulRedisSentinelConnection<String, String>> connect = Mono.fromFuture(redisClient.connectSentinelAsync(StringCodec.UTF8, sentinelUri));\n    return connect.flatMap(this::getNodes).toFuture();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.suspendTopologyRefresh",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.suspendTopologyRefresh", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.<clinit>" ],
    "methodSlices" : [ "/**\n * Suspend (cancel) periodic topology refresh.\n */\npublic void suspendTopologyRefresh() {\n    if (clusterTopologyRefreshActivated.compareAndSet(true, false)) {\n        ScheduledFuture<?> scheduledFuture = clusterTopologyRefreshFuture.get();\n        try {\n            scheduledFuture.cancel(false);\n            clusterTopologyRefreshFuture.set(null);\n        } catch (Exception e) {\n            logger.debug(\"Could not cancel Cluster topology refresh\", e);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSub", "io.lettuce.core.cluster.RedisClusterClient.assertInitialPartitions", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to encode/decode keys and\n * values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n    assertInitialPartitions()\n}", "private void assertInitialPartitions() {\n    if (partitions == null) {\n        get(initializePartitions(), e -> new RedisConnectionException(\"Unable to establish a connection to Redis Cluster\", e));\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    ctx.channel().attr(INIT_FAILURE).set(cause);\n    super.exceptionCaught(ctx, cause);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.<init>", "io.lettuce.core.RedisChannelHandler.<init>", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * Initialize a new connection.\n *\n * @param writer\n * \t\tthe channel writer\n * @param pushHandler\n * \t\tthe Cluster push handler\n * @param codec\n * \t\tCodec used to encode/decode keys and values.\n * @param timeout\n * \t\tMaximum time to wait for a response.\n * @param parser\n * \t\tthe JSON parser\n */\npublic StatefulRedisClusterConnectionImpl(RedisChannelWriter writer, ClusterPushHandler pushHandler, RedisCodec<K, V> codec, Duration timeout, Supplier<JsonParser> parser) {\n    super(writer, timeout);\n    this.pushHandler = pushHandler;\n    this.codec = codec;\n    this.parser = parser;\n    this.async = newRedisAdvancedClusterAsyncCommandsImpl();\n    this.sync = newRedisAdvancedClusterCommandsImpl();\n    this.reactive = newRedisAdvancedClusterReactiveCommandsImpl();\n}", "/**\n *\n * @param writer\n * \t\tthe channel writer\n * @param timeout\n * \t\ttimeout value\n */\npublic RedisChannelHandler(RedisChannelWriter writer, Duration timeout) {\n    this.channelWriter = writer;\n    this.clientResources = writer.getClientResources();\n    this.tracingEnabled = clientResources.tracing().isEnabled();\n    writer.setConnectionFacade(this);\n    setTimeout(timeout);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Creates a uri-less RedisClient with default {@link ClientResources}. You can connect to different Redis servers but you\n * must supply a {@link RedisURI} on connecting. Methods without having a {@link RedisURI} will fail with a\n * {@link java.lang.IllegalStateException}.\n *\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create() {\n    return new RedisClient(null, EMPTY_URI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.StatefulRedisClusterConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}", "protected <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {\n    if (debugEnabled) {\n        logger.debug(\"dispatching command {}\", cmd);\n    }\n    if (tracingEnabled) {\n        RedisCommand<K, V, T> commandToSend = cmd;\n        TraceContextProvider provider = CommandWrapper.unwrap(cmd, TraceContextProvider.class);\n        if (provider == null) {\n            commandToSend = new TracedCommand<>(cmd, clientResources.tracing().initialTraceContextProvider().getTraceContext());\n        }\n        return channelWriter.write(commandToSend);\n    }\n    return channelWriter.write(cmd);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Create an instance of a {@link EventExecutorGroup} using the default {@link ThreadFactoryProvider}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n */\npublic static <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads) {\n    return createEventLoopGroup(type, numberOfThreads, DefaultThreadFactoryProvider.INSTANCE);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.psubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.psubscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void psubscribed(RedisClusterNode node, K pattern, long count) {\n    if (nodeMessagePropagation) {\n        super.psubscribed(node, pattern, count);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.domainSocketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> domainSocketChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onMovedRedirection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onMovedRedirection", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void onMovedRedirection() {\n}", "private boolean indicateTopologyRefreshSignal() {\n    logger.debug(\"ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal()\");\n    if (!acquireTimeout()) {\n        return false;\n    }\n    return scheduleRefresh();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.SocketAddressResolver.resolve",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.SocketAddressResolver.resolve", "io.lettuce.core.resource.SocketAddressResolver.getDomainSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Resolves a {@link io.lettuce.core.RedisURI} to a {@link java.net.SocketAddress}.\n *\n * @param redisURI\n * \t\tmust not be {@code null}.\n * @param dnsResolver\n * \t\tmust not be {@code null}.\n * @return the resolved {@link SocketAddress}.\n */\npublic static SocketAddress resolve(RedisURI redisURI, DnsResolver dnsResolver) {\n}", "static SocketAddress getDomainSocketAddress(RedisURI redisURI) {\n    if (KqueueProvider.isAvailable() || EpollProvider.isAvailable()) {\n        EventLoopResources resources = (KqueueProvider.isAvailable()) ? KqueueProvider.getResources() : EpollProvider.getResources();\n        return resources.newSocketAddress(redisURI.getSocket());\n    }\n    throw new IllegalStateException(\"No native transport available. Make sure that either netty's epoll or kqueue library is on the class path and supported by your operating system.\");\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushdb() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.SubscriptionCommand.hasDemand",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.SubscriptionCommand.hasDemand", "io.lettuce.core.RedisPublisher.RedisSubscription.state", "io.lettuce.core.RedisPublisher.RedisSubscription.<clinit>" ],
    "methodSlices" : [ "@Override\npublic boolean hasDemand() {\n    return (isDone() || (subscription.state() == State.COMPLETED)) || subscription.data.isEmpty();\n}", "RedisPublisher.State state() {\n    return STATE.get(this);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasupdate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAliasupdate(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, CreateArgs<K, V> arguments, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisAsyncCommands.jsonNumincrby",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.AbstractRedisAsyncCommands.jsonNumincrby", "io.lettuce.core.RedisJsonCommandBuilder.jsonNumincrby", "io.lettuce.core.output.NumberListOutput.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<List<Number>> jsonNumincrby(K key, JsonPath jsonPath, Number number) {\n}", "Command<K, V, List<Number>> jsonNumincrby(K key, JsonPath jsonPath, Number number) {\n    notNullKey(key);\n    CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key);\n    args.add(jsonPath.toString());\n    args.add(number.toString());\n    return createCommand(JSON_NUMINCRBY, new NumberListOutput<>(codec), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAlter",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAlter(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftList",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftList", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<List<V>> ftList() {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.<init>", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link DefaultEndpoint}.\n *\n * @param clientOptions\n * \t\tclient options for this connection, must not be {@code null}.\n * @param clientResources\n * \t\tclient resources for this connection, must not be {@code null}.\n */\npublic DefaultEndpoint(ClientOptions clientOptions, ClientResources clientResources) {\n    LettuceAssert.notNull(clientOptions, \"ClientOptions must not be null\");\n    LettuceAssert.notNull(clientOptions, \"ClientResources must not be null\");\n    this.clientOptions = clientOptions;\n    this.clientResources = clientResources;\n    this.reliability = (clientOptions.isAutoReconnect()) ? Reliability.AT_LEAST_ONCE : Reliability.AT_MOST_ONCE;\n    this.replayFilter = clientOptions.getReplayFilter();\n    this.disconnectedBuffer = LettuceFactories.newConcurrentQueue(clientOptions.getRequestQueueSize());\n    this.commandBuffer = LettuceFactories.newConcurrentQueue(clientOptions.getRequestQueueSize());\n    this.boundedQueues = clientOptions.getRequestQueueSize() != Integer.MAX_VALUE;\n    this.rejectCommandsWhileDisconnected = isRejectCommand(clientOptions);\n    this.cachedEndpointId = \"0x\" + Long.toHexString(endpointId);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelInactive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelInactive", "io.lettuce.core.protocol.DefaultEndpoint.isClosed", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void notifyChannelInactive(Channel channel) {\n}", "public boolean isClosed() {\n    return STATUS.get(this) == ST_CLOSED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.message",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.MasterMessageListener.message", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void message(RedisClusterNode node, K pattern, K channel, V message) {\n    if (nodeMessagePropagation) {\n        super.message(node, pattern, channel, message);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.punsubscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.punsubscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void punsubscribed(RedisClusterNode node, K pattern, long count) {\n    getListeners().forEach(listener -> listener.punsubscribed(pattern, count));\n    clusterListeners.forEach(listener -> listener.punsubscribed(node, pattern, count));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.completeExceptionally",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.completeExceptionally", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnError", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.<clinit>" ],
    "methodSlices" : [ "@Override\npublic boolean completeExceptionally(Throwable throwable) {\n    Object[] consumers = ONCOMPLETE.get(this);\n    boolean result = false;\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        result = command.completeExceptionally(throwable);\n        doOnError(throwable);\n        notifyBiConsumer(consumers, throwable);\n    }\n    return result;\n}", "@Override\nprotected void doOnError(Throwable throwable) {\n    onError(throwable);\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}", "/**\n * Called by a listener interface to indicate that as error has occurred.\n *\n * @param t\n * \t\tthe error\n */\nfinal void onError(Throwable t) {\n    State state = state();\n    if (LOG.isErrorEnabled()) {\n        LOG.trace(\"{} onError(): {}\", state, t.toString(), t);\n    }\n    state.onError(this, t);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.VSimScoreAttribsMapOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.VSimScoreAttribsMapOutput.set", "io.lettuce.core.output.VSimScoreAttribsMapOutput.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void set(double number) {\n    if (outputError) {\n        return;\n    }\n    if (state == State.SCORE) {\n        pendingScore = number;\n        state = State.ATTRIBS;\n    } else if (state == State.ATTRIBS) {\n        // RESP3 type/order mismatch for current entry: skip this entry and continue\n        LOG.warn(\"Expected attributes as bulk string but got double; skipping current entry\");\n        resetEntryState();\n    } else {\n        // Received a double while expecting a key: structural error\n        LOG.warn(\"Expected key but got double, discarding the result\");\n        output = new HashMap<>(0);\n        outputError = true;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(ClientResources clientResources, RedisURI redisURI) {\n    assertNotNull(clientResources);\n    assertNotNull(redisURI);\n    return new RedisClient(clientResources, redisURI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createMono",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createMono", "io.lettuce.core.RedisPublisher.<clinit>" ],
    "methodSlices" : [ "public <T> Mono<T> createMono(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n    if (tracingEnabled) {\n        return withTraceContext().flatMap(it -> Mono.from(new RedisPublisher<>(decorate(commandSupplier, it), connection, false, getScheduler().next())));\n    }\n    return Mono.from(new RedisPublisher<>(commandSupplier, connection, false, getScheduler().next()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<StreamScanCursor> scan(KeyStreamingChannel<K> channel, ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "private <T extends ScanCursor> RedisFuture<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyAsyncCommands<K, V>, ScanCursor, RedisFuture<T>> scanFunction, ScanCursorMapper<RedisFuture<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), cursor, scanFunction, resultMapper);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n    logger.debug(\"Initiate shutdown ({}, {}, {})\", quietPeriod, timeout, timeUnit);\n    shutdownCalled = true;\n    Map<Class<? extends EventExecutorGroup>, EventExecutorGroup> copy = new HashMap<>(eventLoopGroups);\n    DefaultPromise<Void> overall = new DefaultPromise<>(ImmediateEventExecutor.INSTANCE);\n    PromiseCombiner combiner = new PromiseCombiner(ImmediateEventExecutor.INSTANCE);\n    for (EventExecutorGroup executorGroup : copy.values()) {\n        combiner.add(doRelease(executorGroup, quietPeriod, timeout, timeUnit));\n    }\n    combiner.finish(overall);\n    return PromiseAdapter.toBooleanPromise(overall);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.subscribed",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.subscribed", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void subscribed(RedisClusterNode node, K channel, long count) {\n    getListeners().forEach(listener -> listener.subscribed(channel, count));\n    clusterListeners.forEach(listener -> listener.subscribed(node, channel, count));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.Operators.request",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.Operators.request", "io.lettuce.core.Operators.<clinit>" ],
    "methodSlices" : [ "/**\n * Concurrent addition bound to Long.MAX_VALUE. Any concurrent write will \"happen before\" this operation.\n *\n * @param <T>\n * \t\tthe parent instance type\n * @param updater\n * \t\tcurrent field updater\n * @param instance\n * \t\tcurrent instance to update\n * @param toAdd\n * \t\tdelta to add\n * @return {@code true} if the operation succeeded.\n * @since 5.0.1\n */\npublic static <T> boolean request(AtomicLongFieldUpdater<T> updater, T instance, long toAdd) {\n    if (validate(toAdd)) {\n        addCap(updater, instance, toAdd);\n        return true;\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n    assertNotNull(redisURI);\n    return getConnection(connectPubSubAsync(newStringStringCodec(), redisURI, redisURI.getTimeout()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> keys(KeyStreamingChannel<K> channel, String pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n    checkForKqueueLibrary();\n    // Use the new Netty 4.2 approach with IoHandlerFactory\n    return new MultiThreadIoEventLoopGroup(nThreads, threadFactory, KQueueIoHandler.newFactory());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.isAvailable", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if io_uring is available.\n */\npublic static boolean isAvailable() {\n    return IOURING_AVAILABLE && IOURING_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnection", "io.lettuce.core.cluster.PooledClusterConnectionProvider.beforeGetConnection", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n}", "private void beforeGetConnection(ConnectionIntent connectionIntent, String host, int port) {\n    if (debugEnabled) {\n        logger.debug((((((\"getConnection(\" + connectionIntent) + \", \") + host) + \", \") + port) + \")\");\n    }\n    RedisClusterNode redisClusterNode = partitions.getPartition(host, port);\n    if (redisClusterNode == null) {\n        clusterEventListener.onUnknownNode();\n        if (validateClusterNodeMembership()) {\n            HostAndPort hostAndPort = HostAndPort.of(host, port);\n            throw connectionAttemptRejected(hostAndPort.toString());\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.complete",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.complete", "io.lettuce.core.cluster.ClusterCommand.complete", "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void complete() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.complete();\n        doOnComplete();\n        notifyConsumers(consumers);\n    }\n}", "@Override\npublic void complete() {\n    if (isMoved() || isAsk()) {\n        boolean retryCommand = maxRedirections > redirections;\n        redirections++;\n        if (retryCommand) {\n            try {\n                retry.write(this);\n            } catch (Exception e) {\n                completeExceptionally(e);\n            }\n            return;\n        }\n    }\n    super.complete();\n    completed = true;\n}", "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n    LettuceAssert.notNull(command, \"Command must not be null\");\n    RedisException validation = validateWrite(1);\n    if (validation != null) {\n        command.completeExceptionally(validation);\n        return command;\n    }\n    try {\n        sharedLock.incrementWriters();\n        if (inActivation) {\n            command = processActivationCommand(command);\n        }\n        if (autoFlushCommands) {\n            Channel channel = this.channel;\n            if (isConnected(channel)) {\n                writeToChannelAndFlush(channel, command);\n            } else {\n                writeToDisconnectedBuffer(command);\n            }\n        } else {\n            writeToBuffer(command);\n        }\n    } finally {\n        sharedLock.decrementWriters();\n        if (debugEnabled) {\n            logger.debug(\"{} write() done\", logPrefix());\n        }\n    }\n    return command;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SpellCheckResultParser.SpellCheckResp3Parser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SpellCheckResultParser.SpellCheckResp3Parser.parse", "io.lettuce.core.search.SpellCheckResultParser.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SpellCheckResult<V> parse(ComplexData data) {\n    SpellCheckResult<V> result = new SpellCheckResult<>();\n    if (data == null) {\n        return null;\n    }\n    Map<Object, Object> elements = data.getDynamicMap();\n    if (((elements == null) || elements.isEmpty()) || (!elements.containsKey(resultsKeyword))) {\n        LOG.warn(\"Failed while parsing FT.SPELLCHECK: data must contain a 'results' key\");\n        return result;\n    }\n    ComplexData resultsData = ((ComplexData) (elements.get(resultsKeyword)));\n    Map<Object, Object> resultsMap = resultsData.getDynamicMap();\n    // Go through each misspelled term, should contain three items itself\n    for (Object term : resultsMap.keySet()) {\n        // Key of the inner map is the misspelled term\n        V misspelledTerm = codec.decodeValue(((ByteBuffer) (term)));\n        // Value of the inner map is the suggestions array\n        ComplexData termData = ((ComplexData) (resultsMap.get(term)));\n        List<Object> suggestionsArray = termData.getDynamicList();\n        List<SpellCheckResult.Suggestion<V>> suggestions = parseSuggestions(suggestionsArray);\n        result.addMisspelledTerm(new SpellCheckResult.MisspelledTerm<>(misspelledTerm, suggestions));\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), getConnectionProvider(), cursor, scanFunction, ((ClusterScanSupport.ScanCursorMapper) (resultMapper)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictdump", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<List<V>> ftDictdump(String dict) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelInactive", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelInactive(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n    if (debugEnabled) {\n        logger.debug(\"{} channelInactive()\", logPrefix());\n    }\n    if ((channel != null) && (ctx.channel() != channel)) {\n        logger.debug(\"{} My channel and ctx.channel mismatch. Propagating event to other listeners.\", logPrefix());\n        super.channelInactive(ctx);\n        return;\n    }\n    tracedEndpoint = null;\n    setState(LifecycleState.DISCONNECTED);\n    setState(LifecycleState.DEACTIVATING);\n    endpoint.notifyChannelInactive(ctx.channel());\n    endpoint.notifyDrainQueuedCommands(this);\n    setState(LifecycleState.DEACTIVATED);\n    PristineFallbackCommand command = this.fallbackCommand;\n    if (isProtectedMode(command)) {\n        onProtectedMode(command.getOutput().getError());\n    }\n    if (debugEnabled) {\n        logger.debug(\"{} channelInactive() done\", logPrefix());\n    }\n    super.channelInactive(ctx);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.datagramChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends DatagramChannel> datagramChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueDatagramChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.close",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.close", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "/**\n * Close the connection (synchronous).\n */\n@Override\npublic void close() {\n    if (debugEnabled) {\n        logger.debug(\"close()\");\n    }\n    closeAsync().join();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftAliasdel", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftAliasdel(String alias) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive", "io.lettuce.core.ConnectionEventTrigger.getRedisUri", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}", "private static String getRedisUri(Channel channel) {\n    String redisUri = null;\n    if (channel.hasAttr(ConnectionBuilder.REDIS_URI)) {\n        redisUri = channel.attr(ConnectionBuilder.REDIS_URI).get();\n    }\n    return redisUri;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.cancel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.cancel", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnError", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void cancel() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.cancel();\n        CancellationException exception = new CancellationException();\n        doOnError(exception);\n        notifyBiConsumer(consumers, exception);\n    }\n}", "@Override\nprotected void doOnError(Throwable throwable) {\n    onError(throwable);\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}", "/**\n * Called by a listener interface to indicate that as error has occurred.\n *\n * @param t\n * \t\tthe error\n */\nfinal void onError(Throwable t) {\n    State state = state();\n    if (LOG.isErrorEnabled()) {\n        LOG.trace(\"{} onError(): {}\", state, t.toString(), t);\n    }\n    state.onError(this, t);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @return a new instance of default client resources.\n */\nstatic ClientResources create() {\n    return DefaultClientResources.create();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.applyKeepAlive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.applyKeepAlive", "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.<clinit>", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "/**\n * Apply Keep-Alive options.\n */\npublic static void applyKeepAlive(Bootstrap bootstrap, int count, Duration idle, Duration interval) {\n    bootstrap.option(NioChannelOption.of(TCP_KEEPCOUNT), count);\n    bootstrap.option(NioChannelOption.of(TCP_KEEPIDLE), Math.toIntExact(idle.getSeconds()));\n    bootstrap.option(NioChannelOption.of(TCP_KEEPINTERVAL), Math.toIntExact(interval.getSeconds()));\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "private <T extends ScanCursor> RedisFuture<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyAsyncCommands<K, V>, ScanCursor, RedisFuture<T>> scanFunction, ScanCursorMapper<RedisFuture<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), cursor, scanFunction, resultMapper);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisVectorSetCommandBuilder.vinfo",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisVectorSetCommandBuilder.vinfo", "io.lettuce.core.output.VectorMetadataParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@code VINFO} command to get information about a vector set.\n *\n * @param key\n * \t\tthe key of the vector set, must not be {@code null}\n * @return a new {@link Command} that returns metadata about the vector set\n * @see <a href=\"https://redis.io/docs/latest/commands/vinfo/\">Redis Documentation: VINFO</a>\n */\npublic Command<K, V, VectorMetadata> vinfo(K key) {\n    notNullKey(key);\n    CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key);\n    return createCommand(VINFO, new ComplexOutput<>(codec, VectorMetadataParser.INSTANCE), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connect", "io.lettuce.core.cluster.RedisClusterClient.assertInitialPartitions", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterConnection<K, V> connect(RedisCodec<K, V> codec) {\n    assertInitialPartitions()\n}", "private void assertInitialPartitions() {\n    if (partitions == null) {\n        get(initializePartitions(), e -> new RedisConnectionException(\"Unable to establish a connection to Redis Cluster\", e));\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodes",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodes", "io.lettuce.core.masterreplica.SentinelTopologyProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic List<RedisNodeDescription> getNodes() {\n    logger.debug(\"lookup topology for masterId {}\", masterId);\n    try {\n        return getNodesAsync().get(timeout.toMillis(), TimeUnit.MILLISECONDS);\n    } catch (Exception e) {\n        throw Exceptions.bubble(e);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.RedisPublisher.<clinit>" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic <T, R> Flux<R> createDissolvingFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n    if (tracingEnabled) {\n        return withTraceContext().flatMapMany(it -> Flux.from(new RedisPublisher<>(decorate(commandSupplier, it), connection, dissolve, getScheduler().next())));\n    }\n    return Flux.from(new RedisPublisher<>(commandSupplier, connection, dissolve, getScheduler().next()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newEventLoopGroup", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftExplain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftExplain(String index, V query, ExplainArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.NumberListOutput.setBigNumber",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.NumberListOutput.setBigNumber", "io.lettuce.core.output.NumberListOutput.parseNumber", "io.lettuce.core.output.NumberListOutput.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void setBigNumber(ByteBuffer bytes) {\n}", "private Number parseNumber(ByteBuffer bytes) {\n    Number result = 0;\n    try {\n        result = NumberFormat.getNumberInstance().parse(decodeString(bytes));\n    } catch (ParseException e) {\n        LOG.warn(\"Failed to parse \" + bytes, e);\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.socketChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link Channel} for socket (network/TCP) transport.\n */\npublic static Class<? extends Channel> socketChannelClass() {\n    if (NativeTransports.isAvailable()) {\n        return NativeTransports.socketChannelClass();\n    }\n    return NioSocketChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.drainQueue",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.drainQueue", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Collection<RedisCommand<?, ?, ?>> drainQueue() {\n    return drainCommands(stack);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushall(FlushMode flushMode) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectToNodeAsync(redisCodec, key.nodeId, null, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectToNodeAsync(redisCodec, (key.host + \":\") + key.port, clusterWriter, getSocketAddressSupplier(key));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n    assertNotNull(codec);\n    assertNotEmpty(initialUris);\n    LettuceAssert.notNull(socketAddressSupplier, \"SocketAddressSupplier must not be null\");\n    ClusterNodeEndpoint endpoint = new ClusterNodeEndpoint(getClusterClientOptions(), getResources(), clusterWriter);\n    RedisChannelWriter writer = endpoint;\n    if (CommandExpiryWriter.isSupported(getClusterClientOptions())) {\n        writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getClusterClientOptions(), getResources());\n    }\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n        writer = new CommandListenerWriter(writer, getCommandListeners());\n    }\n    StatefulRedisConnectionImpl<K, V> connection = newStatefulRedisConnection(writer, endpoint, codec, getFirstUri().getTimeout(), getClusterClientOptions().getJsonParser());\n    connection.setAuthenticationHandler(createHandler(connection, getFirstUri().getCredentialsProvider(), false, getOptions()));\n    ConnectionFuture<StatefulRedisConnection<K, V>> connectionFuture = connectStatefulAsync(connection, endpoint, getFirstUri(), socketAddressSupplier, () -> new CommandHandler(getClusterClientOptions(), getResources(), endpoint));\n    return connectionFuture.whenComplete((conn, throwable) -> {\n        if (throwable != null) {\n            connection.closeAsync();\n        }\n    });\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDictadd", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<Long> ftDictadd(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushdb(FlushMode flushMode) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.StatefulRedisConnectionImpl.dispatch",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.StatefulRedisConnectionImpl.dispatch", "io.lettuce.core.RedisChannelHandler.dispatch", "io.lettuce.core.RedisChannelHandler.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> command) {\n}", "protected <T> RedisCommand<K, V, T> dispatch(RedisCommand<K, V, T> cmd) {\n    if (debugEnabled) {\n        logger.debug(\"dispatching command {}\", cmd);\n    }\n    if (tracingEnabled) {\n        RedisCommand<K, V, T> commandToSend = cmd;\n        TraceContextProvider provider = CommandWrapper.unwrap(cmd, TraceContextProvider.class);\n        if (provider == null) {\n            commandToSend = new TracedCommand<>(cmd, clientResources.tracing().initialTraceContextProvider().getTraceContext());\n        }\n        return channelWriter.write(commandToSend);\n    }\n    return channelWriter.write(cmd);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.AggregateReplyParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.AggregateReplyParser.parse", "io.lettuce.core.search.AggregateReplyParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Parses the complex data from FT.AGGREGATE command into a list of SearchReply objects.\n * <p>\n * The method expects the data to be an array where each element is itself a complex data structure that can be parsed by\n * {@link SearchReplyParser}. If the input data is null, empty, or cannot be converted to a list, an empty list is returned.\n *\n * @param data\n * \t\tthe complex data from the FT.AGGREGATE command response\n * @return a list of SearchReply objects, one for each aggregation result\n */\n@Override\npublic AggregationReply<K, V> parse(ComplexData data) {\n    AggregationReply<K, V> reply = new AggregationReply<>();\n    if (data == null) {\n        return reply;\n    }\n    try {\n        if (!withCursor) {\n            SearchReply<K, V> searchReply = searchReplyParser.parse(data);\n            reply.addSearchReply(searchReply);\n            return reply;\n        }\n        List<Object> aggregateResults = data.getDynamicList();\n        if ((aggregateResults == null) || aggregateResults.isEmpty()) {\n            return reply;\n        }\n        boolean replyRead = false;\n        for (Object aggregateResult : aggregateResults) {\n            if (aggregateResult instanceof Number) {\n                if (replyRead) {\n                    long id = ((Number) (aggregateResult)).longValue();\n                    reply.setCursor(Cursor.of(id, null));\n                } else {\n                    reply.setGroupCount(((Number) (aggregateResult)).longValue());\n                }\n            } else if (aggregateResult instanceof ComplexData) {\n                // Each element should be a ComplexData that can be parsed by SearchReplyParser\n                SearchReply<K, V> searchReply = searchReplyParser.parse(((ComplexData) (aggregateResult)));\n                reply.addSearchReply(searchReply);\n                replyRead = true;\n            }\n        }\n        return reply;\n    } catch (Exception e) {\n        LOG.warn(\"Error while parsing the result returned from Redis\", e);\n        return reply;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<Map<V, List<V>>> ftSyndump(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.datagramChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends DatagramChannel> datagramChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.checkForRedisURI", "io.lettuce.core.RedisClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful pub/sub connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n    checkForRedisURI();\n    return getConnection(connectPubSubAsync(codec, this.redisURI, this.redisURI.getTimeout()));\n}", "private void checkForRedisURI() {\n    LettuceAssert.assertState(this.redisURI != EMPTY_URI, \"RedisURI is not available. Use RedisClient(Host), RedisClient(Host, Port) or RedisClient(RedisURI) to construct your client.\");\n    checkValidRedisURI(this.redisURI);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftSynupdate(String index, V synonymGroupId, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.isAvailable", "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.<clinit>", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "public static boolean isAvailable() {\n    return ((TCP_KEEPCOUNT != null) && (TCP_KEEPIDLE != null)) && (TCP_KEEPINTERVAL != null);\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.builder",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.builder", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns a new {@link DefaultClientResources.Builder} to construct {@link DefaultClientResources}.\n *\n * @return a new {@link DefaultClientResources.Builder} to construct {@link DefaultClientResources}.\n */\npublic static DefaultClientResources.Builder builder() {\n}", "private Builder() {\n}", "private Builder() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Flux<K> keys(String pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "/**\n * Find all keys matching the given pattern (legacy overload).\n *\n * @param pattern\n * \t\tthe pattern type: patternkey (pattern).\n * @return K array-reply list of keys matching {@code pattern}.\n * @deprecated Use {@link #keys(String)} instead. This legacy overload will be removed in a later version.\n */\n@Deprecated\n@Override\npublic Flux<K> keysLegacy(K pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n    return getMono(getConnectionProvider().<K, V>getConnectionAsync(ConnectionIntent.WRITE, host, port)).map(StatefulRedisConnection::reactive);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.mutate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.mutate", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns a builder to create new {@link DefaultClientResources} whose settings are replicated from the current\n * {@link DefaultClientResources}.\n * <p>\n * Note: The resulting {@link DefaultClientResources} retains shared state for {@link Timer},\n * {@link CommandLatencyRecorder}, {@link EventExecutorGroup}, and {@link EventLoopGroupProvider} if these are left\n * unchanged. Thus, you need only to shut down the last created {@link ClientResources} instances. Shutdown affects any\n * previously created {@link ClientResources}.\n * </p>\n *\n * @return a {@link DefaultClientResources.Builder} to create new {@link DefaultClientResources} whose settings are\nreplicated from the current {@link DefaultClientResources}.\n * @since 5.1\n */\n@Override\npublic DefaultClientResources.Builder mutate() {\n}", "private Builder() {\n}", "private Builder() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.closeAsync", "io.lettuce.core.protocol.DefaultEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<Void> closeAsync() {\n    if (debugEnabled) {\n        logger.debug(\"{} closeAsync()\", logPrefix());\n    }\n    if (isClosed()) {\n        return closeFuture;\n    }\n    if (STATUS.compareAndSet(this, ST_OPEN, ST_CLOSED)) {\n        if (connectionWatchdog != null) {\n            connectionWatchdog.prepareClose();\n        }\n        cancelBufferedCommands(\"Close\");\n        Channel channel = getOpenChannel();\n        if (channel != null) {\n            Futures.adapt(channel.close(), closeFuture);\n        } else {\n            closeFuture.complete(null);\n        }\n    }\n    return closeFuture;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.builder",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.builder", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @return a new instance of a default client resources.\n */\nstatic Builder builder() {\n    return DefaultClientResources.builder();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectAsync", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()} first, otherwise the connect\n * will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectAsync(RedisCodec<K, V> codec) {\n    return transformAsyncConnectionException(connectClusterAsync(codec), getInitialUris());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelConnector.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.SentinelConnector.connectAsync", "io.lettuce.core.masterreplica.SentinelTopologyProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsync() {\n    TopologyProvider topologyProvider = new SentinelTopologyProvider(redisURI.getSentinelMasterId(), redisClient, redisURI);\n    SentinelTopologyRefresh sentinelTopologyRefresh = new SentinelTopologyRefresh(redisClient, redisURI.getSentinelMasterId(), redisURI.getSentinels());\n    MasterReplicaTopologyRefresh refresh = new MasterReplicaTopologyRefresh(redisClient, topologyProvider);\n    MasterReplicaConnectionProvider<K, V> connectionProvider = new MasterReplicaConnectionProvider<>(redisClient, codec, redisURI, Collections.emptyMap());\n    Runnable runnable = getTopologyRefreshRunnable(refresh, connectionProvider);\n    return refresh.getNodes(redisURI).flatMap(nodes -> {\n        if (nodes.isEmpty()) {\n            return Mono.error(new RedisException(String.format(\"Cannot determine topology from %s\", redisURI)));\n        }\n        return initializeConnection(codec, sentinelTopologyRefresh, connectionProvider, runnable, nodes);\n    }).onErrorMap(ExecutionException.class, Throwable::getCause).toFuture();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelActive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelActive", "io.lettuce.core.protocol.CommandHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelActive(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n    if (debugEnabled) {\n        logger.debug(\"{} channelActive()\", logPrefix());\n    }\n    setState(LifecycleState.CONNECTED);\n    tracedEndpoint = clientResources.tracing().createEndpoint(ctx.channel().remoteAddress());\n    endpoint.notifyChannelActive(ctx.channel());\n    super.channelActive(ctx);\n    if (debugEnabled) {\n        logger.debug(\"{} channelActive() done\", logPrefix());\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "private <T extends ScanCursor> RedisFuture<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyAsyncCommands<K, V>, ScanCursor, RedisFuture<T>> scanFunction, ScanCursorMapper<RedisFuture<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), cursor, scanFunction, resultMapper);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.smessage",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PubSubClusterEndpoint.NotifyingMessageListener.smessage", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void smessage(RedisClusterNode node, K shardChannel, V message) {\n    getListeners().forEach(listener -> listener.smessage(shardChannel, message));\n    clusterListeners.forEach(listener -> listener.smessage(node, shardChannel, message));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.PubSubEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.pubsub.PubSubEndpoint.write", "io.lettuce.core.pubsub.PubSubEndpoint.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <K1, V1> Collection<RedisCommand<K1, V1, ?>> write(Collection<? extends RedisCommand<K1, V1, ?>> redisCommands) {\n    if (isSubscribed()) {\n        if (containsViolatingCommands(redisCommands)) {\n            rejectCommands(redisCommands);\n            return ((Collection<RedisCommand<K1, V1, ?>>) (redisCommands));\n        }\n    }\n    if (!subscribeWritten) {\n        for (RedisCommand<?, ?, ?> redisCommand : redisCommands) {\n            if (SUBSCRIBE_COMMANDS.contains(redisCommand.getType().toString())) {\n                subscribeWritten = true;\n                break;\n            }\n        }\n    }\n    return super.write(redisCommands);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.VectorMetadataParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.VectorMetadataParser.parse", "io.lettuce.core.output.VectorMetadataParser.verifyStructure", "io.lettuce.core.output.VectorMetadataParser.<clinit>" ],
    "methodSlices" : [ "/**\n * Parse the output of the Redis VINFO command and convert it to a {@link VectorMetadata} object.\n * <p>\n * The VINFO command returns an array of key-value pairs, where each pair consists of a field name followed by its value.\n * This method extracts the relevant fields and populates a {@link VectorMetadata} object with the corresponding values.\n *\n * @param dynamicData\n * \t\toutput of VINFO command\n * @return a {@link VectorMetadata} instance containing the parsed information\n * @throws IllegalArgumentException\n * \t\tif the input data is null, empty, or has an invalid format\n */\n@Override\npublic VectorMetadata parse(ComplexData dynamicData) {\n}", "/**\n * Verifies that the input data has the expected structure for a VINFO command response.\n *\n * @param vinfoOutput\n * \t\tthe output from the VINFO command\n * @return the list of key-value pairs from the VINFO command\n * @throws IllegalArgumentException\n * \t\tif the input data is null, empty, or has an invalid format\n */\nprivate List<Object> verifyStructure(ComplexData vinfoOutput) {\n    if (vinfoOutput == null) {\n        LOG.warn(\"Failed while parsing VINFO: vinfoOutput must not be null\");\n        return null;\n    }\n    List<Object> data;\n    try {\n        data = vinfoOutput.getDynamicList();\n    } catch (UnsupportedOperationException e) {\n        try {\n            Map<Object, Object> map = vinfoOutput.getDynamicMap();\n            data = new ArrayList<>(map.size() * 2);\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                data.add(entry.getKey());\n                data.add(entry.getValue());\n            }\n        } catch (UnsupportedOperationException ex) {\n            LOG.warn(\"Failed while parsing VINFO: vinfoOutput must be a list or a map\", ex);\n            return new ArrayList<>();\n        }\n    }\n    if ((data == null) || data.isEmpty()) {\n        LOG.warn(\"Failed while parsing VINFO: data must not be null or empty\");\n        return new ArrayList<>();\n    }\n    // VINFO returns an array of key-value pairs, so the size must be even\n    if ((data.size() % 2) != 0) {\n        LOG.warn(\"Failed while parsing VINFO: data must contain key-value pairs\");\n        return new ArrayList<>();\n    }\n    return data;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterAsyncCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic RedisFuture<String> ftDropindex(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context.\n * <p>\n * Obtains the executing node id via CLUSTER MYID on the selected node and passes it to {@code routedCall}, allowing reply\n * stamping (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. If routing fails, falls back to {@code superCall}\n * to preserve existing behavior.\n *\n * @param superCall\n * \t\tsupplier of the superclass implementation used as a fallback\n * @param routedCall\n * \t\tbi-function receiving {@code nodeId} and a node-scoped cluster async connection\n * @param commandType\n * \t\tprotocol command used to classify READ vs WRITE intent\n * @param <R>\n * \t\tresult type\n * @return RedisFuture wrapping the routed execution\n */\n<R> RedisFuture<R> routeKeyless(Supplier<RedisFuture<R>> superCall, BiFunction<String, RedisClusterAsyncCommands<K, V>, CompletionStage<R>> routedCall, ProtocolKeyword commandType) {\n}", "private ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.message",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.DelegatingRedisClusterPubSubListener.message", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic void message(K pattern, K channel, V message) {\n    notifications.message(getNode(), pattern, channel, message);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisVectorSetCommandBuilder.vsimWithScore",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisVectorSetCommandBuilder.vsimWithScore", "io.lettuce.core.output.ValueDoubleMapOutput.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@code VSIM} command with the WITHSCORES option to find the most similar vectors to the given query vector\n * with additional options and return them with their similarity scores.\n *\n * @param key\n * \t\tthe key of the vector set, must not be {@code null}\n * @param vSimArgs\n * \t\tthe additional arguments for the VSIM command\n * @param vectors\n * \t\tthe query vector values as floating point numbers, must not be empty\n * @return a new {@link Command} that returns a map of elements to their similarity scores\n * @see <a href=\"https://redis.io/docs/latest/commands/vsim/\">Redis Documentation: VSIM</a>\n */\npublic Command<K, V, Map<V, Double>> vsimWithScore(K key, VSimArgs vSimArgs, Double[] vectors) {\n    notNullKey(key);\n    notEmpty(vectors);\n    CommandArgs<K, V> args = new CommandArgs<>(codec).addKey(key);\n    if (vectors.length > 1) {\n        args.add(CommandKeyword.VALUES);\n        args.add(vectors.length);\n        Arrays.stream(vectors).forEach(args::add);\n    } else {\n        args.add(vectors[0]);\n    }\n    args.add(WITHSCORES);\n    if (vSimArgs != null) {\n        vSimArgs.build(args);\n    }\n    return createCommand(VSIM, new ValueDoubleMapOutput<>(codec), args);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasdel(String alias) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.NodeConnectionPostProcessor.apply",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.NodeConnectionPostProcessor.apply", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    RedisClusterNode targetNode = null;\n    if ((key.nodeId != null) && ((targetNode = getPartitions().getPartitionByNodeId(key.nodeId)) == null)) {\n        clusterEventListener.onUnknownNode();\n        throw connectionAttemptRejected(\"node id \" + key.nodeId);\n    }\n    if ((key.host != null) && ((targetNode = partitions.getPartition(key.host, key.port)) == null)) {\n        clusterEventListener.onUnknownNode();\n        if (validateClusterNodeMembership()) {\n            throw connectionAttemptRejected((key.host + \":\") + key.port);\n        }\n    }\n    ConnectionFuture<StatefulRedisConnection<K, V>> connection = delegate.apply(key);\n    LettuceAssert.notNull(connection, \"Connection is null. Check ConnectionKey because host and nodeId are null.\");\n    if (key.connectionIntent == ConnectionIntent.READ) {\n        connection = connection.thenCompose(c -> {\n            RedisFuture<String> stringRedisFuture = c.async().readOnly();\n            return stringRedisFuture.thenApply(s -> c).whenCompleteAsync((s, throwable) -> {\n                if (throwable != null) {\n                    c.close();\n                }\n            });\n        });\n    }\n    RedisClusterNode actualNode = targetNode;\n    connection = connection.thenApply(c -> {\n        stateLock.lock();\n        try {\n            c.setAutoFlushCommands(autoFlushCommands);\n            c.addListener(message -> onPushMessage(actualNode, message));\n        } finally {\n            stateLock.unlock();\n        }\n        return c;\n    });\n    return connection;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.<init>", "io.lettuce.core.ConnectionBuilder.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new watchdog that adds to new connections to the supplied {@link ChannelGroup} and establishes a new\n * {@link Channel} when disconnected, while reconnect is true. The socketAddressSupplier can supply the reconnect address.\n *\n * @param reconnectDelay\n * \t\treconnect delay, must not be {@code null}\n * @param clientOptions\n * \t\tclient options for the current connection, must not be {@code null}\n * @param bootstrap\n * \t\tConfiguration for new channels, must not be {@code null}\n * @param timer\n * \t\tTimer used for delayed reconnect, must not be {@code null}\n * @param reconnectWorkers\n * \t\texecutor group for reconnect tasks, must not be {@code null}\n * @param socketAddressSupplier\n * \t\tthe socket address supplier to obtain an address for reconnection, may be {@code null}\n * @param reconnectionListener\n * \t\tthe reconnection listener, must not be {@code null}\n * @param connectionFacade\n * \t\tthe connection facade, must not be {@code null}\n * @param eventBus\n * \t\tEvent bus to emit reconnect events.\n * @param endpoint\n * \t\tmust not be {@code null}\n */\npublic ConnectionWatchdog(Delay reconnectDelay, ClientOptions clientOptions, Bootstrap bootstrap, Timer timer, EventExecutorGroup reconnectWorkers, Mono<SocketAddress> socketAddressSupplier, ReconnectionListener reconnectionListener, ConnectionFacade connectionFacade, EventBus eventBus, Endpoint endpoint) {\n    LettuceAssert.notNull(reconnectDelay, \"Delay must not be null\");\n    LettuceAssert.notNull(clientOptions, \"ClientOptions must not be null\");\n    LettuceAssert.notNull(bootstrap, \"Bootstrap must not be null\");\n    LettuceAssert.notNull(timer, \"Timer must not be null\");\n    LettuceAssert.notNull(reconnectWorkers, \"ReconnectWorkers must not be null\");\n    LettuceAssert.notNull(socketAddressSupplier, \"SocketAddressSupplier must not be null\");\n    LettuceAssert.notNull(reconnectionListener, \"ReconnectionListener must not be null\");\n    LettuceAssert.notNull(connectionFacade, \"ConnectionFacade must not be null\");\n    LettuceAssert.notNull(eventBus, \"EventBus must not be null\");\n    LettuceAssert.notNull(endpoint, \"Endpoint must not be null\");\n    this.reconnectDelay = reconnectDelay;\n    this.bootstrap = bootstrap;\n    this.timer = timer;\n    this.reconnectWorkers = reconnectWorkers;\n    this.reconnectionListener = reconnectionListener;\n    this.reconnectSchedulerSync = new AtomicBoolean(false);\n    this.eventBus = eventBus;\n    this.redisUri = ((String) (bootstrap.config().attrs().get(ConnectionBuilder.REDIS_URI)));\n    this.epid = endpoint.getId();\n    Mono<SocketAddress> wrappedSocketAddressSupplier = wrapSocketAddressSupplier(socketAddressSupplier);\n    this.reconnectionHandler = new ReconnectionHandler(clientOptions, bootstrap, wrappedSocketAddressSupplier, timer, reconnectWorkers, connectionFacade);\n    resetReconnectDelay();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnection", "io.lettuce.core.cluster.PooledClusterConnectionProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic StatefulRedisConnection<K, V> getConnection(ConnectionIntent connectionIntent, String nodeId) {\n    if (debugEnabled) {\n        logger.debug((((\"getConnection(\" + connectionIntent) + \", \") + nodeId) + \")\");\n    }\n    return getConnection(new ConnectionKey(connectionIntent, nodeId));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ReconnectionHandler.isExecutionException",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ReconnectionHandler.isExecutionException", "io.lettuce.core.protocol.ReconnectionHandler.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @param throwable\n * @return {@code true} if {@code throwable} is an execution {@link Exception}.\n */\npublic static boolean isExecutionException(Throwable throwable) {\n    for (Class<?> type : EXECUTION_EXCEPTION_TYPES) {\n        if (type.isAssignableFrom(throwable.getClass())) {\n            return true;\n        }\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan() {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n    return clusterScan(getStatefulConnection(), getConnectionProvider(), cursor, scanFunction, ((ClusterScanSupport.ScanCursorMapper) (resultMapper)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplica.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplica.connectAsync", "io.lettuce.core.masterreplica.MasterReplica.connectAsyncSentinelOrAutodiscovery", "io.lettuce.core.masterreplica.SentinelConnector.<clinit>" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis Master-Replica server/servers using the supplied {@link RedisURI} and the\n * supplied {@link RedisCodec codec} to encode/decode keys.\n * <p>\n * This {@link MasterReplica} performs auto-discovery of nodes using either Redis Sentinel or Master/Replica. A\n * {@link RedisURI} can point to either a master or a replica host.\n * </p>\n *\n * @param redisClient\n * \t\tthe Redis client.\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}.\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return {@link CompletableFuture} that is notified once the connect is finished.\n * @since 6.0\n */\npublic static <K, V> CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsync(RedisClient redisClient, RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private static <K, V> CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsyncSentinelOrAutodiscovery(RedisClient redisClient, RedisCodec<K, V> codec, RedisURI redisURI) {\n    LettuceAssert.notNull(redisClient, \"RedisClient must not be null\");\n    LettuceAssert.notNull(codec, \"RedisCodec must not be null\");\n    LettuceAssert.notNull(redisURI, \"RedisURI must not be null\");\n    if (isSentinel(redisURI)) {\n        return new SentinelConnector<>(redisClient, codec, redisURI).connectAsync();\n    }\n    return new AutodiscoveryConnector<>(redisClient, codec, redisURI).connectAsync();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionIntent", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictadd(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Determine READ vs WRITE intent for routing by probing command read-only status.\n */\nprivate ConnectionIntent getConnectionIntent(ProtocolKeyword commandType) {\n    try {\n        RedisCommand probe = new Command(commandType, null);\n        boolean isReadOnly = getStatefulConnection().getOptions().getReadOnlyCommands().isReadOnly(probe);\n        return isReadOnly ? ConnectionIntent.READ : ConnectionIntent.WRITE;\n    } catch (Exception e) {\n        logger.error(\"Error while determining connection intent for \" + commandType, e);\n        return ConnectionIntent.WRITE;\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptFlush() {\n    Map<String, Publisher<String>> publishers = executeOnNodes(RedisScriptingReactiveCommands::scriptFlush, ALL_NODES);\n    return Flux.merge(publishers.values()).last();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLoggerFactory.getInstance",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(ClientResources clientResources, RedisURI redisURI) {\n    assertNotNull(clientResources);\n    assertNotNull(redisURI);\n    return create(clientResources, Collections.singleton(redisURI));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.close",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.Many.tryEmitComplete",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.close" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.currentContext",
    "thirdPartyMethod" : "reactor.core.CoreSubscriber.currentContext",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.currentContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.ImmediateSubscriber.currentContext",
    "thirdPartyMethod" : "reactor.core.CoreSubscriber.currentContext",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.ImmediateSubscriber.currentContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "reactor.core.CoreSubscriber.currentContext",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.RedisPooledObjectFactory.wrap",
    "thirdPartyMethod" : "org.apache.commons.pool2.impl.DefaultPooledObject.<init>",
    "thirdPartyPackage" : "org.apache.commons.pool2.impl",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.RedisPooledObjectFactory.wrap" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3MaybeAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Flowable.singleElement",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3MaybeAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.complete",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.complete", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnComplete", "io.lettuce.core.RedisPublisher.RedisSubscription.onAllDataRead" ],
    "methodSlices" : [ "@Override\npublic void complete() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.complete();\n        doOnComplete();\n        notifyConsumers(consumers);\n    }\n}", "@Override\n@SuppressWarnings({ \"unchecked\", \"CastCanBeRemovedNarrowingVariableType\" })\nprotected void doOnComplete() {\n    if (getOutput() != null) {\n        Object result = getOutput().get();\n        if (getOutput().hasError()) {\n            onError(ExceptionFactory.createExecutionException(getOutput().getError()));\n            return;\n        }\n        if ((!(getOutput() instanceof StreamingOutput<?>)) && (result != null)) {\n            if (dissolve && (result instanceof Collection)) {\n                Collection<T> collection = ((Collection<T>) (result));\n                for (T t : collection) {\n                    if (t != null) {\n                        subscription.onNext(t);\n                    }\n                }\n            } else {\n                subscription.onNext(((T) (result)));\n            }\n        }\n    }\n    subscription.onAllDataRead();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.request",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.request", "io.lettuce.core.RedisPublisher.State.request", "io.lettuce.core.RedisPublisher.RedisSubscription.checkOnDataAvailable", "io.lettuce.core.RedisPublisher.RedisSubscription.onDataAvailable" ],
    "methodSlices" : [ "/**\n * Signal for data demand.\n *\n * @param n\n * \t\tnumber of requested elements.\n */\n@Override\npublic final void request(long n) {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} request: {}\", state, n);\n    }\n    state.request(this, n);\n}", "", "void checkOnDataAvailable() {\n    if (data.isEmpty()) {\n        potentiallyReadMore();\n    }\n    if (!data.isEmpty()) {\n        onDataAvailable();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.cancel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.cancel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.RedisPublisher.RedisSubscription.onDataAvailable" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2CompletableToPublisherAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Completable.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2CompletableToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.concurrent.DefaultPromise.<init>",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.DefaultPromise.<init>",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.DefaultPromise.<init>",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava1ObservableAdapter.apply",
    "thirdPartyMethod" : "rx.RxReactiveStreams.toObservable",
    "thirdPartyPackage" : "rx",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava1ObservableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3CompletableToPublisherAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Completable.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3CompletableToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectPubSubToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), key.nodeId, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), (key.host + \":\") + key.port, getSocketAddressSupplier(key));\n}", "/**\n * Create a pub/sub connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubToNodeAsync(RedisCodec<K, V> codec, String nodeId, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectToNodeAsync(redisCodec, key.nodeId, null, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectToNodeAsync(redisCodec, (key.host + \":\") + key.port, clusterWriter, getSocketAddressSupplier(key));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server that treats keys and values as UTF-8 strings.\n *\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub() {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNodeAsync(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic <K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNode(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnError",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToPublisherAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Observable.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToFluxAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Observable.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToMonoAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Observable.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.ManySpec.replay",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create", "io.lettuce.authx.TokenBasedRedisCredentialsProvider.<init>" ],
    "methodSlices" : [ "public static TokenBasedRedisCredentialsProvider create(TokenManager tokenManager) {\n    TokenBasedRedisCredentialsProvider credentialManager = new TokenBasedRedisCredentialsProvider(tokenManager);\n    credentialManager.init();\n    return credentialManager;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.borrowObject",
    "thirdPartyMethod" : "org.apache.commons.pool2.impl.GenericObjectPool.borrowObject",
    "thirdPartyPackage" : "org.apache.commons.pool2.impl",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.borrowObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.MicrometerOptions.builder",
    "thirdPartyMethod" : "io.micrometer.core.instrument.Tags.empty",
    "thirdPartyPackage" : "io.micrometer.core.instrument",
    "path" : [ "io.lettuce.core.metrics.MicrometerOptions.builder", "io.lettuce.core.metrics.MicrometerOptions.Builder.<init>", "io.lettuce.core.metrics.MicrometerOptions.Builder.<init>" ],
    "methodSlices" : [ "/**\n * Returns a new {@link MicrometerOptions.Builder} to construct {@link MicrometerOptions}.\n *\n * @return a new {@link MicrometerOptions.Builder} to construct {@link MicrometerOptions}.\n */\npublic static MicrometerOptions.Builder builder() {\n}", "private Builder() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToFluxAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Single.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToMonoAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Single.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToPublisherAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Single.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore",
    "thirdPartyMethod" : "io.netty.channel.ChannelConfig.isAutoRead",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.channel.kqueue.KQueueIoHandler.newFactory",
    "thirdPartyPackage" : "io.netty.channel.kqueue",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.Tracing.withTraceContextProvider",
    "thirdPartyMethod" : "reactor.util.context.Context.of",
    "thirdPartyPackage" : "reactor.util.context",
    "path" : [ "io.lettuce.core.tracing.Tracing.withTraceContextProvider" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.event.DefaultEventBus.publish",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.Many.tryEmitNext",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.core.event.DefaultEventBus.publish" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.onTokenRenewed",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.Many.tryEmitNext",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.onTokenRenewed" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToFluxAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Single.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToPublisherAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Single.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToMonoAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Single.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.output.NumberListOutput.setBigNumber",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.NumberListOutput.setBigNumber", "io.lettuce.core.output.NumberListOutput.parseNumber" ],
    "methodSlices" : [ "@Override\npublic void setBigNumber(ByteBuffer bytes) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.run",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.run", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.doRun" ],
    "methodSlices" : [ "public void run() {\n    if (compareAndSet(false, true)) {\n        doRun();\n        return;\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"ClusterTopologyRefreshTask already in progress\");\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.loadViews",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.loadViews", "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.openConnections" ],
    "methodSlices" : [ "/**\n * Load partition views from a collection of {@link RedisURI}s and return the view per {@link RedisURI}. Partitions contain\n * an ordered list of {@link RedisClusterNode}s. The sort key is latency. Nodes with lower latency come first.\n *\n * @param seed\n * \t\tcollection of {@link RedisURI}s\n * @param connectTimeout\n * \t\tconnect timeout\n * @param discovery\n * \t\t{@code true} to discover additional nodes\n * @return mapping between {@link RedisURI} and {@link Partitions}\n */\n@Override\npublic CompletionStage<Map<RedisURI, Partitions>> loadViews(Iterable<RedisURI> seed, Duration connectTimeout, boolean discovery) {\n    if (!isEventLoopActive()) {\n    return CompletableFuture.completedFuture(Collections.emptyMap());\n}\n    long commandTimeoutNs = getCommandTimeoutNs(seed)\n    ConnectionTracker tracker = new ConnectionTracker()\n    long connectionTimeout = commandTimeoutNs + connectTimeout.toNanos()\n    openConnections(tracker, seed, connectionTimeout, TimeUnit.NANOSECONDS)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.NumberListOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.NumberListOutput.set", "io.lettuce.core.output.NumberListOutput.parseNumber" ],
    "methodSlices" : [ "@Override\npublic void set(ByteBuffer bytes) {\n    output.add(bytes != null ? parseNumber(bytes) : null);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.VectorMetadataParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.VectorMetadataParser.parse", "io.lettuce.core.output.VectorMetadataParser.verifyStructure" ],
    "methodSlices" : [ "/**\n * Parse the output of the Redis VINFO command and convert it to a {@link VectorMetadata} object.\n * <p>\n * The VINFO command returns an array of key-value pairs, where each pair consists of a field name followed by its value.\n * This method extracts the relevant fields and populates a {@link VectorMetadata} object with the corresponding values.\n *\n * @param dynamicData\n * \t\toutput of VINFO command\n * @return a {@link VectorMetadata} instance containing the parsed information\n * @throws IllegalArgumentException\n * \t\tif the input data is null, empty, or has an invalid format\n */\n@Override\npublic VectorMetadata parse(ComplexData dynamicData) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.AggregateReplyParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.AggregateReplyParser.parse" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SearchReplyParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SearchReplyParser.parse" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.readerIndex",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue", "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.doWithCipher" ],
    "methodSlices" : [ "@Override\npublic void encodeValue(Object value, ByteBuf target) {\n    ByteBuf serialized;\n    if (delegate instanceof ToByteBufEncoder) {\n        serialized = target.alloc().buffer(estimateSize(value));\n        ((ToByteBufEncoder) (delegate)).encodeKey(value, serialized);\n    } else {\n        ByteBuffer byteBuffer = delegate.encodeValue(value);\n        serialized = target.alloc().buffer(byteBuffer.remaining());\n        serialized.writeBytes(byteBuffer);\n    }\n    try {\n        KeyDescriptor keyDescriptor = this.encrypt.encryptionKey();\n        Cipher cipher = this.encrypt.get(keyDescriptor);\n        keyDescriptor.writeTo(target);\n        doWithCipher(cipher, serialized, target);\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(e);\n    } finally {\n        serialized.release();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisAuthenticationHandler.unsubscribe",
    "thirdPartyMethod" : "reactor.core.Disposable.isDisposed",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisAuthenticationHandler.unsubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisAuthenticationHandler.subscribe",
    "thirdPartyMethod" : "reactor.core.Disposable.isDisposed",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisAuthenticationHandler.subscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.onErrorReturn",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.eventLoopGroupClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onAskRedirection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onAskRedirection", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal" ],
    "methodSlices" : [ "@Override\npublic void onAskRedirection() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.socketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> socketChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueSocketChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.EpollProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.EpollProvider.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if epoll is available.\n */\npublic static boolean isAvailable() {\n    return EpollProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.run",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.run" ],
    "methodSlices" : [ "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter\n * @throws Exception\n * \t\twhen reconnection fails.\n */\npublic void run(int attempt) throws Exception {\n    run(attempt, Duration.ZERO)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.event.jfr.EventRecorder.getInstance",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.event.jfr.EventRecorder.getInstance", "io.lettuce.core.event.jfr.EventRecorderHolder.<clinit>" ],
    "methodSlices" : [ "/**\n * Obtain an instance of the {@link EventRecorder}.\n *\n * @return an instance of the {@link EventRecorder}.\n */\nstatic EventRecorder getInstance() {\n    return EventRecorderHolder.EVENT_RECORDER;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.getOrCreate", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doCreateEventLoopGroup", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T extends EventLoopGroup> T allocate(Class<T> type) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends EventLoopGroup> T getOrCreate(Class<T> type) {\n}", "/**\n * Customization hook for {@link EventLoopGroup} creation.\n *\n * @param <T>\n * @param type\n * \t\trequested event loop group type.\n * @param numberOfThreads\n * \t\tnumber of threads to create.\n * @param threadFactoryProvider\n * \t\tprovider for {@link ThreadFactory}.\n * @return  * @since 6.0\n */\nprotected <T extends EventLoopGroup> EventExecutorGroup doCreateEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider threadFactoryProvider) {\n}", "/**\n * Create an instance of a {@link EventExecutorGroup}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n * @since 5.3\n */\nstatic <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider factoryProvider) {\n    logger.debug(\"Creating executor {}\", type.getName());\n    if (DefaultEventExecutorGroup.class.equals(type)) {\n        return new DefaultEventExecutorGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-eventExecutorLoop\"));\n    }\n    if (NioEventLoopGroup.class.equals(type)) {\n        return new NioEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-nioEventLoop\"));\n    }\n    if (EpollProvider.isAvailable()) {\n        EventLoopResources resources = EpollProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-epollEventLoop\"));\n        }\n    }\n    if (KqueueProvider.isAvailable()) {\n        EventLoopResources resources = KqueueProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-kqueueEventLoop\"));\n        }\n    }\n    if (IOUringProvider.isAvailable()) {\n        EventLoopResources resources = IOUringProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-io_uringEventLoop\"));\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"Type %s not supported\", type.getName()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Initialize the {@link Bootstrap}.\n *\n * @since 6.1\n */\npublic void configureBootstrap(boolean domainSocket, Function<Class<? extends EventLoopGroup>, EventLoopGroup> eventLoopGroupProvider) {\n    LettuceAssert.assertState(bootstrap != null, \"Bootstrap must be set\");\n    LettuceAssert.assertState(clientOptions != null, \"ClientOptions must be set\");\n    Class<? extends EventLoopGroup> eventLoopGroupClass = Transports.eventLoopGroupClass();\n    Class<? extends Channel> channelClass = Transports.socketChannelClass();\n    if (domainSocket) {\n        Transports.NativeTransports.assertDomainSocketAvailable();\n        eventLoopGroupClass = Transports.NativeTransports.eventLoopGroupClass(true);\n        channelClass = Transports.NativeTransports.domainSocketChannelClass();\n    } else {\n        bootstrap.resolver(clientResources.addressResolverGroup());\n    }\n    SocketOptions options = clientOptions.getSocketOptions();\n    EventLoopGroup eventLoopGroup = eventLoopGroupProvider.apply(eventLoopGroupClass);\n    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.toIntExact(options.getConnectTimeout().toMillis()));\n    if (!domainSocket) {\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, options.isKeepAlive());\n        bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());\n        if (options.isEnableTcpUserTimeout()) {\n            SocketOptions.TcpUserTimeoutOptions tcpUserTimeoutOptions = options.getTcpUserTimeout();\n            boolean applied = false;\n            if (IOUringProvider.isAvailable()) {\n                IOUringProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            } else if (EpollProvider.isAvailable()) {\n                EpollProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            }\n            LettuceAssert.assertState(applied, \"TCP User Timeout options could not be applied. Native transports (io_uring or epoll) are required.\");\n        }\n    }\n    bootstrap.channel(channelClass).group(eventLoopGroup);\n    if (options.isKeepAlive() && options.isExtendedKeepAlive()) {\n        SocketOptions.KeepAliveOptions keepAlive = options.getKeepAlive();\n        boolean applied = false;\n        if (IOUringProvider.isAvailable()) {\n            IOUringProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (EpollProvider.isAvailable()) {\n            EpollProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (ExtendedNioSocketOptions.isAvailable() && (!KqueueProvider.isAvailable())) {\n            ExtendedNioSocketOptions.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        }\n        LettuceAssert.assertState(applied, \"Extended TCP keepalive options could not be applied. Native transports (io_uring or epoll) or a compatible NIO transport are required.\");\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.isDomainSocketSupported",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.isDomainSocketSupported", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if a native transport for domain sockets is available.\n */\npublic static boolean isDomainSocketSupported() {\n    return EpollProvider.isAvailable() || KqueueProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.socketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> socketChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.KqueueProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.KqueueProvider.isAvailable", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if kqueue is available.\n */\npublic static boolean isAvailable() {\n    return KqueueProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.eventLoopGroupClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    checkForKqueueLibrary();\n    // Return the new recommended class, but keep backward compatibility\n    return MultiThreadIoEventLoopGroup.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.closeAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.closeAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n    checkForKqueueLibrary();\n    // Use the new Netty 4.2 approach with IoHandlerFactory\n    return new MultiThreadIoEventLoopGroup(nThreads, threadFactory, KQueueIoHandler.newFactory());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.isAvailable", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if io_uring is available.\n */\npublic static boolean isAvailable() {\n    return IOURING_AVAILABLE && IOURING_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnectionAsync", "io.lettuce.core.cluster.PooledClusterConnectionProvider.beforeGetConnection" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisConnection<K, V>> getConnectionAsync(ConnectionIntent connectionIntent, String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnection", "io.lettuce.core.cluster.PooledClusterConnectionProvider.beforeGetConnection" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onReconnectAttempt",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onReconnectAttempt", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal" ],
    "methodSlices" : [ "@Override\npublic void onReconnectAttempt(int attempt) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport {@link EventLoopGroup} class. Defaults to TCP sockets. See\n{@link #eventLoopGroupClass(boolean)} to request a specific EventLoopGroup for Domain Socket usage.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    return eventLoopGroupClass(false);\n}", "/**\n *\n * @return the native transport {@link EventLoopGroup} class.\n * @param domainSocket\n * \t\t{@code true} to indicate Unix Domain Socket usage, {@code false} otherwise.\n * @since 6.3.3\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass(boolean domainSocket) {\n    return (domainSocket && EpollProvider.isAvailable()) && IOUringProvider.isAvailable() ? EpollProvider.getResources().eventLoopGroupClass() : RESOURCES.eventLoopGroupClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.run",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.run" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.matches",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.matches", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic boolean matches(Class<? extends EventExecutorGroup> type) {\n    checkForKqueueLibrary();\n    return false;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.datagramChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link DatagramChannel} for socket (network/UDP) transport.\n */\npublic static Class<? extends DatagramChannel> datagramChannelClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUnknownNode",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUnknownNode", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal" ],
    "methodSlices" : [ "@Override\npublic void onUnknownNode() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodes",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.close",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.close" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.datagramChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends DatagramChannel> datagramChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueDatagramChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnection" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.run",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.run" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.assertDomainSocketAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.assertDomainSocketAvailable", "io.lettuce.core.resource.Transports.NativeTransports.isDomainSocketSupported", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "public static void assertDomainSocketAvailable() {\n    LettuceAssert.assertState(NativeTransports.isDomainSocketSupported(), \"A unix domain socket connection requires epoll or kqueue and neither is available\");\n}", "/**\n *\n * @return {@code true} if a native transport for domain sockets is available.\n */\npublic static boolean isDomainSocketSupported() {\n    return EpollProvider.isAvailable() || KqueueProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connect", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterConnection<K, V> connect(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newEventLoopGroup", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getRandomConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getRandomConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.socketChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link Channel} for socket (network/TCP) transport.\n */\npublic static Class<? extends Channel> socketChannelClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.EpollProvider.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if epoll is available.\n */\npublic static boolean isAvailable() {\n    return EPOLL_AVAILABLE && EPOLL_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.EpollProvider.getResources", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for epoll-backed transport. Check availability with {@link #isAvailable()} prior\n * to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n * @since 6.0\n */\npublic static EventLoopResources getResources() {\n    return EPOLL_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport {@link EventLoopGroup} class.\n * @param domainSocket\n * \t\t{@code true} to indicate Unix Domain Socket usage, {@code false} otherwise.\n * @since 6.3.3\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass(boolean domainSocket) {\n    return (domainSocket && EpollProvider.isAvailable()) && IOUringProvider.isAvailable() ? EpollProvider.getResources().eventLoopGroupClass() : RESOURCES.eventLoopGroupClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectPubSubToNodeAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), key.nodeId, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), (key.host + \":\") + key.port, getSocketAddressSupplier(key));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.domainSocketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> domainSocketChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueDomainSocketChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.isAvailable", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if kqueue is available.\n */\npublic static boolean isAvailable() {\n    return KQUEUE_AVAILABLE && KQUEUE_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to\n * encode/decode keys and values. Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()}\n * first, otherwise the connect will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.datagramChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends DatagramChannel> datagramChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SocketAddress newSocketAddress(String socketPath) {\n    checkForKqueueLibrary();\n    return new DomainSocketAddress(socketPath);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.getResources", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for io_uring-backed transport. Check availability with {@link #isAvailable()}\n * prior to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n */\npublic static EventLoopResources getResources() {\n    return IOURING_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link EventLoopGroup} for socket transport that is compatible with {@link #socketChannelClass()}.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.getResources", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for kqueue-backed transport. Check availability with {@link #isAvailable()} prior\n * to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n * @since 6.0\n */\npublic static EventLoopResources getResources() {\n    return KQUEUE_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSub", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to encode/decode keys and\n * values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Create an instance of a {@link EventExecutorGroup} using the default {@link ThreadFactoryProvider}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n */\npublic static <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads) {\n}", "/**\n * Create an instance of a {@link EventExecutorGroup}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n * @since 5.3\n */\nstatic <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider factoryProvider) {\n    logger.debug(\"Creating executor {}\", type.getName());\n    if (DefaultEventExecutorGroup.class.equals(type)) {\n        return new DefaultEventExecutorGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-eventExecutorLoop\"));\n    }\n    if (NioEventLoopGroup.class.equals(type)) {\n        return new NioEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-nioEventLoop\"));\n    }\n    if (EpollProvider.isAvailable()) {\n        EventLoopResources resources = EpollProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-epollEventLoop\"));\n        }\n    }\n    if (KqueueProvider.isAvailable()) {\n        EventLoopResources resources = KqueueProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-kqueueEventLoop\"));\n        }\n    }\n    if (IOUringProvider.isAvailable()) {\n        EventLoopResources resources = IOUringProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-io_uringEventLoop\"));\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"Type %s not supported\", type.getName()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()} first, otherwise the connect\n * will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.domainSocketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> domainSocketChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.Builder.build",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.Builder.build", "io.lettuce.core.resource.DefaultClientResources.<init>" ],
    "methodSlices" : [ "/**\n *\n * @return a new instance of {@link DefaultClientResources}.\n */\n@Override\npublic DefaultClientResources build() {\n    DefaultClientResources resources = new DefaultClientResources(this);\n    if (this.afterBuild != null) {\n        this.afterBuild.run();\n    }\n    return resources;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onMovedRedirection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onMovedRedirection", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal" ],
    "methodSlices" : [ "@Override\npublic void onMovedRedirection() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.SocketAddressResolver.resolve",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.SocketAddressResolver.resolve", "io.lettuce.core.resource.SocketAddressResolver.getDomainSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Resolves a {@link io.lettuce.core.RedisURI} to a {@link java.net.SocketAddress}.\n *\n * @param redisURI\n * \t\tmust not be {@code null}.\n * @param dnsResolver\n * \t\tmust not be {@code null}.\n * @return the resolved {@link SocketAddress}.\n */\npublic static SocketAddress resolve(RedisURI redisURI, DnsResolver dnsResolver) {\n}", "static SocketAddress getDomainSocketAddress(RedisURI redisURI) {\n    if (KqueueProvider.isAvailable() || EpollProvider.isAvailable()) {\n        EventLoopResources resources = (KqueueProvider.isAvailable()) ? KqueueProvider.getResources() : EpollProvider.getResources();\n        return resources.newSocketAddress(redisURI.getSocket());\n    }\n    throw new IllegalStateException(\"No native transport available. Make sure that either netty's epoll or kqueue library is on the class path and supported by your operating system.\");\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUncoveredSlot",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.onUncoveredSlot", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.indicateTopologyRefreshSignal" ],
    "methodSlices" : [ "@Override\npublic void onUncoveredSlot(int slot) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SocketAddress newSocketAddress(String socketPath) {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnection",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.getConnection" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.debug",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.domainSocketChannelClass", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport domain socket {@link Channel} class.\n */\npublic static Class<? extends Channel> domainSocketChannelClass() {\n    assertDomainSocketAvailable();\n    return EpollProvider.isAvailable() && IOUringProvider.isAvailable() ? EpollProvider.getResources().domainSocketChannelClass() : RESOURCES.domainSocketChannelClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.nioBuffer",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue", "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.doWithCipher" ],
    "methodSlices" : [ "@Override\npublic void encodeValue(Object value, ByteBuf target) {\n    ByteBuf serialized;\n    if (delegate instanceof ToByteBufEncoder) {\n        serialized = target.alloc().buffer(estimateSize(value));\n        ((ToByteBufEncoder) (delegate)).encodeKey(value, serialized);\n    } else {\n        ByteBuffer byteBuffer = delegate.encodeValue(value);\n        serialized = target.alloc().buffer(byteBuffer.remaining());\n        serialized.writeBytes(byteBuffer);\n    }\n    try {\n        KeyDescriptor keyDescriptor = this.encrypt.encryptionKey();\n        Cipher cipher = this.encrypt.get(keyDescriptor);\n        keyDescriptor.writeTo(target);\n        doWithCipher(cipher, serialized, target);\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(e);\n    } finally {\n        serialized.release();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toSet.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.exceptionCaught",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisHandshakeHandler.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.exceptionCaught",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.RedisHandshakeHandler.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.cancel",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onError",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.cancel", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnError", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError", "io.lettuce.core.RedisPublisher.State.onError" ],
    "methodSlices" : [ "@Override\npublic void cancel() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.cancel();\n        CancellationException exception = new CancellationException();\n        doOnError(exception);\n        notifyBiConsumer(consumers, exception);\n    }\n}", "@Override\nprotected void doOnError(Throwable throwable) {\n    onError(throwable);\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}", "/**\n * Called by a listener interface to indicate that as error has occurred.\n *\n * @param t\n * \t\tthe error\n */\nfinal void onError(Throwable t) {\n    State state = state();\n    if (LOG.isErrorEnabled()) {\n        LOG.trace(\"{} onError(): {}\", state, t.toString(), t);\n    }\n    state.onError(this, t);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.OnComplete.run",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onError",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.OnComplete.run" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.complete",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onError",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.complete", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnComplete", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError", "io.lettuce.core.RedisPublisher.State.onError" ],
    "methodSlices" : [ "@Override\npublic void complete() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.complete();\n        doOnComplete();\n        notifyConsumers(consumers);\n    }\n}", "@Override\n@SuppressWarnings({ \"unchecked\", \"CastCanBeRemovedNarrowingVariableType\" })\nprotected void doOnComplete() {\n    if (getOutput() != null) {\n        Object result = getOutput().get();\n        if (getOutput().hasError()) {\n            onError(ExceptionFactory.createExecutionException(getOutput().getError()));\n            return;\n        }\n        if ((!(getOutput() instanceof StreamingOutput<?>)) && (result != null)) {\n            if (dissolve && (result instanceof Collection)) {\n                Collection<T> collection = ((Collection<T>) (result));\n                for (T t : collection) {\n                    if (t != null) {\n                        subscription.onNext(t);\n                    }\n                }\n            } else {\n                subscription.onNext(((T) (result)));\n            }\n        }\n    }\n    subscription.onAllDataRead();\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}", "/**\n * Called by a listener interface to indicate that as error has occurred.\n *\n * @param t\n * \t\tthe error\n */\nfinal void onError(Throwable t) {\n    State state = state();\n    if (LOG.isErrorEnabled()) {\n        LOG.trace(\"{} onError(): {}\", state, t.toString(), t);\n    }\n    state.onError(this, t);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.request",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onError",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.request", "io.lettuce.core.RedisPublisher.State.request", "io.lettuce.core.RedisPublisher.State.onError" ],
    "methodSlices" : [ "/**\n * Signal for data demand.\n *\n * @param n\n * \t\tnumber of requested elements.\n */\n@Override\npublic final void request(long n) {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} request: {}\", state, n);\n    }\n    state.request(this, n);\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.completeExceptionally",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onError",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.completeExceptionally", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnError", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError", "io.lettuce.core.RedisPublisher.State.onError" ],
    "methodSlices" : [ "@Override\npublic boolean completeExceptionally(Throwable throwable) {\n    Object[] consumers = ONCOMPLETE.get(this);\n    boolean result = false;\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        result = command.completeExceptionally(throwable);\n        doOnError(throwable);\n        notifyBiConsumer(consumers, throwable);\n    }\n    return result;\n}", "@Override\nprotected void doOnError(Throwable throwable) {\n    onError(throwable);\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}", "/**\n * Called by a listener interface to indicate that as error has occurred.\n *\n * @param t\n * \t\tthe error\n */\nfinal void onError(Throwable t) {\n    State state = state();\n    if (LOG.isErrorEnabled()) {\n        LOG.trace(\"{} onError(): {}\", state, t.toString(), t);\n    }\n    state.onError(this, t);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onError",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.RedisPublisher.RedisSubscription.onError", "io.lettuce.core.RedisPublisher.State.onError" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}", "/**\n * Called by a listener interface to indicate that as error has occurred.\n *\n * @param t\n * \t\tthe error\n */\nfinal void onError(Throwable t) {\n    State state = state();\n    if (LOG.isErrorEnabled()) {\n        LOG.trace(\"{} onError(): {}\", state, t.toString(), t);\n    }\n    state.onError(this, t);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisHandshakeHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.channelRegistered",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.RedisHandshakeHandler.channelRegistered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.DefaultLettuceObservationConvention.getHighCardinalityKeyValues",
    "thirdPartyMethod" : "io.micrometer.common.KeyValues.of",
    "thirdPartyPackage" : "io.micrometer.common",
    "path" : [ "io.lettuce.core.tracing.DefaultLettuceObservationConvention.getHighCardinalityKeyValues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.DefaultLettuceObservationConvention.getLowCardinalityKeyValues",
    "thirdPartyMethod" : "io.micrometer.common.KeyValues.of",
    "thirdPartyPackage" : "io.micrometer.common",
    "path" : [ "io.lettuce.core.tracing.DefaultLettuceObservationConvention.getLowCardinalityKeyValues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint",
    "thirdPartyMethod" : "zipkin2.Endpoint.ipv6",
    "thirdPartyPackage" : "zipkin2",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.MicrometerTracing.MicrometerTraceContextProvider.getTraceContext",
    "thirdPartyMethod" : "io.micrometer.observation.ObservationRegistry.getCurrentObservation",
    "thirdPartyPackage" : "io.micrometer.observation",
    "path" : [ "io.lettuce.core.tracing.MicrometerTracing.MicrometerTraceContextProvider.getTraceContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "redis.clients.authentication.core.IdentityProviderConfig.getProvider",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlin.collections.ArraysKt.asSequence",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.MulticastReplaySpec.latest",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create", "io.lettuce.authx.TokenBasedRedisCredentialsProvider.<init>" ],
    "methodSlices" : [ "public static TokenBasedRedisCredentialsProvider create(TokenManager tokenManager) {\n    TokenBasedRedisCredentialsProvider credentialManager = new TokenBasedRedisCredentialsProvider(tokenManager);\n    credentialManager.init();\n    return credentialManager;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object)\n */\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.closeAsync", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<Void> closeAsync() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void notifyChannelActive(Channel channel) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelActive", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelActive(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelUnregistered",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelUnregistered", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelUnregistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive", "io.lettuce.core.protocol.ConnectionWatchdog.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRegistered", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelRegistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelInactive", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelInactive(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.close",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.close", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n * Close the connection.\n */\n@Override\npublic void close() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.write", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelDuplexHandler#write(io.netty.channel.ChannelHandlerContext, java.lang.Object,\nio.netty.channel.ChannelPromise)\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n * Move queued and buffered commands from the inactive connection to the upstream command writer. This is done only if the\n * current connection is disconnected and auto-reconnect is enabled (command-retries). If the connection would be open, we\n * could get into a race that the commands we're moving are right now in processing. Alive connections can handle redirects\n * and retries on their own.\n */\n@Override\npublic CompletableFuture<Void> closeAsync() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyException",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyException", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic void notifyException(Throwable t) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive", "io.lettuce.core.protocol.ConnectionWatchdog.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete",
    "thirdPartyMethod" : "io.netty.channel.Channel.isActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint",
    "thirdPartyMethod" : "zipkin2.Endpoint.serviceName",
    "thirdPartyPackage" : "zipkin2",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftDictdump(String dict) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, SynUpdateArgs<K, V> args, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.findConnectionBySlotReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> clusterCountKeysInSlot(int slot) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> findConnectionBySlotReactive(int slot) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query, ExplainArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> keys(KeyStreamingChannel<K> channel, String pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaTopologyRefresh.getNodes",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaTopologyRefresh.getNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftTagvals(String index, String fieldName) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushall() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, boolean skipInitialScan, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.findConnectionBySlotReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Flux<K> clusterGetKeysInSlot(int slot, int count) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> findConnectionBySlotReactive(int slot) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "/**\n * Find all keys matching the given pattern (legacy overload).\n *\n * @param channel\n * \t\tthe channel.\n * @param pattern\n * \t\tthe pattern.\n * @return Long array-reply list of keys matching {@code pattern}.\n * @deprecated Use {@link #keys(String)} instead. This legacy overload will be removed in a later version.\n */\n@Deprecated\n@Override\npublic Mono<Long> keysLegacy(KeyStreamingChannel<K> channel, K pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptLoad(byte[] script) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptKill() {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<Void> shutdown(boolean save) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connect", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterConnection<K, V> connect(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.MicrometerTracing.MicrometerTraceContextProvider.getTraceContextLater",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.MicrometerTracing.MicrometerTraceContextProvider.getTraceContextLater" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushall(FlushMode flushMode) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.randomkey",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.randomkey", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<K> randomkey() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictdel(String dict, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushdb(FlushMode flushMode) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to\n * encode/decode keys and values. Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()}\n * first, otherwise the connect will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasupdate(String alias, String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Map<V, List<V>>> ftSyndump(String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.Tracing.getContext",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.Tracing.getContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushallAsync() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSub", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to encode/decode keys and\n * values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Flux<K> keys(String pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "/**\n * Find all keys matching the given pattern (legacy overload).\n *\n * @param pattern\n * \t\tthe pattern type: patternkey (pattern).\n * @return K array-reply list of keys matching {@code pattern}.\n * @deprecated Use {@link #keys(String)} instead. This legacy overload will be removed in a later version.\n */\n@Deprecated\n@Override\npublic Flux<K> keysLegacy(K pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContextLater",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContextLater" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index, boolean deleteDocumentKeys) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftList() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursorread",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursorread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()} first, otherwise the connect\n * will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasadd(String alias, String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasdel(String alias) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushdb() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> dbsize() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, CreateArgs<K, V> arguments, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictadd(String dict, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptFlush() {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelUnregistered",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.clear",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelUnregistered", "io.lettuce.core.protocol.CommandHandler.reset", "io.lettuce.core.protocol.CommandHandler.resetInternals" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelUnregistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n    if (debugEnabled) {\n    logger.debug(\"{} channelUnregistered()\", logPrefix());\n}\n    if ((channel != null) && (ctx.channel() != channel)) {\n    logger.debug(\"{} My channel and ctx.channel mismatch. Propagating event to other listeners\", logPrefix());\n    ctx.fireChannelUnregistered();\n    return;\n}\n    channel = null\n    if (readBuffer != null) {\n    readBuffer.release();\n}\n    if (rsm != null) {\n    rsm.close();\n}\n    reset()\n}", "private void reset() {\n    resetInternals()\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.StringCodec.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.clear",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.StringCodec.encodeValue", "io.lettuce.core.codec.StringCodec.encodeAndAllocateBuffer" ],
    "methodSlices" : [ "@Override\npublic ByteBuffer encodeValue(String value) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.StringCodec.encodeKey",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.clear",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.StringCodec.encodeKey", "io.lettuce.core.codec.StringCodec.encodeAndAllocateBuffer" ],
    "methodSlices" : [ "@Override\npublic ByteBuffer encodeKey(String key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.userEventTriggered",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.clear",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.userEventTriggered", "io.lettuce.core.protocol.CommandHandler.reset", "io.lettuce.core.protocol.CommandHandler.resetInternals" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#userEventTriggered(io.netty.channel.ChannelHandlerContext, Object)\n */\n@Override\npublic void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n}", "private void reset() {\n    resetInternals()\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.propagation.TraceContextOrSamplingFlags.create",
    "thirdPartyPackage" : "brave.propagation",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.credentials",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.onBackpressureLatest",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.credentials" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.SslOptions.Builder.jdkSslProvider",
    "thirdPartyMethod" : "io.netty.handler.ssl.OpenSsl.isAvailable",
    "thirdPartyPackage" : "io.netty.handler.ssl",
    "path" : [ "io.lettuce.core.SslOptions.Builder.jdkSslProvider", "io.lettuce.core.SslOptions.Builder.sslProvider" ],
    "methodSlices" : [ "/**\n * Use the JDK SSL provider for SSL connections.\n *\n * @return {@code this}\n */\npublic Builder jdkSslProvider() {\n    return sslProvider(SslProvider.JDK);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.SslOptions.Builder.openSslProvider",
    "thirdPartyMethod" : "io.netty.handler.ssl.OpenSsl.isAvailable",
    "thirdPartyPackage" : "io.netty.handler.ssl",
    "path" : [ "io.lettuce.core.SslOptions.Builder.openSslProvider", "io.lettuce.core.SslOptions.Builder.sslProvider" ],
    "methodSlices" : [ "/**\n * Use the OpenSSL provider for SSL connections. The OpenSSL provider requires the\n * <a href=\"https://netty.io/wiki/forked-tomcat-native.html\">{@code netty-tcnative}</a> dependency with the OpenSSL JNI\n * binary.\n *\n * @return {@code this}\n * @throws IllegalStateException\n * \t\tif OpenSSL is not available\n */\npublic Builder openSslProvider() {\n    return sslProvider(SslProvider.OPENSSL);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandEncoder.<init>",
    "thirdPartyMethod" : "io.netty.handler.codec.MessageToByteEncoder.<init>",
    "thirdPartyPackage" : "io.netty.handler.codec",
    "path" : [ "io.lettuce.core.protocol.CommandEncoder.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToSingleAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Observable.singleOrError",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToSingleAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplica.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplica.connectAsync", "io.lettuce.core.masterreplica.MasterReplica.connectAsyncSentinelOrStaticSetup" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis Master-Replica server/servers using the supplied {@link RedisURI} and the\n * supplied {@link RedisCodec codec} to encode/decode keys.\n * <p>\n * This {@link MasterReplica} performs auto-discovery of nodes if the URI is a Redis Sentinel URI. Master/Replica URIs will\n * be treated as static topology and no additional hosts are discovered in such case. Redis Standalone Master/Replica will\n * discover the roles of the supplied {@link RedisURI URIs} and issue commands to the appropriate node.\n * </p>\n * <p>\n * When using Redis Sentinel, ensure that {@link Iterable redisURIs} contains only a single entry as only the first URI is\n * considered. {@link RedisURI} pointing to multiple Sentinels can be configured through\n * {@link RedisURI.Builder#withSentinel}.\n * </p>\n *\n * @param redisClient\n * \t\tthe Redis client.\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}.\n * @param redisURIs\n * \t\tthe Redis server(s) to connect to, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return {@link CompletableFuture} that is notified once the connect is finished.\n * @since 6.0\n */\npublic static <K, V> CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsync(RedisClient redisClient, RedisCodec<K, V> codec, Iterable<RedisURI> redisURIs) {\n    return transformAsyncConnectionException(connectAsyncSentinelOrStaticSetup(redisClient, codec, redisURIs), redisURIs);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplica.connect",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplica.connect", "io.lettuce.core.masterreplica.MasterReplica.connectAsyncSentinelOrStaticSetup" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis Master-Replica server/servers using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n * <p>\n * This {@link MasterReplica} performs auto-discovery of nodes if the URI is a Redis Sentinel URI. Master/Replica URIs will\n * be treated as static topology and no additional hosts are discovered in such case. Redis Standalone Master/Replica will\n * discover the roles of the supplied {@link RedisURI URIs} and issue commands to the appropriate node.\n * </p>\n * <p>\n * When using Redis Sentinel, ensure that {@link Iterable redisURIs} contains only a single entry as only the first URI is\n * considered. {@link RedisURI} pointing to multiple Sentinels can be configured through\n * {@link RedisURI.Builder#withSentinel}.\n * </p>\n *\n * @param redisClient\n * \t\tthe Redis client.\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}.\n * @param redisURIs\n * \t\tthe Redis server(s) to connect to, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new connection.\n * @since 6.0\n */\npublic static <K, V> StatefulRedisMasterReplicaConnection<K, V> connect(RedisClient redisClient, RedisCodec<K, V> codec, Iterable<RedisURI> redisURIs) {\n    return getConnection(connectAsyncSentinelOrStaticSetup(redisClient, codec, redisURIs), redisURIs);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SuggestionParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SuggestionParser.parse" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.MovingEvent.from" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.applyKeepAlive",
    "thirdPartyMethod" : "io.netty.channel.socket.nio.NioChannelOption.of",
    "thirdPartyPackage" : "io.netty.channel.socket.nio",
    "path" : [ "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.applyKeepAlive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToSingleAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Observable.singleOrError",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToSingleAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "redis.clients.authentication.core.TokenAuthConfig.getIdentityProviderConfig",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.json.DefaultJsonParser.createJsonValue",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.node.NullNode.getInstance",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind.node",
    "path" : [ "io.lettuce.core.json.DefaultJsonParser.createJsonValue", "io.lettuce.core.json.DefaultJsonParser.parse" ],
    "methodSlices" : [ "@Override\npublic JsonValue createJsonValue(String value) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.json.DefaultJsonParser.createJsonValue",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.node.NullNode.getInstance",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind.node",
    "path" : [ "io.lettuce.core.json.DefaultJsonParser.createJsonValue", "io.lettuce.core.json.DefaultJsonParser.parse" ],
    "methodSlices" : [ "@Override\npublic JsonValue createJsonValue(String value) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore",
    "thirdPartyMethod" : "io.netty.channel.Channel.config",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.userEventTriggered",
    "thirdPartyMethod" : "io.netty.channel.Channel.config",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.userEventTriggered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain",
    "thirdPartyMethod" : "org.LatencyUtils.PauseDetector.shutdown",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.run",
    "thirdPartyMethod" : "org.LatencyUtils.PauseDetector.shutdown",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.run" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.NoOpPauseDetectorWrapper.getPauseDetector",
    "thirdPartyMethod" : "org.LatencyUtils.PauseDetector.shutdown",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.NoOpPauseDetectorWrapper.getPauseDetector", "io.lettuce.core.metrics.DefaultCommandLatencyCollector.NoPauseDetector.<clinit>", "io.lettuce.core.metrics.DefaultCommandLatencyCollector.NoPauseDetector.<init>" ],
    "methodSlices" : [ "@Override\npublic Object getPauseDetector() {\n    return NoPauseDetector.INSTANCE;\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.release",
    "thirdPartyMethod" : "org.LatencyUtils.PauseDetector.shutdown",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.release" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectPubSubToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), key.nodeId, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), (key.host + \":\") + key.port, getSocketAddressSupplier(key));\n}", "/**\n * Create a pub/sub connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubToNodeAsync(RedisCodec<K, V> codec, String nodeId, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectToNodeAsync(redisCodec, key.nodeId, null, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectToNodeAsync(redisCodec, (key.host + \":\") + key.port, clusterWriter, getSocketAddressSupplier(key));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server that treats keys and values as UTF-8 strings.\n *\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub() {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNodeAsync(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic <K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNode(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.run",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ReconnectionHandler.reconnect" ],
    "methodSlices" : [ "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter\n * @throws Exception\n * \t\twhen reconnection fails.\n */\npublic void run(int attempt) throws Exception {\n    run(attempt, Duration.ZERO)\n}", "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter.\n * @param delay\n * \t\tretry delay.\n * @throws Exception\n * \t\twhen reconnection fails.\n */\nprivate void run(int attempt, Duration delay) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.subscribe",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisStateMachine.Resp2LongProcessor.getValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.skipBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.RedisStateMachine.Resp2LongProcessor.getValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisHandshakeHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.RedisHandshakeHandler.channelRegistered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandExpiryWriter.write",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.CommandExpiryWriter.write", "io.lettuce.core.protocol.CommandExpiryWriter.potentiallyExpire" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n    potentiallyExpire(command, getExecutorService())\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.write",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.write", "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.potentiallyExpire" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n    potentiallyExpire(command, executorService)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.onFailoverCompleted",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.onFailoverCompleted", "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.disableRelaxedTimeoutDelayed" ],
    "methodSlices" : [ "@Override\npublic void onFailoverCompleted(String shards) {\n    disableRelaxedTimeoutDelayed(\"Failover completed: \" + shards, relaxedTimeout)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.write",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.write", "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.potentiallyExpire" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n    potentiallyExpire(command, executorService)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.onMigrateCompleted",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.onMigrateCompleted", "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.disableRelaxedTimeoutDelayed" ],
    "methodSlices" : [ "@Override\npublic void onMigrateCompleted(String shards) {\n    disableRelaxedTimeoutDelayed(\"Migration completed: \" + shards, relaxedTimeout)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.topology.Connections.requestInfo",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.cluster.topology.Connections.requestInfo", "io.lettuce.core.cluster.topology.Connections.doRequest" ],
    "methodSlices" : [ "/* Initiate {@code INFO} on all connections and return the {@link Requests}.\n@return the {@link Requests}.\n */\npublic Requests requestInfo(long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.topology.Connections.requestTopology",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.cluster.topology.Connections.requestTopology", "io.lettuce.core.cluster.topology.Connections.doRequest" ],
    "methodSlices" : [ "/* Initiate {@code CLUSTER NODES} on all connections and return the {@link Requests}.\n@return the {@link Requests}.\n */\npublic Requests requestTopology(long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.loadViews",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.loadViews", "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.openConnections" ],
    "methodSlices" : [ "/**\n * Load partition views from a collection of {@link RedisURI}s and return the view per {@link RedisURI}. Partitions contain\n * an ordered list of {@link RedisClusterNode}s. The sort key is latency. Nodes with lower latency come first.\n *\n * @param seed\n * \t\tcollection of {@link RedisURI}s\n * @param connectTimeout\n * \t\tconnect timeout\n * @param discovery\n * \t\t{@code true} to discover additional nodes\n * @return mapping between {@link RedisURI} and {@link Partitions}\n */\n@Override\npublic CompletionStage<Map<RedisURI, Partitions>> loadViews(Iterable<RedisURI> seed, Duration connectTimeout, boolean discovery) {\n    if (!isEventLoopActive()) {\n    return CompletableFuture.completedFuture(Collections.emptyMap());\n}\n    long commandTimeoutNs = getCommandTimeoutNs(seed)\n    ConnectionTracker tracker = new ConnectionTracker()\n    long connectionTimeout = commandTimeoutNs + connectTimeout.toNanos()\n    openConnections(tracker, seed, connectionTimeout, TimeUnit.NANOSECONDS)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandExpiryWriter.write",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.CommandExpiryWriter.write", "io.lettuce.core.protocol.CommandExpiryWriter.potentiallyExpire" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n    potentiallyExpire(command, getExecutorService())\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.onRebindCompleted",
    "thirdPartyMethod" : "io.netty.util.Timer.newTimeout",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.onRebindCompleted", "io.lettuce.core.protocol.MaintenanceAwareExpiryWriter.disableRelaxedTimeoutDelayed" ],
    "methodSlices" : [ "@Override\npublic void onRebindCompleted() {\n    disableRelaxedTimeoutDelayed(\"Re-bind completed\", relaxedTimeout)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.run",
    "thirdPartyMethod" : "reactor.util.function.Tuples.of",
    "thirdPartyPackage" : "reactor.util.function",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ConnectionWatchdog.run", "io.lettuce.core.protocol.ReconnectionHandler.reconnect" ],
    "methodSlices" : [ "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter\n * @throws Exception\n * \t\twhen reconnection fails.\n */\npublic void run(int attempt) throws Exception {\n    run(attempt, Duration.ZERO)\n}", "/**\n * Reconnect to the remote address that the closed channel was connected to. This creates a new {@link ChannelPipeline} with\n * the same handler instances contained in the old channel's pipeline.\n *\n * @param attempt\n * \t\tattempt counter.\n * @param delay\n * \t\tretry delay.\n * @throws Exception\n * \t\twhen reconnection fails.\n */\nprivate void run(int attempt, Duration delay) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.createEndpoint",
    "thirdPartyMethod" : "zipkin2.Endpoint.Builder.port",
    "thirdPartyPackage" : "zipkin2.Endpoint",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.createEndpoint" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.EpollResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.channel.epoll.EpollIoHandler.newFactory",
    "thirdPartyPackage" : "io.netty.channel.epoll",
    "path" : [ "io.lettuce.core.resource.EpollProvider.EpollResources.newEventLoopGroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.Span.isNoop",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan", "io.lettuce.core.tracing.BraveTracing.BraveTracer.postProcessSpan" ],
    "methodSlices" : [ "@Override\npublic Span nextSpan() {\n    return postProcessSpan(tracing.tracer().nextSpan());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.Span.isNoop",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan", "io.lettuce.core.tracing.BraveTracing.BraveTracer.postProcessSpan" ],
    "methodSlices" : [ "@Override\npublic Span nextSpan(TraceContext traceContext) {\n    if (!(traceContext instanceof BraveTraceContext)) {\n        return nextSpan();\n    }\n    BraveTraceContext braveTraceContext = BraveTracing.BraveTraceContext.class.cast(traceContext);\n    if (braveTraceContext.traceContext == null) {\n        return nextSpan();\n    }\n    return postProcessSpan(tracing.tracer().nextSpan(TraceContextOrSamplingFlags.create(braveTraceContext.traceContext)));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugRestart",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.Boxing.boxLong",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugRestart" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugCrashAndRecover",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.Boxing.boxLong",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugCrashAndRecover" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.NoOpPauseDetectorWrapper.getPauseDetector",
    "thirdPartyMethod" : "org.LatencyUtils.PauseDetector.<init>",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.NoOpPauseDetectorWrapper.getPauseDetector", "io.lettuce.core.metrics.DefaultCommandLatencyCollector.NoPauseDetector.<clinit>", "io.lettuce.core.metrics.DefaultCommandLatencyCollector.NoPauseDetector.<init>" ],
    "methodSlices" : [ "@Override\npublic Object getPauseDetector() {\n    return NoPauseDetector.INSTANCE;\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.OnNext.run",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onNext",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.OnNext.run" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()} first, otherwise the connect\n * will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaTopologyRefresh.getNodes",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaTopologyRefresh.getNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectPubSubToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), key.nodeId, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), (key.host + \":\") + key.port, getSocketAddressSupplier(key));\n}", "/**\n * Create a pub/sub connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubToNodeAsync(RedisCodec<K, V> codec, String nodeId, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectToNodeAsync(redisCodec, key.nodeId, null, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectToNodeAsync(redisCodec, (key.host + \":\") + key.port, clusterWriter, getSocketAddressSupplier(key));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server that treats keys and values as UTF-8 strings.\n *\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub() {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNodeAsync(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.initializeChannelAsync" ],
    "methodSlices" : [ "@Override\npublic <K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNode(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to\n * encode/decode keys and values. Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()}\n * first, otherwise the connect will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connect", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterConnection<K, V> connect(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSub", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to encode/decode keys and\n * values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.doOnNext",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.StaticCredentialsProvider.<init>",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.just",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.StaticCredentialsProvider.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisCredentialsProvider.ImmediateRedisCredentialsProvider.resolveCredentials",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.just",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisCredentialsProvider.ImmediateRedisCredentialsProvider.resolveCredentials" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ResumeAfter.thenEmit",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.just",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.ResumeAfter.thenEmit" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursorread",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.just",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursorread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.just",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.just",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursordel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.just",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursordel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "reactor.core.Exceptions.addSuppressed",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.Operators.onOperatorError" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeKey",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeKey" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.KeyArgument.encode", "io.lettuce.core.protocol.CommandArgs.ByteBufferArgument.writeByteBuffer" ],
    "methodSlices" : [ "/**\n * Encode the {@link CommandArgs} and write the arguments to the {@link ByteBuf}.\n *\n * @param buf\n * \t\tthe target buffer.\n */\npublic void encode(ByteBuf buf) {\n    buf.touch(\"CommandArgs.encode()\");\n    for (SingularArgument singularArgument : singularArguments) {\n        singularArgument.encode(buf);\n    }\n}", "@SuppressWarnings(\"unchecked\")\n@Override\nvoid encode(ByteBuf target) {\n    if (codec instanceof ToByteBufEncoder) {\n        CommandArgs.encode(target, ((ToByteBufEncoder<K, K>) (codec)), key, ToByteBufEncoder::encodeKey);\n        return;\n    }\n    ByteBufferArgument.writeByteBuffer(target, codec.encodeKey(key));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContextLater",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.deferContextual",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContextLater" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.Tracing.getContext",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.deferContextual",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.Tracing.getContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.MicrometerTracing.MicrometerTraceContextProvider.getTraceContextLater",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.deferContextual",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.MicrometerTracing.MicrometerTraceContextProvider.getTraceContextLater" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromSupplier",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic <T, R> Flux<R> createDissolvingFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createMono",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromSupplier",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createMono", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "public <T> Mono<T> createMono(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromSupplier",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "public <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1ObservableToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1ObservableToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ResumeAfter.thenEmit",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.ResumeAfter.thenEmit" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()} first, otherwise the connect\n * will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server that treats keys and values as UTF-8 strings.\n *\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub() {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to\n * encode/decode keys and values. Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()}\n * first, otherwise the connect will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ResumeAfter.thenError",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.ResumeAfter.thenError" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1SingleToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1SingleToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.RebindAwareAddressSupplier.wrappedSupplier",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.RebindAwareAddressSupplier.wrappedSupplier" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connect", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterConnection<K, V> connect(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSub", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to encode/decode keys and\n * values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.RedisClient.getSocketAddressSupplier", "io.lettuce.core.RedisClient.getSocketAddress" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n}", "private Mono<SocketAddress> getSocketAddressSupplier(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftDictdump(String dict) {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, SynUpdateArgs<K, V> args, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}", "/**\n * Perform a SCAN in the cluster.\n */\nstatic <T extends ScanCursor, K, V> Mono<T> clusterScan(StatefulRedisClusterConnection<K, V> connection, AsyncClusterConnectionProvider connectionProvider, ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> mapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}", "/**\n * Perform a SCAN in the cluster.\n */\nstatic <T extends ScanCursor, K, V> Mono<T> clusterScan(StatefulRedisClusterConnection<K, V> connection, AsyncClusterConnectionProvider connectionProvider, ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> mapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.findConnectionBySlotReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> clusterCountKeysInSlot(int slot) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> findConnectionBySlotReactive(int slot) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query, ExplainArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> keys(KeyStreamingChannel<K> channel, String pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftTagvals(String index, String fieldName) {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}", "/**\n * Perform a SCAN in the cluster.\n */\nstatic <T extends ScanCursor, K, V> Mono<T> clusterScan(StatefulRedisClusterConnection<K, V> connection, AsyncClusterConnectionProvider connectionProvider, ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> mapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushall() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, boolean skipInitialScan, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}", "/**\n * Perform a SCAN in the cluster.\n */\nstatic <T extends ScanCursor, K, V> Mono<T> clusterScan(StatefulRedisClusterConnection<K, V> connection, AsyncClusterConnectionProvider connectionProvider, ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> mapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.findConnectionBySlotReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Flux<K> clusterGetKeysInSlot(int slot, int count) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> findConnectionBySlotReactive(int slot) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "/**\n * Find all keys matching the given pattern (legacy overload).\n *\n * @param channel\n * \t\tthe channel.\n * @param pattern\n * \t\tthe pattern.\n * @return Long array-reply list of keys matching {@code pattern}.\n * @deprecated Use {@link #keys(String)} instead. This legacy overload will be removed in a later version.\n */\n@Deprecated\n@Override\npublic Mono<Long> keysLegacy(KeyStreamingChannel<K> channel, K pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptLoad(byte[] script) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptKill() {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<Void> shutdown(boolean save) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushall(FlushMode flushMode) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.randomkey",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.randomkey", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<K> randomkey() {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String nodeId) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictdel(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushdb(FlushMode flushMode) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasupdate(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<Map<V, List<V>>> ftSyndump(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<StreamScanCursor> scan(KeyStreamingChannel<K> channel, ScanCursor scanCursor, ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}", "/**\n * Perform a SCAN in the cluster.\n */\nstatic <T extends ScanCursor, K, V> Mono<T> clusterScan(StatefulRedisClusterConnection<K, V> connection, AsyncClusterConnectionProvider connectionProvider, ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> mapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushallAsync() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}", "/**\n * Perform a SCAN in the cluster.\n */\nstatic <T extends ScanCursor, K, V> Mono<T> clusterScan(StatefulRedisClusterConnection<K, V> connection, AsyncClusterConnectionProvider connectionProvider, ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> mapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Flux<K> keys(String pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "/**\n * Find all keys matching the given pattern (legacy overload).\n *\n * @param pattern\n * \t\tthe pattern type: patternkey (pattern).\n * @return K array-reply list of keys matching {@code pattern}.\n * @deprecated Use {@link #keys(String)} instead. This legacy overload will be removed in a later version.\n */\n@Deprecated\n@Override\npublic Flux<K> keysLegacy(K pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan(ScanArgs scanArgs) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}", "/**\n * Perform a SCAN in the cluster.\n */\nstatic <T extends ScanCursor, K, V> Mono<T> clusterScan(StatefulRedisClusterConnection<K, V> connection, AsyncClusterConnectionProvider connectionProvider, ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> mapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index, boolean deleteDocumentKeys) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftList() {\n}", "/**\n * Route a keyless RediSearch command producing a stream (Flux) using cluster-aware selection. Honors the current ReadFrom\n * policy and the READ/WRITE intent derived from {@code commandType}. Falls back to {@code superCall} on failure to preserve\n * existing behavior.\n */\n<R> Flux<R> routeKeylessMany(Supplier<Flux<R>> superCall, Function<RedisClusterReactiveCommands<K, V>, Flux<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.AsyncConnections.asMono",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.AsyncConnections.asMono" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasadd(String alias, String index) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> clientSetname(K name) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasdel(String alias) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushdb() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> dbsize() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterScan", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<KeyScanCursor<K>> scan() {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends ScanCursor> Mono<T> clusterScan(ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> resultMapper) {\n}", "/**\n * Perform a SCAN in the cluster.\n */\nstatic <T extends ScanCursor, K, V> Mono<T> clusterScan(StatefulRedisClusterConnection<K, V> connection, AsyncClusterConnectionProvider connectionProvider, ScanCursor cursor, BiFunction<RedisKeyReactiveCommands<K, V>, ScanCursor, Mono<T>> scanFunction, ClusterScanSupport.ScanCursorMapper<Mono<T>> mapper) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, CreateArgs<K, V> arguments, List<FieldArgs<K>> fieldArgs) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> args) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getStatefulConnection", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictadd(String dict, V... terms) {\n}", "/**\n * Route a keyless RediSearch command with node context. Obtains the executing node id via CLUSTER MYID and passes it to\n * {@code routedCall} so replies can be stamped (e.g., cursor.nodeId). Honors ReadFrom and READ/WRITE intent. Falls back to\n * {@code superCall} on failure.\n */\n<R> Mono<R> routeKeyless(Supplier<Mono<R>> superCall, BiFunction<String, RedisClusterReactiveCommands<K, V>, Mono<R>> routedCall, ProtocolKeyword commandType) {\n}", "/**\n * Obtain a node-scoped connection for the given intent (READ/WRITE). Selection honors the current ReadFrom policy via the\n * cluster connection provider.\n */\nprivate Mono<StatefulRedisConnection<K, V>> getStatefulConnection(ConnectionIntent intent) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getConnectionReactive", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.getMono" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptFlush() {\n}", "/**\n * Run a command on all available nodes that match {@code filter}.\n *\n * @param function\n * \t\tfunction producing the command\n * @param filter\n * \t\tfilter function for the node selection\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnNodes(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function, Predicate<RedisClusterNode> filter) {\n}", "private Mono<RedisClusterReactiveCommands<K, V>> getConnectionReactive(String host, int port) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ReadFrom.subnet",
    "thirdPartyMethod" : "io.netty.util.NetUtil.isValidIpV4Address",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ReadFrom.subnet", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.<init>", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.createSubnetRule" ],
    "methodSlices" : [ "/**\n * Setting to read from any node in the subnets.\n *\n * @param cidrNotations\n * \t\tCIDR-block notation strings, e.g., \"192.168.0.0/16\", \"2001:db8:abcd:0000::/52\". Must not be\n * \t\t{@code null}.\n * @return an instance of {@link ReadFromImpl.ReadFromSubnet}.\n * @since 6.1\n */\npublic static ReadFrom subnet(String... cidrNotations) {\n}", "/**\n *\n * @param cidrNotations\n * \t\tCIDR-block notation strings, e.g., \"192.168.0.0/16\" or \"2001:db8:abcd:0000::/52\".\n */\nReadFromSubnet(String... cidrNotations) {\n    LettuceAssert.notEmpty(cidrNotations, \"CIDR notations must not be empty\");\n    for (String cidrNotation : cidrNotations) {\n        rules.add(createSubnetRule(cidrNotation));\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv4SubnetRule.isInSubnet",
    "thirdPartyMethod" : "io.netty.util.NetUtil.isValidIpV4Address",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv4SubnetRule.isInSubnet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlin.sequences.SequencesKt.toList",
    "thirdPartyPackage" : "kotlin.sequences",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitSingle",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitSingle",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitSingle",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitSingle",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitSingle",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitSingle",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitSingle",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2ObservableAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Observable.fromPublisher",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2ObservableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContext",
    "thirdPartyMethod" : "brave.Tracing.currentTracer",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.group.ChannelGroup.remove",
    "thirdPartyPackage" : "io.netty.channel.group",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.Tracer.nextSpan",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.<init>",
    "thirdPartyMethod" : "reactor.core.publisher.Operators.toCoreSubscriber",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.ImmediateSubscriber.<init>",
    "thirdPartyMethod" : "reactor.core.publisher.Operators.toCoreSubscriber",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisPublisher.ImmediateSubscriber.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3ObservableAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Observable.fromPublisher",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3ObservableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom",
    "thirdPartyMethod" : "kotlin.ResultKt.throwOnFailure",
    "thirdPartyPackage" : "kotlin",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "reactor.util.context.Context.getOrDefault",
    "thirdPartyPackage" : "reactor.util.context",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.Operators.onOperatorError" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.SentinelConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlinx.coroutines.future.FutureKt.await",
    "thirdPartyPackage" : "kotlinx.coroutines.future",
    "path" : [ "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isCancelled",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.internal.Futures.adapt",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isCancelled",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.internal.Futures.adapt" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isCancelled",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isCancelled",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "/**\n * Shutdown the {@link ClientResources}.\n *\n * @param quietPeriod\n * \t\tthe quiet period as described in the documentation\n * @param timeout\n * \t\tthe maximum amount of time to wait until the executor is shutdown regardless if a task was submitted\n * \t\tduring the quiet period\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}\n * @return eventually the success/failure of the shutdown without errors.\n */\n@SuppressWarnings(\"unchecked\")\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.internal.Futures.toCompletionStage",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isCancelled",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.internal.Futures.toCompletionStage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.error",
    "thirdPartyMethod" : "brave.Span.error",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.error" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.util.Attribute.set",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.util.Attribute.set",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.rebind" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.util.Attribute.set",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writerIndex",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue", "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.doWithCipher" ],
    "methodSlices" : [ "@Override\npublic void encodeValue(Object value, ByteBuf target) {\n    ByteBuf serialized;\n    if (delegate instanceof ToByteBufEncoder) {\n        serialized = target.alloc().buffer(estimateSize(value));\n        ((ToByteBufEncoder) (delegate)).encodeKey(value, serialized);\n    } else {\n        ByteBuffer byteBuffer = delegate.encodeValue(value);\n        serialized = target.alloc().buffer(byteBuffer.remaining());\n        serialized.writeBytes(byteBuffer);\n    }\n    try {\n        KeyDescriptor keyDescriptor = this.encrypt.encryptionKey();\n        Cipher cipher = this.encrypt.get(keyDescriptor);\n        keyDescriptor.writeTo(target);\n        doWithCipher(cipher, serialized, target);\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(e);\n    } finally {\n        serialized.release();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.StringCodec.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writerIndex",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.StringCodec.encode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.StringCodec.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writerIndex",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.StringCodec.encodeValue", "io.lettuce.core.codec.StringCodec.encodeAndAllocateBuffer" ],
    "methodSlices" : [ "@Override\npublic ByteBuffer encodeValue(String value) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.StringCodec.encodeKey",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writerIndex",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.StringCodec.encodeKey", "io.lettuce.core.codec.StringCodec.encodeAndAllocateBuffer" ],
    "methodSlices" : [ "@Override\npublic ByteBuffer encodeKey(String key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.Command.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeByte",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.Command.encode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeByte",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue", "io.lettuce.core.codec.CipherCodec.KeyDescriptor.writeTo" ],
    "methodSlices" : [ "@Override\npublic void encodeValue(Object value, ByteBuf target) {\n    ByteBuf serialized;\n    if (delegate instanceof ToByteBufEncoder) {\n        serialized = target.alloc().buffer(estimateSize(value));\n        ((ToByteBufEncoder) (delegate)).encodeKey(value, serialized);\n    } else {\n        ByteBuffer byteBuffer = delegate.encodeValue(value);\n        serialized = target.alloc().buffer(byteBuffer.remaining());\n        serialized.writeBytes(byteBuffer);\n    }\n    try {\n        KeyDescriptor keyDescriptor = this.encrypt.encryptionKey();\n        Cipher cipher = this.encrypt.get(keyDescriptor);\n        keyDescriptor.writeTo(target);\n        doWithCipher(cipher, serialized, target);\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(e);\n    } finally {\n        serialized.release();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeByte",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.KeyArgument.encode", "io.lettuce.core.protocol.CommandArgs.encode" ],
    "methodSlices" : [ "/**\n * Encode the {@link CommandArgs} and write the arguments to the {@link ByteBuf}.\n *\n * @param buf\n * \t\tthe target buffer.\n */\npublic void encode(ByteBuf buf) {\n    buf.touch(\"CommandArgs.encode()\");\n    for (SingularArgument singularArgument : singularArguments) {\n        singularArgument.encode(buf);\n    }\n}", "@SuppressWarnings(\"unchecked\")\n@Override\nvoid encode(ByteBuf target) {\n    if (codec instanceof ToByteBufEncoder) {\n        CommandArgs.encode(target, ((ToByteBufEncoder<K, K>) (codec)), key, ToByteBufEncoder::encodeKey);\n        return;\n    }\n    ByteBufferArgument.writeByteBuffer(target, codec.encodeKey(key));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava1CompletableAdapter.apply",
    "thirdPartyMethod" : "rx.RxReactiveStreams.toCompletable",
    "thirdPartyPackage" : "rx",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava1CompletableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore",
    "thirdPartyMethod" : "kotlin.collections.CollectionsKt.emptyList",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete",
    "thirdPartyMethod" : "io.netty.channel.EventLoop.submit",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.doComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.potentiallyRequeueCommands" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void operationComplete(Future<Void> future) {\n    try {\n        doComplete(future);\n    } finally {\n        recycle();\n    }\n}", "private void doComplete(Future<Void> future) {\n    Throwable cause = future.cause();\n    boolean success = future.isSuccess();\n    dequeue();\n    if (success) {\n        return;\n    }\n    if (((cause instanceof EncoderException) || (cause instanceof Error)) || (cause.getCause() instanceof Error)) {\n        complete(cause);\n        return;\n    }\n    Channel channel = endpoint.channel;\n    // Capture values before recycler clears these.\n    RedisCommand<?, ?, ?> sentCommand = this.sentCommand;\n    Collection<? extends RedisCommand<?, ?, ?>> sentCommands = this.sentCommands;\n    potentiallyRequeueCommands(channel, sentCommand, sentCommands);\n    if (!(cause instanceof ClosedChannelException)) {\n        String message = \"Unexpected exception during request: {}\";\n        InternalLogLevel logLevel = InternalLogLevel.WARN;\n        if ((cause instanceof IOException) && SUPPRESS_IO_EXCEPTION_MESSAGES.contains(cause.getMessage())) {\n            logLevel = InternalLogLevel.DEBUG;\n        }\n        logger.log(logLevel, message, cause.toString(), cause);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisClient.shutdownAsync",
    "thirdPartyMethod" : "io.netty.channel.Channel.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.AbstractRedisClient.shutdownAsync", "io.lettuce.core.AbstractRedisClient.closeResources" ],
    "methodSlices" : [ "/**\n * Shutdown this client and close all open connections asynchronously. Once all connections are closed, the associated\n * {@link ClientResources} are shut down/released gracefully considering quiet time and the shutdown timeout. The client\n * should be discarded after calling shutdown.\n *\n * @param quietPeriod\n * \t\tthe quiet period to allow the executor gracefully shut down.\n * @param timeout\n * \t\tthe maximum amount of time to wait until the backing executor is shutdown regardless if a task was\n * \t\tsubmitted during the quiet period.\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}.\n * @since 4.4\n * @see EventExecutorGroup#shutdownGracefully(long, long, TimeUnit)\n */\npublic CompletableFuture<Void> shutdownAsync(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore",
    "thirdPartyMethod" : "io.netty.channel.Channel.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.channel.Channel.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.rebind" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.concurrent.DefaultPromise.setFailure",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.DefaultPromise.setFailure",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.DefaultPromise.setFailure",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "/**\n * Shutdown the {@link ClientResources}.\n *\n * @param quietPeriod\n * \t\tthe quiet period as described in the documentation\n * @param timeout\n * \t\tthe maximum amount of time to wait until the executor is shutdown regardless if a task was submitted\n * \t\tduring the quiet period\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}\n * @return eventually the success/failure of the shutdown without errors.\n */\n@SuppressWarnings(\"unchecked\")\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.timeout",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.start",
    "thirdPartyMethod" : "brave.Span.start",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.start" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.filter",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.Latencies.getFirstResponseHistogram",
    "thirdPartyMethod" : "org.LatencyUtils.LatencyStats.getIntervalHistogram",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.Latencies.getFirstResponseHistogram" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.Latencies.getCompletionHistogram",
    "thirdPartyMethod" : "org.LatencyUtils.LatencyStats.getIntervalHistogram",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.Latencies.getCompletionHistogram" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.onTokenRenewed",
    "thirdPartyMethod" : "redis.clients.authentication.core.Token.getUser",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.onTokenRenewed" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "reactor.core.Exceptions.failWithOverflow",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToMonoAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Maybe.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToFluxAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Maybe.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToPublisherAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Maybe.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToPublisherAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Maybe.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToFluxAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Maybe.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToMonoAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Maybe.toFlowable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToPublisherAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Observable.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToMonoAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Observable.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToFluxAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Observable.toFlowable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisClient.shutdownAsync",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.get",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.AbstractRedisClient.shutdownAsync", "io.lettuce.core.AbstractRedisClient.closeResources" ],
    "methodSlices" : [ "/**\n * Shutdown this client and close all open connections asynchronously. Once all connections are closed, the associated\n * {@link ClientResources} are shut down/released gracefully considering quiet time and the shutdown timeout. The client\n * should be discarded after calling shutdown.\n *\n * @param quietPeriod\n * \t\tthe quiet period to allow the executor gracefully shut down.\n * @param timeout\n * \t\tthe maximum amount of time to wait until the backing executor is shutdown regardless if a task was\n * \t\tsubmitted during the quiet period.\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}.\n * @since 4.4\n * @see EventExecutorGroup#shutdownGracefully(long, long, TimeUnit)\n */\npublic CompletableFuture<Void> shutdownAsync(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.get",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive", "io.lettuce.core.ConnectionEventTrigger.getCommandHandler" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.get",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.getCommandHandler" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.get",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.get",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.get",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ChannelGroupListener.getCommandHandler" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.get",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ChannelGroupListener.getCommandHandler" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.get",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.rebind" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLog",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLog" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclUsers",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclUsers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoConsumers",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoConsumers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattrAsJsonValue",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattrAsJsonValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.hscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.ScanFlow.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.masters",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.masters" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonNumincrby",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonNumincrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mget",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.time",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.time" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmget",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hvals",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hvals" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.hscanNovalues",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.ScanFlow.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hkeys",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpiretime",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smembers",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smembers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keysLegacy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetdel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.command",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.command" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.zscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.ScanFlow.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLog",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLog" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpersist",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpersist" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinter",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.replicas",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.replicas" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smismember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smismember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiff",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrtrim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.sscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.ScanFlow.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.httl",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.httl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.slaves",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.slaves" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keys",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoGroups",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoGroups" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangeWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.scan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.ScanFlow.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geohash",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geohash" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGetRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptExists",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptExists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangeWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunion",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpttl",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpttl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetall",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpiretime",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vemb",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vemb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinks",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinks" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoStream",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoStream" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclList",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.role",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.role" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonToggle",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonToggle" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiff",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.ReactiveFlowKt.asFlow",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisClient.shutdownAsync",
    "thirdPartyMethod" : "io.netty.channel.group.ChannelGroup.toArray",
    "thirdPartyPackage" : "io.netty.channel.group",
    "path" : [ "io.lettuce.core.AbstractRedisClient.shutdownAsync", "io.lettuce.core.AbstractRedisClient.closeResources" ],
    "methodSlices" : [ "/**\n * Shutdown this client and close all open connections asynchronously. Once all connections are closed, the associated\n * {@link ClientResources} are shut down/released gracefully considering quiet time and the shutdown timeout. The client\n * should be discarded after calling shutdown.\n *\n * @param quietPeriod\n * \t\tthe quiet period to allow the executor gracefully shut down.\n * @param timeout\n * \t\tthe maximum amount of time to wait until the backing executor is shutdown regardless if a task was\n * \t\tsubmitted during the quiet period.\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}.\n * @since 4.4\n * @see EventExecutorGroup#shutdownGracefully(long, long, TimeUnit)\n */\npublic CompletableFuture<Void> shutdownAsync(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientTrackinginfo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientTrackinginfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpushx",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpushx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientSetinfo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientSetinfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.spublish",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.spublish" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSuglen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSuglen", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSuglen.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zintercard",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zintercard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.dump",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.dump" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.dbsize",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.dbsize" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDeluser",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDeluser" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrankWithScore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrankWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinksWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinksWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.restore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.restore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setbit",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setbit" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hincrbyfloat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hincrbyfloat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientInfo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfcount",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.bgrewriteaof",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.bgrewriteaof" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.publish",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.publish" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebylex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushall",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setnx",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setnx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpush",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSdslen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSdslen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionFlush",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionFlush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expiretime",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientInfo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrem",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrem" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSyndump", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSyndump.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugRestart",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugRestart" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.migrate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.migrate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetinfo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetinfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.randomkey",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.randomkey" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vClearAttributes",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vClearAttributes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestorebylex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestorebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsetattr",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsetattr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMerge",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMerge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.swapdb",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.swapdb", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.swapdb.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasdel", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasdel.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectFreq",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectFreq" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lmove",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lmove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zcount",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configResetstat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configResetstat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionDump",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionDump" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupSetid",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupSetid" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.auth",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.auth" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hstrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hstrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.select",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.select", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.select.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasupdate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasupdate.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.bgsave",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.bgsave" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdbAsync",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdbAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmax",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclSetuser",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclSetuser" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientNoEvict",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientNoEvict" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugCrashAndRecover",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugCrashAndRecover" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getbit",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getbit" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.lastsave",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.lastsave" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogReset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogReset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDryRun",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDryRun" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.ttl",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.ttl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestorebyscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestorebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionKill",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattr",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpoplpush",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpoplpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionRestore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionRestore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdb",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLogReset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLogReset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.type",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.type" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalshaReadOnly",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalshaReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmove",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getdel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcallReadOnly",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcallReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLoad",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pttl",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pttl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopNot",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopNot" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.save",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.save" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.psetex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.psetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hsetex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hsetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.scard",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.scard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vembRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vembRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zlexcount",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zlexcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonClear",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonClear" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.quit",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.quit" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestorebyscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestorebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpoplpush",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpoplpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfmerge",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfmerge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortStore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortStore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sintercard",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sintercard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugHtstats",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugHtstats" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptFlush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incrbyfloat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incrbyfloat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrem",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrem" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incr",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.replicaof",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.replicaof" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmin",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonDel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonDel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vdim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vdim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasadd", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasadd.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientSetname",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incrby",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.auth",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.auth" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.msetnx",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.msetnx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.ltrim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.ltrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugObject",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slaveof",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slaveof" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientPause",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientPause" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xdel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configSet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionLoad",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopOr",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopOr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursordel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursordel", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursordel.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupDestroy",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupDestroy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushallAsync",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushallAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogLen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogLen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.copy",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.copy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdel", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdel.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientCaching",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientCaching" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zintercard",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zintercard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hincrby",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hincrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDryRun",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDryRun" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebyscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGenpass",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGenpass" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectRefcount",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectRefcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmin",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.replicaofNoOne",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.replicaofNoOne" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandCount",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandCount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.decr",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.decr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMSet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearchstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearchstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpush",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpushx",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpushx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptFlush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonClear",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonClear" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrem",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrem" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.linsert",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.linsert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.rename",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.rename" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopAnd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopAnd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebyrank",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebyrank" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.append",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.append" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hdel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclWhoami",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclWhoami" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionLoad",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrankWithScore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrankWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slaveofNoOne",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slaveofNoOne" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmax",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vinfo",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vinfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalsha",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalsha" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreateconsumer",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreateconsumer" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.restore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.restore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hset",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.strlen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.strlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vcard",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vcard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.llen",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.llen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xautoclaim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xautoclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.renamenx",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.renamenx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientGetname",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientGetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopXor",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopXor" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcallReadOnly",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcallReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zincrby",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zincrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalsha",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalsha" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.move",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.move" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.persist",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.persist" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictadd", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictadd.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hsetnx",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hsetnx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configSet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpoplpush",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpoplpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectIdletime",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectIdletime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdb",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptKill",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.lcs",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.lcs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexists",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinterstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinterstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.migrate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.migrate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientGetname",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientGetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.del",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.del" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiffstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiffstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.exists",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.exists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupDelconsumer",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupDelconsumer" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonDel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonDel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.unlink",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.unlink" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sintercard",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sintercard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestorebylex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestorebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sismember",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sismember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zaddincr",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zaddincr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmove",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xack",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xack" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushall",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zaddincr",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zaddincr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionRestore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionRestore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srem",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srem" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclSave",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclSave" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.decrby",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.decrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zcard",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zcard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.get",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.get" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smove",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugReload",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugReload" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configGet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalReadOnly",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configRewrite",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configRewrite" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGenpass",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGenpass" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugdel",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugdel", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugdel.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectEncoding",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectEncoding" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMerge",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMerge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.waitForReplication",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.waitForReplication" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrank",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrank" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.memoryUsage",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.memoryUsage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientTracking",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientTracking" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientId",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientId" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientUnblock",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientUnblock" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcall",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.copy",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.copy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geodist",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geodist" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunionstore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunionstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hget",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsetattr",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsetattr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitcount",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalReadOnly",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpiretime",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitcount",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lindex",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getrange",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate.suspendImpl" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.touch",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.touch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcall",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientGetredir",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientGetredir" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreate",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrank",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrNull",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrank" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive", "io.lettuce.core.ConnectionEventTrigger.getCommandHandler" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.getCommandHandler" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ChannelGroupListener.getCommandHandler" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.pipeline",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ChannelGroupListener.getCommandHandler" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.support.RedisClusterClientCdiBean.create",
    "thirdPartyMethod" : "javax.enterprise.inject.spi.BeanManager.createCreationalContext",
    "thirdPartyPackage" : "javax.enterprise.inject.spi",
    "path" : [ "io.lettuce.core.support.RedisClusterClientCdiBean.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.RedisClientCdiBean.create",
    "thirdPartyMethod" : "javax.enterprise.inject.spi.BeanManager.createCreationalContext",
    "thirdPartyPackage" : "javax.enterprise.inject.spi",
    "path" : [ "io.lettuce.core.support.RedisClientCdiBean.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.write",
    "thirdPartyMethod" : "io.netty.util.Recycler.<init>",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.write", "io.lettuce.core.protocol.CommandHandler.writeSingleCommand", "io.lettuce.core.protocol.CommandHandler.addToStack", "io.lettuce.core.protocol.CommandHandler.AddToStack.<clinit>", "io.lettuce.core.protocol.CommandHandler.AddToStack.<init>" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelDuplexHandler#write(io.netty.channel.ChannelHandlerContext, java.lang.Object,\nio.netty.channel.ChannelPromise)\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n}", "private void writeSingleCommand(ChannelHandlerContext ctx, RedisCommand<?, ?, ?> command, ChannelPromise promise) {\n    if (!isWriteable(command)) {\n    promise.trySuccess();\n    return;\n}\n    addToStack(command, promise)\n}", "private void addToStack(RedisCommand<?, ?, ?> command, ChannelPromise promise) {\n    try {\n        if (!ActivationCommand.isActivationCommand(command)) {\n            validateWrite(1);\n        }\n        if (command.getOutput() == null) {\n            // fire&forget commands are excluded from metrics and replies\n            complete(command);\n        }\n        RedisCommand<?, ?, ?> redisCommand = potentiallyWrapLatencyCommand(command);\n        stack.add(redisCommand);\n        if (!promise.isVoid()) {\n            promise.addListener(AddToStack.newInstance(stack, redisCommand));\n        }\n    } catch (Exception e) {\n        command.completeExceptionally(e);\n        throw e;\n    }\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.util.Recycler.<init>",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.writeToChannelAndFlush", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.<clinit>", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.<init>" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n}", "private void writeToChannelAndFlush(Channel channel, Collection<? extends RedisCommand<?, ?, ?>> commands) {\n    QUEUE_SIZE.addAndGet(this, commands.size());\n    if (reliability == Reliability.AT_MOST_ONCE) {\n        // cancel on exceptions and remove from queue, because there is no housekeeping\n        for (RedisCommand<?, ?, ?> command : commands) {\n            channelWrite(channel, command).addListener(AtMostOnceWriteListener.newInstance(this, command));\n        }\n    }\n    if (reliability == Reliability.AT_LEAST_ONCE) {\n        // commands are ok to stay within the queue, reconnect will retrigger them\n        for (RedisCommand<?, ?, ?> command : commands) {\n            channelWrite(channel, command).addListener(RetryListener.newInstance(this, command));\n        }\n    }\n    channelFlush(channel);\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onError",
    "thirdPartyMethod" : "io.netty.util.Recycler.<init>",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onError", "io.lettuce.core.RedisPublisher.OnComplete.<clinit>", "io.lettuce.core.RedisPublisher.OnComplete.<init>" ],
    "methodSlices" : [ "@Override\npublic void onError(Throwable t) {\n    executor.execute(OnComplete.newInstance(t, delegate));\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.Recycler.<init>",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.writeToChannelAndFlush", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.<clinit>", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.<init>" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}", "private void writeToChannelAndFlush(Channel channel, Collection<? extends RedisCommand<?, ?, ?>> commands) {\n    QUEUE_SIZE.addAndGet(this, commands.size());\n    if (reliability == Reliability.AT_MOST_ONCE) {\n        // cancel on exceptions and remove from queue, because there is no housekeeping\n        for (RedisCommand<?, ?, ?> command : commands) {\n            channelWrite(channel, command).addListener(AtMostOnceWriteListener.newInstance(this, command));\n        }\n    }\n    if (reliability == Reliability.AT_LEAST_ONCE) {\n        // commands are ok to stay within the queue, reconnect will retrigger them\n        for (RedisCommand<?, ?, ?> command : commands) {\n            channelWrite(channel, command).addListener(RetryListener.newInstance(this, command));\n        }\n    }\n    channelFlush(channel);\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.Recycler.<init>",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.writeToChannelAndFlush", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.<clinit>", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.<init>" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}", "private void writeToChannelAndFlush(Channel channel, RedisCommand<?, ?, ?> command) {\n    QUEUE_SIZE.incrementAndGet(this);\n    ChannelFuture channelFuture = channelWriteAndFlush(channel, command);\n    if (reliability == Reliability.AT_MOST_ONCE) {\n        // cancel on exceptions and remove from queue, because there is no housekeeping\n        channelFuture.addListener(AtMostOnceWriteListener.newInstance(this, command));\n    }\n    if (reliability == Reliability.AT_LEAST_ONCE) {\n        // commands are ok to stay within the queue, reconnect will retrigger them\n        channelFuture.addListener(RetryListener.newInstance(this, command));\n    }\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onNext",
    "thirdPartyMethod" : "io.netty.util.Recycler.<init>",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onNext", "io.lettuce.core.RedisPublisher.OnNext.<clinit>", "io.lettuce.core.RedisPublisher.OnNext.<init>" ],
    "methodSlices" : [ "@Override\npublic void onNext(T t) {\n    executor.execute(OnNext.newInstance(t, delegate));\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onComplete",
    "thirdPartyMethod" : "io.netty.util.Recycler.<init>",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onComplete", "io.lettuce.core.RedisPublisher.OnComplete.<clinit>", "io.lettuce.core.RedisPublisher.OnComplete.<init>" ],
    "methodSlices" : [ "@Override\npublic void onComplete() {\n    executor.execute(OnComplete.newInstance(delegate));\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.Tracer.nextSpan",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.onTokenRenewed",
    "thirdPartyMethod" : "redis.clients.authentication.core.Token.getValue",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.onTokenRenewed" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newEventLoopGroup", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.Transports.socketChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link Channel} for socket (network/TCP) transport.\n */\npublic static Class<? extends Channel> socketChannelClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.eventLoopGroupClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.EpollProvider.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if epoll is available.\n */\npublic static boolean isAvailable() {\n    return EPOLL_AVAILABLE && EPOLL_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.EpollProvider.getResources", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for epoll-backed transport. Check availability with {@link #isAvailable()} prior\n * to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n * @since 6.0\n */\npublic static EventLoopResources getResources() {\n    return EPOLL_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport {@link EventLoopGroup} class.\n * @param domainSocket\n * \t\t{@code true} to indicate Unix Domain Socket usage, {@code false} otherwise.\n * @since 6.3.3\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass(boolean domainSocket) {\n    return (domainSocket && EpollProvider.isAvailable()) && IOUringProvider.isAvailable() ? EpollProvider.getResources().eventLoopGroupClass() : RESOURCES.eventLoopGroupClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.socketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> socketChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueSocketChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.domainSocketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> domainSocketChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueDomainSocketChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.EpollProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.EpollProvider.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if epoll is available.\n */\npublic static boolean isAvailable() {\n    return EpollProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.isAvailable", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if kqueue is available.\n */\npublic static boolean isAvailable() {\n    return KQUEUE_AVAILABLE && KQUEUE_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.event.jfr.EventRecorder.getInstance",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.event.jfr.EventRecorder.getInstance", "io.lettuce.core.event.jfr.EventRecorderHolder.<clinit>" ],
    "methodSlices" : [ "/**\n * Obtain an instance of the {@link EventRecorder}.\n *\n * @return an instance of the {@link EventRecorder}.\n */\nstatic EventRecorder getInstance() {\n    return EventRecorderHolder.EVENT_RECORDER;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.getOrCreate", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doCreateEventLoopGroup", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T extends EventLoopGroup> T allocate(Class<T> type) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends EventLoopGroup> T getOrCreate(Class<T> type) {\n}", "/**\n * Customization hook for {@link EventLoopGroup} creation.\n *\n * @param <T>\n * @param type\n * \t\trequested event loop group type.\n * @param numberOfThreads\n * \t\tnumber of threads to create.\n * @param threadFactoryProvider\n * \t\tprovider for {@link ThreadFactory}.\n * @return  * @since 6.0\n */\nprotected <T extends EventLoopGroup> EventExecutorGroup doCreateEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider threadFactoryProvider) {\n}", "/**\n * Create an instance of a {@link EventExecutorGroup}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n * @since 5.3\n */\nstatic <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider factoryProvider) {\n    logger.debug(\"Creating executor {}\", type.getName());\n    if (DefaultEventExecutorGroup.class.equals(type)) {\n        return new DefaultEventExecutorGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-eventExecutorLoop\"));\n    }\n    if (NioEventLoopGroup.class.equals(type)) {\n        return new NioEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-nioEventLoop\"));\n    }\n    if (EpollProvider.isAvailable()) {\n        EventLoopResources resources = EpollProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-epollEventLoop\"));\n        }\n    }\n    if (KqueueProvider.isAvailable()) {\n        EventLoopResources resources = KqueueProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-kqueueEventLoop\"));\n        }\n    }\n    if (IOUringProvider.isAvailable()) {\n        EventLoopResources resources = IOUringProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-io_uringEventLoop\"));\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"Type %s not supported\", type.getName()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.datagramChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends DatagramChannel> datagramChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SocketAddress newSocketAddress(String socketPath) {\n    checkForKqueueLibrary();\n    return new DomainSocketAddress(socketPath);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Initialize the {@link Bootstrap}.\n *\n * @since 6.1\n */\npublic void configureBootstrap(boolean domainSocket, Function<Class<? extends EventLoopGroup>, EventLoopGroup> eventLoopGroupProvider) {\n    LettuceAssert.assertState(bootstrap != null, \"Bootstrap must be set\");\n    LettuceAssert.assertState(clientOptions != null, \"ClientOptions must be set\");\n    Class<? extends EventLoopGroup> eventLoopGroupClass = Transports.eventLoopGroupClass();\n    Class<? extends Channel> channelClass = Transports.socketChannelClass();\n    if (domainSocket) {\n        Transports.NativeTransports.assertDomainSocketAvailable();\n        eventLoopGroupClass = Transports.NativeTransports.eventLoopGroupClass(true);\n        channelClass = Transports.NativeTransports.domainSocketChannelClass();\n    } else {\n        bootstrap.resolver(clientResources.addressResolverGroup());\n    }\n    SocketOptions options = clientOptions.getSocketOptions();\n    EventLoopGroup eventLoopGroup = eventLoopGroupProvider.apply(eventLoopGroupClass);\n    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.toIntExact(options.getConnectTimeout().toMillis()));\n    if (!domainSocket) {\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, options.isKeepAlive());\n        bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());\n        if (options.isEnableTcpUserTimeout()) {\n            SocketOptions.TcpUserTimeoutOptions tcpUserTimeoutOptions = options.getTcpUserTimeout();\n            boolean applied = false;\n            if (IOUringProvider.isAvailable()) {\n                IOUringProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            } else if (EpollProvider.isAvailable()) {\n                EpollProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            }\n            LettuceAssert.assertState(applied, \"TCP User Timeout options could not be applied. Native transports (io_uring or epoll) are required.\");\n        }\n    }\n    bootstrap.channel(channelClass).group(eventLoopGroup);\n    if (options.isKeepAlive() && options.isExtendedKeepAlive()) {\n        SocketOptions.KeepAliveOptions keepAlive = options.getKeepAlive();\n        boolean applied = false;\n        if (IOUringProvider.isAvailable()) {\n            IOUringProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (EpollProvider.isAvailable()) {\n            EpollProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (ExtendedNioSocketOptions.isAvailable() && (!KqueueProvider.isAvailable())) {\n            ExtendedNioSocketOptions.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        }\n        LettuceAssert.assertState(applied, \"Extended TCP keepalive options could not be applied. Native transports (io_uring or epoll) or a compatible NIO transport are required.\");\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.CannotRetrieveClusterPartitions.getMessage",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.cluster.topology.DefaultClusterTopologyRefresh.CannotRetrieveClusterPartitions.getMessage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.getResources", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for io_uring-backed transport. Check availability with {@link #isAvailable()}\n * prior to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n */\npublic static EventLoopResources getResources() {\n    return IOURING_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.Transports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link EventLoopGroup} for socket transport that is compatible with {@link #socketChannelClass()}.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.isDomainSocketSupported",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.isDomainSocketSupported", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if a native transport for domain sockets is available.\n */\npublic static boolean isDomainSocketSupported() {\n    return EpollProvider.isAvailable() || KqueueProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.socketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> socketChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.getResources",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.getResources", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for kqueue-backed transport. Check availability with {@link #isAvailable()} prior\n * to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n * @since 6.0\n */\npublic static EventLoopResources getResources() {\n    return KQUEUE_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.KqueueProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.KqueueProvider.isAvailable", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if kqueue is available.\n */\npublic static boolean isAvailable() {\n    return KqueueProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.eventLoopGroupClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    checkForKqueueLibrary();\n    // Return the new recommended class, but keep backward compatibility\n    return MultiThreadIoEventLoopGroup.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\n    checkForKqueueLibrary();\n    // Use the new Netty 4.2 approach with IoHandlerFactory\n    return new MultiThreadIoEventLoopGroup(nThreads, threadFactory, KQueueIoHandler.newFactory());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.isAvailable", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if io_uring is available.\n */\npublic static boolean isAvailable() {\n    return IOURING_AVAILABLE && IOURING_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport {@link EventLoopGroup} class. Defaults to TCP sockets. See\n{@link #eventLoopGroupClass(boolean)} to request a specific EventLoopGroup for Domain Socket usage.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    return eventLoopGroupClass(false);\n}", "/**\n *\n * @return the native transport {@link EventLoopGroup} class.\n * @param domainSocket\n * \t\t{@code true} to indicate Unix Domain Socket usage, {@code false} otherwise.\n * @since 6.3.3\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass(boolean domainSocket) {\n    return (domainSocket && EpollProvider.isAvailable()) && IOUringProvider.isAvailable() ? EpollProvider.getResources().eventLoopGroupClass() : RESOURCES.eventLoopGroupClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Create an instance of a {@link EventExecutorGroup} using the default {@link ThreadFactoryProvider}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n */\npublic static <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads) {\n}", "/**\n * Create an instance of a {@link EventExecutorGroup}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n * @since 5.3\n */\nstatic <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider factoryProvider) {\n    logger.debug(\"Creating executor {}\", type.getName());\n    if (DefaultEventExecutorGroup.class.equals(type)) {\n        return new DefaultEventExecutorGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-eventExecutorLoop\"));\n    }\n    if (NioEventLoopGroup.class.equals(type)) {\n        return new NioEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-nioEventLoop\"));\n    }\n    if (EpollProvider.isAvailable()) {\n        EventLoopResources resources = EpollProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-epollEventLoop\"));\n        }\n    }\n    if (KqueueProvider.isAvailable()) {\n        EventLoopResources resources = KqueueProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-kqueueEventLoop\"));\n        }\n    }\n    if (IOUringProvider.isAvailable()) {\n        EventLoopResources resources = IOUringProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-io_uringEventLoop\"));\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"Type %s not supported\", type.getName()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.matches",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.matches", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic boolean matches(Class<? extends EventExecutorGroup> type) {\n    checkForKqueueLibrary();\n    return false;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.Transports.datagramChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link DatagramChannel} for socket (network/UDP) transport.\n */\npublic static Class<? extends DatagramChannel> datagramChannelClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.domainSocketChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends Channel> domainSocketChannelClass() {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.Builder.build",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.Builder.build", "io.lettuce.core.resource.DefaultClientResources.<init>", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return a new instance of {@link DefaultClientResources}.\n */\n@Override\npublic DefaultClientResources build() {\n    DefaultClientResources resources = new DefaultClientResources(this);\n    if (this.afterBuild != null) {\n        this.afterBuild.run();\n    }\n    return resources;\n}", "protected DefaultClientResources(Builder builder) {\n}", "/**\n * Create an instance of a {@link EventExecutorGroup}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n * @since 5.3\n */\nstatic <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider factoryProvider) {\n    logger.debug(\"Creating executor {}\", type.getName());\n    if (DefaultEventExecutorGroup.class.equals(type)) {\n        return new DefaultEventExecutorGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-eventExecutorLoop\"));\n    }\n    if (NioEventLoopGroup.class.equals(type)) {\n        return new NioEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-nioEventLoop\"));\n    }\n    if (EpollProvider.isAvailable()) {\n        EventLoopResources resources = EpollProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-epollEventLoop\"));\n        }\n    }\n    if (KqueueProvider.isAvailable()) {\n        EventLoopResources resources = KqueueProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-kqueueEventLoop\"));\n        }\n    }\n    if (IOUringProvider.isAvailable()) {\n        EventLoopResources resources = IOUringProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-io_uringEventLoop\"));\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"Type %s not supported\", type.getName()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.datagramChannelClass", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic Class<? extends DatagramChannel> datagramChannelClass() {\n    checkForKqueueLibrary();\n    return KQueueDatagramChannel.class;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.SocketAddressResolver.resolve",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.SocketAddressResolver.resolve", "io.lettuce.core.resource.SocketAddressResolver.getDomainSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Resolves a {@link io.lettuce.core.RedisURI} to a {@link java.net.SocketAddress}.\n *\n * @param redisURI\n * \t\tmust not be {@code null}.\n * @param dnsResolver\n * \t\tmust not be {@code null}.\n * @return the resolved {@link SocketAddress}.\n */\npublic static SocketAddress resolve(RedisURI redisURI, DnsResolver dnsResolver) {\n}", "static SocketAddress getDomainSocketAddress(RedisURI redisURI) {\n    if (KqueueProvider.isAvailable() || EpollProvider.isAvailable()) {\n        EventLoopResources resources = (KqueueProvider.isAvailable()) ? KqueueProvider.getResources() : EpollProvider.getResources();\n        return resources.newSocketAddress(redisURI.getSocket());\n    }\n    throw new IllegalStateException(\"No native transport available. Make sure that either netty's epoll or kqueue library is on the class path and supported by your operating system.\");\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.UnavailableKqueueResources.newSocketAddress", "io.lettuce.core.resource.KqueueProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic SocketAddress newSocketAddress(String socketPath) {\n    checkForKqueueLibrary();\n    return null;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.assertDomainSocketAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.assertDomainSocketAvailable", "io.lettuce.core.resource.Transports.NativeTransports.isDomainSocketSupported", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "public static void assertDomainSocketAvailable() {\n    LettuceAssert.assertState(NativeTransports.isDomainSocketSupported(), \"A unix domain socket connection requires epoll or kqueue and neither is available\");\n}", "/**\n *\n * @return {@code true} if a native transport for domain sockets is available.\n */\npublic static boolean isDomainSocketSupported() {\n    return EpollProvider.isAvailable() || KqueueProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.SystemPropertyUtil.get",
    "thirdPartyPackage" : "io.netty.util.internal",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.domainSocketChannelClass", "io.lettuce.core.resource.EpollProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport domain socket {@link Channel} class.\n */\npublic static Class<? extends Channel> domainSocketChannelClass() {\n    assertDomainSocketAvailable();\n    return EpollProvider.isAvailable() && IOUringProvider.isAvailable() ? EpollProvider.getResources().domainSocketChannelClass() : RESOURCES.domainSocketChannelClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat", "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat", "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop", "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec", "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop", "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch", "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop", "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly", "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault", "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite", "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown", "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop", "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop", "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop", "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown", "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat", "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList", "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard", "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub", "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch", "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub", "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping", "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList", "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi", "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo", "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore", "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi", "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser", "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set", "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom",
    "thirdPartyMethod" : "kotlin.coroutines.jvm.internal.ContinuationImpl.<init>",
    "thirdPartyPackage" : "kotlin.coroutines.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom", "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.collectList",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.collectList",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.collectList",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.collectList",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.collectList",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.<init>",
    "thirdPartyMethod" : "io.netty.channel.ChannelDuplexHandler.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.<init>",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.<init>",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisHandshakeHandler.<init>",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.RedisHandshakeHandler.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.hscan",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.hscan", "io.lettuce.core.ScanStream.hscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over entries in a hash identified by {@code key}. This method uses {@code HSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe hash to scan.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<KeyValue<K, V>> hscan(RedisHashReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.hscanNovalues",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.hscanNovalues", "io.lettuce.core.ScanStream.hscanNovalues" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over keys in a hash identified by {@code key}. This method uses {@code HSCAN NOVALUES} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe hash to scan.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n * @since 6.4\n */\npublic static <K, V> Flux<K> hscanNovalues(RedisHashReactiveCommands<K, V> commands, K key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.sscan",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.sscan", "io.lettuce.core.ScanStream.sscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over elements in a set identified by {@code key}. This method uses {@code SSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe set to scan.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<V> sscan(RedisSetReactiveCommands<K, V> commands, K key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.zscan",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.zscan", "io.lettuce.core.ScanStream.zscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over elements in a set identified by {@code key}. This method uses {@code SSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe sorted set to scan.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<ScoredValue<V>> zscan(RedisSortedSetReactiveCommands<K, V> commands, K key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.zscan",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.zscan", "io.lettuce.core.ScanStream.zscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over elements in a set identified by {@code key}. This method uses {@code SSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe sorted set to scan.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<ScoredValue<V>> zscan(RedisSortedSetReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.hscan",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.hscan", "io.lettuce.core.ScanStream.hscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over entries in a hash identified by {@code key}. This method uses {@code HSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe hash to scan.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<KeyValue<K, V>> hscan(RedisHashReactiveCommands<K, V> commands, K key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.scan", "io.lettuce.core.ScanStream.scan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over keys in the keyspace. This method uses {@code SCAN} to perform an iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<K> scan(RedisKeyReactiveCommands<K, V> commands) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.sscan",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.sscan", "io.lettuce.core.ScanStream.sscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over elements in a set identified by {@code key}. This method uses {@code SSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe set to scan.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<V> sscan(RedisSetReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.scan", "io.lettuce.core.ScanStream.scan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over keys in the keyspace. This method uses {@code SCAN} to perform an iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<K> scan(RedisKeyReactiveCommands<K, V> commands, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.hscanNovalues",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMapIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.hscanNovalues", "io.lettuce.core.ScanStream.hscanNovalues" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over keys in a hash identified by {@code key}. This method uses {@code HSCAN NOVALUES} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe hash to scan.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n * @since 6.4\n */\npublic static <K, V> Flux<K> hscanNovalues(RedisHashReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, SynUpdateArgs<K, V> args, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictdel(String dict, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to\n * encode/decode keys and values. Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()}\n * first, otherwise the connect will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasupdate(String alias, String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSyndump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Map<V, List<V>>> ftSyndump(String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSub", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to encode/decode keys and\n * values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query, ExplainArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDropindex", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftDropindex(String index, boolean deleteDocumentKeys) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()} first, otherwise the connect\n * will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasadd(String alias, String index) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSynupdate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftSynupdate(String index, V synonymGroupId, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAliasdel", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAliasdel(String alias) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAlter", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftAlter(String index, boolean skipInitialScan, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSearch", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SearchReply<K, V>> ftSearch(String index, V query, SearchArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftExplain", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftExplain(String index, V query) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query, SpellCheckArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftSpellcheck", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<SpellCheckResult<V>> ftSpellcheck(String index, V query) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connect", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterConnection<K, V> connect(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCreate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<String> ftCreate(String index, CreateArgs<K, V> arguments, List<FieldArgs<K>> fieldArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftAggregate", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<AggregationReply<K, V>> ftAggregate(String index, V query, AggregateArgs<K, V> args) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.onErrorResume",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictadd", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeyless" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> ftDictadd(String dict, V... terms) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToObservableAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Single.toObservable",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToObservableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onSubscribe",
    "thirdPartyMethod" : "reactor.core.CoreSubscriber.onSubscribe",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.PublishOnSubscriber.onSubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.ImmediateSubscriber.onSubscribe",
    "thirdPartyMethod" : "reactor.core.CoreSubscriber.onSubscribe",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.ImmediateSubscriber.onSubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToObservableAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Single.toObservable",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToObservableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic <T, R> Flux<R> createDissolvingFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURIs\n * \t\tone or more Redis URI, must not be {@code null} and not empty\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    assertNotNull(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    return new RedisClusterClient(clientResources, redisURIs);\n}", "/**\n * Initialize the client with a list of cluster URI's. All uris are tried in sequence for connecting initially to the\n * cluster. If any uri is successful for connection, the others are not tried anymore. The initial uri is needed to discover\n * the cluster structure for distributing the requests.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n * @param redisURIs\n * \t\titerable of initial {@link RedisURI cluster URIs}. Must not be {@code null} and not empty.\n */\nprotected RedisClusterClient(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    super(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    this.initialUris = Collections.unmodifiableList(LettuceLists.newList(redisURIs));\n    this.refresh = createTopologyRefresh();\n    setOptions(ClusterClientOptions.create());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createMono",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createMono" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>" ],
    "methodSlices" : [ "/**\n * Creates a uri-less RedisClient with default {@link ClientResources}. You can connect to different Redis servers but you\n * must supply a {@link RedisURI} on connecting. Methods without having a {@link RedisURI} will fail with a\n * {@link java.lang.IllegalStateException}.\n *\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create() {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(ClientResources clientResources, RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURIs\n * \t\tone or more Redis URI, must not be {@code null} and not empty.\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(Iterable<RedisURI> redisURIs) {\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    return new RedisClusterClient(null, redisURIs);\n}", "/**\n * Initialize the client with a list of cluster URI's. All uris are tried in sequence for connecting initially to the\n * cluster. If any uri is successful for connection, the others are not tried anymore. The initial uri is needed to discover\n * the cluster structure for distributing the requests.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n * @param redisURIs\n * \t\titerable of initial {@link RedisURI cluster URIs}. Must not be {@code null} and not empty.\n */\nprotected RedisClusterClient(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    super(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    this.initialUris = Collections.unmodifiableList(LettuceLists.newList(redisURIs));\n    this.refresh = createTopologyRefresh();\n    setOptions(ClusterClientOptions.create());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createFlux",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.next",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux" ],
    "methodSlices" : [ "public <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.createSoftReferenceObjectPool",
    "thirdPartyMethod" : "org.apache.commons.pool2.impl.SoftReferenceObjectPool.<init>",
    "thirdPartyPackage" : "org.apache.commons.pool2.impl",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.createSoftReferenceObjectPool", "io.lettuce.core.support.ConnectionPoolSupport.<init>" ],
    "methodSlices" : [ "/**\n * Creates a new {@link SoftReferenceObjectPool} using the {@link Supplier}.\n *\n * @param connectionSupplier\n * \t\tmust not be {@code null}.\n * @param wrapConnections\n * \t\t{@code false} to return direct connections that need to be returned to the pool using\n * \t\t{@link ObjectPool#returnObject(Object)}. {@code true} to return wrapped connections that are returned to the pool\n * \t\twhen invoking {@link StatefulConnection#close()}.\n * @param validationPredicate\n * \t\ta {@link Predicate} to help validate connections\n * @param <T>\n * \t\tconnection type.\n * @return the connection pool.\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T extends StatefulConnection<?, ?>> SoftReferenceObjectPool<T> createSoftReferenceObjectPool(Supplier<T> connectionSupplier, boolean wrapConnections, Predicate<T> validationPredicate) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.touch",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.touch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.exists",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.exists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.del",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.del" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.msetnx",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.msetnx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.unlink",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.reduce",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.unlink" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirst",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirst",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirst",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirst",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirst",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirst",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirst",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2FlowableAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Flowable.fromPublisher",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2FlowableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2MaybeAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Flowable.fromPublisher",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava2MaybeAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.filter",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContextLater",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.filter",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContextLater" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.Tracing.getContext",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.filter",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.Tracing.getContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.MicrometerTracing.MicrometerTraceContextProvider.getTraceContextLater",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.filter",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.tracing.MicrometerTracing.MicrometerTraceContextProvider.getTraceContextLater" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ReactiveExecutionsImpl.flux",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.flatMap",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.ReactiveExecutionsImpl.flux" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.channel",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3FlowableAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Flowable.fromPublisher",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3FlowableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3MaybeAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Flowable.fromPublisher",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava3MaybeAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic <T, R> Flux<R> createDissolvingFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> keys(KeyStreamingChannel<K> channel, String pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftList", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftList() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushall(FlushMode flushMode) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftDictdump", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftDictdump(String dict) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftTagvals", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.routeKeylessMany" ],
    "methodSlices" : [ "@Override\npublic Flux<V> ftTagvals(String index, String fieldName) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushdb(FlushMode flushMode) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushall() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushdb() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> dbsize() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<String> flushallAsync() {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "/**\n * Find all keys matching the given pattern (legacy overload).\n *\n * @param channel\n * \t\tthe channel.\n * @param pattern\n * \t\tthe pattern.\n * @return Long array-reply list of keys matching {@code pattern}.\n * @deprecated Use {@link #keys(String)} instead. This legacy overload will be removed in a later version.\n */\n@Deprecated\n@Override\npublic Mono<Long> keysLegacy(KeyStreamingChannel<K> channel, K pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptLoad(byte[] script) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptKill() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<Void> shutdown(boolean save) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux" ],
    "methodSlices" : [ "public <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Mono<String> scriptFlush() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "@Override\npublic Flux<K> keys(String pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.flatMapMany",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnUpstream", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.executeOnNodes" ],
    "methodSlices" : [ "/**\n * Find all keys matching the given pattern (legacy overload).\n *\n * @param pattern\n * \t\tthe pattern type: patternkey (pattern).\n * @return K array-reply list of keys matching {@code pattern}.\n * @deprecated Use {@link #keys(String)} instead. This legacy overload will be removed in a later version.\n */\n@Deprecated\n@Override\npublic Flux<K> keysLegacy(K pattern) {\n}", "/**\n * Run a command on all available masters,\n *\n * @param function\n * \t\tfunction producing the command\n * @param <T>\n * \t\tresult type\n * @return map of a key (counter) and commands.\n */\nprotected <T> Map<String, Publisher<T>> executeOnUpstream(Function<RedisClusterReactiveCommands<K, V>, ? extends Publisher<T>> function) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.event.metrics.DefaultCommandLatencyEventPublisher.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.ScheduledFuture.cancel",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.event.metrics.DefaultCommandLatencyEventPublisher.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.suspendTopologyRefresh",
    "thirdPartyMethod" : "io.netty.util.concurrent.ScheduledFuture.cancel",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.suspendTopologyRefresh" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.fromIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ReactiveExecutionsImpl.flux",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.fromIterable",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.ReactiveExecutionsImpl.flux" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.mergeSequential",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.concurrent.SucceededFuture.<init>",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doRelease" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.SucceededFuture.<init>",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doRelease" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.touch",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.touch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.exists",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.exists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.unlink",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.unlink" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.dbsize" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.del",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.del" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mset",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mset", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.pipeliningWithMap" ],
    "methodSlices" : [ "@Override\npublic Mono<String> mset(Map<K, V> map) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.msetnx",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.msetnx", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.pipeliningWithMap" ],
    "methodSlices" : [ "@Override\npublic Mono<Boolean> msetnx(Map<K, V> map) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.merge",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.keysLegacy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.mget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.srandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.srandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangeWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.keysLegacy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hvals",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hvals" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.hscanNovalues",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hgetall",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hgetall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hgetdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hgetdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hgetex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hgetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.zscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hkeys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smismember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smismember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zdiffWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zdiffWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiff",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hvals",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hvals" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.StatefulRedisSentinelConnectionExtensionsKt.coroutines",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.StatefulRedisSentinelConnectionExtensionsKt.coroutines" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.StatefulRedisConnectionExtensionsKt.coroutines",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.StatefulRedisConnectionExtensionsKt.coroutines" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geohash",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geohash" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sdiff",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zpopmax",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.keysLegacy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangeWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.geohash",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.geohash" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.smismember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.smismember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetall",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangeWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.srandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.srandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.StatefulRedisClusterConnectionExtensionsKt.coroutines",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.StatefulRedisClusterConnectionExtensionsKt.coroutines" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hmget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hmget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.smembers",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.smembers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiff",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hgetdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hgetdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.hscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield", "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.sam.java_util_function_Function.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hkeys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.keys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.keys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangeWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zdiffWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zdiffWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zdiff",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hkeys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smembers",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smembers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keysLegacy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.mget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zpopmin",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zpopmin",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos", "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.sam.java_util_function_Function.<init>" ],
    "methodSlices" : [ "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sdiff",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.sscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hgetex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hgetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangeWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.scan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.keys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.keys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.smismember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.smismember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zdiff",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hvals",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hvals" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.sync.RedisSyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.sync.RedisSyncCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hgetall",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.hgetall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hmget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.hmget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.smembers",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.smembers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.geohash",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.geohash" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zpopmax",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.zpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangeWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.zrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.<init>",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullParameter",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectAsync",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.scheduleAtFixedRate",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.activateTopologyRefreshIfNeeded" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()} first, otherwise the connect\n * will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectAsync(RedisCodec<K, V> codec) {\n}", "/**\n * Create a clustered pub/sub connection with command distributor.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a new connection\n */\nprivate <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectClusterAsync(RedisCodec<K, V> codec) {\n    if (partitions == null) {\n    return Futures.failed(new IllegalStateException(\"Partitions not initialized. Initialize via RedisClusterClient.getPartitions().\"));\n}\n    topologyRefreshScheduler.activateTopologyRefreshIfNeeded()\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.event.metrics.DefaultCommandLatencyEventPublisher.<init>",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.scheduleAtFixedRate",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.event.metrics.DefaultCommandLatencyEventPublisher.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connect",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.scheduleAtFixedRate",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connect", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.activateTopologyRefreshIfNeeded" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterConnection<K, V> connect(RedisCodec<K, V> codec) {\n}", "/**\n * Create a clustered pub/sub connection with command distributor.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a new connection\n */\nprivate <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectClusterAsync(RedisCodec<K, V> codec) {\n    if (partitions == null) {\n    return Futures.failed(new IllegalStateException(\"Partitions not initialized. Initialize via RedisClusterClient.getPartitions().\"));\n}\n    topologyRefreshScheduler.activateTopologyRefreshIfNeeded()\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.scheduleAtFixedRate",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.activateTopologyRefreshIfNeeded" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to\n * encode/decode keys and values. Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()}\n * first, otherwise the connect will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec) {\n}", "/**\n * Create a clustered connection with command distributor.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a new connection\n */\nprivate <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectClusterPubSubAsync(RedisCodec<K, V> codec) {\n    if (partitions == null) {\n    return Futures.failed(new IllegalStateException(\"Partitions not initialized. Initialize via RedisClusterClient.getPartitions().\"));\n}\n    topologyRefreshScheduler.activateTopologyRefreshIfNeeded()\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.scheduleAtFixedRate",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSub", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync", "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.activateTopologyRefreshIfNeeded" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to encode/decode keys and\n * values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n}", "/**\n * Create a clustered connection with command distributor.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a new connection\n */\nprivate <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectClusterPubSubAsync(RedisCodec<K, V> codec) {\n    if (partitions == null) {\n    return Futures.failed(new IllegalStateException(\"Partitions not initialized. Initialize via RedisClusterClient.getPartitions().\"));\n}\n    topologyRefreshScheduler.activateTopologyRefreshIfNeeded()\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete",
    "thirdPartyMethod" : "io.netty.channel.Channel.eventLoop",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.doComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.potentiallyRequeueCommands" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void operationComplete(Future<Void> future) {\n    try {\n        doComplete(future);\n    } finally {\n        recycle();\n    }\n}", "private void doComplete(Future<Void> future) {\n    Throwable cause = future.cause();\n    boolean success = future.isSuccess();\n    dequeue();\n    if (success) {\n        return;\n    }\n    if (((cause instanceof EncoderException) || (cause instanceof Error)) || (cause.getCause() instanceof Error)) {\n        complete(cause);\n        return;\n    }\n    Channel channel = endpoint.channel;\n    // Capture values before recycler clears these.\n    RedisCommand<?, ?, ?> sentCommand = this.sentCommand;\n    Collection<? extends RedisCommand<?, ?, ?>> sentCommands = this.sentCommands;\n    potentiallyRequeueCommands(channel, sentCommand, sentCommands);\n    if (!(cause instanceof ClosedChannelException)) {\n        String message = \"Unexpected exception during request: {}\";\n        InternalLogLevel logLevel = InternalLogLevel.WARN;\n        if ((cause instanceof IOException) && SUPPRESS_IO_EXCEPTION_MESSAGES.contains(cause.getMessage())) {\n            logLevel = InternalLogLevel.DEBUG;\n        }\n        logger.log(logLevel, message, cause.toString(), cause);\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.channel.Channel.eventLoop",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.MicrometerTracing.MicrometerSpan.error",
    "thirdPartyMethod" : "io.micrometer.observation.Observation.error",
    "thirdPartyPackage" : "io.micrometer.observation",
    "path" : [ "io.lettuce.core.tracing.MicrometerTracing.MicrometerSpan.error" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isDone",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.internal.Futures.adapt",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isDone",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.internal.Futures.adapt" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isDone",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isDone",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "/**\n * Shutdown the {@link ClientResources}.\n *\n * @param quietPeriod\n * \t\tthe quiet period as described in the documentation\n * @param timeout\n * \t\tthe maximum amount of time to wait until the executor is shutdown regardless if a task was submitted\n * \t\tduring the quiet period\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}\n * @return eventually the success/failure of the shutdown without errors.\n */\n@SuppressWarnings(\"unchecked\")\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.internal.Futures.toCompletionStage",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isDone",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.internal.Futures.toCompletionStage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.buffer.ByteBufAllocator.buffer",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRegistered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBufAllocator.buffer",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBufAllocator.buffer",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.KeyArgument.encode", "io.lettuce.core.protocol.CommandArgs.encode" ],
    "methodSlices" : [ "/**\n * Encode the {@link CommandArgs} and write the arguments to the {@link ByteBuf}.\n *\n * @param buf\n * \t\tthe target buffer.\n */\npublic void encode(ByteBuf buf) {\n    buf.touch(\"CommandArgs.encode()\");\n    for (SingularArgument singularArgument : singularArguments) {\n        singularArgument.encode(buf);\n    }\n}", "@SuppressWarnings(\"unchecked\")\n@Override\nvoid encode(ByteBuf target) {\n    if (codec instanceof ToByteBufEncoder) {\n        CommandArgs.encode(target, ((ToByteBufEncoder<K, K>) (codec)), key, ToByteBufEncoder::encodeKey);\n        return;\n    }\n    ByteBufferArgument.writeByteBuffer(target, codec.encodeKey(key));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive", "io.lettuce.core.ConnectionEventTrigger.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyException",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyException", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic void notifyException(Throwable t) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ChannelGroupListener.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ChannelGroupListener.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.rebind" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.Channel.attr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.initialState",
    "thirdPartyMethod" : "io.netty.channel.ChannelFuture.syncUninterruptibly",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.initialState" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.channel.unix.DomainSocketAddress.<init>",
    "thirdPartyPackage" : "io.netty.channel.unix",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newSocketAddress" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.IOUringResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.channel.unix.DomainSocketAddress.<init>",
    "thirdPartyPackage" : "io.netty.channel.unix",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.IOUringResources.newSocketAddress" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.EpollResources.newSocketAddress",
    "thirdPartyMethod" : "io.netty.channel.unix.DomainSocketAddress.<init>",
    "thirdPartyPackage" : "io.netty.channel.unix",
    "path" : [ "io.lettuce.core.resource.EpollProvider.EpollResources.newSocketAddress" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.OnComplete.run",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onComplete",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.OnComplete.run" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.complete",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onComplete",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.complete", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnComplete", "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.RedisPublisher.RedisSubscription.onDataAvailable", "io.lettuce.core.RedisPublisher.State.onDataAvailable", "io.lettuce.core.RedisPublisher.State.read", "io.lettuce.core.RedisPublisher.State.onAllDataRead" ],
    "methodSlices" : [ "@Override\npublic void complete() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.complete();\n        doOnComplete();\n        notifyConsumers(consumers);\n    }\n}", "@Override\n@SuppressWarnings({ \"unchecked\", \"CastCanBeRemovedNarrowingVariableType\" })\nprotected void doOnComplete() {\n    if (getOutput() != null) {\n        Object result = getOutput().get();\n        if (getOutput().hasError()) {\n            onError(ExceptionFactory.createExecutionException(getOutput().getError()));\n            return;\n        }\n        if ((!(getOutput() instanceof StreamingOutput<?>)) && (result != null)) {\n            if (dissolve && (result instanceof Collection)) {\n                Collection<T> collection = ((Collection<T>) (result));\n                for (T t : collection) {\n                    if (t != null) {\n                        subscription.onNext(t);\n                    }\n                }\n            } else {\n                subscription.onNext(((T) (result)));\n            }\n        }\n    }\n    subscription.onAllDataRead();\n}", "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}", "/**\n * Called via a listener interface to indicate that reading is possible.\n */\nfinal void onDataAvailable() {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} onDataAvailable()\", state);\n    }\n    state.onDataAvailable(this);\n}", "", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.request",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onComplete",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.request", "io.lettuce.core.RedisPublisher.State.request", "io.lettuce.core.RedisPublisher.State.onDataAvailable", "io.lettuce.core.RedisPublisher.State.read", "io.lettuce.core.RedisPublisher.State.onAllDataRead" ],
    "methodSlices" : [ "/**\n * Signal for data demand.\n *\n * @param n\n * \t\tnumber of requested elements.\n */\n@Override\npublic final void request(long n) {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} request: {}\", state, n);\n    }\n    state.request(this, n);\n}", "", null, null ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "org.reactivestreams.Subscriber.onComplete",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.RedisPublisher.RedisSubscription.onDataAvailable", "io.lettuce.core.RedisPublisher.State.onDataAvailable", "io.lettuce.core.RedisPublisher.State.read", "io.lettuce.core.RedisPublisher.State.onAllDataRead" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}", "/**\n * Called via a listener interface to indicate that reading is possible.\n */\nfinal void onDataAvailable() {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} onDataAvailable()\", state);\n    }\n    state.onDataAvailable(this);\n}", null, null ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisStateMachine.Resp2LongProcessor.getValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.forEachByte",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.RedisStateMachine.Resp2LongProcessor.getValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrElse",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlinx.coroutines.reactive.AwaitKt.awaitFirstOrElse",
    "thirdPartyPackage" : "kotlinx.coroutines.reactive",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.isAvailable",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.isAvailable", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return {@code true} if io_uring is available.\n */\npublic static boolean isAvailable() {\n    return IOURING_AVAILABLE && IOURING_ENABLED;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.socketChannelClass",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.Transports.socketChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link Channel} for socket (network/TCP) transport.\n */\npublic static Class<? extends Channel> socketChannelClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport {@link EventLoopGroup} class. Defaults to TCP sockets. See\n{@link #eventLoopGroupClass(boolean)} to request a specific EventLoopGroup for Domain Socket usage.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n    return eventLoopGroupClass(false);\n}", "/**\n *\n * @return the native transport {@link EventLoopGroup} class.\n * @param domainSocket\n * \t\t{@code true} to indicate Unix Domain Socket usage, {@code false} otherwise.\n * @since 6.3.3\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass(boolean domainSocket) {\n    return (domainSocket && EpollProvider.isAvailable()) && IOUringProvider.isAvailable() ? EpollProvider.getResources().eventLoopGroupClass() : RESOURCES.eventLoopGroupClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Create an instance of a {@link EventExecutorGroup} using the default {@link ThreadFactoryProvider}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n */\npublic static <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads) {\n}", "/**\n * Create an instance of a {@link EventExecutorGroup}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n * @since 5.3\n */\nstatic <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider factoryProvider) {\n    logger.debug(\"Creating executor {}\", type.getName());\n    if (DefaultEventExecutorGroup.class.equals(type)) {\n        return new DefaultEventExecutorGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-eventExecutorLoop\"));\n    }\n    if (NioEventLoopGroup.class.equals(type)) {\n        return new NioEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-nioEventLoop\"));\n    }\n    if (EpollProvider.isAvailable()) {\n        EventLoopResources resources = EpollProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-epollEventLoop\"));\n        }\n    }\n    if (KqueueProvider.isAvailable()) {\n        EventLoopResources resources = KqueueProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-kqueueEventLoop\"));\n        }\n    }\n    if (IOUringProvider.isAvailable()) {\n        EventLoopResources resources = IOUringProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-io_uringEventLoop\"));\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"Type %s not supported\", type.getName()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.eventLoopGroupClass", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport {@link EventLoopGroup} class.\n * @param domainSocket\n * \t\t{@code true} to indicate Unix Domain Socket usage, {@code false} otherwise.\n * @since 6.3.3\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass(boolean domainSocket) {\n    return (domainSocket && EpollProvider.isAvailable()) && IOUringProvider.isAvailable() ? EpollProvider.getResources().eventLoopGroupClass() : RESOURCES.eventLoopGroupClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.Transports.datagramChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link DatagramChannel} for socket (network/UDP) transport.\n */\npublic static Class<? extends DatagramChannel> datagramChannelClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.Builder.build",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.Builder.build", "io.lettuce.core.resource.DefaultClientResources.<init>", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return a new instance of {@link DefaultClientResources}.\n */\n@Override\npublic DefaultClientResources build() {\n    DefaultClientResources resources = new DefaultClientResources(this);\n    if (this.afterBuild != null) {\n        this.afterBuild.run();\n    }\n    return resources;\n}", "protected DefaultClientResources(Builder builder) {\n}", "/**\n * Create an instance of a {@link EventExecutorGroup}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n * @since 5.3\n */\nstatic <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider factoryProvider) {\n    logger.debug(\"Creating executor {}\", type.getName());\n    if (DefaultEventExecutorGroup.class.equals(type)) {\n        return new DefaultEventExecutorGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-eventExecutorLoop\"));\n    }\n    if (NioEventLoopGroup.class.equals(type)) {\n        return new NioEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-nioEventLoop\"));\n    }\n    if (EpollProvider.isAvailable()) {\n        EventLoopResources resources = EpollProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-epollEventLoop\"));\n        }\n    }\n    if (KqueueProvider.isAvailable()) {\n        EventLoopResources resources = KqueueProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-kqueueEventLoop\"));\n        }\n    }\n    if (IOUringProvider.isAvailable()) {\n        EventLoopResources resources = IOUringProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-io_uringEventLoop\"));\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"Type %s not supported\", type.getName()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.allocate", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.getOrCreate", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.doCreateEventLoopGroup", "io.lettuce.core.resource.DefaultEventLoopGroupProvider.createEventLoopGroup", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "@Override\npublic <T extends EventLoopGroup> T allocate(Class<T> type) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <T extends EventLoopGroup> T getOrCreate(Class<T> type) {\n}", "/**\n * Customization hook for {@link EventLoopGroup} creation.\n *\n * @param <T>\n * @param type\n * \t\trequested event loop group type.\n * @param numberOfThreads\n * \t\tnumber of threads to create.\n * @param threadFactoryProvider\n * \t\tprovider for {@link ThreadFactory}.\n * @return  * @since 6.0\n */\nprotected <T extends EventLoopGroup> EventExecutorGroup doCreateEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider threadFactoryProvider) {\n}", "/**\n * Create an instance of a {@link EventExecutorGroup}. Supported types are:\n * <ul>\n * <li>DefaultEventExecutorGroup</li>\n * <li>NioEventLoopGroup</li>\n * <li>EpollEventLoopGroup</li>\n * <li>KqueueEventLoopGroup</li>\n * </ul>\n *\n * @param type\n * \t\tthe type\n * @param numberOfThreads\n * \t\tthe number of threads to use for the {@link EventExecutorGroup}\n * @param <T>\n * \t\ttype parameter\n * @return a new instance of a {@link EventExecutorGroup}\n * @throws IllegalArgumentException\n * \t\tif the {@code type} is not supported.\n * @since 5.3\n */\nstatic <T extends EventExecutorGroup> EventExecutorGroup createEventLoopGroup(Class<T> type, int numberOfThreads, ThreadFactoryProvider factoryProvider) {\n    logger.debug(\"Creating executor {}\", type.getName());\n    if (DefaultEventExecutorGroup.class.equals(type)) {\n        return new DefaultEventExecutorGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-eventExecutorLoop\"));\n    }\n    if (NioEventLoopGroup.class.equals(type)) {\n        return new NioEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-nioEventLoop\"));\n    }\n    if (EpollProvider.isAvailable()) {\n        EventLoopResources resources = EpollProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-epollEventLoop\"));\n        }\n    }\n    if (KqueueProvider.isAvailable()) {\n        EventLoopResources resources = KqueueProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-kqueueEventLoop\"));\n        }\n    }\n    if (IOUringProvider.isAvailable()) {\n        EventLoopResources resources = IOUringProvider.getResources();\n        if (resources.matches(type)) {\n            return resources.newEventLoopGroup(numberOfThreads, factoryProvider.getThreadFactory(\"lettuce-io_uringEventLoop\"));\n        }\n    }\n    throw new IllegalArgumentException(String.format(\"Type %s not supported\", type.getName()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Initialize the {@link Bootstrap}.\n *\n * @since 6.1\n */\npublic void configureBootstrap(boolean domainSocket, Function<Class<? extends EventLoopGroup>, EventLoopGroup> eventLoopGroupProvider) {\n    LettuceAssert.assertState(bootstrap != null, \"Bootstrap must be set\");\n    LettuceAssert.assertState(clientOptions != null, \"ClientOptions must be set\");\n    Class<? extends EventLoopGroup> eventLoopGroupClass = Transports.eventLoopGroupClass();\n    Class<? extends Channel> channelClass = Transports.socketChannelClass();\n    if (domainSocket) {\n        Transports.NativeTransports.assertDomainSocketAvailable();\n        eventLoopGroupClass = Transports.NativeTransports.eventLoopGroupClass(true);\n        channelClass = Transports.NativeTransports.domainSocketChannelClass();\n    } else {\n        bootstrap.resolver(clientResources.addressResolverGroup());\n    }\n    SocketOptions options = clientOptions.getSocketOptions();\n    EventLoopGroup eventLoopGroup = eventLoopGroupProvider.apply(eventLoopGroupClass);\n    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.toIntExact(options.getConnectTimeout().toMillis()));\n    if (!domainSocket) {\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, options.isKeepAlive());\n        bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());\n        if (options.isEnableTcpUserTimeout()) {\n            SocketOptions.TcpUserTimeoutOptions tcpUserTimeoutOptions = options.getTcpUserTimeout();\n            boolean applied = false;\n            if (IOUringProvider.isAvailable()) {\n                IOUringProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            } else if (EpollProvider.isAvailable()) {\n                EpollProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            }\n            LettuceAssert.assertState(applied, \"TCP User Timeout options could not be applied. Native transports (io_uring or epoll) are required.\");\n        }\n    }\n    bootstrap.channel(channelClass).group(eventLoopGroup);\n    if (options.isKeepAlive() && options.isExtendedKeepAlive()) {\n        SocketOptions.KeepAliveOptions keepAlive = options.getKeepAlive();\n        boolean applied = false;\n        if (IOUringProvider.isAvailable()) {\n            IOUringProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (EpollProvider.isAvailable()) {\n            EpollProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (ExtendedNioSocketOptions.isAvailable() && (!KqueueProvider.isAvailable())) {\n            ExtendedNioSocketOptions.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        }\n        LettuceAssert.assertState(applied, \"Extended TCP keepalive options could not be applied. Native transports (io_uring or epoll) or a compatible NIO transport are required.\");\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.getResources",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.getResources", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns the {@link EventLoopResources} for io_uring-backed transport. Check availability with {@link #isAvailable()}\n * prior to obtaining the resources.\n *\n * @return the {@link EventLoopResources}. May be unavailable.\n */\npublic static EventLoopResources getResources() {\n    return IOURING_RESOURCES;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.Transports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link EventLoopGroup} for socket transport that is compatible with {@link #socketChannelClass()}.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n}", "/**\n *\n * @return {@code true} if a native transport is available.\n */\nstatic boolean isAvailable() {\n    if (EpollProvider.isAvailable() && IOUringProvider.isAvailable()) {\n        transportsLogger.warn(\"Both epoll and io_uring native transports are available, epoll has been prioritized.\");\n    }\n    return (EpollProvider.isAvailable() || KqueueProvider.isAvailable()) || IOUringProvider.isAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.assertDomainSocketAvailable",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.assertDomainSocketAvailable", "io.lettuce.core.resource.Transports.NativeTransports.<clinit>", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "public static void assertDomainSocketAvailable() {\n    LettuceAssert.assertState(NativeTransports.isDomainSocketSupported(), \"A unix domain socket connection requires epoll or kqueue and neither is available\");\n}", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.NativeTransports.domainSocketChannelClass",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUring.isAvailable",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.Transports.NativeTransports.domainSocketChannelClass", "io.lettuce.core.resource.IOUringProvider.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return the native transport domain socket {@link Channel} class.\n */\npublic static Class<? extends Channel> domainSocketChannelClass() {\n    assertDomainSocketAvailable();\n    return EpollProvider.isAvailable() && IOUringProvider.isAvailable() ? EpollProvider.getResources().domainSocketChannelClass() : RESOURCES.domainSocketChannelClass();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisAuthenticationHandler.unsubscribe",
    "thirdPartyMethod" : "reactor.core.Disposable.dispose",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisAuthenticationHandler.unsubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisAuthenticationHandler.subscribe",
    "thirdPartyMethod" : "reactor.core.Disposable.dispose",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisAuthenticationHandler.subscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3MaybeToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createMono",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createMono" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2SingleToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3CompletableToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3CompletableToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2CompletableToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2CompletableToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2MaybeToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3SingleToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1CompletableToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1CompletableToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToMonoAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.from",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToMonoAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint",
    "thirdPartyMethod" : "brave.Span.remoteServiceName",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "redis.clients.authentication.core.TokenAuthConfig.getTokenManagerConfig",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "redis.clients.authentication.core.TokenManager.<init>",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.group",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint",
    "thirdPartyMethod" : "zipkin2.Endpoint.portAsInt",
    "thirdPartyPackage" : "zipkin2",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "org.reactivestreams.Subscription.cancel",
    "thirdPartyPackage" : "org.reactivestreams",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.Operators.onOperatorError" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.sam.java_util_function_Function.apply",
    "thirdPartyMethod" : "kotlin.jvm.functions.Function1.invoke",
    "thirdPartyPackage" : "kotlin.jvm.functions",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.sam.java_util_function_Function.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.sync.RedisSyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.jvm.functions.Function1.invoke",
    "thirdPartyPackage" : "kotlin.jvm.functions",
    "path" : [ "io.lettuce.core.api.sync.RedisSyncCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.jvm.functions.Function1.invoke",
    "thirdPartyPackage" : "kotlin.jvm.functions",
    "path" : [ "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.jvm.functions.Function1.invoke",
    "thirdPartyPackage" : "kotlin.jvm.functions",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.sam.java_util_function_Function.apply",
    "thirdPartyMethod" : "kotlin.jvm.functions.Function1.invoke",
    "thirdPartyPackage" : "kotlin.jvm.functions",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.sam.java_util_function_Function.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.output.VSimScoreAttribsMapOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.VSimScoreAttribsMapOutput.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.socketChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.socketChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link Channel} for socket (network/TCP) transport.\n */\npublic static Class<? extends Channel> socketChannelClass() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SpellCheckResultParser.SpellCheckResp3Parser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SpellCheckResultParser.SpellCheckResp3Parser.parse" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.datagramChannelClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.datagramChannelClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link DatagramChannel} for socket (network/UDP) transport.\n */\npublic static Class<? extends DatagramChannel> datagramChannelClass() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.ValueDoubleMapOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.ValueDoubleMapOutput.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.output.VectorMetadataParser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.VectorMetadataParser.parse", "io.lettuce.core.output.VectorMetadataParser.verifyStructure" ],
    "methodSlices" : [ "/**\n * Parse the output of the Redis VINFO command and convert it to a {@link VectorMetadata} object.\n * <p>\n * The VINFO command returns an array of key-value pairs, where each pair consists of a field name followed by its value.\n * This method extracts the relevant fields and populates a {@link VectorMetadata} object with the corresponding values.\n *\n * @param dynamicData\n * \t\toutput of VINFO command\n * @return a {@link VectorMetadata} instance containing the parsed information\n * @throws IllegalArgumentException\n * \t\tif the input data is null, empty, or has an invalid format\n */\n@Override\npublic VectorMetadata parse(ComplexData dynamicData) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.VSimScoreAttribsMapOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.VSimScoreAttribsMapOutput.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisAuthenticationHandler.subscribe",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisAuthenticationHandler.subscribe", "io.lettuce.core.RedisAuthenticationHandler.isSupportedConnection" ],
    "methodSlices" : [ "/**\n * This method subscribes to a stream of credentials provided by the `StreamingCredentialsProvider`.\n * <p>\n * Each time new credentials are received, the client is re-authenticated. The previous subscription, if any, is disposed of\n * before setting the new subscription.\n */\npublic void subscribe() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.Transports.eventLoopGroupClass",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.Transports.eventLoopGroupClass", "io.lettuce.core.resource.Transports.NativeTransports.isAvailable" ],
    "methodSlices" : [ "/**\n *\n * @return the default {@link EventLoopGroup} for socket transport that is compatible with {@link #socketChannelClass()}.\n */\npublic static Class<? extends EventLoopGroup> eventLoopGroupClass() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.output.ValueDoubleMapOutput.set",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.output.ValueDoubleMapOutput.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.search.SpellCheckResultParser.SpellCheckResp2Parser.parse",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.search.SpellCheckResultParser.SpellCheckResp2Parser.parse" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.closeAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.warn",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.closeAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNull",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNull",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.cancel",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isErrorEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.cancel", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnError", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "@Override\npublic void cancel() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.cancel();\n        CancellationException exception = new CancellationException();\n        doOnError(exception);\n        notifyBiConsumer(consumers, exception);\n    }\n}", "@Override\nprotected void doOnError(Throwable throwable) {\n    onError(throwable);\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.complete",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isErrorEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.complete", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnComplete", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "@Override\npublic void complete() {\n    Object[] consumers = ONCOMPLETE.get(this);\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        command.complete();\n        doOnComplete();\n        notifyConsumers(consumers);\n    }\n}", "@Override\n@SuppressWarnings({ \"unchecked\", \"CastCanBeRemovedNarrowingVariableType\" })\nprotected void doOnComplete() {\n    if (getOutput() != null) {\n        Object result = getOutput().get();\n        if (getOutput().hasError()) {\n            onError(ExceptionFactory.createExecutionException(getOutput().getError()));\n            return;\n        }\n        if ((!(getOutput() instanceof StreamingOutput<?>)) && (result != null)) {\n            if (dissolve && (result instanceof Collection)) {\n                Collection<T> collection = ((Collection<T>) (result));\n                for (T t : collection) {\n                    if (t != null) {\n                        subscription.onNext(t);\n                    }\n                }\n            } else {\n                subscription.onNext(((T) (result)));\n            }\n        }\n    }\n    subscription.onAllDataRead();\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.request",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isErrorEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.request", "io.lettuce.core.RedisPublisher.State.request", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "/**\n * Signal for data demand.\n *\n * @param n\n * \t\tnumber of requested elements.\n */\n@Override\npublic final void request(long n) {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} request: {}\", state, n);\n    }\n    state.request(this, n);\n}", null ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandWrapper.completeExceptionally",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isErrorEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandWrapper.completeExceptionally", "io.lettuce.core.RedisPublisher.SubscriptionCommand.doOnError", "io.lettuce.core.RedisPublisher.SubscriptionCommand.onError", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "@Override\npublic boolean completeExceptionally(Throwable throwable) {\n    Object[] consumers = ONCOMPLETE.get(this);\n    boolean result = false;\n    if ((consumers != COMPLETE) && ONCOMPLETE.compareAndSet(this, consumers, COMPLETE)) {\n        result = command.completeExceptionally(throwable);\n        doOnError(throwable);\n        notifyBiConsumer(consumers, throwable);\n    }\n    return result;\n}", "@Override\nprotected void doOnError(Throwable throwable) {\n    onError(throwable);\n}", "private void onError(Throwable throwable) {\n    subscription.onError(throwable);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isErrorEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.RedisPublisher.RedisSubscription.onError" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.computationThreadPoolSize",
    "thirdPartyMethod" : "io.netty.util.concurrent.EventExecutorGroup.iterator",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.computationThreadPoolSize" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaTopologyRefresh.getNodes",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaTopologyRefresh.getNodes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava1SingleAdapter.apply",
    "thirdPartyMethod" : "rx.RxReactiveStreams.toSingle",
    "thirdPartyPackage" : "rx",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.PublisherToRxJava1SingleAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.hscan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.hscan", "io.lettuce.core.ScanStream.hscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over entries in a hash identified by {@code key}. This method uses {@code HSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe hash to scan.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<KeyValue<K, V>> hscan(RedisHashReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.hscanNovalues",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.hscanNovalues", "io.lettuce.core.ScanStream.hscanNovalues" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over keys in a hash identified by {@code key}. This method uses {@code HSCAN NOVALUES} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe hash to scan.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n * @since 6.4\n */\npublic static <K, V> Flux<K> hscanNovalues(RedisHashReactiveCommands<K, V> commands, K key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.sscan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.sscan", "io.lettuce.core.ScanStream.sscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over elements in a set identified by {@code key}. This method uses {@code SSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe set to scan.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<V> sscan(RedisSetReactiveCommands<K, V> commands, K key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.zscan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.zscan", "io.lettuce.core.ScanStream.zscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over elements in a set identified by {@code key}. This method uses {@code SSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe sorted set to scan.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<ScoredValue<V>> zscan(RedisSortedSetReactiveCommands<K, V> commands, K key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.zscan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.zscan", "io.lettuce.core.ScanStream.zscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over elements in a set identified by {@code key}. This method uses {@code SSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe sorted set to scan.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<ScoredValue<V>> zscan(RedisSortedSetReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.hscan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.hscan", "io.lettuce.core.ScanStream.hscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over entries in a hash identified by {@code key}. This method uses {@code HSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe hash to scan.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<KeyValue<K, V>> hscan(RedisHashReactiveCommands<K, V> commands, K key) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.scan", "io.lettuce.core.ScanStream.scan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over keys in the keyspace. This method uses {@code SCAN} to perform an iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<K> scan(RedisKeyReactiveCommands<K, V> commands) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.sscan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.sscan", "io.lettuce.core.ScanStream.sscan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over elements in a set identified by {@code key}. This method uses {@code SSCAN} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe set to scan.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<V> sscan(RedisSetReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.scan",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.scan", "io.lettuce.core.ScanStream.scan" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over keys in the keyspace. This method uses {@code SCAN} to perform an iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n */\npublic static <K, V> Flux<K> scan(RedisKeyReactiveCommands<K, V> commands, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanStream.hscanNovalues",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.expand",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.ScanStream.hscanNovalues", "io.lettuce.core.ScanStream.hscanNovalues" ],
    "methodSlices" : [ "/**\n * Sequentially iterate over keys in a hash identified by {@code key}. This method uses {@code HSCAN NOVALUES} to perform an\n * iterative scan.\n *\n * @param commands\n * \t\tthe commands interface, must not be {@code null}.\n * @param key\n * \t\tthe hash to scan.\n * @param scanArgs\n * \t\tthe scan arguments, must not be {@code null}.\n * @param <K>\n * \t\tKey type.\n * @param <V>\n * \t\tValue type.\n * @return a new {@link Flux}.\n * @since 6.4\n */\npublic static <K, V> Flux<K> hscanNovalues(RedisHashReactiveCommands<K, V> commands, K key, ScanArgs scanArgs) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive", "io.lettuce.core.ConnectionEventTrigger.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyException",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyException", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic void notifyException(Throwable t) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ChannelGroupListener.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ChannelGroupListener.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete",
    "thirdPartyMethod" : "io.netty.util.Attribute.get",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.build",
    "thirdPartyMethod" : "io.netty.channel.ChannelInitializer.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionBuilder.build", "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.<init>" ],
    "methodSlices" : [ "public ChannelInitializer<Channel> build(SocketAddress socketAddress) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.<init>",
    "thirdPartyMethod" : "io.netty.channel.ChannelInitializer.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.fromCompletionStage",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync", "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.<init>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsync() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandEncoder.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandEncoder.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @param threadFactoryProvider\n * \t\tprovides a {@link java.util.concurrent.ThreadFactory} to create threads.\n * @return a new instance of default client resources.\n * @since 6.1.1\n */\nstatic ClientResources create(ThreadFactoryProvider threadFactoryProvider) {\n    return DefaultClientResources.builder().threadFactoryProvider(threadFactoryProvider).build();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(ClientResources clientResources, RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link DefaultClientResources} using default settings.\n *\n * @return a new instance of a default client resources.\n */\npublic static DefaultClientResources create() {\n    return builder().build();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURIs\n * \t\tone or more Redis URI, must not be {@code null} and not empty.\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(Iterable<RedisURI> redisURIs) {\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    return new RedisClusterClient(null, redisURIs);\n}", "/**\n * Initialize the client with a list of cluster URI's. All uris are tried in sequence for connecting initially to the\n * cluster. If any uri is successful for connection, the others are not tried anymore. The initial uri is needed to discover\n * the cluster structure for distributing the requests.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n * @param redisURIs\n * \t\titerable of initial {@link RedisURI cluster URIs}. Must not be {@code null} and not empty.\n */\nprotected RedisClusterClient(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    super(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    this.initialUris = Collections.unmodifiableList(LettuceLists.newList(redisURIs));\n    this.refresh = createTopologyRefresh();\n    setOptions(ClusterClientOptions.create());\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisStateMachine.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.RedisStateMachine.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.Operators.request",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.Operators.request", "io.lettuce.core.Operators.validate", "io.lettuce.core.Operators.reportBadRequest" ],
    "methodSlices" : [ "/**\n * Concurrent addition bound to Long.MAX_VALUE. Any concurrent write will \"happen before\" this operation.\n *\n * @param <T>\n * \t\tthe parent instance type\n * @param updater\n * \t\tcurrent field updater\n * @param instance\n * \t\tcurrent instance to update\n * @param toAdd\n * \t\tdelta to add\n * @return {@code true} if the operation succeeded.\n * @since 5.0.1\n */\npublic static <T> boolean request(AtomicLongFieldUpdater<T> updater, T instance, long toAdd) {\n}", "/**\n * Evaluate if a request is strictly positive otherwise {@link #reportBadRequest(long)}\n *\n * @param n\n * \t\tthe request value\n * @return true if valid\n */\nstatic boolean validate(long n) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.builder",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.builder", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns a new {@link DefaultClientResources.Builder} to construct {@link DefaultClientResources}.\n *\n * @return a new {@link DefaultClientResources.Builder} to construct {@link DefaultClientResources}.\n */\npublic static DefaultClientResources.Builder builder() {\n}", "private Builder() {\n}", "private Builder() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.create", "io.lettuce.core.cluster.RedisClusterClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with shared {@link ClientResources}. You need to\n * shut down the {@link ClientResources} upon shutting down your application.You can connect to different Redis servers but\n * you must supply a {@link RedisURI} on connecting.\n *\n * @param clientResources\n * \t\tthe client resources, must not be {@code null}\n * @param redisURIs\n * \t\tone or more Redis URI, must not be {@code null} and not empty\n * @return a new instance of {@link RedisClusterClient}\n */\npublic static RedisClusterClient create(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    assertNotNull(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    return new RedisClusterClient(clientResources, redisURIs);\n}", "/**\n * Initialize the client with a list of cluster URI's. All uris are tried in sequence for connecting initially to the\n * cluster. If any uri is successful for connection, the others are not tried anymore. The initial uri is needed to discover\n * the cluster structure for distributing the requests.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n * @param redisURIs\n * \t\titerable of initial {@link RedisURI cluster URIs}. Must not be {@code null} and not empty.\n */\nprotected RedisClusterClient(ClientResources clientResources, Iterable<RedisURI> redisURIs) {\n    super(clientResources);\n    assertNotEmpty(redisURIs);\n    assertSameOptions(redisURIs);\n    this.initialUris = Collections.unmodifiableList(LettuceLists.newList(redisURIs));\n    this.refresh = createTopologyRefresh();\n    setOptions(ClusterClientOptions.create());\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new client that connects to the supplied {@link RedisURI uri} with default {@link ClientResources}. You can\n * connect to different Redis servers but you must supply a {@link RedisURI} on connecting.\n *\n * @param redisURI\n * \t\tthe Redis URI, must not be {@code null}\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create(RedisURI redisURI) {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.mutate",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.mutate", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.Builder.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Returns a builder to create new {@link DefaultClientResources} whose settings are replicated from the current\n * {@link DefaultClientResources}.\n * <p>\n * Note: The resulting {@link DefaultClientResources} retains shared state for {@link Timer},\n * {@link CommandLatencyRecorder}, {@link EventExecutorGroup}, and {@link EventLoopGroupProvider} if these are left\n * unchanged. Thus, you need only to shut down the last created {@link ClientResources} instances. Shutdown affects any\n * previously created {@link ClientResources}.\n * </p>\n *\n * @return a {@link DefaultClientResources.Builder} to create new {@link DefaultClientResources} whose settings are\nreplicated from the current {@link DefaultClientResources}.\n * @since 5.1\n */\n@Override\npublic DefaultClientResources.Builder mutate() {\n}", "private Builder() {\n}", "private Builder() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisClient.create", "io.lettuce.core.RedisClient.<init>", "io.lettuce.core.AbstractRedisClient.<init>", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Creates a uri-less RedisClient with default {@link ClientResources}. You can connect to different Redis servers but you\n * must supply a {@link RedisURI} on connecting. Methods without having a {@link RedisURI} will fail with a\n * {@link java.lang.IllegalStateException}.\n *\n * @return a new instance of {@link RedisClient}\n */\npublic static RedisClient create() {\n}", "protected RedisClient(ClientResources clientResources, RedisURI redisURI) {\n    super(clientResources);\n    assertNotNull(redisURI);\n    this.redisURI = redisURI;\n}", "/**\n * Create a new instance with client resources.\n *\n * @param clientResources\n * \t\tthe client resources. If {@code null}, the client will create a new dedicated instance of client\n * \t\tresources and keep track of them.\n */\nprotected AbstractRedisClient(ClientResources clientResources) {\n    if (clientResources == null) {\n        this.sharedResources = false;\n        this.clientResources = DefaultClientResources.create();\n    } else {\n        this.sharedResources = true;\n        this.clientResources = clientResources;\n    }\n    this.channels = new DefaultChannelGroup(this.clientResources.eventExecutorGroup().next());\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.run",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.cluster.ClusterTopologyRefreshScheduler.ClusterTopologyRefreshTask.run" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.builder",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.builder", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @return a new instance of a default client resources.\n */\nstatic Builder builder() {\n    return DefaultClientResources.builder();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelConnector.connectAsync",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.masterreplica.SentinelConnector.connectAsync", "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.<init>" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<StatefulRedisMasterReplicaConnection<K, V>> connectAsync() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisChannelHandler.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisChannelHandler.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.Builder.build",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.Builder.build", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n *\n * @return a new instance of {@link DefaultClientResources}.\n */\n@Override\npublic DefaultClientResources build() {\n    DefaultClientResources resources = new DefaultClientResources(this);\n    if (this.afterBuild != null) {\n        this.afterBuild.run();\n    }\n    return resources;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.ClientResources.create",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.ClientResources.create", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Create a new {@link ClientResources} using default settings.\n *\n * @return a new instance of default client resources.\n */\nstatic ClientResources create() {\n    return DefaultClientResources.create();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isDebugEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown", "io.lettuce.core.resource.DefaultClientResources.<clinit>" ],
    "methodSlices" : [ "/**\n * Shutdown the {@link ClientResources}.\n *\n * @param quietPeriod\n * \t\tthe quiet period as described in the documentation\n * @param timeout\n * \t\tthe maximum amount of time to wait until the executor is shutdown regardless if a task was submitted\n * \t\tduring the quiet period\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}\n * @return eventually the success/failure of the shutdown without errors.\n */\n@SuppressWarnings(\"unchecked\")\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n    logger.debug(\"Initiate shutdown ({}, {}, {})\", quietPeriod, timeout, timeUnit);\n    shutdownCalled = true;\n    DefaultPromise<Void> voidPromise = new DefaultPromise<>(ImmediateEventExecutor.INSTANCE);\n    PromiseCombiner aggregator = new PromiseCombiner(ImmediateEventExecutor.INSTANCE);\n    if (metricEventPublisher != null) {\n        metricEventPublisher.shutdown();\n    }\n    if (!sharedTimer) {\n        timer.stop();\n    }\n    if (!sharedEventLoopGroupProvider) {\n        Future<Boolean> shutdown = eventLoopGroupProvider.shutdown(quietPeriod, timeout, timeUnit);\n        aggregator.add(shutdown);\n    }\n    if (!sharedEventExecutor) {\n        Future<?> shutdown = eventExecutorGroup.shutdownGracefully(quietPeriod, timeout, timeUnit);\n        aggregator.add(shutdown);\n    }\n    if ((!sharedCommandLatencyRecorder) && (commandLatencyRecorder instanceof MetricCollector)) {\n        ((MetricCollector<?>) (commandLatencyRecorder)).shutdown();\n    }\n    aggregator.finish(voidPromise);\n    return PromiseAdapter.toBooleanPromise(voidPromise);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DecodeBufferPolicy.afterDecoding",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardSomeReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.DecodeBufferPolicy.afterDecoding" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DecodeBufferPolicies.afterPartialDecode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardSomeReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.DecodeBufferPolicies.afterPartialDecode" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DecodeBufferPolicies.afterDecoding",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardSomeReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.DecodeBufferPolicies.afterDecoding" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DecodeBufferPolicies.afterCommandDecoded",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.discardSomeReadBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.DecodeBufferPolicies.afterCommandDecoded" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.LettuceCdiExtension.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.info",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.support.LettuceCdiExtension.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.info",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.DefaultPauseDetectorWrapper.retain" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isTraceEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isTraceEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandEncoder.<init>",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isTraceEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandEncoder.<init>" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.subscribe",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.isTraceEnabled",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.subscribe", "io.lettuce.core.RedisPublisher.RedisSubscription.<init>" ],
    "methodSlices" : [ "@Override\npublic void subscribe(Subscriber<? super T> subscriber) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushallAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.flushdb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mset",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.mset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.last",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.scriptFlush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.ImmediateSubscriber.onComplete",
    "thirdPartyMethod" : "reactor.core.CoreSubscriber.onComplete",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.ImmediateSubscriber.onComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.close",
    "thirdPartyMethod" : "redis.clients.authentication.core.TokenManager.stop",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.close" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "redis.clients.authentication.core.TokenManager.stop",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create", "io.lettuce.authx.TokenBasedRedisCredentialsProvider.init" ],
    "methodSlices" : [ "public static TokenBasedRedisCredentialsProvider create(TokenManager tokenManager) {\n    TokenBasedRedisCredentialsProvider credentialManager = new TokenBasedRedisCredentialsProvider(tokenManager);\n    credentialManager.init();\n    return credentialManager;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.request",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.request" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.subscribe",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.RedisPublisher.subscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.log",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.doComplete" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void operationComplete(Future<Void> future) {\n    try {\n        doComplete(future);\n    } finally {\n        recycle();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.release",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelUnregistered",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.release",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelUnregistered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.toString",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.release",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.release",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.release",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.KeyArgument.encode", "io.lettuce.core.protocol.CommandArgs.encode" ],
    "methodSlices" : [ "/**\n * Encode the {@link CommandArgs} and write the arguments to the {@link ByteBuf}.\n *\n * @param buf\n * \t\tthe target buffer.\n */\npublic void encode(ByteBuf buf) {\n    buf.touch(\"CommandArgs.encode()\");\n    for (SingularArgument singularArgument : singularArguments) {\n        singularArgument.encode(buf);\n    }\n}", "@SuppressWarnings(\"unchecked\")\n@Override\nvoid encode(ByteBuf target) {\n    if (codec instanceof ToByteBufEncoder) {\n        CommandArgs.encode(target, ((ToByteBufEncoder<K, K>) (codec)), key, ToByteBufEncoder::encodeKey);\n        return;\n    }\n    ByteBufferArgument.writeByteBuffer(target, codec.encodeKey(key));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.channelActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.channelActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelInboundHandlerAdapter.channelActive",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.createGenericObjectPool",
    "thirdPartyMethod" : "org.apache.commons.pool2.impl.GenericObjectPool.<init>",
    "thirdPartyPackage" : "org.apache.commons.pool2.impl",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.createGenericObjectPool", "io.lettuce.core.support.ConnectionPoolSupport.<init>" ],
    "methodSlices" : [ "/**\n * Creates a new {@link GenericObjectPool} using the {@link Supplier}.\n *\n * @param connectionSupplier\n * \t\tmust not be {@code null}.\n * @param config\n * \t\tmust not be {@code null}.\n * @param wrapConnections\n * \t\t{@code false} to return direct connections that need to be returned to the pool using\n * \t\t{@link ObjectPool#returnObject(Object)}. {@code true} to return wrapped connections that are returned to the pool\n * \t\twhen invoking {@link StatefulConnection#close()}.\n * @param validationPredicate\n * \t\ta {@link Predicate} to help validate connections\n * @param <T>\n * \t\tconnection type.\n * @return the connection pool.\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T extends StatefulConnection<?, ?>> GenericObjectPool<T> createGenericObjectPool(Supplier<T> connectionSupplier, GenericObjectPoolConfig<T> config, boolean wrapConnections, Predicate<T> validationPredicate) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.DefaultLettuceObservationConvention.getHighCardinalityKeyValues",
    "thirdPartyMethod" : "io.micrometer.common.KeyValues.empty",
    "thirdPartyPackage" : "io.micrometer.common",
    "path" : [ "io.lettuce.core.tracing.DefaultLettuceObservationConvention.getHighCardinalityKeyValues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv6SubnetRule.<init>",
    "thirdPartyMethod" : "io.netty.util.NetUtil.createByteArrayFromIpAddressString",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv6SubnetRule.<init>", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv6SubnetRule.toNetworkAddress", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv6SubnetRule.toBigInteger" ],
    "methodSlices" : [ "", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.ReadFrom.subnet",
    "thirdPartyMethod" : "io.netty.util.NetUtil.createByteArrayFromIpAddressString",
    "thirdPartyPackage" : "io.netty.util",
    "path" : [ "io.lettuce.core.ReadFrom.subnet", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.<init>", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.createSubnetRule", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv4SubnetRule.<init>", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv4SubnetRule.toNetworkAddress", "io.lettuce.core.ReadFromImpl.ReadFromSubnet.Ipv4SubnetRule.toInt" ],
    "methodSlices" : [ "/**\n * Setting to read from any node in the subnets.\n *\n * @param cidrNotations\n * \t\tCIDR-block notation strings, e.g., \"192.168.0.0/16\", \"2001:db8:abcd:0000::/52\". Must not be\n * \t\t{@code null}.\n * @return an instance of {@link ReadFromImpl.ReadFromSubnet}.\n * @since 6.1\n */\npublic static ReadFrom subnet(String... cidrNotations) {\n}", "/**\n *\n * @param cidrNotations\n * \t\tCIDR-block notation strings, e.g., \"192.168.0.0/16\" or \"2001:db8:abcd:0000::/52\".\n */\nReadFromSubnet(String... cidrNotations) {\n    LettuceAssert.notEmpty(cidrNotations, \"CIDR notations must not be empty\");\n    for (String cidrNotation : cidrNotations) {\n        rules.add(createSubnetRule(cidrNotation));\n    }\n}", "SubnetRule createSubnetRule(String cidrNotation) {\n    String[] parts = cidrNotation.split(\"/\");\n    LettuceAssert.isTrue(parts.length == 2, \"CIDR notation must have exact one '/'\");\n    String ipAddress = parts[0];\n    int cidrPrefix = Integer.parseInt(parts[1]);\n    if (NetUtil.isValidIpV4Address(ipAddress)) {\n        return new Ipv4SubnetRule(ipAddress, cidrPrefix, ipv4AddressCache);\n    } else if (NetUtil.isValidIpV6Address(ipAddress)) {\n        return new Ipv6SubnetRule(ipAddress, cidrPrefix, ipv6AddressCache);\n    } else {\n        throw new IllegalArgumentException(\"Invalid CIDR notation \" + cidrNotation);\n    }\n}", "", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursorread",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursorread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ResumeAfter.thenError",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.ResumeAfter.thenError" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterGetKeysInSlot", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.findConnectionBySlotReactive" ],
    "methodSlices" : [ "@Override\npublic Flux<K> clusterGetKeysInSlot(int slot, int count) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.clusterCountKeysInSlot", "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.findConnectionBySlotReactive" ],
    "methodSlices" : [ "@Override\npublic Mono<Long> clusterCountKeysInSlot(int slot) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursordel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisAdvancedClusterReactiveCommandsImpl.ftCursordel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.error",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.message",
    "thirdPartyMethod" : "reactor.core.publisher.FluxSink.next",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.message" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.message",
    "thirdPartyMethod" : "reactor.core.publisher.FluxSink.next",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.message" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.onNext",
    "thirdPartyMethod" : "reactor.core.Exceptions.unwrap",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.onNext", "io.lettuce.core.Operators.onOperatorError" ],
    "methodSlices" : [ "/**\n * Called by {@link StreamingOutput} to dispatch data (push).\n *\n * @param t\n * \t\telement\n */\n@Override\npublic void onNext(T t) {\n    LettuceAssert.notNull(t, \"Data must not be null\");\n    State state = state();\n    if (state == State.COMPLETED) {\n        return;\n    }\n    // Fast-path publishing, preserve ordering\n    if (data.isEmpty() && (state() == State.DEMAND)) {\n        long initial = getDemand();\n        if (initial > 0) {\n            try {\n                DEMAND.decrementAndGet(this);\n                this.subscriber.onNext(t);\n            } catch (Exception e) {\n                onError(e);\n            }\n            return;\n        }\n    }\n    if (!data.offer(t)) {\n        Subscriber<?> subscriber = this.subscriber;\n        Context context = Context.empty();\n        if (subscriber instanceof CoreSubscriber) {\n            context = ((CoreSubscriber) (subscriber)).currentContext();\n        }\n        Throwable e = Operators.onOperatorError(this, Exceptions.failWithOverflow(), t, context);\n        onError(e);\n        return;\n    }\n    onDataAvailable();\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1SingleToObservableAdapter.apply",
    "thirdPartyMethod" : "rx.Single.toObservable",
    "thirdPartyPackage" : "rx",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1SingleToObservableAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToMaybeAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.rxjava3.core.Observable.singleElement",
    "thirdPartyPackage" : "io.reactivex.rxjava3.core",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava3ObservableToMaybeAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.disconnect",
    "thirdPartyMethod" : "io.netty.channel.Channel.disconnect",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.disconnect" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.disconnect",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelInactive", "io.lettuce.core.protocol.CommandHandler.onProtectedMode" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelInactive(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToMaybeAdapter.apply",
    "thirdPartyMethod" : "io.reactivex.Observable.singleElement",
    "thirdPartyPackage" : "io.reactivex",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava2ObservableToMaybeAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isSuccess",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.doComplete" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void operationComplete(Future<Void> future) {\n    try {\n        doComplete(future);\n    } finally {\n        recycle();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.AddToStack.operationComplete",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isSuccess",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.AddToStack.operationComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isSuccess",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.release", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Promise<Boolean> release(EventExecutorGroup eventLoopGroup, long quietPeriod, long timeout, TimeUnit unit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.internal.Futures.adapt",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isSuccess",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.internal.Futures.adapt" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isSuccess",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultEventLoopGroupProvider.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "@Override\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.DefaultClientResources.shutdown",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isSuccess",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.resource.DefaultClientResources.shutdown", "io.lettuce.core.resource.PromiseAdapter.toBooleanPromise" ],
    "methodSlices" : [ "/**\n * Shutdown the {@link ClientResources}.\n *\n * @param quietPeriod\n * \t\tthe quiet period as described in the documentation\n * @param timeout\n * \t\tthe maximum amount of time to wait until the executor is shutdown regardless if a task was submitted\n * \t\tduring the quiet period\n * @param timeUnit\n * \t\tthe unit of {@code quietPeriod} and {@code timeout}\n * @return eventually the success/failure of the shutdown without errors.\n */\n@SuppressWarnings(\"unchecked\")\npublic Future<Boolean> shutdown(long quietPeriod, long timeout, TimeUnit timeUnit) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.internal.Futures.toCompletionStage",
    "thirdPartyMethod" : "io.netty.util.concurrent.Future.isSuccess",
    "thirdPartyPackage" : "io.netty.util.concurrent",
    "path" : [ "io.lettuce.core.internal.Futures.toCompletionStage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore",
    "thirdPartyMethod" : "io.netty.channel.ChannelPipeline.fireUserEventTriggered",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.BackpressureSource.requestMore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.operationComplete",
    "thirdPartyMethod" : "io.netty.channel.ChannelFuture.isSuccess",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.operationComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Lambda.<init>",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat", "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.<clinit>", "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.<init>" ],
    "methodSlices" : [ "", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield",
    "thirdPartyMethod" : "kotlin.jvm.internal.Lambda.<init>",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield", "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield.<clinit>", "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield.<init>" ],
    "methodSlices" : [ "", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Lambda.<init>",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos", "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos.<clinit>", "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos.<init>" ],
    "methodSlices" : [ "", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Lambda.<init>",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat", "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.<clinit>", "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.<init>" ],
    "methodSlices" : [ "", "" ]
  }, {
    "entryPoint" : "io.lettuce.core.json.DelegateJsonValue.toObject",
    "thirdPartyMethod" : "com.fasterxml.jackson.databind.ObjectMapper.treeToValue",
    "thirdPartyPackage" : "com.fasterxml.jackson.databind",
    "path" : [ "io.lettuce.core.json.DelegateJsonValue.toObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLog",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLog" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientTrackinginfo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientTrackinginfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpushx",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpushx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclUsers",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclUsers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientSetinfo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientSetinfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.spublish",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.spublish" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSuglen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSuglen", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSuglen.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zintercard",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zintercard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.dump",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.dump" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattrAsJsonValue",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattrAsJsonValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.dbsize",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.dbsize" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDeluser",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDeluser" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrankWithScore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrankWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinksWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinksWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.restore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.restore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setbit",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setbit" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hincrbyfloat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hincrbyfloat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientInfo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfcount",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.time",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.time" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.bgrewriteaof",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.bgrewriteaof" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.publish",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.publish" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hvals",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hvals" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushall",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setnx",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setnx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpush",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSdslen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSdslen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionFlush",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionFlush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expiretime",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientInfo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrem",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrem" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSyndump",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSyndump", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSyndump.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugRestart",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugRestart" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.migrate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.migrate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetinfo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetinfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.randomkey",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.randomkey" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vClearAttributes",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vClearAttributes" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpersist",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpersist" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestorebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestorebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsetattr",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsetattr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMerge",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMerge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.swapdb",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.swapdb", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.swapdb.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smismember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smismember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasdel", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasdel.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectFreq",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectFreq" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.echo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.echo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lmove",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lmove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zcount",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configResetstat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configResetstat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiff",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionDump",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionDump" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupSetid",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupSetid" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.auth",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.auth" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.StatefulRedisConnectionExtensionsKt.coroutines",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.StatefulRedisConnectionExtensionsKt.coroutines" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hstrlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hstrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.slaves",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.slaves" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.select",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.select", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.select.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasupdate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasupdate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasupdate.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.bgsave",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.bgsave" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geohash",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geohash" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdbAsync",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdbAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmax",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptExists",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptExists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclSetuser",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclSetuser" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientNoEvict",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientNoEvict" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugCrashAndRecover",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugCrashAndRecover" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getbit",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getbit" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.lastsave",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.lastsave" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetall",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogReset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogReset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDryRun",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDryRun" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursorread.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vemb",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vemb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.ttl",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.ttl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinks",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinks" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoStream",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoStream" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestorebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestorebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionKill",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattr",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpoplpush",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpoplpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionRestore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionRestore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdb",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLogReset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLogReset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.type",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.type" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalshaReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalshaReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmove",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.hscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcallReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcallReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLoad",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pttl",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pttl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopNot",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopNot" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.save",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.save" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.psetex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.psetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hsetex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hsetex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonNumincrby",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonNumincrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.scard",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.scard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vembRaw",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vembRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zlexcount",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zlexcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonClear",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonClear" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.quit",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.quit" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestorebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestorebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpoplpush",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpoplpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfmerge",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHLLCoroutinesCommandsImpl.pfmerge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hkeys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortStore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortStore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smembers",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smembers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sintercard",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sintercard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugHtstats",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugHtstats" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptFlush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incrbyfloat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incrbyfloat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrem",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrem" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incr",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.replicaof",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.replicaof" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmin",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonDel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonDel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vdim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vdim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSpellcheck.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasadd", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAliasadd.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientSetname",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incrby",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.incrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.auth",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.coroutines.RedisClusterCoroutinesCommandsImpl.auth" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.msetnx",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.msetnx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.ltrim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.ltrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugObject",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slaveof",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slaveof" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientPause",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientPause" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configSet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionLoad",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopOr",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopOr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursordel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursordel", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCursordel.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.sscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupDestroy",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupDestroy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.httl",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.httl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth", "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.auth.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushallAsync",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushallAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogLen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogLen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.copy",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.copy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdel", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdel.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangeWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.scan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientCaching",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientCaching" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScoreWithAttribs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGetRaw",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zintercard",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zintercard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hincrby",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hincrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDryRun",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclDryRun" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpiretime",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGenpass",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGenpass" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectRefcount",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectRefcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmin",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.brpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.replicaofNoOne",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.replicaofNoOne" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xreadgroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandCount",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandCount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.decr",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.decr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMSet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearchstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearchstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoConsumers",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoConsumers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpush",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpushx",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpushx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptFlush",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptFlush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.masters",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.masters" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonClear",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonClear" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrem",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrem" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.linsert",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.linsert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.rename",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.rename" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopAnd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopAnd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebyrank",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zremrangebyrank" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.append",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.append" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.mset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.hscanNovalues",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclWhoami",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclWhoami" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionLoad",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpiretime",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrankWithScore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrankWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slaveofNoOne",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slaveofNoOne" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xpending" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmax",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzpopmax" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftExplain.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vinfo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vinfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalsha",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalsha" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.scan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangestore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreateconsumer",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreateconsumer" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.restore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.restore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.command",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.command" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hset",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscanNovalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ScanFlow.zscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.ScanFlow.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLog",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclLog" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.echo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsImpl.echo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.strlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.strlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.replicas",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.replicas" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vcard",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vcard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.llen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.llen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xautoclaim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xautoclaim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.renamenx",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.renamenx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientGetname",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientGetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sortReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSynupdate.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrtrim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopXor",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitopXor" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcallReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcallReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.StatefulRedisSentinelConnectionExtensionsKt.coroutines",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.StatefulRedisSentinelConnectionExtensionsKt.coroutines" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zincrby",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zincrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalsha",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalsha" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.move",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.move" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.persist",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.persist" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictadd", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictadd.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAlter.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hsetnx",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hsetnx" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configSet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpoplpush",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpoplpush" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectIdletime",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectIdletime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdb",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushdb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangeWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangeWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptKill",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.lcs",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.lcs" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpttl",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpttl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexists",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinterstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sinterstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geosearch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.migrate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.migrate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientGetname",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientGetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.del",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.del" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinter" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiffstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sdiffstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.role",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.role" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.exists",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.exists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.api.StatefulRedisClusterConnectionExtensionsKt.coroutines",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.cluster.api.StatefulRedisClusterConnectionExtensionsKt.coroutines" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiff",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiff" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupDelconsumer",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupDelconsumer" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonDel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonDel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.unlink",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.unlink" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sintercard",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sintercard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestorebylex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangestorebylex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sismember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sismember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zaddincr",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zaddincr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmove",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xack",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xack" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.setGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugadd.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushall",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.flushall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hmget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zaddincr",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zaddincr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zpopmin" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDropindex.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadius" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionRestore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionRestore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srem",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.srem" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keysLegacy",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.keysLegacy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hgetdel" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclSave",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclSave" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.decrby",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.decrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zcard",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zcard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.get",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.get" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smove",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.smove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSearch.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugReload",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugReload" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configGet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.digest",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.digest" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configRewrite",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.configRewrite" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGenpass",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGenpass" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftAggregate.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugdel",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugdel", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugdel.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectEncoding",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.objectEncoding" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.georadiusbymember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMerge",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMerge" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zdiffWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunionstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.expire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.waitForReplication",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.waitForReplication" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hscan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrank",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrank" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geoadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.memoryUsage",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.memoryUsage" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientTracking",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientTracking" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.sort" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonSet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.dispatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientId",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientId" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientUnblock",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientUnblock" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcall",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoGroups",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoGroups" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.copy",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.copy" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zinterWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.digest",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.digest" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geodist",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geodist" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.sync.RedisSyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.sync.RedisSyncCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunionstore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunionstore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hget",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hget" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.spop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsetattr",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsetattr" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitcount",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xread" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSetCoroutinesCommandsImpl.sunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsimWithScore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalReadOnly",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.evalReadOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpiretime",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.pexpiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitcount",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitcount" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lindex",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.eval" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xadd" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blpop",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.blpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getrange",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.getrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftCreate.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclList",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zunion" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.touch",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisKeyCoroutinesCommandsImpl.touch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonToggle",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonToggle" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcall",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.fcall" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientGetredir",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.clientGetredir" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptLoad",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptLoad" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreate",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xgroupCreate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrangebyscoreWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrank",
    "thirdPartyMethod" : "kotlin.jvm.internal.Intrinsics.checkNotNullExpressionValue",
    "thirdPartyPackage" : "kotlin.jvm.internal",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrevrank" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive", "io.lettuce.core.ConnectionEventTrigger.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyException",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyException", "io.lettuce.core.protocol.DefaultEndpoint.isConnected" ],
    "methodSlices" : [ "@Override\npublic void notifyException(Throwable t) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ChannelGroupListener.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ChannelGroupListener.getRedisUri" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete",
    "thirdPartyMethod" : "io.netty.channel.Channel.hasAttr",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap", "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.<clinit>" ],
    "methodSlices" : [ "/**\n * Initialize the {@link Bootstrap}.\n *\n * @since 6.1\n */\npublic void configureBootstrap(boolean domainSocket, Function<Class<? extends EventLoopGroup>, EventLoopGroup> eventLoopGroupProvider) {\n    LettuceAssert.assertState(bootstrap != null, \"Bootstrap must be set\");\n    LettuceAssert.assertState(clientOptions != null, \"ClientOptions must be set\");\n    Class<? extends EventLoopGroup> eventLoopGroupClass = Transports.eventLoopGroupClass();\n    Class<? extends Channel> channelClass = Transports.socketChannelClass();\n    if (domainSocket) {\n        Transports.NativeTransports.assertDomainSocketAvailable();\n        eventLoopGroupClass = Transports.NativeTransports.eventLoopGroupClass(true);\n        channelClass = Transports.NativeTransports.domainSocketChannelClass();\n    } else {\n        bootstrap.resolver(clientResources.addressResolverGroup());\n    }\n    SocketOptions options = clientOptions.getSocketOptions();\n    EventLoopGroup eventLoopGroup = eventLoopGroupProvider.apply(eventLoopGroupClass);\n    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.toIntExact(options.getConnectTimeout().toMillis()));\n    if (!domainSocket) {\n        bootstrap.option(ChannelOption.SO_KEEPALIVE, options.isKeepAlive());\n        bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());\n        if (options.isEnableTcpUserTimeout()) {\n            SocketOptions.TcpUserTimeoutOptions tcpUserTimeoutOptions = options.getTcpUserTimeout();\n            boolean applied = false;\n            if (IOUringProvider.isAvailable()) {\n                IOUringProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            } else if (EpollProvider.isAvailable()) {\n                EpollProvider.applyTcpUserTimeout(bootstrap, tcpUserTimeoutOptions.getTcpUserTimeout());\n                applied = true;\n            }\n            LettuceAssert.assertState(applied, \"TCP User Timeout options could not be applied. Native transports (io_uring or epoll) are required.\");\n        }\n    }\n    bootstrap.channel(channelClass).group(eventLoopGroup);\n    if (options.isKeepAlive() && options.isExtendedKeepAlive()) {\n        SocketOptions.KeepAliveOptions keepAlive = options.getKeepAlive();\n        boolean applied = false;\n        if (IOUringProvider.isAvailable()) {\n            IOUringProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (EpollProvider.isAvailable()) {\n            EpollProvider.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        } else if (ExtendedNioSocketOptions.isAvailable() && (!KqueueProvider.isAvailable())) {\n            ExtendedNioSocketOptions.applyKeepAlive(bootstrap, keepAlive.getCount(), keepAlive.getIdle(), keepAlive.getInterval());\n            applied = true;\n        }\n        LettuceAssert.assertState(applied, \"Extended TCP keepalive options could not be applied. Native transports (io_uring or epoll) or a compatible NIO transport are required.\");\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.applyKeepAlive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.applyKeepAlive", "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.<clinit>" ],
    "methodSlices" : [ "/**\n * Apply Keep-Alive options.\n */\npublic static void applyKeepAlive(Bootstrap bootstrap, int count, Duration idle, Duration interval) {\n    bootstrap.option(NioChannelOption.of(TCP_KEEPCOUNT), count);\n    bootstrap.option(NioChannelOption.of(TCP_KEEPIDLE), Math.toIntExact(idle.getSeconds()));\n    bootstrap.option(NioChannelOption.of(TCP_KEEPINTERVAL), Math.toIntExact(interval.getSeconds()));\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.isAvailable",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.trace",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.isAvailable", "io.lettuce.core.ConnectionBuilder.ExtendedNioSocketOptions.<clinit>" ],
    "methodSlices" : [ "public static boolean isAvailable() {\n    return ((TCP_KEEPCOUNT != null) && (TCP_KEEPIDLE != null)) && (TCP_KEEPINTERVAL != null);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object)\n */\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.local" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.closeAsync", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<Void> closeAsync() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void notifyChannelActive(Channel channel) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelActive", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelActive(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelUnregistered",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelUnregistered", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelUnregistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive", "io.lettuce.core.protocol.ConnectionWatchdog.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ConnectionEventTrigger.local" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ConnectionEventTrigger.local" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRegistered", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelRegistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelInactive", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelInactive(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.close",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.close", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n * Close the connection.\n */\n@Override\npublic void close() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.write", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelDuplexHandler#write(io.netty.channel.ChannelHandlerContext, java.lang.Object,\nio.netty.channel.ChannelPromise)\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive", "io.lettuce.core.ConnectionEventTrigger.local" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect", "io.lettuce.core.protocol.ConnectionWatchdog.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n * Schedule reconnect if channel is not available/not active.\n */\npublic void scheduleReconnect() {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n * Move queued and buffered commands from the inactive connection to the upstream command writer. This is done only if the\n * current connection is disconnected and auto-reconnect is enabled (command-retries). If the connection would be open, we\n * could get into a race that the commands we're moving are right now in processing. Alive connections can handle redirects\n * and retries on their own.\n */\n@Override\npublic CompletableFuture<Void> closeAsync() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.exceptionCaught", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive", "io.lettuce.core.protocol.ConnectionWatchdog.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete",
    "thirdPartyMethod" : "io.netty.channel.Channel.localAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.IOUringResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.channel.MultiThreadIoEventLoopGroup.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.IOUringResources.newEventLoopGroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.channel.MultiThreadIoEventLoopGroup.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.resource.KqueueProvider.KqueueResources.newEventLoopGroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.EpollProvider.EpollResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.channel.MultiThreadIoEventLoopGroup.<init>",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.resource.EpollProvider.EpollResources.newEventLoopGroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.map",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive",
    "thirdPartyMethod" : "io.netty.util.internal.logging.InternalLogger.info",
    "thirdPartyPackage" : "io.netty.util.internal.logging",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object)\n */\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.flushCommands",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.flushCommands", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\n@SuppressWarnings( {\n    flushCommands(this.channel, commandBuffer)\n}", "private void flushCommands(Channel channel, Queue<RedisCommand<?, ?, ?>> queue) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.remote" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.closeAsync", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic CompletableFuture<Void> closeAsync() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.notifyChannelActive", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void notifyChannelActive(Channel channel) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelUnregistered",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelUnregistered", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelUnregistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ConnectionEventTrigger.remote" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ConnectionEventTrigger.remote" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRegistered", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelRegistered(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelInactive", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelInboundHandlerAdapter#channelInactive(io.netty.channel.ChannelHandlerContext)\n */\n@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.onPushMessage", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void onPushMessage(PushMessage message) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.close",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.close", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n * Close the connection.\n */\n@Override\npublic void close() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.write", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelDuplexHandler#write(io.netty.channel.ChannelHandlerContext, java.lang.Object,\nio.netty.channel.ChannelPromise)\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.scheduleReconnect", "io.lettuce.core.protocol.ConnectionWatchdog.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n * Schedule reconnect if channel is not available/not active.\n */\npublic void scheduleReconnect() {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.cluster.ClusterNodeEndpoint.closeAsync", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "/**\n * Move queued and buffered commands from the inactive connection to the upstream command writer. This is done only if the\n * current connection is disconnected and auto-reconnect is enabled (command-retries). If the connection would be open, we\n * could get into a race that the commands we're moving are right now in processing. Alive connections can handle redirects\n * and retries on their own.\n */\n@Override\npublic CompletableFuture<Void> closeAsync() {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.exceptionCaught", "io.lettuce.core.protocol.CommandHandler.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.write",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.write", "io.lettuce.core.protocol.DefaultEndpoint.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic <K, V, T> RedisCommand<K, V, T> write(RedisCommand<K, V, T> command) {\n}", "protected String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelInactive", "io.lettuce.core.protocol.ConnectionWatchdog.logPrefix", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}", "private String logPrefix() {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete",
    "thirdPartyMethod" : "io.netty.channel.Channel.remoteAddress",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete", "io.lettuce.core.protocol.ChannelLogDescriptor.logDescriptor" ],
    "methodSlices" : [ "@Override\npublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionBuilder.PlainChannelInitializer.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelUnregistered",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelUnregistered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.ConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.ConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRegistered",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRegistered" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelInactive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.RedisHandshakeHandler.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.RedisHandshakeHandler.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.write",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.write", "io.lettuce.core.protocol.CommandHandler.writeSingleCommand", "io.lettuce.core.protocol.CommandHandler.attachTracing" ],
    "methodSlices" : [ "/**\n *\n * @see io.netty.channel.ChannelDuplexHandler#write(io.netty.channel.ChannelHandlerContext, java.lang.Object,\nio.netty.channel.ChannelPromise)\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n}", "private void writeSingleCommand(ChannelHandlerContext ctx, RedisCommand<?, ?, ?> command, ChannelPromise promise) {\n    if (!isWriteable(command)) {\n    promise.trySuccess();\n    return;\n}\n    attachTracing(ctx, command)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelActive",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.protocol.MaintenanceAwareConnectionWatchdog.channelReadComplete" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught",
    "thirdPartyMethod" : "io.netty.channel.ChannelHandlerContext.channel",
    "thirdPartyPackage" : "io.netty.channel",
    "path" : [ "io.lettuce.core.SslConnectionBuilder.SslChannelInitializer.exceptionCaught" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.annotate",
    "thirdPartyMethod" : "brave.Span.annotate",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.annotate" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionBuilder.configureBootstrap",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.resolver",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.ConnectionBuilder.configureBootstrap" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.writeBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.KeyArgument.encode", "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.ByteBufferArgument.writeByteBuf" ],
    "methodSlices" : [ "/**\n * Encode the {@link CommandArgs} and write the arguments to the {@link ByteBuf}.\n *\n * @param buf\n * \t\tthe target buffer.\n */\npublic void encode(ByteBuf buf) {\n    buf.touch(\"CommandArgs.encode()\");\n    for (SingularArgument singularArgument : singularArguments) {\n        singularArgument.encode(buf);\n    }\n}", "@SuppressWarnings(\"unchecked\")\n@Override\nvoid encode(ByteBuf target) {\n    if (codec instanceof ToByteBufEncoder) {\n        CommandArgs.encode(target, ((ToByteBufEncoder<K, K>) (codec)), key, ToByteBufEncoder::encodeKey);\n        return;\n    }\n    ByteBufferArgument.writeByteBuffer(target, codec.encodeKey(key));\n}", "static <T> void encode(ByteBuf target, ToByteBufEncoder<T, T> encoder, T item, EncodeFunction<T> encodeFunction) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.concatWith",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.switchIfEmpty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.switchIfEmpty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createDissolvingFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\npublic <T, R> Flux<R> createDissolvingFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createMono",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.switchIfEmpty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createMono", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "public <T> Mono<T> createMono(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.createFlux",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.switchIfEmpty",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.createFlux", "io.lettuce.core.AbstractRedisReactiveCommands.withTraceContext" ],
    "methodSlices" : [ "public <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier) {\n}", "private <T> Flux<T> createFlux(Supplier<RedisCommand<K, V, T>> commandSupplier, boolean dissolve) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclUsers",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclUsers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoConsumers",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoConsumers" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattrAsJsonValue",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vgetattrAsJsonValue" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStringCoroutinesCommandsImpl.bitfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.masters",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.masters" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonNumincrby",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonNumincrby" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.time",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.time" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrinsert" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpiretime",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrange",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lrange" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGet",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftTagvals.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfield" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.command",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.command" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonType" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpersist",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpersist" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.replicas",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.replicas" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisGeoCoroutinesCommandsImpl.geopos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftSugget.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftDictdump.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrtrim",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrtrim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmember" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.httl",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.httl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.slaves",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.slaves" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.rpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpopRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoGroups",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoGroups" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList", "io.lettuce.core.api.coroutines.RediSearchCoroutinesCommandsImpl.ftList.suspendImpl" ],
    "methodSlices" : [ null ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonObjkeys" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zrandmemberWithScores" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonArrindex" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGetRaw",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonMGetRaw" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptExists",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisScriptingCoroutinesCommandsImpl.scriptExists" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vsim" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrappend" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpttl",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpttl" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpiretime",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpiretime" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hrandfieldWithvalues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardChannels" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.slowlogGet" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vemb",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vemb" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinks",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisVectorSetCoroutinesCommandsImpl.vlinks" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoStream",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisStreamCoroutinesCommandsImpl.xinfoStream" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.role",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.role" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hexpireat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisListCoroutinesCommandsImpl.lpos" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonStrlen" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonToggle",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisJsonCoroutinesCommandsImpl.jsonToggle" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.commandInfo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire",
    "thirdPartyMethod" : "kotlinx.coroutines.flow.FlowKt.toList.default",
    "thirdPartyPackage" : "kotlinx.coroutines.flow.FlowKt",
    "path" : [ "io.lettuce.core.api.coroutines.RedisHashCoroutinesCommandsImpl.hpexpire" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.credentials",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.Many.asFlux",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.credentials" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.resolveCredentials",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.Many.asFlux",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.resolveCredentials" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.event.DefaultEventBus.get",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.Many.asFlux",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.core.event.DefaultEventBus.get" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1ObservableToSingleAdapter.apply",
    "thirdPartyMethod" : "rx.Observable.toSingle",
    "thirdPartyPackage" : "rx",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1ObservableToSingleAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.ImmediateSubscriber.onError",
    "thirdPartyMethod" : "reactor.core.CoreSubscriber.onError",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.ImmediateSubscriber.onError" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.CummulativeLatencies.getCompletionHistogram",
    "thirdPartyMethod" : "org.HdrHistogram.Histogram.add",
    "thirdPartyPackage" : "org.HdrHistogram",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.CummulativeLatencies.getCompletionHistogram" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.CummulativeLatencies.getFirstResponseHistogram",
    "thirdPartyMethod" : "org.HdrHistogram.Histogram.add",
    "thirdPartyPackage" : "org.HdrHistogram",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.CummulativeLatencies.getFirstResponseHistogram" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.DefaultLettuceObservationConvention.getLowCardinalityKeyValues",
    "thirdPartyMethod" : "io.micrometer.common.KeyValues.and",
    "thirdPartyPackage" : "io.micrometer.common",
    "path" : [ "io.lettuce.core.tracing.DefaultLettuceObservationConvention.getLowCardinalityKeyValues" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelActive",
    "thirdPartyMethod" : "io.netty.channel.local.LocalAddress.<init>",
    "thirdPartyPackage" : "io.netty.channel.local",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelActive", "io.lettuce.core.ConnectionEventTrigger.remote" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ConnectionEventTrigger.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.local.LocalAddress.<init>",
    "thirdPartyPackage" : "io.netty.channel.local",
    "path" : [ "io.lettuce.core.ConnectionEventTrigger.channelInactive", "io.lettuce.core.ConnectionEventTrigger.remote" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelInactive",
    "thirdPartyMethod" : "io.netty.channel.local.LocalAddress.<init>",
    "thirdPartyPackage" : "io.netty.channel.local",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelInactive", "io.lettuce.core.ConnectionEventTrigger.remote" ],
    "methodSlices" : [ "@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.local.LocalAddress.<init>",
    "thirdPartyPackage" : "io.netty.channel.local",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive", "io.lettuce.core.ConnectionEventTrigger.remote" ],
    "methodSlices" : [ "@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.resource.IOUringProvider.IOUringResources.newEventLoopGroup",
    "thirdPartyMethod" : "io.netty.channel.uring.IoUringIoHandler.newFactory",
    "thirdPartyPackage" : "io.netty.channel.uring",
    "path" : [ "io.lettuce.core.resource.IOUringProvider.IOUringResources.newEventLoopGroup" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumpat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.remove" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.exec" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.unwatch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readOnly" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.readWrite" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugSegfault" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisCoroutinesCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientKill" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.getMasterAddrByName" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.master" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.bzmpop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientSetname" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.discard" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubShardNumsub" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.watch" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.info" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientPause" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.pubsubNumsub" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.monitor" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.ping" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisFunctionCoroutinesCommandsImpl.functionList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.failover" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisTransactionalCoroutinesCommandsImpl.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.BaseRedisCoroutinesCommandsImpl.echo" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisSortedSetCoroutinesCommandsImpl.zmscore" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.clientList" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.ping" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.async.RedisAsyncCommandsExtensionsKt.multi" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.reset" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclGetuser" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.sentinel.api.coroutines.RedisSentinelCoroutinesCommandsImpl.set" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom",
    "thirdPartyMethod" : "kotlin.coroutines.intrinsics.IntrinsicsKt.getCOROUTINE_SUSPENDED",
    "thirdPartyPackage" : "kotlin.coroutines.intrinsics",
    "path" : [ "io.lettuce.core.api.coroutines.RedisServerCoroutinesCommandsImpl.debugOom" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    DefaultEndpoint endpoint = new DefaultEndpoint(getOptions(), getResources())\n    RedisChannelWriter writer = endpoint\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n    writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n}\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n    writer = new CommandListenerWriter(writer, getCommandListeners());\n}\n    StatefulRedisSentinelConnectionImpl<K, V> connection = newStatefulRedisSentinelConnection(writer, codec, timeout)\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.cluster.ClusterPubSubConnectionProvider.PubSubNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectPubSubToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.cluster.RedisClusterClient.createConnectionBuilder", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), key.nodeId, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectPubSubToNodeAsync(((RedisCodec) (redisCodec)), (key.host + \":\") + key.port, getSocketAddressSupplier(key));\n}", "/**\n * Create a pub/sub connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubToNodeAsync(RedisCodec<K, V> codec, String nodeId, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}", "private <K, V> ConnectionBuilder createConnectionBuilder(RedisChannelHandler<K, V> connection, ConnectionState state, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n    ConnectionBuilder connectionBuilder\n    if (connectionSettings.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(connectionSettings);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(socketAddressSupplier, connectionBuilder, connection.getConnectionEvents(), connectionSettings)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectAsync",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectAsync", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new connection to a Redis server using the supplied {@link RedisURI} and the supplied\n * {@link RedisCodec codec} to encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.cluster.PooledClusterConnectionProvider.DefaultClusterNodeConnectionFactory.apply", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.cluster.RedisClusterClient.createConnectionBuilder", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "@Override\npublic ConnectionFuture<StatefulRedisConnection<K, V>> apply(ConnectionKey key) {\n    if (key.nodeId != null) {\n        // NodeId connections do not provide command recovery due to cluster reconfiguration\n        return redisClusterClient.connectToNodeAsync(redisCodec, key.nodeId, null, getSocketAddressSupplier(key));\n    }\n    // Host and port connections do provide command recovery due to cluster reconfiguration\n    return redisClusterClient.connectToNodeAsync(redisCodec, (key.host + \":\") + key.port, clusterWriter, getSocketAddressSupplier(key));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}", "private <K, V> ConnectionBuilder createConnectionBuilder(RedisChannelHandler<K, V> connection, ConnectionState state, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n    ConnectionBuilder connectionBuilder\n    if (connectionSettings.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(connectionSettings);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(socketAddressSupplier, connectionBuilder, connection.getConnectionEvents(), connectionSettings)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server that treats keys and values as UTF-8 strings.\n *\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub() {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisConnection<String, String> connect(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.cluster.RedisClusterClient.createConnectionBuilder", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "@Override\npublic <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNodeAsync(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}", "private <K, V> ConnectionBuilder createConnectionBuilder(RedisChannelHandler<K, V> connection, ConnectionState state, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n    ConnectionBuilder connectionBuilder\n    if (connectionSettings.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(connectionSettings);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(socketAddressSupplier, connectionBuilder, connection.getConnectionEvents(), connectionSettings)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.NodeConnectionFactoryImpl.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNode", "io.lettuce.core.cluster.RedisClusterClient.connectToNodeAsync", "io.lettuce.core.cluster.RedisClusterClient.connectStatefulAsync", "io.lettuce.core.cluster.RedisClusterClient.createConnectionBuilder", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "@Override\npublic <K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, SocketAddress socketAddress) {\n    return this.connectToNode(codec, socketAddress.toString(), null, Mono.just(socketAddress));\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> StatefulRedisConnection<K, V> connectToNode(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Create a connection to a redis socket address.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param nodeId\n * \t\tthe nodeId\n * @param clusterWriter\n * \t\tglobal cluster writer\n * @param socketAddressSupplier\n * \t\tsupplier for the socket address\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\n<K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectToNodeAsync(RedisCodec<K, V> codec, String nodeId, RedisChannelWriter clusterWriter, Mono<SocketAddress> socketAddressSupplier) {\n}", "/**\n * Initiates a channel connection considering {@link ClientOptions} initialization options, authentication and client name\n * options.\n */\n@SuppressWarnings(\"unchecked\")\nprivate <K, V, T extends StatefulRedisConnectionImpl<K, V>, S> ConnectionFuture<S> connectStatefulAsync(T connection, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n}", "private <K, V> ConnectionBuilder createConnectionBuilder(RedisChannelHandler<K, V> connection, ConnectionState state, DefaultEndpoint endpoint, RedisURI connectionSettings, Mono<SocketAddress> socketAddressSupplier, Supplier<CommandHandler> commandHandlerSupplier) {\n    ConnectionBuilder connectionBuilder\n    if (connectionSettings.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(connectionSettings);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(socketAddressSupplier, connectionBuilder, connection.getConnectionEvents(), connectionSettings)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connect",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connect", "io.lettuce.core.RedisClient.connectStandaloneAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new connection to a Redis server using the supplied {@link RedisURI} and the supplied {@link RedisCodec codec} to\n * encode/decode keys.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisConnection<K, V> connect(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisConnection<K, V>> connectStandaloneAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    DefaultEndpoint endpoint = new DefaultEndpoint(getOptions(), getResources())\n    RedisChannelWriter writer = endpoint\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n    writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n}\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n    writer = new CommandListenerWriter(writer, getCommandListeners());\n}\n    StatefulRedisSentinelConnectionImpl<K, V> connection = newStatefulRedisSentinelConnection(writer, codec, timeout)\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    DefaultEndpoint endpoint = new DefaultEndpoint(getOptions(), getResources())\n    RedisChannelWriter writer = endpoint\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n    writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n}\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n    writer = new CommandListenerWriter(writer, getCommandListeners());\n}\n    StatefulRedisSentinelConnectionImpl<K, V> connection = newStatefulRedisSentinelConnection(writer, codec, timeout)\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSubAsync",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open asynchronously a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return {@link ConnectionFuture} to indicate success or failure to connect.\n * @since 5.0\n */\npublic <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.doConnectSentinelAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}", "private <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "private <K, V> ConnectionFuture<StatefulRedisSentinelConnection<K, V>> doConnectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout, ConnectionMetadata metadata) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    DefaultEndpoint endpoint = new DefaultEndpoint(getOptions(), getResources())\n    RedisChannelWriter writer = endpoint\n    if (CommandExpiryWriter.isSupported(getOptions())) {\n    writer = CommandExpiryWriter.buildCommandExpiryWriter(writer, getOptions(), getResources());\n}\n    if (CommandListenerWriter.isSupported(getCommandListeners())) {\n    writer = new CommandListenerWriter(writer, getCommandListeners());\n}\n    StatefulRedisSentinelConnectionImpl<K, V> connection = newStatefulRedisSentinelConnection(writer, codec, timeout)\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to the Redis server using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values.\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec, RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectPubSub",
    "thirdPartyMethod" : "io.netty.bootstrap.Bootstrap.<init>",
    "thirdPartyPackage" : "io.netty.bootstrap",
    "path" : [ "io.lettuce.core.RedisClient.connectPubSub", "io.lettuce.core.RedisClient.connectPubSubAsync", "io.lettuce.core.RedisClient.connectStatefulAsync", "io.lettuce.core.AbstractRedisClient.connectionBuilder" ],
    "methodSlices" : [ "/**\n * Open a new pub/sub connection to a Redis server using the supplied {@link RedisURI} that treats keys and values as UTF-8\n * strings.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new stateful pub/sub connection\n */\npublic StatefulRedisPubSubConnection<String, String> connectPubSub(RedisURI redisURI) {\n}", "private <K, V> ConnectionFuture<StatefulRedisPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec, RedisURI redisURI, Duration timeout) {\n}", "@SuppressWarnings(\"unchecked\")\nprivate <K, V, S> ConnectionFuture<S> connectStatefulAsync(StatefulRedisConnectionImpl<K, V> connection, Endpoint endpoint, RedisURI redisURI, Supplier<CommandHandler> commandHandlerSupplier, Boolean isPubSub) {\n    ConnectionBuilder connectionBuilder\n    if (redisURI.isSsl()) {\n    SslConnectionBuilder sslConnectionBuilder = SslConnectionBuilder.sslConnectionBuilder();\n    sslConnectionBuilder.ssl(redisURI);\n    connectionBuilder = sslConnectionBuilder;\n} else {\n    connectionBuilder = ConnectionBuilder.connectionBuilder();\n}\n    connectionBuilder(getSocketAddressSupplier(redisURI), connectionBuilder, connection.getConnectionEvents(), redisURI)\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.SentinelConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()} first, otherwise the connect\n * will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterConnection<K, V>> connectAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinelAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinelAsync", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open asynchronously a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied\n * {@link RedisCodec codec} to encode/decode keys and values. The client {@link RedisURI} must contain one or more\n * sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisSentinelConnection<K, V>> connectSentinelAsync(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisHandshake.initialize",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisHandshake.initialize", "io.lettuce.core.RedisHandshake.initializeResp2", "io.lettuce.core.RedisHandshake.initiateHandshakeResp2" ],
    "methodSlices" : [ "@Override\npublic CompletionStage<Void> initialize(Channel channel) {\n}", "private CompletableFuture<?> initializeResp2(Channel channel) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSubAsync", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect asynchronously to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to\n * encode/decode keys and values. Connecting asynchronously requires an initialized topology. Call {@link #getPartitions()}\n * first, otherwise the connect will fail with a{@link IllegalStateException}.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return a {@link CompletableFuture} that is notified with the connection progress.\n * @since 5.1\n */\npublic <K, V> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectPubSubAsync(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} and use the supplied {@link RedisCodec codec}\n * to encode/decode keys and values. The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param codec\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new connection\n */\npublic <K, V> StatefulRedisSentinelConnection<K, V> connectSentinel(RedisCodec<K, V> codec, RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.ReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.MasterReplicaConnectionProvider.getConnectionAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisClient.connectSentinel",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.RedisClient.connectSentinel", "io.lettuce.core.RedisClient.connectSentinelAsync" ],
    "methodSlices" : [ "/**\n * Open a connection to a Redis Sentinel using the supplied {@link RedisURI} that treats keys and values as UTF-8 strings.\n * The client {@link RedisURI} must contain one or more sentinels.\n *\n * @param redisURI\n * \t\tthe Redis server to connect to, must not be {@code null}\n * @return A new connection\n */\npublic StatefulRedisSentinelConnection<String, String> connectSentinel(RedisURI redisURI) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.StaticMasterReplicaTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.SentinelTopologyProvider.getNodesAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.masterreplica.AutodiscoveryConnector.connectAsync" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connect",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connect", "io.lettuce.core.cluster.RedisClusterClient.connectClusterAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster. Use the supplied {@link RedisCodec codec} to encode/decode keys and values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the lowest latency</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * <li>Pub/sub commands are sent to the node that handles the slot derived from the pub/sub channel</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterConnection<K, V> connect(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.cluster.RedisClusterClient.connectPubSub",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.toFuture",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.cluster.RedisClusterClient.connectPubSub", "io.lettuce.core.cluster.RedisClusterClient.connectClusterPubSubAsync" ],
    "methodSlices" : [ "/**\n * Connect to a Redis Cluster using pub/sub connections. Use the supplied {@link RedisCodec codec} to encode/decode keys and\n * values.\n * <p>\n * What to expect from this connection:\n * </p>\n * <ul>\n * <li>A <i>default</i> connection is created to the node with the least number of clients</li>\n * <li>Pub/sub commands are sent to the node with the least number of clients</li>\n * <li>Keyless commands are send to the default connection</li>\n * <li>Single-key keyspace commands are routed to the appropriate node</li>\n * <li>Multi-key keyspace commands require the same slot-hash and are routed to the appropriate node</li>\n * </ul>\n *\n * @param codec\n * \t\tUse this codec to encode/decode keys and values, must not be {@code null}\n * @param <K>\n * \t\tKey type\n * @param <V>\n * \t\tValue type\n * @return A new stateful Redis Cluster connection\n */\npublic <K, V> StatefulRedisClusterPubSubConnection<K, V> connectPubSub(RedisCodec<K, V> codec) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.channelRead",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.readableBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.channelRead" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.toString",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.readableBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.toString" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.readableBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.encodeValue", "io.lettuce.core.codec.CipherCodec.CipherCodecWrapper.doWithCipher" ],
    "methodSlices" : [ "@Override\npublic void encodeValue(Object value, ByteBuf target) {\n    ByteBuf serialized;\n    if (delegate instanceof ToByteBufEncoder) {\n        serialized = target.alloc().buffer(estimateSize(value));\n        ((ToByteBufEncoder) (delegate)).encodeKey(value, serialized);\n    } else {\n        ByteBuffer byteBuffer = delegate.encodeValue(value);\n        serialized = target.alloc().buffer(byteBuffer.remaining());\n        serialized.writeBytes(byteBuffer);\n    }\n    try {\n        KeyDescriptor keyDescriptor = this.encrypt.encryptionKey();\n        Cipher cipher = this.encrypt.get(keyDescriptor);\n        keyDescriptor.writeTo(target);\n        doWithCipher(cipher, serialized, target);\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(e);\n    } finally {\n        serialized.release();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandArgs.encode",
    "thirdPartyMethod" : "io.netty.buffer.ByteBuf.readableBytes",
    "thirdPartyPackage" : "io.netty.buffer",
    "path" : [ "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.KeyArgument.encode", "io.lettuce.core.protocol.CommandArgs.encode", "io.lettuce.core.protocol.CommandArgs.ByteBufferArgument.writeByteBuf" ],
    "methodSlices" : [ "/**\n * Encode the {@link CommandArgs} and write the arguments to the {@link ByteBuf}.\n *\n * @param buf\n * \t\tthe target buffer.\n */\npublic void encode(ByteBuf buf) {\n    buf.touch(\"CommandArgs.encode()\");\n    for (SingularArgument singularArgument : singularArguments) {\n        singularArgument.encode(buf);\n    }\n}", "@SuppressWarnings(\"unchecked\")\n@Override\nvoid encode(ByteBuf target) {\n    if (codec instanceof ToByteBufEncoder) {\n        CommandArgs.encode(target, ((ToByteBufEncoder<K, K>) (codec)), key, ToByteBufEncoder::encodeKey);\n        return;\n    }\n    ByteBufferArgument.writeByteBuffer(target, codec.encodeKey(key));\n}", "static <T> void encode(ByteBuf target, ToByteBufEncoder<T, T> encoder, T item, EncodeFunction<T> encodeFunction) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.RedisSubscription.request",
    "thirdPartyMethod" : "reactor.core.Exceptions.nullOrNegativeRequestException",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.RedisSubscription.request", "io.lettuce.core.RedisPublisher.State.request" ],
    "methodSlices" : [ "/**\n * Signal for data demand.\n *\n * @param n\n * \t\tnumber of requested elements.\n */\n@Override\npublic final void request(long n) {\n    State state = state();\n    if (traceEnabled) {\n        LOG.trace(\"{} request: {}\", state, n);\n    }\n    state.request(this, n);\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.Operators.request",
    "thirdPartyMethod" : "reactor.core.Exceptions.nullOrNegativeRequestException",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.Operators.request", "io.lettuce.core.Operators.validate", "io.lettuce.core.Operators.reportBadRequest" ],
    "methodSlices" : [ "/**\n * Concurrent addition bound to Long.MAX_VALUE. Any concurrent write will \"happen before\" this operation.\n *\n * @param <T>\n * \t\tthe parent instance type\n * @param updater\n * \t\tcurrent field updater\n * @param instance\n * \t\tcurrent instance to update\n * @param toAdd\n * \t\tdelta to add\n * @return {@code true} if the operation succeeded.\n * @since 5.0.1\n */\npublic static <T> boolean request(AtomicLongFieldUpdater<T> updater, T instance, long toAdd) {\n}", "/**\n * Evaluate if a request is strictly positive otherwise {@link #reportBadRequest(long)}\n *\n * @param n\n * \t\tthe request value\n * @return true if valid\n */\nstatic boolean validate(long n) {\n}" ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "reactor.core.publisher.Sinks.Many.tryEmitError",
    "thirdPartyPackage" : "reactor.core.publisher.Sinks",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create", "io.lettuce.authx.TokenBasedRedisCredentialsProvider.init" ],
    "methodSlices" : [ "public static TokenBasedRedisCredentialsProvider create(TokenManager tokenManager) {\n    TokenBasedRedisCredentialsProvider credentialManager = new TokenBasedRedisCredentialsProvider(tokenManager);\n    credentialManager.init();\n    return credentialManager;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContext",
    "thirdPartyMethod" : "brave.Span.context",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTraceContextProvider.getTraceContext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.ImmediateSubscriber.onNext",
    "thirdPartyMethod" : "reactor.core.CoreSubscriber.onNext",
    "thirdPartyPackage" : "reactor.core",
    "path" : [ "io.lettuce.core.RedisPublisher.ImmediateSubscriber.onNext" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.support.ConnectionPoolSupport.returnObject",
    "thirdPartyMethod" : "org.apache.commons.pool2.impl.GenericObjectPool.returnObject",
    "thirdPartyPackage" : "org.apache.commons.pool2.impl",
    "path" : [ "io.lettuce.core.support.ConnectionPoolSupport.returnObject" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.debugOom",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.debugOom" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.shutdown",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.psubscribe",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.pubsub.RedisPubSubReactiveCommandsImpl.psubscribe" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.AbstractRedisReactiveCommands.shutdown",
    "thirdPartyMethod" : "reactor.core.publisher.Mono.then",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.AbstractRedisReactiveCommands.shutdown" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.invoke",
    "thirdPartyMethod" : "kotlin.collections.SetsKt.emptySet",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.invoke" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.invoke",
    "thirdPartyMethod" : "kotlin.collections.SetsKt.emptySet",
    "thirdPartyPackage" : "kotlin.collections",
    "path" : [ "io.lettuce.core.api.coroutines.RedisAclCoroutinesCommandsImpl.aclCat.invoke" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.Tracing.tracer",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan",
    "thirdPartyMethod" : "brave.Tracing.tracer",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveTracer.nextSpan" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create",
    "thirdPartyMethod" : "redis.clients.authentication.core.TokenManager.start",
    "thirdPartyPackage" : "redis.clients.authentication.core",
    "path" : [ "io.lettuce.authx.TokenBasedRedisCredentialsProvider.create", "io.lettuce.authx.TokenBasedRedisCredentialsProvider.init" ],
    "methodSlices" : [ "public static TokenBasedRedisCredentialsProvider create(TokenManager tokenManager) {\n    TokenBasedRedisCredentialsProvider credentialManager = new TokenBasedRedisCredentialsProvider(tokenManager);\n    credentialManager.init();\n    return credentialManager;\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1SingleToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1SingleToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1ObservableToPublisherAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1ObservableToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1SingleToPublisherAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1SingleToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1CompletableToPublisherAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1CompletableToPublisherAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1ObservableToFluxAdapter.apply",
    "thirdPartyMethod" : "reactor.core.publisher.Flux.defer",
    "thirdPartyPackage" : "reactor.core.publisher",
    "path" : [ "io.lettuce.core.dynamic.ReactiveTypeAdapters.RxJava1ObservableToFluxAdapter.apply" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete",
    "thirdPartyMethod" : "io.netty.util.Recycler.Handle.recycle",
    "thirdPartyPackage" : "io.netty.util.Recycler",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.operationComplete", "io.lettuce.core.protocol.DefaultEndpoint.RetryListener.recycle" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void operationComplete(Future<Void> future) {\n    try {\n        doComplete(future);\n    } finally {\n        recycle();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.OnNext.run",
    "thirdPartyMethod" : "io.netty.util.Recycler.Handle.recycle",
    "thirdPartyPackage" : "io.netty.util.Recycler",
    "path" : [ "io.lettuce.core.RedisPublisher.OnNext.run", "io.lettuce.core.RedisPublisher.OnNext.recycle" ],
    "methodSlices" : [ "@Override\npublic void run() {\n    try {\n        subscriber.onNext(signal);\n    } finally {\n        recycle();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.RedisPublisher.OnComplete.run",
    "thirdPartyMethod" : "io.netty.util.Recycler.Handle.recycle",
    "thirdPartyPackage" : "io.netty.util.Recycler",
    "path" : [ "io.lettuce.core.RedisPublisher.OnComplete.run", "io.lettuce.core.RedisPublisher.OnComplete.recycle" ],
    "methodSlices" : [ "@Override\npublic void run() {\n    try {\n        if (signal != null) {\n            subscriber.onError(signal);\n        } else {\n            subscriber.onComplete();\n        }\n    } finally {\n        recycle();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.CommandHandler.AddToStack.operationComplete",
    "thirdPartyMethod" : "io.netty.util.Recycler.Handle.recycle",
    "thirdPartyPackage" : "io.netty.util.Recycler",
    "path" : [ "io.lettuce.core.protocol.CommandHandler.AddToStack.operationComplete", "io.lettuce.core.protocol.CommandHandler.AddToStack.recycle" ],
    "methodSlices" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void operationComplete(Future<Void> future) {\n    try {\n        if (!future.isSuccess()) {\n            stack.remove(command);\n        }\n    } finally {\n        recycle();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.operationComplete",
    "thirdPartyMethod" : "io.netty.util.Recycler.Handle.recycle",
    "thirdPartyPackage" : "io.netty.util.Recycler",
    "path" : [ "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.operationComplete", "io.lettuce.core.protocol.DefaultEndpoint.AtMostOnceWriteListener.recycle" ],
    "methodSlices" : [ "@Override\npublic void operationComplete(ChannelFuture future) {\n    try {\n        dequeue();\n        if ((!future.isSuccess()) && (future.cause() != null)) {\n            complete(future.cause());\n        }\n    } finally {\n        recycle();\n    }\n}" ]
  }, {
    "entryPoint" : "io.lettuce.core.metrics.DefaultCommandLatencyCollector.Latencies.stop",
    "thirdPartyMethod" : "org.LatencyUtils.LatencyStats.stop",
    "thirdPartyPackage" : "org.LatencyUtils",
    "path" : [ "io.lettuce.core.metrics.DefaultCommandLatencyCollector.Latencies.stop" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.MicrometerTracing.MicrometerSpan.finish",
    "thirdPartyMethod" : "io.micrometer.observation.Observation.stop",
    "thirdPartyPackage" : "io.micrometer.observation",
    "path" : [ "io.lettuce.core.tracing.MicrometerTracing.MicrometerSpan.finish" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.ChannelGroupListener.channelActive",
    "thirdPartyMethod" : "io.netty.channel.group.ChannelGroup.add",
    "thirdPartyPackage" : "io.netty.channel.group",
    "path" : [ "io.lettuce.core.ChannelGroupListener.channelActive" ],
    "methodSlices" : [ ]
  }, {
    "entryPoint" : "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint",
    "thirdPartyMethod" : "brave.Span.remoteIpAndPort",
    "thirdPartyPackage" : "brave",
    "path" : [ "io.lettuce.core.tracing.BraveTracing.BraveSpan.remoteEndpoint" ],
    "methodSlices" : [ ]
  } ]
}