{
  "fullMethodsPaths" : [ {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolylineAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolylineAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolylineAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationPolyline annotation = ((PDAnnotationPolyline) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getVertices();\n    if ((pathsArray == null) || (pathsArray.length < 4)) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if (((color == null) || (color.getComponents().length == 0)) || (Float.compare(ab.width, 0) == 0)) {\n        return;\n    }\n    // Adjust rectangle even if not empty\n    // CTAN-example-Annotations.pdf and pdf_commenting_new.pdf p11\n    // TODO in a class structure this should be overridable\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    // arrow length is 9 * width at about 30Â° => 10 * width seems to be enough\n    rect.setLowerLeftX(Math.min(minX - (ab.width * 10), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width * 10), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width * 10), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width * 10), rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        setOpacity(cs, annotation.getConstantOpacity());\n        boolean hasStroke = cs.setStrokingColorOnDemand(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        for (int i = 0; i < (pathsArray.length / 2); ++i) {\n            float x = pathsArray[i * 2];\n            float y = pathsArray[(i * 2) + 1];\n            if (i == 0) {\n                if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                    // modify coordinate to shorten the segment\n                    // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n                    float x1 = pathsArray[2];\n                    float y1 = pathsArray[3];\n                    float len = ((float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2))));\n                    if (Float.compare(len, 0) != 0) {\n                        x += ((x1 - x) / len) * ab.width;\n                        y += ((y1 - y) / len) * ab.width;\n                    }\n                }\n                cs.moveTo(x, y);\n            } else {\n                if ((i == ((pathsArray.length / 2) - 1)) && SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                    // modify coordinate to shorten the segment\n                    // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n                    float x0 = pathsArray[pathsArray.length - 4];\n                    float y0 = pathsArray[pathsArray.length - 3];\n                    float len = ((float) (Math.sqrt(Math.pow(x0 - x, 2) + Math.pow(y0 - y, 2))));\n                    if (Float.compare(len, 0) != 0) {\n                        x -= ((x - x0) / len) * ab.width;\n                        y -= ((y - y0) / len) * ab.width;\n                    }\n                }\n                cs.lineTo(x, y);\n            }\n        }\n        cs.stroke();\n        // do a transform so that first and last \"arms\" are imagined flat, like in line handler\n        // the alternative would be to apply the transform to the LE shapes directly,\n        // which would be more work and produce code difficult to understand\n        // paint the styles here and after polyline draw, to avoid line crossing a filled shape\n        if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {\n            // check only needed to avoid q cm Q if LE_NONE\n            float x2 = pathsArray[2];\n            float y2 = pathsArray[3];\n            float x1 = pathsArray[0];\n            float y1 = pathsArray[1];\n            cs.saveGraphicsState();\n            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                double angle = Math.atan2(y2 - y1, x2 - x1);\n                cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n            } else {\n                cs.transform(Matrix.getTranslateInstance(x1, y1));\n            }\n            drawStyle(annotation.getStartPointEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, false);\n            cs.restoreGraphicsState();\n        }\n        if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {\n            // check only needed to avoid q cm Q if LE_NONE\n            float x1 = pathsArray[pathsArray.length - 4];\n            float y1 = pathsArray[pathsArray.length - 3];\n            float x2 = pathsArray[pathsArray.length - 2];\n            float y2 = pathsArray[pathsArray.length - 1];\n            // save / restore not needed because it's the last one\n            if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                double angle = Math.atan2(y2 - y1, x2 - x1);\n                cs.transform(Matrix.getRotateInstance(angle, x2, y2));\n            } else {\n                cs.transform(Matrix.getTranslateInstance(x2, y2));\n            }\n            drawStyle(annotation.getEndPointEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, true);\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.writeHexByte",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.writeHexByte", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Writes the given byte as hex value to the given output stream.\n *\n * @param b\n * \t\tthe byte to be written\n * @param output\n * \t\tthe output stream to be written to\n * @throws IOException\n * \t\texception if anything went wrong\n */\npublic static void writeHexByte(byte b, OutputStream output) throws IOException {\n    output.write(HEX_BYTES[getHighNibble(b)]);\n    output.write(HEX_BYTES[getLowNibble(b)]);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getActions",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getActions", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the page actions.\n *\n * @return The Actions for this Page\n */\npublic PDPageAdditionalActions getActions() {\n    COSDictionary addAct = page.getCOSDictionary(COSName.AA);\n    if (addAct == null) {\n        addAct = new COSDictionary();\n        page.setItem(COSName.AA, addAct);\n    }\n    return new PDPageAdditionalActions(addAct);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.Overlay.overlay",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.Overlay.overlay", "org.apache.pdfbox.multipdf.Overlay.processPages", "org.apache.pdfbox.multipdf.PDFCloneUtility.<clinit>" ],
    "fullMethods" : [ "/**\n * This will add overlays to a document.\n *\n * @param specificPageOverlayMap\n * \t\tOptional map of overlay files of which the first page will be\n * \t\tused for specific pages of the input document. The page numbers are 1-based. The map must be\n * \t\tempty (but not null) if no specific mappings are used.\n * @return The modified input PDF document, which has to be saved and closed by the caller. If\nthe input document was passed by {@link #setInputPDF(PDDocument) setInputPDF(PDDocument)}\nthen it is that object that is returned.\n * @throws IOException\n * \t\tif something went wrong.\n * @throws IllegalArgumentException\n * \t\tif the input document is missing.\n */\npublic PDDocument overlay(Map<Integer, String> specificPageOverlayMap) throws IOException {\n    Map<String, LayoutPage> layouts = new HashMap<>();\n    String path;\n    loadPDFs();\n    for (Map.Entry<Integer, String> e : specificPageOverlayMap.entrySet()) {\n        path = e.getValue();\n        LayoutPage layoutPage = layouts.get(path);\n        if (layoutPage == null) {\n            PDDocument doc = loadPDF(path);\n            layoutPage = createLayoutPageFromDocument(doc);\n            layouts.put(path, layoutPage);\n            openDocumentsSet.add(doc);\n        }\n        specificPageOverlayLayoutPageMap.put(e.getKey(), layoutPage);\n    }\n    processPages(inputPDFDocument);\n    return inputPDFDocument;\n}", "private void processPages(PDDocument document) throws IOException {\n    int pageCounter = 0;\n    PDFCloneUtility cloner = new PDFCloneUtility(document);\n    PDPageTree pageTree = document.getPages();\n    int numberOfPages = pageTree.getCount();\n    for (PDPage page : pageTree) {\n        pageCounter++;\n        LayoutPage layoutPage = getLayoutPage(pageCounter, numberOfPages);\n        if (layoutPage == null) {\n            continue;\n        }\n        COSDictionary pageDictionary = page.getCOSObject();\n        COSBase originalContent = pageDictionary.getDictionaryObject(COSName.CONTENTS);\n        COSArray newContentArray = new COSArray();\n        switch (position) {\n            case FOREGROUND :\n                // save state\n                newContentArray.add(createStream(\"q\\n\"));\n                addOriginalContent(originalContent, newContentArray);\n                // restore state\n                newContentArray.add(createStream(\"Q\\n\"));\n                // overlay content last\n                overlayPage(page, layoutPage, newContentArray, cloner);\n                break;\n            case BACKGROUND :\n                // overlay content first\n                overlayPage(page, layoutPage, newContentArray, cloner);\n                addOriginalContent(originalContent, newContentArray);\n                break;\n            default :\n                throw new IOException(\"Unknown type of position:\" + position);\n        }\n        pageDictionary.setItem(COSName.CONTENTS, newContentArray);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Version.getVersion",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Version.getVersion", "org.apache.pdfbox.util.Version.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the version of PDFBox.\n *\n * @return the version of PDFBox\n */\npublic static String getVersion() {\n    try (InputStream resourceAsStream = Version.class.getResourceAsStream(PDFBOX_VERSION_PROPERTIES);InputStream is = new BufferedInputStream(resourceAsStream)) {\n        Properties properties = new Properties();\n        properties.load(is);\n        return properties.getProperty(\"pdfbox.version\", null);\n    } catch (IOException io) {\n        LOG.debug(\"Unable to read version from properties - returning null\", io);\n        return null;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getRectangle",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getRectangle", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * The annotation rectangle, defining the location of the annotation on the page in default user space units. This\n * is usually required and should not return null on valid PDF documents. But where this is a parent form field with\n * children, such as radio button collections then the rectangle will be null.\n *\n * @return The Rect value of this annotation.\n */\npublic PDRectangle getRectangle() {\n    COSArray rectArray = dictionary.getCOSArray(COSName.RECT);\n    PDRectangle rectangle = null;\n    if (rectArray != null) {\n        if (((((rectArray.size() == 4) && (rectArray.getObject(0) instanceof COSNumber)) && (rectArray.getObject(1) instanceof COSNumber)) && (rectArray.getObject(2) instanceof COSNumber)) && (rectArray.getObject(3) instanceof COSNumber)) {\n            rectangle = new PDRectangle(rectArray);\n        } else {\n            LOG.warn(rectArray + \" is not a rectangle array, returning null\");\n        }\n    }\n    return rectangle;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.prepress.PDBoxStyle.getGuidelineColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.prepress.PDBoxStyle.getGuidelineColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the RGB color to be used for the guidelines.  This is guaranteed to\n * not return null. The default color is [0,0,0].\n *\n * @return The guideline color.\n */\npublic PDColor getGuidelineColor() {\n    COSArray colorValues = dictionary.getCOSArray(COSName.C);\n    if (colorValues == null) {\n        colorValues = new COSArray();\n        colorValues.add(COSInteger.ZERO);\n        colorValues.add(COSInteger.ZERO);\n        colorValues.add(COSInteger.ZERO);\n        dictionary.setItem(COSName.C, colorValues);\n    }\n    return new PDColor(colorValues.toFloatArray(), PDDeviceRGB.INSTANCE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDObjectStream.getExtends",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDObjectStream.getExtends", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * A reference to an object stream, of which the current object stream is\n * considered an extension.\n *\n * @return The object that this stream is an extension.\n */\npublic PDObjectStream getExtends() {\n    COSStream stream = getCOSObject().getCOSStream(COSName.EXTENDS);\n    return stream != null ? new PDObjectStream(stream) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.readObjectNumbers",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.readObjectNumbers", "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.privateReadObjectNumbers", "org.apache.pdfbox.pdfparser.BaseParser.readLong", "org.apache.pdfbox.pdfparser.BaseParser.skipSpaces", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Read all object numbers from the compressed object stream. The stream is closed after reading the object numbers.\n *\n * @return a map off all object numbers and the corresponding offset within the object stream.\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic Map<Long, Integer> readObjectNumbers() throws IOException {\n    Map<Long, Integer> objectNumbers = null;\n    try {\n        objectNumbers = privateReadObjectNumbers();\n    } finally {\n        source.close();\n        document = null;\n    }\n    return objectNumbers;\n}", "private Map<Long, Integer> privateReadObjectNumbers() throws IOException {\n    // don't initialize map using numberOfObjects as there might by less object numbers than expected\n    Map<Long, Integer> objectNumbers = new HashMap<>();\n    long firstObjectPosition = (source.getPosition() + firstObject) - 1;\n    for (int i = 0; i < numberOfObjects; i++) {\n        // don't read beyond the part of the stream reserved for the object numbers\n        if (source.getPosition() >= firstObjectPosition) {\n            break;\n        }\n        long objectNumber = readObjectNumber();\n        int offset = ((int) (readLong()));\n        objectNumbers.put(objectNumber, offset);\n    }\n    return objectNumbers;\n}", "/**\n * This will read an long from the stream.\n *\n * @return The long that was read from the stream.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected long readLong() throws IOException {\n    skipSpaces();\n    long retval = 0;\n    StringBuilder longBuffer = readStringNumber();\n    try {\n        retval = Long.parseLong(longBuffer.toString());\n    } catch (NumberFormatException e) {\n        source.rewind(longBuffer.toString().getBytes(StandardCharsets.ISO_8859_1).length);\n        throw new IOException((((\"Error: Expected a long type at offset \" + source.getPosition()) + \", instead got '\") + longBuffer) + \"'\", e);\n    }\n    return retval;\n}", "/**\n * This will skip all spaces and comments that are present.\n *\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected void skipSpaces() throws IOException {\n    int c = source.read();\n    // 37 is the % character, a comment\n    while (isWhitespace(c) || (c == 37)) {\n        if (c == 37) {\n            // skip past the comment section\n            c = source.read();\n            while ((!isEOL(c)) && (c != (-1))) {\n                c = source.read();\n            } \n        } else {\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDVariableText.setRichTextValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDVariableText.setRichTextValue", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the fields rich text value.\n *\n * <p>\n * Setting the rich text value will not generate the appearance\n * for the field.\n * <br>\n * You can set {@link PDAcroForm#setNeedAppearances(Boolean)} to\n * signal a conforming reader to generate the appearance stream.\n * </p>\n *\n * Providing null as the value will remove the default style string.\n *\n * @param richTextValue\n * \t\ta rich text string\n */\npublic void setRichTextValue(String richTextValue) {\n    if (richTextValue != null) {\n        getCOSObject().setItem(COSName.RV, new COSString(richTextValue));\n    } else {\n        getCOSObject().removeItem(COSName.RV);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceN.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceN.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new DeviceN color space from the given COS array.\n *\n * @param deviceN\n * \t\tan array containing the color space information\n * @param resources\n * \t\tresources, can be null.\n * @throws IOException\n * \t\tif the colorspace could not be created\n */\npublic PDDeviceN(COSArray deviceN, PDResources resources) throws IOException {\n    array = deviceN;\n    alternateColorSpace = PDColorSpace.create(array.getObject(ALTERNATE_CS), resources);\n    tintTransform = PDFunction.create(array.getObject(TINT_TRANSFORM));\n    if (array.size() > DEVICEN_ATTRIBUTES) {\n        attributes = new PDDeviceNAttributes(((COSDictionary) (array.getObject(DEVICEN_ATTRIBUTES))));\n    }\n    initColorConversionCache(resources);\n    // set initial color space\n    int n = getNumberOfComponents();\n    float[] initial = new float[n];\n    Arrays.fill(initial, 1);\n    initialColor = new PDColor(initial, this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.getRoleMap",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.getRoleMap", "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the role map.\n *\n * @return the role map\n */\npublic Map<String, Object> getRoleMap() {\n    COSDictionary rm = getCOSObject().getCOSDictionary(COSName.ROLE_MAP);\n    if (rm != null) {\n        try {\n            return COSDictionaryMap.convertBasicTypesToMap(rm);\n        } catch (IOException e) {\n            LOG.error(e, e);\n        }\n    }\n    return new HashMap<>();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFField.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFField.<init>", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param f\n * \t\tThe FDF field.\n */\npublic FDFField(COSDictionary f) {\n    field = f;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.text.SetFontAndSize.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.text.SetFontAndSize.process", "org.apache.pdfbox.contentstream.operator.text.SetFontAndSize.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    if (arguments.size() < 2) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    COSBase base1 = arguments.get(1);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    COSName fontName = ((COSName) (base0));\n    float fontSize = ((COSNumber) (base1)).floatValue();\n    PDFStreamEngine context = getContext();\n    context.getGraphicsState().getTextState().setFontSize(fontSize);\n    PDFont font = context.getResources().getFont(fontName);\n    if (font == null) {\n        LOG.warn((\"font '\" + fontName.getName()) + \"' not found in resources\");\n    }\n    context.getGraphicsState().getTextState().setFont(font);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.exportFDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.exportFDF", "org.apache.pdfbox.pdmodel.fdf.FDFDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will export all FDF form data.\n *\n * @return An FDF document used to export the document.\n * @throws IOException\n * \t\tIf there is an error when exporting the document.\n */\npublic FDFDocument exportFDF() throws IOException {\n    FDFDocument fdf = new FDFDocument();\n    FDFCatalog catalog = fdf.getCatalog();\n    FDFDictionary fdfDict = new FDFDictionary();\n    catalog.setFDF(fdfDict);\n    List<PDField> fields = getFields();\n    List<FDFField> fdfFields = new ArrayList<>(fields.size());\n    for (PDField field : fields) {\n        fdfFields.add(field.exportFDF());\n    }\n    fdfDict.setID(document.getDocument().getDocumentID());\n    if (!fdfFields.isEmpty()) {\n        fdfDict.setFields(fdfFields);\n    }\n    return fdf;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFile",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFile", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image file, see {@link #createFromFileByExtension(File, PDDocument)} for\n * more details.\n *\n * @param imagePath\n * \t\tthe image file path.\n * @param doc\n * \t\tthe document that shall use this PDImageXObject.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject, or if the image type is not supported.\n */\npublic static PDImageXObject createFromFile(String imagePath, PDDocument doc) throws IOException {\n    return createFromFileByExtension(new File(imagePath), doc);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDAnnotationAdditionalActions.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDAnnotationAdditionalActions.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDAnnotationAdditionalActions() {\n    actions = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<init>", "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param parent\n * \t\tThe parent font.\n * @throws IOException\n * \t\tif the font could not be read\n */\npublic PDCIDFontType0(COSDictionary fontDictionary, PDType0Font parent) throws IOException {\n    super(fontDictionary, parent);\n    boolean fontIsDamaged = false;\n    CFFFont cffFont = null;\n    PDFontDescriptor fd = getFontDescriptor();\n    if (fd != null) {\n        PDStream ff3Stream = fd.getFontFile3();\n        if (ff3Stream != null) {\n            try (RandomAccessRead randomAccessRead = ff3Stream.getCOSObject().createView()) {\n                if ((randomAccessRead.length() > 0) && (randomAccessRead.peek() == '%')) {\n                    // PDFBOX-2642 contains a corrupt PFB font instead of a CFF\n                    LOG.warn(\"Found PFB but expected embedded CFF font \" + fd.getFontName());\n                    fontIsDamaged = true;\n                } else {\n                    CFFParser cffParser = new CFFParser();\n                    cffFont = cffParser.parse(randomAccessRead).get(0);\n                }\n            } catch (IOException e) {\n                LOG.error(\"Can't read the embedded CFF font \" + fd.getFontName(), e);\n                fontIsDamaged = true;\n            }\n        }\n    }\n    if (cffFont != null) {\n        // embedded\n        if (cffFont instanceof CFFCIDFont) {\n            cidFont = ((CFFCIDFont) (cffFont));\n            t1Font = null;\n        } else {\n            cidFont = null;\n            t1Font = cffFont;\n        }\n        cid2gid = readCIDToGIDMap();\n        isEmbedded = true;\n        isDamaged = false;\n    } else {\n        // find font or substitute\n        CIDFontMapping mapping = FontMappers.instance().getCIDFont(getBaseFont(), getFontDescriptor(), getCIDSystemInfo());\n        FontBoxFont font;\n        if (mapping.isCIDFont()) {\n            cffFont = mapping.getFont().getCFF().getFont();\n            if (cffFont instanceof CFFCIDFont) {\n                cidFont = ((CFFCIDFont) (cffFont));\n                t1Font = null;\n                font = cidFont;\n            } else {\n                // PDFBOX-3515: OpenType fonts are loaded as CFFType1Font\n                CFFType1Font f = ((CFFType1Font) (cffFont));\n                cidFont = null;\n                t1Font = f;\n                font = f;\n            }\n        } else {\n            cidFont = null;\n            t1Font = mapping.getTrueTypeFont();\n            font = t1Font;\n        }\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback \" + font.getName()) + \" for CID-keyed font \") + getBaseFont());\n        }\n        isEmbedded = false;\n        isDamaged = fontIsDamaged;\n    }\n    fontMatrixTransform = getFontMatrix().createAffineTransform();\n    fontMatrixTransform.scale(1000, 1000);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDEmbeddedFilesNameTreeNode.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDEmbeddedFilesNameTreeNode.<init>", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDEmbeddedFilesNameTreeNode() {\n}", "/**\n * Constructor.\n */\nprotected PDNameTreeNode() {\n    node = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.DateConverter.toString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.DateConverter.toString", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * Converts a Calendar to a string formatted as:\n *     D:yyyyMMddHHmmss#hh'mm'  where # is Z, +, or -.\n *\n * @param cal\n * \t\tThe date to convert to a string. May be null.\n * \t\tThe DST_OFFSET is included when computing the output time zone.\n * @return The date as a String to be used in a PDF document,\nor null if the cal value is null\n */\npublic static String toString(Calendar cal) {\n    if (cal == null) {\n        return null;\n    }\n    String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET), \"'\");\n    return // trailing apostrophe\n    String.format(Locale.US, (((\"D:\" + \"%1$4tY%1$2tm%1$2td\")// yyyyMMdd\n     + \"%1$2tH%1$2tM%1$2tS\")// HHmmss\n     + \"%2$s\")// time zone\n     + \"'\", cal, offset);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getContentStreams",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getContentStreams", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the content streams which make up this page.\n *\n * @return content stream iterator\n */\npublic Iterator<PDStream> getContentStreams() {\n    COSBase base = page.getDictionaryObject(COSName.CONTENTS);\n    if (base instanceof COSStream) {\n        return Collections.singletonList(new PDStream(((COSStream) (base)))).iterator();\n    } else if (base instanceof COSArray) {\n        COSArray array = ((COSArray) (base));\n        List<PDStream> streams = new ArrayList<>(array.size());\n        for (int i = 0; i < array.size(); i++) {\n            COSStream stream = ((COSStream) (array.getObject(i)));\n            streams.add(new PDStream(stream));\n        }\n        return streams.iterator();\n    }\n    return Collections.emptyIterator();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDCalGray.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDCalGray.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Create a new CalGray color space.\n */\npublic PDCalGray() {\n    super(COSName.CALGRAY);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getWidth", "org.apache.pdfbox.pdfparser.PDFStreamParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the width from a type3 charproc stream.\n *\n * @return the glyph width.\n * @throws IOException\n * \t\tif the stream could not be read, or did not have d0 or d1 as first\n * \t\toperator, or if their first argument was not a number.\n */\npublic float getWidth() throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(this);\n    Object token = parser.parseNextToken();\n    while (token != null) {\n        if (token instanceof Operator) {\n            return parseWidth(((Operator) (token)), arguments);\n        } else {\n            arguments.add(((COSBase) (token)));\n        }\n        token = parser.parseNextToken();\n    } \n    throw new IOException(\"Unexpected end of stream\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new instance of PDPage for embedding.\n *\n * @param mediaBox\n * \t\tThe MediaBox of the page.\n */\npublic PDPage(PDRectangle mediaBox) {\n    page = new COSDictionary();\n    page.setItem(COSName.TYPE, COSName.PAGE);\n    page.setItem(COSName.MEDIA_BOX, mediaBox);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRawRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRawRaster", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "/**\n * Extract the raw unconverted raster of the given image\n *\n * @param pdImage\n * \t\tThe image to get the raw raster data from\n * @return the raw raster of this image\n * @throws IOException\n */\npublic static WritableRaster getRawRaster(PDImage pdImage) throws IOException {\n    if (pdImage.isEmpty()) {\n        throw new IOException(\"Image stream is empty\");\n    }\n    // get parameters, they must be valid or have been repaired\n    final PDColorSpace colorSpace = pdImage.getColorSpace();\n    final int numComponents = colorSpace.getNumberOfComponents();\n    final int width = pdImage.getWidth();\n    final int height = pdImage.getHeight();\n    final int bitsPerComponent = pdImage.getBitsPerComponent();\n    if ((width <= 0) || (height <= 0)) {\n        throw new IOException(\"image width and height must be positive\");\n    }\n    try {\n        int dataBufferType = DataBuffer.TYPE_BYTE;\n        if (bitsPerComponent > 8) {\n            dataBufferType = DataBuffer.TYPE_USHORT;\n        }\n        WritableRaster raster = Raster.createInterleavedRaster(dataBufferType, width, height, numComponents, new Point(0, 0));\n        readRasterFromAny(pdImage, raster);\n        return raster;\n    } catch (NegativeArraySizeException | IllegalArgumentException ex) {\n        throw new IOException(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadPDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadPDF", "org.apache.pdfbox.pdfparser.PDFParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Parses a PDF.\n *\n * @param input\n * \t\tbyte array that contains the document. {@link org.apache.pdfbox.io.RandomAccessReadBuffer} is used\n * \t\tto read the data.\n * @param password\n * \t\tpassword to be used for decryption\n * @param keyStore\n * \t\tkey store to be used for decryption when using public key security\n * @param alias\n * \t\talias to be used for decryption when using public key security\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache to be used for buffering\n * \t\tnew/altered PDF streams\n * @return loaded document\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIn case of a reading or parsing error.\n */\npublic static PDDocument loadPDF(byte[] input, String password, InputStream keyStore, String alias, StreamCacheCreateFunction streamCacheCreateFunction) throws IOException {\n    RandomAccessRead source = null;\n    try {\n        // RandomAccessRead is not closed here, may be needed for signing\n        source = new RandomAccessReadBuffer(input);\n        PDFParser parser = new PDFParser(source, password, keyStore, alias, streamCacheCreateFunction);\n        return parser.parse();\n    } catch (IOException ioe) {\n        IOUtils.closeQuietly(source);\n        throw ioe;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.visitFromDocument",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.visitFromDocument", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void visitFromDocument(COSDocument doc) throws IOException {\n    if (!incrementalUpdate) {\n        doWriteHeader(doc);\n    } else {\n        // Sometimes the original file will be missing a newline at the end\n        // In order to avoid having %%EOF the first object on the same line\n        // as the %%EOF, we put a newline here. If there's already one at\n        // the end of the file, an extra one won't hurt. PDFBOX-1051\n        getStandardOutput().writeCRLF();\n    }\n    if (isCompress()) {\n        doWriteBodyCompressed(doc);\n    } else {\n        doWriteBody(doc);\n    }\n    if (incrementalUpdate || doc.isXRefStream()) {\n        doWriteXRefInc(doc);\n    } else {\n        doWriteXRefTable();\n        doWriteTrailer(doc);\n    }\n    // write endof\n    getStandardOutput().write(STARTXREF);\n    getStandardOutput().writeEOL();\n    getStandardOutput().write(String.valueOf(getStartxref()).getBytes(StandardCharsets.ISO_8859_1));\n    getStandardOutput().writeEOL();\n    getStandardOutput().write(EOF);\n    getStandardOutput().writeEOL();\n    if (incrementalUpdate) {\n        if ((signatureOffset == 0) || (byteRangeOffset == 0)) {\n            doWriteIncrement();\n        } else {\n            doWriteSignature();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.createFromImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.createFromImage", "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.prepareImageXObject", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new CCITT group 4 (T6) compressed image XObject from a b/w BufferedImage. This\n * compression technique usually results in smaller images than those produced by {@link LosslessFactory#createFromImage(PDDocument, BufferedImage)}.\n *\n * @param document\n * \t\tthe document to create the image as part of.\n * @param image\n * \t\tthe image.\n * @return a new image XObject.\n * @throws IOException\n * \t\tif there is an error creating the image.\n * @throws IllegalArgumentException\n * \t\tif the BufferedImage is not a b/w image.\n */\npublic static PDImageXObject createFromImage(PDDocument document, BufferedImage image) throws IOException {\n    if ((image.getType() != BufferedImage.TYPE_BYTE_BINARY) && (image.getColorModel().getPixelSize() != 1)) {\n        throw new IllegalArgumentException(\"Only 1-bit b/w images supported\");\n    }\n    int height = image.getHeight();\n    int width = image.getWidth();\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(Math.max(32, (width + 1) * height));\n    try (MemoryCacheImageOutputStream mcios = new MemoryCacheImageOutputStream(bos)) {\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                // flip bit to avoid having to set /BlackIs1\n                mcios.writeBits(~(image.getRGB(x, y) & 1), 1);\n            }\n            int bitOffset = mcios.getBitOffset();\n            if (bitOffset != 0) {\n                mcios.writeBits(0, 8 - bitOffset);\n            }\n        }\n        mcios.flush();\n    }\n    return prepareImageXObject(document, bos.toByteArray(), width, height, PDDeviceGray.INSTANCE);\n}", "private static PDImageXObject prepareImageXObject(PDDocument document, byte[] byteArray, int width, int height, PDColorSpace initColorSpace) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    Filter filter = FilterFactory.INSTANCE.getFilter(COSName.CCITTFAX_DECODE);\n    COSDictionary dict = new COSDictionary();\n    dict.setInt(COSName.COLUMNS, width);\n    dict.setInt(COSName.ROWS, height);\n    filter.encode(new ByteArrayInputStream(byteArray), baos, dict, 0);\n    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(baos.toByteArray());\n    PDImageXObject image = new PDImageXObject(document, encodedByteStream, COSName.CCITTFAX_DECODE, width, height, 1, initColorSpace);\n    dict.setInt(COSName.K, -1);\n    image.getCOSObject().setItem(COSName.DECODE_PARMS, dict);\n    return image;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDInkAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDInkAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDInkAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationInk ink = ((PDAnnotationInk) (getAnnotation()));\n    PDColor color = ink.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    // PDF spec does not mention /Border for ink annotations, but it is used if /BS is not available\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\n    if (Float.compare(ab.width, 0) == 0) {\n        return;\n    }\n    // Adjust rectangle even if not empty\n    // file from PDF.js issue 13447\n    // TODO in a class structure this should be overridable\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (float[] pathArray : ink.getInkList()) {\n        int nPoints = pathArray.length / 2;\n        for (int i = 0; i < nPoints; ++i) {\n            float x = pathArray[i * 2];\n            float y = pathArray[(i * 2) + 1];\n            minX = Math.min(minX, x);\n            minY = Math.min(minY, y);\n            maxX = Math.max(maxX, x);\n            maxY = Math.max(maxY, y);\n        }\n    }\n    PDRectangle rect = ink.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    rect.setLowerLeftX(Math.min(minX - (ab.width * 2), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width * 2), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width * 2), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width * 2), rect.getUpperRightY()));\n    ink.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, ink.getConstantOpacity());\n        cs.setStrokingColor(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        for (float[] pathArray : ink.getInkList()) {\n            int nPoints = pathArray.length / 2;\n            // \"When drawn, the points shall be connected by straight lines or curves\n            // in an implementation-dependent way\" - we do lines.\n            for (int i = 0; i < nPoints; ++i) {\n                float x = pathArray[i * 2];\n                float y = pathArray[(i * 2) + 1];\n                if (i == 0) {\n                    cs.moveTo(x, y);\n                } else {\n                    cs.lineTo(x, y);\n                }\n            }\n            cs.stroke();\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.codeToGID",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.codeToGID", "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the GID for the given character code.\n *\n * @param code\n * \t\tcharacter code\n * @return GID\n * @throws IOException\n * \t\tif the mapping could not be read\n */\n@Override\npublic int codeToGID(int code) throws IOException {\n    if (!isEmbedded) {\n        // The conforming reader shall select glyphs by translating characters from the\n        // encoding specified by the predefined CMap to one of the encodings in the TrueType\n        // font's 'cmap' table. The means by which this is accomplished are implementation-\n        // dependent.\n        // omit the CID2GID mapping if the embedded font is replaced by an external font\n        String name = getName();\n        if ((((cid2gid != null) && (!isDamaged)) && (name != null)) && name.equals(ttf.getName())) {\n            // Acrobat allows non-embedded GIDs - todo: can we find a test PDF for this?\n            // PDFBOX-5612: should happen only if it's really the same font\n            // this is not perfect, we may have to improve this because some identical fonts\n            // have different names\n            LOG.warn(\"Using non-embedded GIDs in font \" + getName());\n            int cid = codeToCID(code);\n            if (cid < cid2gid.length) {\n                return cid2gid[cid];\n            } else {\n                return 0;\n            }\n        } else {\n            // fallback to the ToUnicode CMap, test with PDFBOX-1422 and PDFBOX-2560\n            String unicode = parent.toUnicode(code);\n            if (unicode == null) {\n                if (!noMapping.contains(code)) {\n                    // we keep track of which warnings have been issued, so we don't log multiple times\n                    noMapping.add(code);\n                    LOG.warn(((\"Failed to find a character mapping for \" + code) + \" in \") + getName());\n                }\n                // Acrobat is willing to use the CID as a GID, even when the font isn't embedded\n                // see PDFBOX-2599\n                return codeToCID(code);\n            } else if (unicode.length() > 1) {\n                LOG.warn(\"Trying to map multi-byte character using 'cmap', result will be poor\");\n            }\n            // a non-embedded font always has a cmap (otherwise FontMapper won't load it)\n            return cmap.getGlyphId(unicode.codePointAt(0));\n        }\n    } else {\n        // If the TrueType font program is embedded, the Type 2 CIDFont dictionary shall contain\n        // a CIDToGIDMap entry that maps CIDs to the glyph indices for the appropriate glyph\n        // descriptions in that font program.\n        int cid = codeToCID(code);\n        if (cid2gid != null) {\n            // use CIDToGIDMap\n            if (cid < cid2gid.length) {\n                return cid2gid[cid];\n            } else {\n                return 0;\n            }\n        } else {\n            // \"Identity\" is the default for CFF-based OpenTypeFonts\n            if ((otf != null) && otf.isPostScript()) {\n                return cid;\n            }\n            // \"Identity\" is the default for TrueTypeFonts if the CID is within the range\n            return cid < ttf.getNumberOfGlyphs() ? cid : 0;\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareDocumentForEncryption",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareDocumentForEncryption", "org.apache.pdfbox.pdmodel.encryption.PDEncryption.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Prepare document for encryption.\n *\n * @param document\n * \t\tThe document to encrypt.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\n@Override\npublic void prepareDocumentForEncryption(PDDocument document) throws IOException {\n    PDEncryption encryptionDictionary = document.getEncryption();\n    if (encryptionDictionary == null) {\n        encryptionDictionary = new PDEncryption();\n    }\n    int version = computeVersionNumber();\n    int revision = computeRevisionNumber(version);\n    encryptionDictionary.setFilter(FILTER);\n    encryptionDictionary.setVersion(version);\n    if ((version != REVISION_4) && (version != REVISION_5)) {\n        // remove CF, StmF, and StrF entries that may be left from a previous encryption\n        encryptionDictionary.removeV45filters();\n    }\n    encryptionDictionary.setRevision(revision);\n    encryptionDictionary.setLength(getKeyLength());\n    StandardProtectionPolicy protectionPolicy = getProtectionPolicy();\n    String ownerPassword = protectionPolicy.getOwnerPassword();\n    String userPassword = protectionPolicy.getUserPassword();\n    if (ownerPassword == null) {\n        ownerPassword = \"\";\n    }\n    if (userPassword == null) {\n        userPassword = \"\";\n    }\n    // If no owner password is set, use the user password instead.\n    if (ownerPassword.isEmpty()) {\n        ownerPassword = userPassword;\n    }\n    int permissionInt = protectionPolicy.getPermissions().getPermissionBytes();\n    encryptionDictionary.setPermissions(permissionInt);\n    int length = getKeyLength() / 8;\n    if (revision == REVISION_6) {\n        // PDFBOX-4155\n        ownerPassword = SaslPrep.saslPrepStored(ownerPassword);\n        userPassword = SaslPrep.saslPrepStored(userPassword);\n        prepareEncryptionDictRev6(ownerPassword, userPassword, encryptionDictionary, permissionInt);\n    } else {\n        prepareEncryptionDictRev234(ownerPassword, userPassword, encryptionDictionary, permissionInt, document, revision, length);\n    }\n    document.setEncryptionDictionary(encryptionDictionary);\n    document.getDocument().setEncryptionDictionary(encryptionDictionary.getCOSObject());\n}", "/**\n * creates a new empty encryption dictionary.\n */\npublic PDEncryption() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDStream.getFileDecodeParams",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDStream.getFileDecodeParams", "org.apache.pdfbox.pdmodel.common.PDStream.internalGetDecodeParams", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the list of decode parameters. Each entry in the list will refer to\n * an entry in the filters list.\n *\n * @return The list of decode parameters.\n * @throws IOException\n * \t\tif there is an error retrieving the parameters.\n */\npublic List<Object> getFileDecodeParams() throws IOException {\n    return internalGetDecodeParams(COSName.F_DECODE_PARMS, null);\n}", "private List<Object> internalGetDecodeParams(COSName name1, COSName name2) throws IOException {\n    COSBase dp = stream.getDictionaryObject(name1, name2);\n    if (dp instanceof COSDictionary) {\n        Map<?, ?> map = COSDictionaryMap.convertBasicTypesToMap(((COSDictionary) (dp)));\n        return new COSArrayList<>(map, dp, stream, name1);\n    }\n    if (dp instanceof COSArray) {\n        COSArray array = ((COSArray) (dp));\n        List<Object> actuals = new ArrayList<>(array.size());\n        for (int i = 0; i < array.size(); i++) {\n            COSBase base = array.getObject(i);\n            if (base instanceof COSDictionary) {\n                actuals.add(COSDictionaryMap.convertBasicTypesToMap(((COSDictionary) (base))));\n            } else {\n                LOG.warn((\"Expected COSDictionary, got \" + base) + \", ignored\");\n            }\n        }\n        return new COSArrayList<>(actuals, array);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFDocument.close",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFDocument.close", "org.apache.pdfbox.pdmodel.fdf.FDFDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will close the underlying COSDocument object.\n *\n * @throws IOException\n * \t\tIf there is an error releasing resources.\n */\n@Override\npublic void close() throws IOException {\n    if (!document.isClosed()) {\n        IOException firstException = null;\n        // close all intermediate I/O streams\n        firstException = IOUtils.closeAndLogException(document, LOG, \"COSDocument\", firstException);\n        // close the source PDF stream, if we read from one\n        if (fdfSource != null) {\n            firstException = IOUtils.closeAndLogException(fdfSource, LOG, \"RandomAccessRead pdfSource\", firstException);\n        }\n        // rethrow first exception to keep method contract\n        if (firstException != null) {\n            throw firstException;\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValue.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValue.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDSeedValue() {\n    dictionary = new COSDictionary();\n    dictionary.setItem(COSName.TYPE, COSName.SV);\n    dictionary.setDirect(true);// the specification claim to use direct objects\n\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.importPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.importPage", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "/**\n * This will import and copy the contents from another location. Currently the content stream is\n * stored in a scratch file. The scratch file is associated with the document. If you are adding\n * a page to this document from another document and want to copy the contents to this\n * document's scratch file then use this method otherwise just use the {@link #addPage addPage()}\n * method.\n * <p>\n * Unlike {@link #addPage addPage()}, this method creates a new PDPage object. If your page has\n * annotations, and if these link to pages not in the target document, then the target document\n * might become huge. What you need to do is to delete page references of such annotations. See\n * <a href=\"http://stackoverflow.com/a/35477351/535646\">here</a> for how to do this.\n * <p>\n * Inherited (global) resources are ignored because these can contain resources not needed for\n * this page which could bloat your document, see\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-28\">PDFBOX-28</a> and related issues.\n * If you need them, call <code>importedPage.setResources(page.getResources());</code>\n * <p>\n * This method should only be used to import a page from a loaded document, not from a generated\n * document because these can contain unfinished parts, e.g. font subsetting information.\n *\n * @param page\n * \t\tThe page to import.\n * @return The page that was imported.\n * @throws IOException\n * \t\tIf there is an error copying the page.\n */\npublic PDPage importPage(PDPage page) throws IOException {\n    PDPage importedPage = new PDPage(new COSDictionary(page.getCOSObject()), resourceCache);\n    importedPage.getCOSObject().removeItem(COSName.PARENT);\n    PDStream dest = new PDStream(this, page.getContents(), COSName.FLATE_DECODE);\n    importedPage.setContents(dest);\n    addPage(importedPage);\n    importedPage.setCropBox(new PDRectangle(page.getCropBox().getCOSArray()));\n    importedPage.setMediaBox(new PDRectangle(page.getMediaBox().getCOSArray()));\n    importedPage.setRotation(page.getRotation());\n    if ((page.getResources() != null) && (!page.getCOSObject().containsKey(COSName.RESOURCES))) {\n        LOG.warn(\"inherited resources of source document are not imported to destination page\");\n        LOG.warn(\"call importedPage.setResources(page.getResources()) to do this\");\n    }\n    return importedPage;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.put",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the pattern resource with the given name.\n *\n * @param name\n * \t\tthe name of the resource\n * @param pattern\n * \t\tthe pattern to be added\n */\npublic void put(COSName name, PDAbstractPattern pattern) {\n    put(COSName.PATTERN, name, pattern);\n}", "/**\n * Sets the value of a given named resource.\n */\nprivate void put(COSName kind, COSName name, COSObjectable object) {\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if (dict == null) {\n        dict = new COSDictionary();\n        resources.setItem(kind, dict);\n    }\n    dict.setItem(name, object);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadXFDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadXFDF", "org.apache.pdfbox.pdmodel.fdf.FDFDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will load a document from an input stream. The stream is loaded to the memory to establish random access to\n * the data.\n *\n * @param input\n * \t\tThe stream that contains the document.\n * @return The document that was loaded.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\npublic static FDFDocument loadXFDF(InputStream input) throws IOException {\n    return new FDFDocument(XMLUtil.parse(input));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDUnderlineAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDUnderlineAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDUnderlineAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationUnderline annotation = ((PDAnnotationUnderline) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getQuadPoints();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    if (Float.compare(ab.width, 0) == 0) {\n        // value found in adobe reader\n        ab.width = 1.5F;\n    }\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    // TODO in a class structure this should be overridable\n    // this is similar to polyline but different data type\n    // all coordinates (unlike painting) are used because I'm lazy\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    rect.setLowerLeftX(Math.min(minX - (ab.width / 2), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width / 2), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width / 2), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width / 2), rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        cs.setStrokingColor(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        // spec is incorrect\n        // https://stackoverflow.com/questions/9855814/pdf-spec-vs-acrobat-creation-quadpoints\n        for (int i = 0; i < (pathsArray.length / 8); ++i) {\n            // Adobe doesn't use the lower coordinate for the line, it uses lower + delta / 7.\n            // do the math for diagonal annotations with this weird old trick:\n            // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n            float len0 = ((float) (Math.sqrt(Math.pow(pathsArray[i * 8] - pathsArray[(i * 8) + 4], 2) + Math.pow(pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5], 2))));\n            float x0 = pathsArray[(i * 8) + 4];\n            float y0 = pathsArray[(i * 8) + 5];\n            if (Float.compare(len0, 0) != 0) {\n                // only if both coordinates are not identical to avoid divide by zero\n                x0 += (((pathsArray[i * 8] - pathsArray[(i * 8) + 4]) / len0) * len0) / 7;\n                y0 += ((pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5]) / len0) * (len0 / 7);\n            }\n            float len1 = ((float) (Math.sqrt(Math.pow(pathsArray[(i * 8) + 2] - pathsArray[(i * 8) + 6], 2) + Math.pow(pathsArray[(i * 8) + 3] - pathsArray[(i * 8) + 7], 2))));\n            float x1 = pathsArray[(i * 8) + 6];\n            float y1 = pathsArray[(i * 8) + 7];\n            if (Float.compare(len1, 0) != 0) {\n                // only if both coordinates are not identical to avoid divide by zero\n                x1 += (((pathsArray[(i * 8) + 2] - pathsArray[(i * 8) + 6]) / len1) * len1) / 7;\n                y1 += (((pathsArray[(i * 8) + 3] - pathsArray[(i * 8) + 7]) / len1) * len1) / 7;\n            }\n            cs.moveTo(x0, y0);\n            cs.lineTo(x1, y1);\n        }\n        cs.stroke();\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSArray.set",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSArray.set", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set an object at a specific index.\n *\n * @param index\n * \t\tzero based index into array.\n * @param object\n * \t\tThe object to set.\n */\npublic void set(int index, COSBase object) {\n    // wrap indirect objects\n    if ((((object instanceof COSDictionary) || (object instanceof COSArray)) && (!object.isDirect())) && (object.getKey() != null)) {\n        COSObject cosObject = new COSObject(object, object.getKey());\n        objects.set(index, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        objects.set(index, object);\n        getUpdateState().update(object);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given color space to the resources of the current page and returns the name for the\n * new resources. Returns the existing resource name if the given item already exists.\n *\n * @param colorSpace\n * \t\tthe color space to add\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDColorSpace colorSpace) {\n    return add(COSName.COLORSPACE, \"cs\", colorSpace);\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.write",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.write", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will write the pdf document.\n *\n * @throws IOException\n * \t\tIf an error occurs while generating the data.\n * @param doc\n * \t\tThe document to write.\n */\npublic void write(COSDocument doc) throws IOException {\n    PDDocument pdDoc = new PDDocument(doc);\n    write(pdDoc);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTransparencyGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTransparencyGroup", "org.apache.pdfbox.contentstream.PDFStreamEngine.processTransparencyGroup", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.PDFStreamParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Shows a transparency group from the content stream.\n *\n * @param form\n * \t\ttransparency group (form) XObject\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\npublic void showTransparencyGroup(PDTransparencyGroup form) throws IOException {\n    processTransparencyGroup(form);\n}", "/**\n * Processes a transparency group stream.\n *\n * @param group\n * \t\ttransparency group to be processed\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\nprotected void processTransparencyGroup(PDTransparencyGroup group) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    PDResources parent = pushResources(group);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(group.getMatrix());\n    // Before execution of the transparency group XObjectâs content stream,\n    // the current blend mode in the graphics state shall be initialized to Normal,\n    // the current stroking and nonstroking alpha constants to 1.0, and the current soft mask to None.\n    graphicsState.setBlendMode(BlendMode.NORMAL);\n    graphicsState.setAlphaConstant(1);\n    graphicsState.setNonStrokeAlphaConstant(1);\n    graphicsState.setSoftMask(null);\n    // clip to bounding box\n    clipToRect(group.getBBox());\n    try {\n        processStreamOperators(group);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAcroForm",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAcroForm", "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createAcroForm(PDDocument template) {\n    PDAcroForm theAcroForm = new PDAcroForm(template);\n    template.getDocumentCatalog().setAcroForm(theAcroForm);\n    pdfStructure.setAcroForm(theAcroForm);\n    LOG.info(\"AcroForm has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setStartxref",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setStartxref", "org.apache.pdfbox.pdfparser.XrefTrailerResolver.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the byte position of the first XRef\n * (has to be called after very last startxref was read).\n * This is used to resolve chain of active XRef/trailer.\n *\n * In case startxref position is not found we output a\n * warning and use all XRef/trailer objects combined\n * in byte position order.\n * Thus for incomplete PDF documents with missing\n * startxref one could call this method with parameter value -1.\n *\n * @param startxrefBytePosValue\n * \t\tstarting position of the first XRef\n */\npublic void setStartxref(long startxrefBytePosValue) {\n    if (resolvedXrefTrailer != null) {\n        LOG.warn(\"Method must be called only ones with last startxref value.\");\n        return;\n    }\n    resolvedXrefTrailer = new XrefTrailerObj();\n    resolvedXrefTrailer.trailer = new COSDictionary();\n    XrefTrailerObj curObj = bytePosToXrefMap.get(startxrefBytePosValue);\n    List<Long> xrefSeqBytePos = new ArrayList<>();\n    if (curObj == null) {\n        // no XRef at given position\n        LOG.warn(\"Did not found XRef object at specified startxref position \" + startxrefBytePosValue);\n        // use all objects in byte position order (last entries overwrite previous ones)\n        xrefSeqBytePos.addAll(bytePosToXrefMap.keySet());\n        Collections.sort(xrefSeqBytePos);\n    } else {\n        // copy xref type\n        resolvedXrefTrailer.xrefType = curObj.xrefType;\n        // found starting Xref object\n        // add this and follow chain defined by 'Prev' keys\n        xrefSeqBytePos.add(startxrefBytePosValue);\n        while (curObj.trailer != null) {\n            long prevBytePos = curObj.trailer.getLong(COSName.PREV, -1L);\n            if (prevBytePos == (-1)) {\n                break;\n            }\n            curObj = bytePosToXrefMap.get(prevBytePos);\n            if (curObj == null) {\n                LOG.warn(\"Did not found XRef object pointed to by 'Prev' key at position \" + prevBytePos);\n                break;\n            }\n            xrefSeqBytePos.add(prevBytePos);\n            // prevent infinite loops\n            if (xrefSeqBytePos.size() >= bytePosToXrefMap.size()) {\n                break;\n            }\n        } \n        // have to reverse order so that later XRefs will overwrite previous ones\n        Collections.reverse(xrefSeqBytePos);\n    }\n    // merge used and sorted XRef/trailer\n    for (Long bPos : xrefSeqBytePos) {\n        curObj = bytePosToXrefMap.get(bPos);\n        if (curObj.trailer != null) {\n            resolvedXrefTrailer.trailer.addAll(curObj.trailer);\n        }\n        resolvedXrefTrailer.xrefTable.putAll(curObj.xrefTable);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDURIDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDURIDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDURIDictionary() {\n    this.uriDictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.toString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.toString", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic String toString() {\n    try {\n        return getDictionaryString(this, new ArrayList<>());\n    } catch (IOException e) {\n        LOG.debug(\"An exception occurred trying - returning error message instead\", e);\n        return (\"COSDictionary{\" + e.getMessage()) + \"}\";\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFJavaScript.setBefore",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFJavaScript.setBefore", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the javascript code the will get execute before the import.\n *\n * @param before\n * \t\tA reference to some javascript code.\n */\npublic void setBefore(String before) {\n    dictionary.setItem(COSName.BEFORE, new COSString(before));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.getBoundingBox",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.getBoundingBox", "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.generateBoundingBox", "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<clinit>" ],
    "fullMethods" : [ "@Override\npublic BoundingBox getBoundingBox() {\n    if (fontBBox == null) {\n        fontBBox = generateBoundingBox();\n    }\n    return fontBBox;\n}", "private BoundingBox generateBoundingBox() {\n    if (getFontDescriptor() != null) {\n        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();\n        if ((bbox != null) && ((((Float.compare(bbox.getLowerLeftX(), 0) != 0) || (Float.compare(bbox.getLowerLeftY(), 0) != 0)) || (Float.compare(bbox.getUpperRightX(), 0) != 0)) || (Float.compare(bbox.getUpperRightY(), 0) != 0))) {\n            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());\n        }\n    }\n    try {\n        return cidFont != null ? cidFont.getFontBBox() : t1Font.getFontBBox();\n    } catch (IOException e) {\n        LOG.debug(\"Couldn't get font bounding box - returning default value\", e);\n        return new BoundingBox();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.setVisualSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.setVisualSignature", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.initFromRandomAccessRead", "org.apache.pdfbox.pdfparser.PDFParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Reads the visual signature from the given file.\n *\n * @param file\n * \t\tthe file containing the visual signature\n * @throws IOException\n * \t\twhen something went wrong during parsing\n */\npublic void setVisualSignature(File file) throws IOException {\n    initFromRandomAccessRead(new RandomAccessReadBufferedFile(file));\n}", "private void initFromRandomAccessRead(RandomAccessRead rar) throws IOException {\n    pdfSource = rar;\n    PDFParser parser = new PDFParser(pdfSource);\n    visualSignature = parser.parse().getDocument();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDPageLabels.getCOSObject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDPageLabels.getCOSObject", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic COSBase getCOSObject() {\n    COSArray arr = new COSArray();\n    labels.forEach((key, value) -> {\n        arr.add(COSInteger.get(key));\n        arr.add(value);\n    });\n    COSDictionary dict = new COSDictionary();\n    dict.setItem(COSName.NUMS, arr);\n    return dict;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.GlyphCache.getPathForCharacterCode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.GlyphCache.getPathForCharacterCode", "org.apache.pdfbox.rendering.GlyphCache.<clinit>" ],
    "fullMethods" : [ "public GeneralPath getPathForCharacterCode(int code) {\n    GeneralPath path = cache.get(code);\n    if (path != null) {\n        return path;\n    }\n    try {\n        if (!font.hasGlyph(code)) {\n            String fontName = ((PDFontLike) (font)).getName();\n            if (font instanceof PDType0Font) {\n                int cid = ((PDType0Font) (font)).codeToCID(code);\n                String cidHex = String.format(\"%04x\", cid);\n                LOG.warn(((((\"No glyph for code \" + code) + \" (CID \") + cidHex) + \") in font \") + fontName);\n            } else if (font instanceof PDSimpleFont) {\n                PDSimpleFont simpleFont = ((PDSimpleFont) (font));\n                LOG.warn((((((((\"No glyph for code \" + code) + \" in \") + font.getClass().getSimpleName()) + \" \") + fontName) + \" (embedded or system font used: \") + simpleFont.getFontBoxFont().getName()) + \")\");\n                if ((code == 10) && simpleFont.isStandard14()) {\n                    // PDFBOX-4001 return empty path for line feed on std14\n                    path = new GeneralPath();\n                    cache.put(code, path);\n                    return path;\n                }\n            } else {\n                LOG.warn(((\"No glyph for code \" + code) + \" in font \") + fontName);\n            }\n        }\n        path = font.getNormalizedPath(code);\n        cache.put(code, path);\n        return path;\n    } catch (IOException e) {\n        // todo: escalate this error?\n        String fontName = ((PDFontLike) (font)).getName();\n        LOG.error(((\"Glyph rendering failed for code \" + code) + \" in font \") + fontName, e);\n        return new GeneralPath();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator", "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator", "org.apache.pdfbox.contentstream.operator.text.MoveText.process", "org.apache.pdfbox.contentstream.operator.text.MoveText.<clinit>" ],
    "fullMethods" : [ "/**\n * This is used to handle an operation.\n *\n * @param operation\n * \t\tThe operation to perform.\n * @param arguments\n * \t\tThe list of arguments.\n * @throws IOException\n * \t\tIf there is an error processing the operation.\n */\npublic void processOperator(String operation, List<COSBase> arguments) throws IOException {\n    Operator operator = Operator.getOperator(operation);\n    processOperator(operator, arguments);\n}", "/**\n * This is used to handle an operation.\n *\n * @param operator\n * \t\tThe operation to perform.\n * @param operands\n * \t\tThe list of arguments.\n * @throws IOException\n * \t\tIf there is an error processing the operation.\n */\nprotected void processOperator(Operator operator, List<COSBase> operands) throws IOException {\n    String name = operator.getName();\n    OperatorProcessor processor = operators.get(name);\n    if (processor != null) {\n        try {\n            processor.process(operator, operands);\n        } catch (IOException e) {\n            operatorException(operator, operands, e);\n        }\n    } else {\n        unsupportedOperator(operator, operands);\n    }\n}", "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws MissingOperandException {\n    if (arguments.size() < 2) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    PDFStreamEngine context = getContext();\n    Matrix textLineMatrix = context.getTextLineMatrix();\n    if (textLineMatrix == null) {\n        LOG.warn((\"TextLineMatrix is null, \" + getName()) + \" operator will be ignored\");\n        return;\n    }\n    COSBase base0 = arguments.get(0);\n    COSBase base1 = arguments.get(1);\n    if (!(base0 instanceof COSNumber)) {\n        return;\n    }\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    COSNumber x = ((COSNumber) (base0));\n    COSNumber y = ((COSNumber) (base1));\n    Matrix matrix = new Matrix(1, 0, 0, 1, x.floatValue(), y.floatValue());\n    textLineMatrix.concatenate(matrix);\n    context.setTextMatrix(textLineMatrix.clone());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default Constructor.\n */\npublic PDObjectReference() {\n    this.dictionary = new COSDictionary();\n    this.dictionary.setName(COSName.TYPE, TYPE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.getZapfDingbats",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.getZapfDingbats", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the Zapf Dingbats glyph list.\n *\n * @return the Zapf Dingbats glyph list\n */\npublic static GlyphList getZapfDingbats() {\n    return ZAPF_DINGBATS;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor. Creates empty COSDictionary if dict is null.\n *\n * @param dict\n * \t\tThe dictionary that fulfils this file specification.\n */\npublic PDComplexFileSpecification(COSDictionary dict) {\n    if (dict == null) {\n        fs = new COSDictionary();\n        fs.setItem(COSName.TYPE, COSName.FILESPEC);\n    } else {\n        fs = dict;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentNameDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentNameDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param cat\n * \t\tThe document catalog that this dictionary is part of.\n */\npublic PDDocumentNameDictionary(PDDocumentCatalog cat) {\n    COSDictionary names = cat.getCOSObject().getCOSDictionary(COSName.NAMES);\n    if (names == null) {\n        names = new COSDictionary();\n        cat.getCOSObject().setItem(COSName.NAMES, names);\n    }\n    nameDictionary = names;\n    catalog = cat;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroupAttributes.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroupAttributes.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a group object with /Transparency subtype entry.\n */\npublic PDTransparencyGroupAttributes() {\n    dictionary = new COSDictionary();\n    dictionary.setItem(COSName.S, COSName.TRANSPARENCY);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.getFontFile",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.getFontFile", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * A stream containing a Type 1 font program.\n *\n * @return A stream containing a Type 1 font program.\n */\npublic PDStream getFontFile() {\n    COSStream stream = dic.getCOSStream(COSName.FONT_FILE);\n    return stream != null ? new PDStream(stream) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.codeToName",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.codeToName", "org.apache.pdfbox.pdmodel.font.PDType1Font.getNameInFont", "org.apache.pdfbox.pdmodel.font.PDType1Font.<clinit>" ],
    "fullMethods" : [ "// @Override\npublic String codeToName(int code) throws IOException {\n    String name = (getEncoding() != null) ? getEncoding().getName(code) : \".notdef\";\n    return getNameInFont(name);\n}", "/**\n * Maps a PostScript glyph name to the name in the underlying font, for example when\n * using a TTF font we might map \"W\" to \"uni0057\".\n */\nprivate String getNameInFont(String name) throws IOException {\n    if (isEmbedded() || genericFont.hasGlyph(name)) {\n        return name;\n    }\n    // try alternative name\n    String altName = ALT_NAMES.get(name);\n    if (((altName != null) && (!name.equals(\".notdef\"))) && genericFont.hasGlyph(altName)) {\n        return altName;\n    }\n    // try unicode name\n    String unicodes = getGlyphList().toUnicode(name);\n    if ((unicodes != null) && (unicodes.length() == 1)) {\n        String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));\n        if (genericFont.hasGlyph(uniName)) {\n            return uniName;\n        }\n        // PDFBOX-4017: no postscript table on Windows 10, and the low uni00NN\n        // names are not found in Symbol font. What works is using the PDF code plus 0xF000\n        // while disregarding encoding from the PDF (because of file from PDFBOX-1606,\n        // makes sense because this segment is about finding the name in a standard font)\n        // TODO bring up better solution than this\n        if (\"SymbolMT\".equals(genericFont.getName())) {\n            Integer code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(name);\n            if (code != null) {\n                uniName = getUniNameOfCodePoint(code + 0xf000);\n                if (genericFont.hasGlyph(uniName)) {\n                    return uniName;\n                }\n            }\n        }\n    }\n    return \".notdef\";\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.toUnicode", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String toUnicode(int code) {\n    // try to use a ToUnicode CMap\n    String unicode = super.toUnicode(code);\n    if (unicode != null) {\n        return unicode;\n    }\n    // Use identity mapping if the given ToUnicode CMap doesn't provide any valid mapping\n    // a predefined map shall only be used if there isn't any ToUnicode CMap\n    // PDFBOX-6022: not when there's a predefined cmap\n    if ((getToUnicodeCMap() != null) && (!isCMapPredefined)) {\n        return Character.toString(((char) (code)));\n    }\n    if ((isCMapPredefined || isDescendantCJK) && (cMapUCS2 != null)) {\n        // if the font is composite and uses a predefined cmap (excluding Identity-H/V) then\n        // or if its descendant font uses Adobe-GB1/CNS1/Japan1/Korea1\n        // a) Map the character code to a character identifier (CID) according to the font?s CMap\n        int cid = codeToCID(code);\n        // e) Map the CID according to the CMap from step d), producing a Unicode value\n        return cMapUCS2.toUnicode(cid);\n    }\n    // PDFBOX-5324: try to get unicode from font cmap\n    if (descendantFont instanceof PDCIDFontType2) {\n        TrueTypeFont font = ((PDCIDFontType2) (descendantFont)).getTrueTypeFont();\n        if (font != null) {\n            try {\n                CmapLookup cmap = font.getUnicodeCmapLookup(false);\n                if (cmap != null) {\n                    int gid;\n                    if (descendantFont.isEmbedded()) {\n                        // original PDFBOX-5324 supported only embedded fonts\n                        gid = descendantFont.codeToGID(code);\n                    } else {\n                        // PDFBOX-5331: this bypasses the fallback attempt in\n                        // PDCIDFontType2.codeToGID() which would bring a stackoverflow\n                        gid = descendantFont.codeToCID(code);\n                    }\n                    List<Integer> codes = cmap.getCharCodes(gid);\n                    if ((codes != null) && (!codes.isEmpty())) {\n                        return Character.toString(((char) (int) (codes.get(0))));\n                    }\n                }\n            } catch (IOException e) {\n                LOG.warn(\"get unicode from font cmap fail\", e);\n            }\n        }\n    }\n    if (LOG.isWarnEnabled() && (!noUnicode.contains(code))) {\n        // if no value has been produced, there is no way to obtain Unicode for the character.\n        String cid = \"CID+\" + codeToCID(code);\n        LOG.warn(((((\"No Unicode mapping for \" + cid) + \" (\") + code) + \") in font \") + getName());\n        // we keep track of which warnings have been issued, so we don't log multiple times\n        noUnicode.add(code);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.decodeHex",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.decodeHex", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Decodes a hex String into a byte array.\n *\n * @param s\n * \t\tA String with ASCII hex.\n * @return decoded byte array.\n */\npublic static byte[] decodeHex(String s) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream((s.length() + 1) / 2);\n    int i = 0;\n    while (i < (s.length() - 1)) {\n        if ((s.charAt(i) == '\\n') || (s.charAt(i) == '\\r')) {\n            ++i;\n        } else {\n            int value = (16 * getHexValue(s.charAt(i))) + getHexValue(s.charAt(i + 1));\n            if (value >= 0) {\n                baos.write(value);\n            } else {\n                String hexByte = s.substring(i, i + 2);\n                LOG.error((\"Can't parse \" + hexByte) + \", aborting decode\");\n                break;\n            }\n            i += 2;\n        }\n    } \n    return baos.toByteArray();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDSimpleFont.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDSimpleFont.toUnicode", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String toUnicode(int code, GlyphList customGlyphList) {\n    // allow the glyph list to be overridden for the purpose of extracting Unicode\n    // we only do this when the font's glyph list is the AGL, to avoid breaking Zapf Dingbats\n    GlyphList unicodeGlyphList;\n    if (this.glyphList == GlyphList.getAdobeGlyphList()) {\n        unicodeGlyphList = customGlyphList;\n    } else {\n        unicodeGlyphList = this.glyphList;\n    }\n    // first try to use a ToUnicode CMap\n    String unicode = super.toUnicode(code);\n    if (unicode != null) {\n        return unicode;\n    }\n    // if the font is a \"simple font\" and uses MacRoman/MacExpert/WinAnsi[Encoding]\n    // or has Differences with names from only Adobe Standard and/or Symbol, then:\n    // \n    // a) Map the character codes to names\n    // b) Look up the name in the Adobe Glyph List to obtain the Unicode value\n    String name = null;\n    if (encoding != null) {\n        name = encoding.getName(code);\n        unicode = unicodeGlyphList.toUnicode(name);\n        if (unicode != null) {\n            return unicode;\n        }\n    }\n    // if no value has been produced, there is no way to obtain Unicode for the character.\n    if (LOG.isWarnEnabled() && (!noUnicode.contains(code))) {\n        // we keep track of which warnings have been issued, so we don't log multiple times\n        noUnicode.add(code);\n        if (name != null) {\n            LOG.warn(((((\"No Unicode mapping for \" + name) + \" (\") + code) + \") in font \") + getName());\n        } else {\n            LOG.warn(((\"No Unicode mapping for character code \" + code) + \" in font \") + getName());\n        }\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.visitFromString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.visitFromString", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void visitFromString(COSString obj) throws IOException {\n    if (willEncrypt) {\n        pdDocument.getEncryption().getSecurityHandler().encryptString(obj, currentObjectKey.getNumber(), currentObjectKey.getGeneration());\n    }\n    COSWriter.writeString(obj, getStandardOutput());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentGroup.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentGroup.<init>", "org.apache.pdfbox.pdmodel.documentinterchange.markedcontent.PDPropertyList.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new optional content group (OCG).\n *\n * @param name\n * \t\tthe name of the content group\n */\npublic PDOptionalContentGroup(String name) {\n    this.dict.setItem(COSName.TYPE, COSName.OCG);\n    setName(name);\n}", "/**\n * Constructor for subclasses.\n */\nprotected PDPropertyList() {\n    this.dict = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.load", "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a simple font.\n *\n * <p>\n * <b>Note:</b> Simple fonts only support 256 characters. For Unicode support, use\n * {@link PDType0Font#load(PDDocument, InputStream)} instead.\n * </p>\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param input\n * \t\tA TTF file stream. It will be closed before returning.\n * @param encoding\n * \t\tThe PostScript encoding vector to be used for embedding.\n * @return a PDTrueTypeFont instance.\n * @throws IOException\n * \t\tIf there is an error loading the data.\n */\npublic static PDTrueTypeFont load(PDDocument doc, InputStream input, Encoding encoding) throws IOException {\n    return load(doc, RandomAccessReadBuffer.createBufferFromStream(input), encoding);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.doWriteObject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.doWriteObject", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * This will write a COS object for a predefined key.\n *\n * @param key\n * \t\tThe key of the object to write.\n * @param obj\n * \t\tThe object to write.\n * @throws IOException\n * \t\tif the output cannot be written\n */\npublic void doWriteObject(COSObjectKey key, COSBase obj) throws IOException {\n    // don't write missing objects to avoid broken xref tables\n    if ((obj == null) || ((obj instanceof COSObject) && (((COSObject) (obj)).getObject() == null))) {\n        return;\n    }\n    // add a x ref entry\n    addXRefEntry(new NormalXReference(getStandardOutput().getPos(), key, obj));\n    // write the object\n    getStandardOutput().write(String.valueOf(key.getNumber()).getBytes(StandardCharsets.ISO_8859_1));\n    getStandardOutput().write(SPACE);\n    getStandardOutput().write(String.valueOf(key.getGeneration()).getBytes(StandardCharsets.ISO_8859_1));\n    getStandardOutput().write(SPACE);\n    getStandardOutput().write(OBJ);\n    getStandardOutput().writeEOL();\n    obj.accept(this);\n    getStandardOutput().writeEOL();\n    getStandardOutput().write(ENDOBJ);\n    getStandardOutput().writeEOL();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from bytes of an image file. The file format is determined by the\n * file content. The following file types are supported: JPG, JPEG, TIF, TIFF, GIF, BMP and PNG.\n * This is a convenience method that calls {@link JPEGFactory#createFromByteArray},\n * {@link CCITTFactory#createFromFile} or {@link ImageIO#read} combined with\n * {@link LosslessFactory#createFromImage}. (The later can also be used to create a\n * PDImageXObject from a BufferedImage). Starting with 2.0.18, this call will create an image\n * directly from a PNG file without decoding it (when possible), which is faster. However the\n * result size depends on the compression skill of the software that created the PNG file. If\n * file size or bandwidth are important to you or to your clients, then create your PNG files\n * with a tool that has implemented the\n * <a href=\"https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/\">Zopfli\n * algorithm</a>, or use the two-step process mentioned above.\n *\n * @param byteArray\n * \t\tbytes from an image file.\n * @param document\n * \t\tthe document that shall use this PDImageXObject.\n * @param name\n * \t\tname of image file for exception messages, can be null.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray, String name) throws IOException {\n    return createFromByteArray(document, byteArray, name, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationMarkup.getInReplyTo",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationMarkup.getInReplyTo", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the annotation to which this one is \"In Reply To\" the actual relationship\n * is specified by the RT entry.\n *\n * @return the other annotation or null if there is none.\n * @throws IOException\n * \t\tif there is an error creating the other annotation.\n */\npublic PDAnnotation getInReplyTo() throws IOException {\n    COSDictionary base = getCOSObject().getCOSDictionary(COSName.IRT);\n    return base != null ? PDAnnotation.createAnnotation(base) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFontBoxFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFontBoxFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFontBoxFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.<clinit>" ],
    "fullMethods" : [ "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null. This allows\n * any font to be substituted with a PFB, TTF or OTF.\n *\n * @param fontDescriptor\n * \t\tthe FontDescriptor of the font to find\n */\n@Override\npublic FontMapping<FontBoxFont> getFontBoxFont(String baseFont, PDFontDescriptor fontDescriptor) {\n    FontBoxFont font = findFontBoxFont(baseFont);\n    if (font != null) {\n        return new FontMapping<>(font, false);\n    } else {\n        // fallback - todo: i.e. fuzzy match\n        String fallbackName = getFallbackFontName(fontDescriptor);\n        font = findFontBoxFont(fallbackName);\n        if (font == null) {\n            // we have to return something here as TTFs aren't strictly required on the system\n            font = lastResortFont;\n        }\n        return new FontMapping<>(font, true);\n    }\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFontBoxFont(String postScriptName) {\n    Type1Font t1 = ((Type1Font) (findFont(FontFormat.PFB, postScriptName)));\n    if (t1 != null) {\n        return t1;\n    }\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, postScriptName)));\n    if (ttf != null) {\n        return ttf;\n    }\n    OpenTypeFont otf = ((OpenTypeFont) (findFont(FontFormat.OTF, postScriptName)));\n    if (otf != null) {\n        return otf;\n    }\n    return null;\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFont(FontFormat format, String postScriptName) {\n    // handle damaged PDFs, see PDFBOX-2884\n    if (postScriptName == null) {\n        return null;\n    }\n    // make sure the font provider is initialized\n    if (fontProvider == null) {\n        getProvider();\n    }\n    // first try to match the PostScript name\n    FontInfo info = getFont(format, postScriptName);\n    if (info != null) {\n        return info.getFont();\n    }\n    // remove hyphens (e.g. Arial-Black -> ArialBlack)\n    info = getFont(format, postScriptName.replace(\"-\", \"\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    // then try named substitutes\n    for (String substituteName : getSubstitutes(postScriptName)) {\n        info = getFont(format, substituteName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // then try converting Windows names e.g. (ArialNarrow,Bold) -> (ArialNarrow-Bold)\n    info = getFont(format, postScriptName.replace(\",\", \"-\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    if (postScriptName.contains(\",\")) {\n        postScriptName = postScriptName.substring(0, postScriptName.indexOf(\",\"));\n        // PDFBOX-5806: try cutting font style and getting the basefont\n        // eg. for \"Wingdings,Bolt\" to \"Wingding-Regular\" (including the following step)\n        info = getFont(format, postScriptName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // try appending \"-Regular\", works for Wingdings on windows\n    info = getFont(format, postScriptName + \"-Regular\");\n    if (info != null) {\n        return info.getFont();\n    }\n    // no matches\n    return null;\n}", "/**\n * Finds the named font with the given format.\n */\nprivate FontInfo getFont(FontFormat format, String postScriptName) {\n    int index = postScriptName.indexOf('+');\n    // strip subset tag (happens when we substitute a corrupt embedded font, see PDFBOX-2642)\n    if (index > (-1)) {\n        postScriptName = postScriptName.substring(index + 1);\n    }\n    // look up the PostScript name\n    FontInfo info = fontInfoByName.get(postScriptName.toLowerCase(Locale.ENGLISH));\n    if ((info != null) && (info.getFormat() == format)) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"getFont('%s','%s') returns %s\", format, postScriptName, info));\n        }\n        return info;\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.getFontMatrix",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.getFontMatrix", "org.apache.pdfbox.pdmodel.font.PDType1Font.<clinit>" ],
    "fullMethods" : [ "@Override\npublic final Matrix getFontMatrix() {\n    if (fontMatrix == null) {\n        // PDF specified that Type 1 fonts use a 1000upem matrix, but some fonts specify\n        // their own custom matrix anyway, for example PDFBOX-2298\n        List<Number> numbers = null;\n        try {\n            numbers = genericFont.getFontMatrix();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font matrix box - returning default value\", e);\n            fontMatrix = DEFAULT_FONT_MATRIX;\n        }\n        if ((numbers != null) && (numbers.size() == 6)) {\n            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());\n        } else {\n            return super.getFontMatrix();\n        }\n    }\n    return fontMatrix;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.<init>", "org.apache.pdfbox.pdmodel.PDPageTree.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor for reading.\n *\n * @param root\n * \t\tA page tree root.\n */\npublic PDPageTree(COSDictionary root) {\n    this(root, null);\n}", "/**\n * Constructor for reading.\n *\n * @param root\n * \t\tA page tree root.\n * @param document\n * \t\tThe document which contains \"root\".\n */\nPDPageTree(COSDictionary root, PDDocument document) {\n    if (root == null) {\n        throw new IllegalArgumentException(\"page tree root cannot be null\");\n    }\n    // repair bad PDFs which contain a Page dict instead of a page tree, see PDFBOX-3154\n    if (COSName.PAGE.equals(root.getCOSName(COSName.TYPE))) {\n        COSArray kids = new COSArray();\n        kids.add(root);\n        this.root = new COSDictionary();\n        this.root.setItem(COSName.KIDS, kids);\n        this.root.setInt(COSName.COUNT, 1);\n    } else {\n        this.root = root;\n    }\n    this.document = document;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType1.toPaint",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType1.toPaint", "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Paint toPaint(Matrix matrix) {\n    return new Type1ShadingPaint(this, matrix);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquigglyAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquigglyAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.PDAbstractContentStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationSquiggly annotation = ((PDAnnotationSquiggly) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getQuadPoints();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    if (Float.compare(ab.width, 0) == 0) {\n        // value found in adobe reader\n        ab.width = 1.5F;\n    }\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    // TODO in a class structure this should be overridable\n    // this is similar to polyline but different data type\n    // all coordinates (unlike painting) are used because I'm lazy\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    rect.setLowerLeftX(Math.min(minX - (ab.width / 2), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width / 2), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width / 2), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width / 2), rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        cs.setStrokingColor(color);\n        // TODO we ignore dash pattern and line width for now. Do they have any effect?\n        // quadpoints spec is incorrect\n        // https://stackoverflow.com/questions/9855814/pdf-spec-vs-acrobat-creation-quadpoints\n        for (int i = 0; i < (pathsArray.length / 8); ++i) {\n            // Adobe uses a fixed pattern that assumes a height of 40, and it transforms to that height\n            // horizontally and the same / 1.8 vertically.\n            // translation apparently based on bottom left, but slightly different in Adobe\n            // TODO what if the annotation is not horizontal?\n            float height = pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5];\n            cs.transform(new Matrix(height / 40.0F, 0, 0, (height / 40.0F) / 1.8F, pathsArray[(i * 8) + 4], pathsArray[(i * 8) + 5]));\n            // Create form, BBox is mostly fixed, except for the horizontal size which is\n            // horizontal size divided by the horizontal transform factor from above\n            // (almost)\n            PDFormXObject form = new PDFormXObject(createCOSStream());\n            form.setBBox(new PDRectangle(-0.5F, -0.5F, (((pathsArray[(i * 8) + 2] - pathsArray[i * 8]) / height) * 40.0F) + 0.5F, 13));\n            form.setResources(new PDResources());\n            form.setMatrix(AffineTransform.getTranslateInstance(0.5F, 0.5F));\n            cs.drawForm(form);\n            try (PDFormContentStream formCS = new PDFormContentStream(form)) {\n                PDTilingPattern pattern = new PDTilingPattern();\n                pattern.setBBox(new PDRectangle(0, 0, 10, 12));\n                pattern.setXStep(10);\n                pattern.setYStep(13);\n                pattern.setTilingType(PDTilingPattern.TILING_CONSTANT_SPACING_FASTER_TILING);\n                pattern.setPaintType(PDTilingPattern.PAINT_UNCOLORED);\n                try (PDPatternContentStream patternCS = new PDPatternContentStream(pattern)) {\n                    // from Adobe\n                    patternCS.setLineCapStyle(1);\n                    patternCS.setLineJoinStyle(1);\n                    patternCS.setLineWidth(1);\n                    patternCS.setMiterLimit(10);\n                    patternCS.moveTo(0, 1);\n                    patternCS.lineTo(5, 11);\n                    patternCS.lineTo(10, 1);\n                    patternCS.stroke();\n                }\n                COSName patternName = form.getResources().add(pattern);\n                PDColorSpace patternColorSpace = new PDPattern(null, PDDeviceRGB.INSTANCE);\n                PDColor patternColor = new PDColor(color.getComponents(), patternName, patternColorSpace);\n                formCS.setNonStrokingColor(patternColor);\n                // With Adobe, the horizontal size is slightly different, don't know why\n                formCS.addRect(0, 0, ((pathsArray[(i * 8) + 2] - pathsArray[i * 8]) / height) * 40.0F, 12);\n                formCS.fill();\n            }\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getNumberOfColorComponents",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getNumberOfColorComponents", "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.<clinit>" ],
    "fullMethods" : [ "/**\n * The number of color components of this shading.\n *\n * @return number of color components of this shading\n * @throws IOException\n * \t\tif the data could not be read\n */\npublic int getNumberOfColorComponents() throws IOException {\n    if (numberOfColorComponents == (-1)) {\n        numberOfColorComponents = (getFunction() != null) ? 1 : getColorSpace().getNumberOfComponents();\n        LOG.debug(\"numberOfColorComponents: \" + numberOfColorComponents);\n    }\n    return numberOfColorComponents;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.drawImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.drawImage", "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void drawImage(PDImage pdImage) throws IOException {\n    if ((pdImage instanceof PDImageXObject) && isHiddenOCG(((PDImageXObject) (pdImage)).getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    AffineTransform at = ctm.createAffineTransform();\n    if (!pdImage.getInterpolate()) {\n        // if the image is scaled down, we use smooth interpolation, eg PDFBOX-2364\n        // only when scaled up do we use nearest neighbour, eg PDFBOX-2302 / mori-cvpr01.pdf\n        // PDFBOX-4930: we use the sizes of the ARGB image. These can be different\n        // than the original sizes of the base image, when the mask is bigger.\n        // PDFBOX-5091: also consider subsampling, the sizes are different too.\n        BufferedImage bim;\n        if (subsamplingAllowed) {\n            bim = pdImage.getImage(null, getSubsampling(pdImage, at));\n        } else {\n            bim = pdImage.getImage();\n        }\n        boolean isScaledUp = (bim.getWidth() <= Math.abs(Math.round(ctm.getScalingFactorX() * xformScalingFactorX))) || (bim.getHeight() <= Math.abs(Math.round(ctm.getScalingFactorY() * xformScalingFactorY)));\n        if (isScaledUp) {\n            graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        }\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    if (pdImage.isStencil()) {\n        if (getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDPattern) {\n            // The earlier code for stencils (see \"else\") doesn't work with patterns because the\n            // CTM is not taken into consideration.\n            // this code is based on the fact that it is easily possible to draw the mask and\n            // the paint at the correct place with the existing code, but not in one step.\n            // Thus what we do is to draw both in separate images, then combine the two and draw\n            // the result.\n            // Note that the device scale is not used. In theory, some patterns can get better\n            // at higher resolutions but the stencil would become more and more \"blocky\".\n            // If anybody wants to do this, have a look at the code in showTransparencyGroup().\n            // draw the paint\n            Paint paint = getNonStrokingPaint();\n            Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);\n            Rectangle2D bounds = at.createTransformedShape(unitRect).getBounds2D();\n            int w = ((int) (Math.ceil(bounds.getWidth())));\n            int h = ((int) (Math.ceil(bounds.getHeight())));\n            BufferedImage renderedPaint = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n            Graphics2D g = ((Graphics2D) (renderedPaint.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setPaint(paint);\n            g.setRenderingHints(graphics.getRenderingHints());\n            g.fill(bounds);\n            g.dispose();\n            // draw the mask\n            BufferedImage mask = pdImage.getImage();\n            AffineTransform imageTransform = new AffineTransform(at);\n            imageTransform.scale(1.0 / mask.getWidth(), (-1.0) / mask.getHeight());\n            imageTransform.translate(0, -mask.getHeight());\n            AffineTransform full = new AffineTransform(g.getTransform());\n            full.concatenate(imageTransform);\n            Matrix m = new Matrix(full);\n            double scaleX = Math.abs(m.getScalingFactorX());\n            double scaleY = Math.abs(m.getScalingFactorY());\n            boolean smallMask = (mask.getWidth() <= 8) && (mask.getHeight() <= 8);\n            if ((mask.getWidth() == 1) && (mask.getHeight() == 1)) {\n                // PDFBOX-5802: force usage of the lookup table if it is only 1 pixel\n                // (See the comment for PDFBOX-5403 that it isn't done for some\n                // cases based purely on the rendering result of one file!)\n                smallMask = false;\n            }\n            if (!smallMask) {\n                // PDFBOX-5403:\n                // The mask is copied to RGB because this supports a smooth scaling, so we\n                // get a mask with 255 values instead of just 0 and 255.\n                // Inverting is done because when we don't do it, the getScaledInstance() call\n                // produces a black line in many masks. With the inversion we have a white line\n                // which is neutral. Because of the inversion we don't have to substract from 255\n                // in the \"apply the mask\" segment when rasterPixel[3] is assigned.\n                // The inversion is not done for very small ones, because of\n                // PDFBOX-2171-002-002710-p14.pdf where the \"New Harmony Consolidated\" and\n                // \"Sailor Springs\" patterns became almost invisible.\n                // (We may have to decide this differently in the future, e.g. on b/w relationship)\n                BufferedImage tmp = new BufferedImage(mask.getWidth(), mask.getHeight(), BufferedImage.TYPE_INT_RGB);\n                mask = new LookupOp(getInvLookupTable(), graphics.getRenderingHints()).filter(mask, tmp);\n            }\n            BufferedImage renderedMask = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n            g = ((Graphics2D) (renderedMask.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setRenderingHints(graphics.getRenderingHints());\n            if (smallMask) {\n                g.drawImage(mask, imageTransform, null);\n            } else if ((scaleX != 0) && (scaleY != 0)) {\n                while ((scaleX < 0.25) || (Math.round(mask.getWidth() * scaleX) < 1)) {\n                    scaleX *= 2.0;\n                } \n                while ((scaleY < 0.25) || (Math.round(mask.getHeight() * scaleY) < 1)) {\n                    scaleY *= 2.0;\n                } \n                int w2 = ((int) (Math.round(mask.getWidth() * scaleX)));\n                int h2 = ((int) (Math.round(mask.getHeight() * scaleY)));\n                Image scaledMask = mask.getScaledInstance(w2, h2, Image.SCALE_SMOOTH);\n                imageTransform.scale(1.0F / Math.abs(scaleX), 1.0F / Math.abs(scaleY));\n                g.drawImage(scaledMask, imageTransform, null);\n            }\n            g.dispose();\n            // apply the mask\n            int[] alphaPixel = null;\n            int[] rasterPixel = null;\n            WritableRaster raster = renderedPaint.getRaster();\n            WritableRaster alpha = renderedMask.getRaster();\n            for (int y = 0; y < h; y++) {\n                for (int x = 0; x < w; x++) {\n                    alphaPixel = alpha.getPixel(x, y, alphaPixel);\n                    rasterPixel = raster.getPixel(x, y, rasterPixel);\n                    rasterPixel[3] = alphaPixel[0];\n                    raster.setPixel(x, y, rasterPixel);\n                }\n            }\n            // draw the image\n            graphics.drawImage(renderedPaint, AffineTransform.getTranslateInstance(bounds.getMinX(), bounds.getMinY()), null);\n        } else {\n            // fill the image with stenciled paint\n            BufferedImage image = pdImage.getStencilImage(getNonStrokingPaint());\n            // draw the image\n            drawBufferedImage(pdImage, image, at);\n        }\n    } else if (subsamplingAllowed) {\n        int subsampling = getSubsampling(pdImage, at);\n        // draw the subsampled image\n        drawBufferedImage(pdImage, pdImage.getImage(null, subsampling), at);\n    } else {\n        // subsampling not allowed, draw the image\n        drawBufferedImage(pdImage, pdImage.getImage(), at);\n    }\n    if (!pdImage.getInterpolate()) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    return SampledImageReader.getRGBImage(this, region, subsampling, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentMembershipDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentMembershipDictionary.<init>", "org.apache.pdfbox.pdmodel.documentinterchange.markedcontent.PDPropertyList.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new optional content membership dictionary (OCMD).\n */\npublic PDOptionalContentMembershipDictionary() {\n    this.dict.setItem(COSName.TYPE, COSName.OCMD);\n}", "/**\n * Constructor for subclasses.\n */\nprotected PDPropertyList() {\n    this.dict = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.ToUnicodeWriter.writeTo",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.ToUnicodeWriter.writeTo", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Writes the CMap as ASCII to the given output stream.\n *\n * @param out\n * \t\tASCII output stream\n * @throws IOException\n * \t\tif the stream could not be written\n */\npublic void writeTo(OutputStream out) throws IOException {\n    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, StandardCharsets.US_ASCII));\n    writeLine(writer, \"/CIDInit /ProcSet findresource begin\");\n    writeLine(writer, \"12 dict begin\\n\");\n    writeLine(writer, \"begincmap\");\n    writeLine(writer, \"/CIDSystemInfo\");\n    writeLine(writer, \"<< /Registry (Adobe)\");\n    writeLine(writer, \"/Ordering (UCS)\");\n    writeLine(writer, \"/Supplement 0\");\n    writeLine(writer, \">> def\\n\");\n    writeLine(writer, \"/CMapName /Adobe-Identity-UCS\" + \" def\");\n    writeLine(writer, \"/CMapType 2 def\\n\");// 2 = ToUnicode\n\n    if (wMode != 0) {\n        writeLine(writer, (\"/WMode /\" + wMode) + \" def\");\n    }\n    // ToUnicode always uses 16-bit CIDs\n    writeLine(writer, \"1 begincodespacerange\");\n    writeLine(writer, \"<0000> <FFFF>\");\n    writeLine(writer, \"endcodespacerange\\n\");\n    // CID -> Unicode mappings, we use ranges to generate a smaller CMap\n    List<Integer> srcFrom = new ArrayList<>();\n    List<Integer> srcTo = new ArrayList<>();\n    List<String> dstString = new ArrayList<>();\n    Map.Entry<Integer, String> prev = null;\n    for (Map.Entry<Integer, String> next : cidToUnicode.entrySet()) {\n        if (allowCIDToUnicodeRange(prev, next)) {\n            // extend range\n            srcTo.set(srcTo.size() - 1, next.getKey());\n        } else {\n            // begin range\n            srcFrom.add(next.getKey());\n            srcTo.add(next.getKey());\n            dstString.add(next.getValue());\n        }\n        prev = next;\n    }\n    // limit entries per operator\n    int batchCount = ((int) (Math.ceil(srcFrom.size() / ((double) (MAX_ENTRIES_PER_OPERATOR)))));\n    for (int batch = 0; batch < batchCount; batch++) {\n        int count = (batch == (batchCount - 1)) ? srcFrom.size() - (MAX_ENTRIES_PER_OPERATOR * batch) : MAX_ENTRIES_PER_OPERATOR;\n        writer.write(count + \" beginbfrange\\n\");\n        for (int j = 0; j < count; j++) {\n            int index = (batch * MAX_ENTRIES_PER_OPERATOR) + j;\n            writer.write('<');\n            writer.write(Hex.getChars(srcFrom.get(index).shortValue()));\n            writer.write(\"> \");\n            writer.write('<');\n            writer.write(Hex.getChars(srcTo.get(index).shortValue()));\n            writer.write(\"> \");\n            writer.write('<');\n            writer.write(Hex.getCharsUTF16BE(dstString.get(index)));\n            writer.write(\">\\n\");\n        }\n        writeLine(writer, \"endbfrange\\n\");\n    }\n    // footer\n    writeLine(writer, \"endcmap\");\n    writeLine(writer, \"CMapName currentdict /CMap defineresource pop\");\n    writeLine(writer, \"end\");\n    writeLine(writer, \"end\");\n    writer.flush();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given form to the resources of the current page and returns the name for the\n * new resources. Returns the existing resource name if the given item already exists.\n *\n * @param form\n * \t\tthe form to add\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDFormXObject form) {\n    return add(COSName.XOBJECT, \"Form\", form);\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given pattern to the resources of the current page and returns the name for the\n * new resources. Returns the existing resource name if the given item already exists.\n *\n * @param pattern\n * \t\tthe pattern to add\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDAbstractPattern pattern) {\n    return add(COSName.PATTERN, \"p\", pattern);\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.<init>", "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureNode.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default Constructor.\n */\npublic PDStructureTreeRoot() {\n    super(TYPE);\n}", "/**\n * Constructor.\n *\n * @param type\n * \t\tthe type\n */\nprotected PDStructureNode(String type) {\n    this.dictionary = new COSDictionary();\n    this.dictionary.setName(COSName.TYPE, type);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFParser.parse", "org.apache.pdfbox.pdfparser.PDFParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the PDDocument object. This will close the keystore stream when it is\n * done parsing.\n *\n * @param lenient\n * \t\tactivate leniency if set to true\n * @return the populated PDDocument\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic PDDocument parse(boolean lenient) throws IOException {\n    setLenient(lenient);\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        // PDFBOX-1922 read the version header and rewind\n        if ((!parsePDFHeader()) && (!parseFDFHeader())) {\n            if (lenient) {\n                LOG.warn(\"Error: Header doesn't contain versioninfo\");\n            } else {\n                throw new IOException(\"Error: Header doesn't contain versioninfo\");\n            }\n        }\n        if (!initialParseDone) {\n            initialParse();\n        }\n        exceptionOccurred = false;\n        PDDocument pdDocument = createDocument();\n        pdDocument.setEncryptionDictionary(getEncryption());\n        return pdDocument;\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getKids",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getKids", "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Return the children of this node.  This list will contain PDNumberTreeNode objects.\n *\n * @return The list of children or null if there are no children.\n */\npublic List<PDNumberTreeNode> getKids() {\n    List<PDNumberTreeNode> retval = null;\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids != null) {\n        List<PDNumberTreeNode> pdObjects = new ArrayList<>(kids.size());\n        for (int i = 0; i < kids.size(); i++) {\n            COSBase base = kids.getObject(i);\n            PDNumberTreeNode childNode;\n            if (base instanceof COSDictionary) {\n                childNode = createChildNode(((COSDictionary) (base)));\n            } else {\n                LOG.warn(\"Bad child node at position \" + i);\n                childNode = new PDNumberTreeNode(valueType);\n            }\n            pdObjects.add(childNode);\n        }\n        retval = new COSArrayList<>(pdObjects, kids);\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFileDos",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFileDos", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the embedded dos file.\n *\n * @return The embedded dos file for this file spec.\n */\npublic PDEmbeddedFile getEmbeddedFileDos() {\n    COSBase base = getObjectFromEFDictionary(COSName.DOS);\n    if (base instanceof COSStream) {\n        return new PDEmbeddedFile(((COSStream) (base)));\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<init>", "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param parent\n * \t\tThe parent font.\n * @param trueTypeFont\n * \t\tThe true type font used to create the parent font\n * @throws IOException\n * \t\tif the font could not be read\n */\npublic PDCIDFontType2(COSDictionary fontDictionary, PDType0Font parent, TrueTypeFont trueTypeFont) throws IOException {\n    super(fontDictionary, parent);\n    PDFontDescriptor fd = getFontDescriptor();\n    if (trueTypeFont != null) {\n        ttf = trueTypeFont;\n        otf = ((trueTypeFont instanceof OpenTypeFont) && ((OpenTypeFont) (trueTypeFont)).isSupportedOTF()) ? ((OpenTypeFont) (trueTypeFont)) : null;\n        isEmbedded = true;\n        isDamaged = false;\n    } else {\n        boolean fontIsDamaged = false;\n        TrueTypeFont ttfFont = null;\n        PDStream stream = null;\n        if (fd != null) {\n            stream = fd.getFontFile2();\n            if (stream == null) {\n                stream = fd.getFontFile3();\n            }\n            if (stream == null) {\n                // Acrobat looks in FontFile too, even though it is not in the spec, see PDFBOX-2599\n                stream = fd.getFontFile();\n            }\n        }\n        if (stream != null) {\n            try {\n                // embedded OTF or TTF\n                RandomAccessRead view = stream.getCOSObject().createView();\n                TTFParser ttfParser = getParser(view, true);\n                ttfFont = ttfParser.parse(view);\n                ttfFont.close();\n            } catch (IOException e) {\n                fontIsDamaged = true;\n                LOG.warn(\"Could not read embedded OTF for font \" + getBaseFont(), e);\n            }\n            if ((ttfFont instanceof OpenTypeFont) && (!((OpenTypeFont) (ttfFont)).isSupportedOTF())) {\n                // the OpenType font contains CFF2 outlines which are not supported yet\n                ttfFont = null;\n                fontIsDamaged = true;\n                LOG.warn(\"Found an OpenType font using CFF2 outlines which are not supported \" + fd.getFontName());\n            }\n        }\n        isEmbedded = ttfFont != null;\n        isDamaged = fontIsDamaged;\n        if (ttfFont == null) {\n            ttfFont = findFontOrSubstitute();\n        }\n        otf = ((ttfFont instanceof OpenTypeFont) && ((OpenTypeFont) (ttfFont)).isSupportedOTF()) ? ((OpenTypeFont) (ttfFont)) : null;\n        ttf = ttfFont;\n    }\n    cmap = ttf.getUnicodeCmapLookup(false);\n    cid2gid = readCIDToGIDMap();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.<init>", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @see PDField#PDField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroform.\n */\npublic PDTextField(PDAcroForm acroForm) {\n    super(acroForm);\n    getCOSObject().setItem(COSName.FT, COSName.TX);\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDEmbeddedFile.setMacSubtype",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDEmbeddedFile.setMacSubtype", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the mac subtype.\n *\n * @param macSubtype\n * \t\tThe mac subtype.\n */\npublic void setMacSubtype(String macSubtype) {\n    COSDictionary params = getCOSObject().getCOSDictionary(COSName.PARAMS);\n    if ((params == null) && (macSubtype != null)) {\n        params = new COSDictionary();\n        getCOSObject().setItem(COSName.PARAMS, params);\n    }\n    if (params != null) {\n        params.setEmbeddedString(COSName.MAC, COSName.SUBTYPE, macSubtype);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.openNode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.openNode", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.switchNodeCount", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set this node to be open when it is shown in the viewer. By default, when a new node is created it will\n * be closed. This will do nothing if the node is already open.\n */\npublic void openNode() {\n    // if the node is already open then do nothing.\n    if (!isNodeOpen()) {\n        switchNodeCount();\n    }\n}", "private void switchNodeCount() {\n    int openCount = getOpenCount();\n    setOpenCount(-openCount);\n    updateParentOpenCount(-openCount);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setTrailer",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setTrailer", "org.apache.pdfbox.pdfparser.XrefTrailerResolver.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds trailer information for current XRef object.\n *\n * @param trailer\n * \t\tthe current document trailer dictionary\n */\npublic void setTrailer(COSDictionary trailer) {\n    if (curXrefTrailerObj == null) {\n        // should not happen...\n        LOG.warn(\"Cannot add trailer because XRef start was not signalled.\");\n        return;\n    }\n    curXrefTrailerObj.trailer = trailer;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.measurement.PDViewportDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.measurement.PDViewportDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDViewportDictionary() {\n    this.viewportDictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getMetadata",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getMetadata", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the metadata that is part of the document catalog. This will return null if there is no\n * meta data for this object.\n *\n * @return The metadata for this object.\n */\npublic PDMetadata getMetadata() {\n    COSStream metaObj = root.getCOSStream(COSName.METADATA);\n    return metaObj != null ? new PDMetadata(metaObj) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSStream.createInputStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSStream.createInputStream", "org.apache.pdfbox.cos.COSInputStream.create", "org.apache.pdfbox.filter.Filter.<clinit>" ],
    "fullMethods" : [ "public COSInputStream createInputStream(DecodeOptions options) throws IOException {\n    InputStream input = createRawInputStream();\n    return COSInputStream.create(getFilterList(), this, input, options);\n}", "/**\n * Creates a new COSInputStream from an encoded input stream.\n *\n * @param filters\n * \t\tFilters to be applied.\n * @param parameters\n * \t\tFilter parameters.\n * @param in\n * \t\tEncoded input stream.\n * @param options\n * \t\tdecode options for the encoded stream\n * @return Decoded stream.\n * @throws IOException\n * \t\tIf the stream could not be read.\n */\nstatic COSInputStream create(List<Filter> filters, COSDictionary parameters, InputStream in, DecodeOptions options) throws IOException {\n    if (filters.isEmpty()) {\n        return new COSInputStream(in, Collections.emptyList());\n    }\n    List<DecodeResult> results = new ArrayList<>(filters.size());\n    RandomAccessRead decoded = Filter.decode(in, filters, parameters, options, results);\n    return new COSInputStream(new RandomAccessInputStream(decoded), results);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.toString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.toString", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(dictionary.getNameAsString(COSName.SUBTYPE));\n    sb.append('{');\n    PDDeviceNProcess process = getProcess();\n    if (process != null) {\n        sb.append(process);\n        sb.append(' ');\n    }\n    Map<String, PDSeparation> colorants;\n    try {\n        colorants = getColorants(null);\n        sb.append(\"Colorants{\");\n        for (Map.Entry<String, PDSeparation> col : colorants.entrySet()) {\n            sb.append('\\\"');\n            sb.append(col.getKey());\n            sb.append(\"\\\": \");\n            sb.append(col.getValue());\n            sb.append(' ');\n        }\n        sb.append('}');\n    } catch (IOException e) {\n        LOG.debug(\"Couldn't get the colorants information - returning 'ERROR' instead'\", e);\n        sb.append(\"ERROR\");\n    }\n    sb.append('}');\n    return sb.toString();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSArray.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSArray.add", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * This will add an object to the array.\n *\n * @param object\n * \t\tThe object to add to the array.\n */\npublic void add(COSBase object) {\n    // wrap indirect objects\n    if ((((object instanceof COSDictionary) || (object instanceof COSArray)) && (!object.isDirect())) && (object.getKey() != null)) {\n        COSObject cosObject = new COSObject(object, object.getKey());\n        objects.add(cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        objects.add(object);\n        getUpdateState().update(object);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.setEndPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.setEndPage", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the last page to be extracted by this class.\n *\n * @param endPageValue\n * \t\tNew value of 1-based endPage property.\n */\npublic void setEndPage(int endPageValue) {\n    if (endPageValue <= 0) {\n        LOG.warn(\"Parameter must be 1-based, but is \" + endPageValue);\n    }\n    endPage = endPageValue;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.LosslessFactory.createFromImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.LosslessFactory.createFromImage", "org.apache.pdfbox.pdmodel.graphics.image.LosslessFactory.PredictorEncoder.encode", "org.apache.pdfbox.filter.Filter.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new lossless encoded image XObject from a BufferedImage.\n * <p>\n * <u>New for advanced users from 2.0.12 on:</u><br>\n * If you created your image with a non standard ICC colorspace, it will be\n * preserved. (If you load images in java using ImageIO then no need to read\n * this segment) However a new colorspace will be created for each image. So\n * if you create a PDF with several such images, consider replacing the\n * colorspace with a common object to save space. This is done with\n * {@link PDImageXObject#getColorSpace()} and\n * {@link PDImageXObject#setColorSpace(org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace) PDImageXObject.setColorSpace()}\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param image\n * \t\tthe BufferedImage to embed\n * @return a new image XObject\n * @throws IOException\n * \t\tif something goes wrong\n */\npublic static PDImageXObject createFromImage(PDDocument document, BufferedImage image) throws IOException {\n    if (isGrayImage(image)) {\n        return createFromGrayImage(image, document);\n    }\n    // We try to encode the image with predictor\n    if (USE_PREDICTOR_ENCODER) {\n        PDImageXObject pdImageXObject = new PredictorEncoder(document, image).encode();\n        if (pdImageXObject != null) {\n            if (((pdImageXObject.getColorSpace() == PDDeviceRGB.INSTANCE) && (pdImageXObject.getBitsPerComponent() < 16)) && ((image.getWidth() * image.getHeight()) <= (50 * 50))) {\n                // also create classic compressed image, compare sizes\n                PDImageXObject pdImageXObjectClassic = createFromRGBImage(image, document);\n                if (pdImageXObjectClassic.getCOSObject().getLength() < pdImageXObject.getCOSObject().getLength()) {\n                    pdImageXObject.getCOSObject().close();\n                    return pdImageXObjectClassic;\n                } else {\n                    pdImageXObjectClassic.getCOSObject().close();\n                }\n            }\n            return pdImageXObject;\n        }\n    }\n    // Fallback: We export the image as 8-bit sRGB and might lose color information\n    return createFromRGBImage(image, document);\n}", "/**\n * Tries to compress the image using a predictor.\n *\n * @return the image or null if it is not possible to encoded the image (e.g. not supported\nraster format etc.)\n */\nPDImageXObject encode() throws IOException {\n    Raster imageRaster = image.getRaster();\n    final int elementsInRowPerPixel;\n    // These variables store a row of the image each, the exact type depends\n    // on the image encoding. Can be a int[], short[] or byte[]\n    Object prevRow;\n    Object transferRow;\n    switch (imageType) {\n        case BufferedImage.TYPE_CUSTOM :\n            switch (imageRaster.getTransferType()) {\n                case DataBuffer.TYPE_USHORT :\n                    elementsInRowPerPixel = componentsPerPixel;\n                    prevRow = new short[width * elementsInRowPerPixel];\n                    transferRow = new short[width * elementsInRowPerPixel];\n                    break;\n                case DataBuffer.TYPE_BYTE :\n                    elementsInRowPerPixel = componentsPerPixel;\n                    prevRow = new byte[width * elementsInRowPerPixel];\n                    transferRow = new byte[width * elementsInRowPerPixel];\n                    break;\n                default :\n                    return null;\n            }\n            break;\n        case BufferedImage.TYPE_3BYTE_BGR :\n        case BufferedImage.TYPE_4BYTE_ABGR :\n            elementsInRowPerPixel = componentsPerPixel;\n            prevRow = new byte[width * elementsInRowPerPixel];\n            transferRow = new byte[width * elementsInRowPerPixel];\n            break;\n        case BufferedImage.TYPE_INT_BGR :\n        case BufferedImage.TYPE_INT_ARGB :\n        case BufferedImage.TYPE_INT_RGB :\n            elementsInRowPerPixel = 1;\n            prevRow = new int[width * elementsInRowPerPixel];\n            transferRow = new int[width * elementsInRowPerPixel];\n            break;\n        default :\n            // We can not handle this unknown format\n            return null;\n    }\n    final int elementsInTransferRow = width * elementsInRowPerPixel;\n    // pre-size the output stream to half of the maximum size\n    ByteArrayOutputStream stream = new ByteArrayOutputStream(((height * width) * bytesPerPixel) / 2);\n    Deflater deflater = new Deflater(Filter.getCompressionLevel());\n    DeflaterOutputStream zip = new DeflaterOutputStream(stream, deflater);\n    int alphaPtr = 0;\n    for (int rowNum = 0; rowNum < height; rowNum++) {\n        imageRaster.getDataElements(0, rowNum, width, 1, transferRow);\n        // We start to write at index one, as the predictor marker is in index zero\n        int writerPtr = 1;\n        Arrays.fill(aValues, ((byte) (0)));\n        Arrays.fill(cValues, ((byte) (0)));\n        final byte[] transferRowByte;\n        final byte[] prevRowByte;\n        final int[] transferRowInt;\n        final int[] prevRowInt;\n        final short[] transferRowShort;\n        final short[] prevRowShort;\n        if (transferRow instanceof byte[]) {\n            transferRowByte = ((byte[]) (transferRow));\n            prevRowByte = ((byte[]) (prevRow));\n            transferRowInt = prevRowInt = null;\n            transferRowShort = prevRowShort = null;\n        } else if (transferRow instanceof int[]) {\n            transferRowInt = ((int[]) (transferRow));\n            prevRowInt = ((int[]) (prevRow));\n            transferRowShort = prevRowShort = null;\n            transferRowByte = prevRowByte = null;\n        } else {\n            // This must be short[]\n            transferRowShort = ((short[]) (transferRow));\n            prevRowShort = ((short[]) (prevRow));\n            transferRowInt = prevRowInt = null;\n            transferRowByte = prevRowByte = null;\n        }\n        for (int indexInTransferRow = 0; indexInTransferRow < elementsInTransferRow; indexInTransferRow += elementsInRowPerPixel , alphaPtr += bytesPerComponent) {\n            // Copy the pixel values into the byte array\n            if (transferRowByte != null) {\n                copyImageBytes(transferRowByte, indexInTransferRow, xValues, alphaImageData, alphaPtr);\n                copyImageBytes(prevRowByte, indexInTransferRow, bValues, null, 0);\n            } else if (transferRowInt != null) {\n                copyIntToBytes(transferRowInt, indexInTransferRow, xValues, alphaImageData, alphaPtr);\n                copyIntToBytes(prevRowInt, indexInTransferRow, bValues, null, 0);\n            } else {\n                // This must be short[]\n                copyShortsToBytes(transferRowShort, indexInTransferRow, xValues, alphaImageData, alphaPtr);\n                copyShortsToBytes(prevRowShort, indexInTransferRow, bValues, null, 0);\n            }\n            // Encode the pixel values in the different encodings\n            int length = xValues.length;\n            for (int bytePtr = 0; bytePtr < length; bytePtr++) {\n                int x = xValues[bytePtr] & 0xff;\n                int a = aValues[bytePtr] & 0xff;\n                int b = bValues[bytePtr] & 0xff;\n                int c = cValues[bytePtr] & 0xff;\n                dataRawRowNone[writerPtr] = ((byte) (x));\n                dataRawRowSub[writerPtr] = pngFilterSub(x, a);\n                dataRawRowUp[writerPtr] = pngFilterUp(x, b);\n                dataRawRowAverage[writerPtr] = pngFilterAverage(x, a, b);\n                dataRawRowPaeth[writerPtr] = pngFilterPaeth(x, a, b, c);\n                writerPtr++;\n            }\n            // We shift the values into the prev / upper left values for the next pixel\n            System.arraycopy(xValues, 0, aValues, 0, bytesPerPixel);\n            System.arraycopy(bValues, 0, cValues, 0, bytesPerPixel);\n        }\n        byte[] rowToWrite = chooseDataRowToWrite();\n        // Write and compress the row as long it is hot (CPU cache wise)\n        zip.write(rowToWrite, 0, rowToWrite.length);\n        // We swap prev and transfer row, so that we have the prev row for the next row.\n        Object temp = prevRow;\n        prevRow = transferRow;\n        transferRow = temp;\n    }\n    zip.close();\n    deflater.end();\n    return preparePredictorPDImage(stream, bytesPerComponent * 8);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDExtendedGraphicsState.getSoftMask",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDExtendedGraphicsState.getSoftMask", "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the soft mask stored in the COS dictionary\n *\n * @return the soft mask or null if there isn't any.\n */\npublic PDSoftMask getSoftMask() {\n    COSBase smask = dict.getDictionaryObject(COSName.SMASK);\n    return smask == null ? null : PDSoftMask.create(smask, cache);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeTokens",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeTokens", "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeObject", "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeObject", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * This will write out the list of tokens to the stream.\n *\n * @param tokens\n * \t\tThe tokens to write to the stream.\n * @throws IOException\n * \t\tIf there is an error writing to the stream.\n */\npublic void writeTokens(List<?> tokens) throws IOException {\n    for (Object token : tokens) {\n        writeObject(token);\n    }\n}", "private void writeObject(Object o) throws IOException {\n    if (o instanceof COSBase) {\n        writeObject(((COSBase) (o)));\n    } else if (o instanceof Operator) {\n        writeObject(((Operator) (o)));\n    } else {\n        throw new IOException(\"Error:Unknown type in content stream:\" + o);\n    }\n}", "private void writeObject(COSBase o) throws IOException {\n    if (o instanceof COSString) {\n        COSWriter.writeString(((COSString) (o)), output);\n        output.write(SPACE);\n    } else if (o instanceof COSFloat) {\n        ((COSFloat) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSInteger) {\n        ((COSInteger) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSBoolean) {\n        ((COSBoolean) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSName) {\n        ((COSName) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSArray) {\n        COSArray array = ((COSArray) (o));\n        output.write(COSWriter.ARRAY_OPEN);\n        for (int i = 0; i < array.size(); i++) {\n            writeObject(array.get(i));\n        }\n        output.write(COSWriter.ARRAY_CLOSE);\n        output.write(SPACE);\n    } else if (o instanceof COSDictionary) {\n        COSDictionary obj = ((COSDictionary) (o));\n        output.write(COSWriter.DICT_OPEN);\n        for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {\n            if (entry.getValue() != null) {\n                writeObject(entry.getKey());\n                writeObject(entry.getValue());\n            }\n        }\n        output.write(COSWriter.DICT_CLOSE);\n        output.write(SPACE);\n    } else if (o instanceof COSNull) {\n        output.write(\"null\".getBytes(StandardCharsets.US_ASCII));\n        output.write(SPACE);\n    } else {\n        throw new IOException(\"Error:Unknown type in content stream:\" + o);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDStream.createInputStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDStream.createInputStream", "org.apache.pdfbox.filter.Filter.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get a stream with some filters applied but not others. This is\n * useful when doing images, ie filters = [flate,dct], we want to remove\n * flate but leave dct\n *\n * @param stopFilters\n * \t\tA list of filters to stop decoding at.\n * @return A stream with decoded data.\n * @throws IOException\n * \t\tIf there is an error processing the stream.\n */\npublic InputStream createInputStream(List<String> stopFilters) throws IOException {\n    if (stopFilters == null) {\n        stopFilters = Collections.emptyList();\n    }\n    InputStream is = stream.createRawInputStream();\n    List<Filter> someFilters = new ArrayList<>();\n    List<COSName> filters = getFilters();\n    for (COSName nextFilter : filters) {\n        if (stopFilters.contains(nextFilter.getName())) {\n            break;\n        }\n        someFilters.add(FilterFactory.INSTANCE.getFilter(nextFilter));\n    }\n    if (someFilters.isEmpty()) {\n        return is;\n    }\n    RandomAccessRead decoded = Filter.decode(is, someFilters, getCOSObject(), DecodeOptions.DEFAULT, null);\n    return new RandomAccessInputStream(decoded);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShading.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShading.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDShading() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLine.getInteriorColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLine.getInteriorColor", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the interior color of the line endings defined in the LE entry. color is in DeviceRGB color\n * space.\n *\n * @return object representing the color.\n */\npublic PDColor getInteriorColor() {\n    return getColor(COSName.IC);\n}", "protected PDColor getColor(COSName itemName) {\n    COSArray cs = this.getCOSObject().getCOSArray(itemName);\n    if (cs != null) {\n        PDColorSpace colorSpace = null;\n        switch (cs.size()) {\n            case 1 :\n                colorSpace = PDDeviceGray.INSTANCE;\n                break;\n            case 3 :\n                colorSpace = PDDeviceRGB.INSTANCE;\n                break;\n            case 4 :\n                colorSpace = PDDeviceCMYK.INSTANCE;\n                break;\n            default :\n                break;\n        }\n        return new PDColor(cs, colorSpace);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.getPreviousSibling",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.getPreviousSibling", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getOutlineItem", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Return the previous sibling or null if there is no sibling.\n *\n * @return The previous sibling.\n */\npublic PDOutlineItem getPreviousSibling() {\n    return getOutlineItem(COSName.PREV);\n}", "PDOutlineItem getOutlineItem(COSName name) {\n    COSDictionary outline = getCOSObject().getCOSDictionary(name);\n    return outline != null ? new PDOutlineItem(outline) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingContext.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingContext.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tthe bounds of the area to paint, in device units\n * @throws IOException\n * \t\tif there is an error getting the color space or doing color conversion.\n */\npublic RadialShadingContext(PDShadingType3 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    this.radialShadingType = shading;\n    coords = shading.getCoords().toFloatArray();\n    // domain values\n    if (this.radialShadingType.getDomain() != null) {\n        domain = shading.getDomain().toFloatArray();\n    } else {\n        // set default values\n        domain = new float[]{ 0, 1 };\n    }\n    // extend values\n    COSArray extendValues = shading.getExtend();\n    if (extendValues != null) {\n        extend = new boolean[2];\n        extend[0] = ((COSBoolean) (extendValues.getObject(0))).getValue();\n        extend[1] = ((COSBoolean) (extendValues.getObject(1))).getValue();\n    } else {\n        // set default values\n        extend = new boolean[]{ false, false };\n    }\n    // calculate some constants to be used in getRaster\n    x1x0 = coords[3] - coords[0];\n    y1y0 = coords[4] - coords[1];\n    r1r0 = coords[5] - coords[2];\n    r0pow2 = Math.pow(coords[2], 2);\n    denom = (Math.pow(x1x0, 2) + Math.pow(y1y0, 2)) - Math.pow(r1r0, 2);\n    d1d0 = domain[1] - domain[0];\n    try {\n        // get inverse transform to be independent of current user / device space\n        // when handling actual pixels in getRaster()\n        rat = matrix.createAffineTransform().createInverse();\n        rat.concatenate(xform.createInverse());\n    } catch (NoninvertibleTransformException ex) {\n        LOG.error((ex.getMessage() + \", matrix: \") + matrix, ex);\n        rat = new AffineTransform();\n    }\n    // shading space -> device space\n    AffineTransform shadingToDevice = ((AffineTransform) (xform.clone()));\n    shadingToDevice.concatenate(matrix.createAffineTransform());\n    // worst case for the number of steps is opposite diagonal corners, so use that\n    double dist = Math.sqrt(Math.pow(deviceBounds.getMaxX() - deviceBounds.getMinX(), 2) + Math.pow(deviceBounds.getMaxY() - deviceBounds.getMinY(), 2));\n    factor = ((int) (Math.ceil(dist)));\n    // build the color table for the given number of steps\n    colorTable = calcColorTable();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.color.SetColor.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.color.SetColor.process", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    PDColorSpace colorSpace = getColorSpace();\n    if (!(colorSpace instanceof PDPattern)) {\n        if (arguments.size() < colorSpace.getNumberOfComponents()) {\n            throw new MissingOperandException(operator, arguments);\n        }\n        if (!checkArrayTypesClass(arguments, COSNumber.class)) {\n            // PDFBOX-5851: set an invalid color because Pattern colorspace is missing\n            // this will produce transparency in PageDrawer\n            setColor(new PDColor(new float[0], null));\n            return;\n        }\n    }\n    COSArray array = new COSArray();\n    array.addAll(arguments);\n    setColor(new PDColor(array, colorSpace));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureElement.getPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureElement.getPage", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the page on which some or all of the content items designated by\n *  the K entry shall be rendered (Pg).\n *\n * @return the page on which some or all of the content items designated by\nthe K entry shall be rendered\n */\npublic PDPage getPage() {\n    COSDictionary page = getCOSObject().getCOSDictionary(COSName.PG);\n    return page != null ? new PDPage(page) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDTextAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDTextAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDTextAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationText annotation = ((PDAnnotationText) (getAnnotation()));\n    if (!SUPPORTED_NAMES.contains(annotation.getName())) {\n        return;\n    }\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        PDColor bgColor = getColor();\n        if (bgColor == null) {\n            // White is used by Adobe when /C entry is missing\n            contentStream.setNonStrokingColor(1.0F);\n        } else {\n            contentStream.setNonStrokingColor(bgColor);\n        }\n        // stroking color is always black which is the PDF default\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        switch (annotation.getName()) {\n            case PDAnnotationText.NAME_NOTE :\n                drawNote(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_CROSS :\n                drawZapf(annotation, contentStream, 19, 0, \"a22\");// 0x2716\n\n                break;\n            case PDAnnotationText.NAME_CIRCLE :\n                drawCircles(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_INSERT :\n                drawInsert(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_HELP :\n                drawHelp(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_PARAGRAPH :\n                drawParagraph(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_NEW_PARAGRAPH :\n                drawNewParagraph(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_STAR :\n                drawZapf(annotation, contentStream, 19, 0, \"a35\");// 0x2605\n\n                break;\n            case PDAnnotationText.NAME_CHECK :\n                drawZapf(annotation, contentStream, 19, 50, \"a20\");// 0x2714\n\n                break;\n            case PDAnnotationText.NAME_RIGHT_ARROW :\n                drawRightArrow(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_RIGHT_POINTER :\n                drawZapf(annotation, contentStream, 17, 50, \"a174\");// 0x27A4\n\n                break;\n            case PDAnnotationText.NAME_CROSS_HAIRS :\n                drawCrossHairs(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_UP_ARROW :\n                drawUpArrow(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_UP_LEFT_ARROW :\n                drawUpLeftArrow(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_COMMENT :\n                drawComment(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_KEY :\n                drawKey(annotation, contentStream);\n                break;\n            default :\n                break;\n        }\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.saveIncremental",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.saveIncremental", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * Save the PDF as an incremental update. This is only possible if the PDF was loaded from a file or a stream, not\n * if the document was created in PDFBox itself. There must be a path of objects that have\n * {@link COSUpdateInfo#isNeedToBeUpdated()} set, starting from the document catalog. For signatures this is taken\n * care by PDFBox itself.\n * <p>\n * Other usages of this method are for experienced users only. You will usually never need it. It is useful only if\n * you are required to keep the current revision and append the changes. A typical use case is changing a signed\n * file without invalidating the signature.\n * <p>\n * If your modification includes annotations, make sure these link back to their page by calling\n * {@link PDAnnotation#setPage(PDPage)}. Although this is optional,\n * not doing it\n * <a href=\"https://stackoverflow.com/questions/74836898/\">can cause trouble when PDFs get\n * signed</a>. (PDFBox already does this for signature widget annotations)\n * <p>\n * Another problem with page-based modifications can occur if the page tree isn't flat: there\n * won't be an closed update path from the catalog to the page. To fix this, add code like this:\n * <pre>{@code COSDictionary parent = page.getCOSObject().getCOSDictionary(COSName.PARENT);\n * while (parent != null)\n * {\n *     parent.setNeedToBeUpdated(true);\n *     parent = parent.getCOSDictionary(COSName.PARENT);\n * }}</pre>\n * <p>\n * Don't use the input file as target as this will produce a corrupted file.\n *\n * @param output\n * \t\tstream to write to. It will be closed when done. It <i><b>must never</b></i> point to the source\n * \t\tfile or that one will be harmed!\n * @throws IOException\n * \t\tif the output could not be written\n * @throws IllegalStateException\n * \t\tif the document was not loaded from a file or a stream.\n */\npublic void saveIncremental(OutputStream output) throws IOException {\n    subsetDesignatedFonts();\n    if (pdfSource == null) {\n        throw new IllegalStateException(\"document was not loaded from a file or a stream\");\n    }\n    COSWriter writer = new COSWriter(output, pdfSource);\n    writer.write(this, signInterface);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDEmbeddedFile.setMacResFork",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDEmbeddedFile.setMacResFork", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the mac ResFork.\n *\n * @param macResFork\n * \t\tThe mac ResFork.\n */\npublic void setMacResFork(String macResFork) {\n    COSDictionary params = getCOSObject().getCOSDictionary(COSName.PARAMS);\n    if ((params == null) && (macResFork != null)) {\n        params = new COSDictionary();\n        getCOSObject().setItem(COSName.PARAMS, params);\n    }\n    if (params != null) {\n        params.setEmbeddedString(COSName.MAC, COSName.RES_FORK, macResFork);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.DictionaryEncoding.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.DictionaryEncoding.<init>", "org.apache.pdfbox.pdmodel.font.encoding.DictionaryEncoding.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new DictionaryEncoding for a Type 3 font from a PDF.\n *\n * @param fontEncoding\n * \t\tThe Type 3 encoding dictionary.\n */\npublic DictionaryEncoding(COSDictionary fontEncoding) {\n    encoding = fontEncoding;\n    COSName name = encoding.getCOSName(COSName.BASE_ENCODING);\n    if (name != null) {\n        baseEncoding = Encoding.getInstance(name);// null when the name is invalid\n\n        if (baseEncoding != null) {\n            // PDFBOX-5963\n            // PDF Specification: \"Differences array shall specify the complete character\n            // encoding for this font\" but other viewers read it, thus we do too.\n            LOG.warn(\"/BaseEncoding in type 3 font\");\n            codeToName.putAll(baseEncoding.codeToName);\n            inverted.putAll(baseEncoding.inverted);\n        }\n    } else {\n        baseEncoding = null;\n    }\n    applyDifferences();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>", "org.apache.pdfbox.pdmodel.font.PDType1CFont.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tthe corresponding dictionary\n * @throws IOException\n * \t\tit something went wrong\n */\npublic PDType1CFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    boolean fontIsDamaged = false;\n    CFFType1Font cffEmbedded = null;\n    PDFontDescriptor fd = getFontDescriptor();\n    if (fd != null) {\n        PDStream ff3Stream = fd.getFontFile3();\n        if (ff3Stream != null) {\n            try (RandomAccessRead randomAccessRead = ff3Stream.getCOSObject().createView()) {\n                if (randomAccessRead.length() == 0) {\n                    LOG.error(\"Invalid data for embedded Type1C font \" + getName());\n                } else {\n                    // note: this could be an OpenType file, fortunately CFFParser can handle that\n                    CFFParser cffParser = new CFFParser();\n                    CFFFont parsedCffFont = cffParser.parse(randomAccessRead).get(0);\n                    if (parsedCffFont instanceof CFFType1Font) {\n                        cffEmbedded = ((CFFType1Font) (parsedCffFont));\n                    } else {\n                        LOG.error(\"Expected CFFType1Font, got \" + parsedCffFont.getClass().getSimpleName());\n                        fontIsDamaged = true;\n                    }\n                }\n            } catch (IOException e) {\n                LOG.error(\"Can't read the embedded Type1C font \" + getName(), e);\n                fontIsDamaged = true;\n            }\n        }\n    }\n    isDamaged = fontIsDamaged;\n    cffFont = cffEmbedded;\n    if (cffFont != null) {\n        genericFont = cffFont;\n        isEmbedded = true;\n    } else {\n        String baseFont = getBaseFont();\n        FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(baseFont, fd);\n        genericFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + genericFont.getName()) + \" for \") + baseFont);\n        }\n        isEmbedded = false;\n    }\n    readEncoding();\n    fontMatrixTransform = getFontMatrix().createAffineTransform();\n    fontMatrixTransform.scale(1000, 1000);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getTrueTypeFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getTrueTypeFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.<clinit>" ],
    "fullMethods" : [ "/**\n * Finds a TrueType font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param fontDescriptor\n * \t\tFontDescriptor\n */\n@Override\npublic FontMapping<TrueTypeFont> getTrueTypeFont(String baseFont, PDFontDescriptor fontDescriptor) {\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, baseFont)));\n    if (ttf != null) {\n        return new FontMapping<>(ttf, false);\n    } else {\n        // fallback - todo: i.e. fuzzy match\n        String fontName = getFallbackFontName(fontDescriptor);\n        ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, fontName)));\n        if (ttf == null) {\n            // we have to return something here as TTFs aren't strictly required on the system\n            ttf = lastResortFont;\n        }\n        return new FontMapping<>(ttf, true);\n    }\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFont(FontFormat format, String postScriptName) {\n    // handle damaged PDFs, see PDFBOX-2884\n    if (postScriptName == null) {\n        return null;\n    }\n    // make sure the font provider is initialized\n    if (fontProvider == null) {\n        getProvider();\n    }\n    // first try to match the PostScript name\n    FontInfo info = getFont(format, postScriptName);\n    if (info != null) {\n        return info.getFont();\n    }\n    // remove hyphens (e.g. Arial-Black -> ArialBlack)\n    info = getFont(format, postScriptName.replace(\"-\", \"\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    // then try named substitutes\n    for (String substituteName : getSubstitutes(postScriptName)) {\n        info = getFont(format, substituteName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // then try converting Windows names e.g. (ArialNarrow,Bold) -> (ArialNarrow-Bold)\n    info = getFont(format, postScriptName.replace(\",\", \"-\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    if (postScriptName.contains(\",\")) {\n        postScriptName = postScriptName.substring(0, postScriptName.indexOf(\",\"));\n        // PDFBOX-5806: try cutting font style and getting the basefont\n        // eg. for \"Wingdings,Bolt\" to \"Wingding-Regular\" (including the following step)\n        info = getFont(format, postScriptName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // try appending \"-Regular\", works for Wingdings on windows\n    info = getFont(format, postScriptName + \"-Regular\");\n    if (info != null) {\n        return info.getFont();\n    }\n    // no matches\n    return null;\n}", "/**\n * Finds the named font with the given format.\n */\nprivate FontInfo getFont(FontFormat format, String postScriptName) {\n    int index = postScriptName.indexOf('+');\n    // strip subset tag (happens when we substitute a corrupt embedded font, see PDFBOX-2642)\n    if (index > (-1)) {\n        postScriptName = postScriptName.substring(index + 1);\n    }\n    // look up the PostScript name\n    FontInfo info = fontInfoByName.get(postScriptName.toLowerCase(Locale.ENGLISH));\n    if ((info != null) && (info.getFormat() == format)) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"getFont('%s','%s') returns %s\", format, postScriptName, info));\n        }\n        return info;\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDCryptFilterDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDCryptFilterDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * creates a new empty crypt filter dictionary.\n */\npublic PDCryptFilterDictionary() {\n    cryptFilterDictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSStream.close",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSStream.close", "org.apache.pdfbox.cos.COSStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void close() throws IOException {\n    super.close();\n    setInt(COSName.LENGTH, ((int) (randomAccess.length())));\n    isWriting = false;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.pattern.PDTilingPattern.getContentStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.pattern.PDTilingPattern.getContentStream", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "public PDStream getContentStream() {\n    return new PDStream(((COSStream) (getCOSObject())));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType1FontEmbedder.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new Type 1 font for embedding.\n *\n * @param doc\n * \t\tPDF document to write to\n * @param pfbIn\n * \t\tPFB file stream\n * @param encoding\n * \t\tencoding to be used for the font\n * @throws IOException\n * \t\tif the font could not be read\n */\npublic PDType1Font(PDDocument doc, InputStream pfbIn, Encoding encoding) throws IOException {\n    PDType1FontEmbedder embedder = new PDType1FontEmbedder(doc, dict, pfbIn, encoding);\n    this.encoding = (encoding == null) ? embedder.getFontEncoding() : encoding;\n    glyphList = embedder.getGlyphList();\n    type1font = embedder.getType1Font();\n    genericFont = embedder.getType1Font();\n    isEmbedded = true;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}", "/**\n * This will load a PFB to be embedded into a document.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param dict\n * \t\tThe Font dictionary to write to.\n * @param pfbStream\n * \t\tThe pfb input.\n * @throws IOException\n * \t\tIf there is an error loading the data.\n */\nPDType1FontEmbedder(PDDocument doc, COSDictionary dict, InputStream pfbStream, Encoding encoding) throws IOException {\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    // read the pfb\n    byte[] pfbBytes = IOUtils.toByteArray(pfbStream);\n    PfbParser pfbParser = new PfbParser(pfbBytes);\n    type1 = Type1Font.createWithPFB(pfbBytes);\n    if (encoding == null) {\n        fontEncoding = Type1Encoding.fromFontBox(type1.getEncoding());\n    } else {\n        fontEncoding = encoding;\n    }\n    // build font descriptor\n    PDFontDescriptor fd = buildFontDescriptor(type1);\n    PDStream fontStream = new PDStream(doc, pfbParser.getInputStream(), COSName.FLATE_DECODE);\n    fontStream.getCOSObject().setInt(\"Length\", pfbParser.size());\n    for (int i = 0; i < pfbParser.getLengths().length; i++) {\n        fontStream.getCOSObject().setInt(\"Length\" + (i + 1), pfbParser.getLengths()[i]);\n    }\n    fd.setFontFile(fontStream);\n    // set the values\n    dict.setItem(COSName.FONT_DESC, fd);\n    dict.setName(COSName.BASE_FONT, type1.getName());\n    // widths\n    List<Integer> widths = new ArrayList<>(256);\n    for (int code = 0; code <= 255; code++) {\n        String name = fontEncoding.getName(code);\n        int width = Math.round(type1.getWidth(name));\n        widths.add(width);\n    }\n    dict.setInt(COSName.FIRST_CHAR, 0);\n    dict.setInt(COSName.LAST_CHAR, 255);\n    dict.setItem(COSName.WIDTHS, COSArray.ofCOSIntegers(widths));\n    dict.setItem(COSName.ENCODING, encoding);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDFontFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor for reading a Type0 font from a PDF file.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @throws IOException\n * \t\tif the descendant font is missing.\n */\npublic PDType0Font(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    gsubData = GsubData.NO_DATA_FOUND;\n    cmapLookup = null;\n    COSArray descendantFonts = dict.getCOSArray(COSName.DESCENDANT_FONTS);\n    if (descendantFonts == null) {\n        throw new IOException(\"Missing descendant font array\");\n    }\n    if (descendantFonts.size() == 0) {\n        throw new IOException(\"Descendant font array is empty\");\n    }\n    COSBase descendantFontDictBase = descendantFonts.getObject(0);\n    if (!(descendantFontDictBase instanceof COSDictionary)) {\n        throw new IOException(\"Missing descendant font dictionary\");\n    }\n    if (!COSName.FONT.equals(((COSDictionary) (descendantFontDictBase)).getCOSName(COSName.TYPE, COSName.FONT))) {\n        throw new IOException(\"Missing or wrong type in descendant font dictionary\");\n    }\n    descendantFont = PDFontFactory.createDescendantFont(((COSDictionary) (descendantFontDictBase)), this);\n    readEncoding();\n    fetchCMapUCS2();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPopup.getParent",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPopup.getParent", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the markup annotation which this popup relates to.\n *\n * @return The parent markup annotation.\n */\npublic PDAnnotationMarkup getParent() {\n    try {\n        PDAnnotation ann = PDAnnotation.createAnnotation(getCOSObject().getDictionaryObject(COSName.PARENT, COSName.P));\n        if (!(ann instanceof PDAnnotationMarkup)) {\n            LOG.error((\"parent annotation is of type \" + ann.getClass().getSimpleName()) + \" but should be of type PDAnnotationMarkup\");\n            return null;\n        }\n        return ((PDAnnotationMarkup) (ann));\n    } catch (IOException ioe) {\n        LOG.debug(\"An exception while trying to get the parent markup - ignoring\", ioe);\n        // Couldn't construct the annotation, so return null i.e. do nothing\n        return null;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setParent",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setParent", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.calculateLimits", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the parent to the given node.\n *\n * @param parentNode\n * \t\tthe node to be set as parent\n */\npublic void setParent(PDNameTreeNode<T> parentNode) {\n    parent = parentNode;\n    calculateLimits();\n}", "private void calculateLimits() {\n    if (isRootNode()) {\n        node.setItem(COSName.LIMITS, null);\n    } else {\n        List<PDNameTreeNode<T>> kids = getKids();\n        if ((kids != null) && (!kids.isEmpty())) {\n            PDNameTreeNode<T> firstKid = kids.get(0);\n            PDNameTreeNode<T> lastKid = kids.get(kids.size() - 1);\n            String lowerLimit = firstKid.getLowerLimit();\n            setLowerLimit(lowerLimit);\n            String upperLimit = lastKid.getUpperLimit();\n            setUpperLimit(upperLimit);\n        } else {\n            try {\n                Map<String, T> names = getNames();\n                if ((names != null) && (names.size() > 0)) {\n                    Set<String> strings = names.keySet();\n                    String[] keys = strings.toArray(new String[strings.size()]);\n                    String lowerLimit = keys[0];\n                    setLowerLimit(lowerLimit);\n                    String upperLimit = keys[keys.length - 1];\n                    setUpperLimit(upperLimit);\n                } else {\n                    node.setItem(COSName.LIMITS, null);\n                }\n            } catch (IOException exception) {\n                node.setItem(COSName.LIMITS, null);\n                LOG.error(\"Error while calculating the Limits of a PageNameTreeNode:\", exception);\n            }\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setPerms",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setPerms", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the Perms entry in the encryption dictionary.\n *\n * @param perms\n * \t\tA 16 byte array.\n * @throws IOException\n * \t\tIf there is an error setting the data.\n */\npublic void setPerms(byte[] perms) throws IOException {\n    dictionary.setItem(COSName.PERMS, new COSString(perms));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.removeSubject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.removeSubject", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * removes a subject from the list\n *\n * @param subject\n * \t\tbyte array containing DER-encoded X.509v3 certificate\n */\npublic void removeSubject(byte[] subject) {\n    COSArray array = dictionary.getCOSArray(COSName.SUBJECT);\n    if (array != null) {\n        array.remove(new COSString(subject));\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont", "org.apache.pdfbox.pdmodel.font.PDFontFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new PDFont instance with the appropriate subclass.\n *\n * @param dictionary\n * \t\ta font dictionary\n * @return a PDFont instance, based on the SubType entry of the dictionary\n * @throws IOException\n * \t\tif something goes wrong\n */\npublic static PDFont createFont(COSDictionary dictionary) throws IOException {\n    return createFont(dictionary, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.addIssuer",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.addIssuer", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * array of bytes containing DER-encoded X.509v3 certificates of acceptable issuers. If the\n * signerâs certificate chains up to any of the specified issuers (either directly or\n * indirectly), the certificate is considered acceptable for signing.\n *\n * @param issuer\n * \t\tA byte array containing DER-encoded X.509v3 certificate\n */\npublic void addIssuer(byte[] issuer) {\n    COSArray array = dictionary.getCOSArray(COSName.ISSUER);\n    if (array == null) {\n        array = new COSArray();\n    }\n    array.add(new COSString(issuer));\n    dictionary.setItem(COSName.ISSUER, array);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.<init>", "org.apache.pdfbox.rendering.TilingPaintFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param parameters\n * \t\tParameters for page drawing.\n * @throws IOException\n * \t\tIf there is an error loading properties from the file.\n */\npublic PageDrawer(PageDrawerParameters parameters) throws IOException {\n    super(parameters.getPage());\n    this.renderer = parameters.getRenderer();\n    this.subsamplingAllowed = parameters.isSubsamplingAllowed();\n    this.destination = parameters.getDestination();\n    this.renderingHints = parameters.getRenderingHints();\n    this.imageDownscalingOptimizationThreshold = parameters.getImageDownscalingOptimizationThreshold();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType2.toPaint",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType2.toPaint", "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Paint toPaint(Matrix matrix) {\n    return new AxialShadingPaint(this, matrix);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.DateConverter.toCalendar",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.DateConverter.toCalendar", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the Calendar for a given string containing a date,\n * or {@code null} if it cannot be parsed.\n *\n * The returned value will have 0 for DST_OFFSET.\n *\n * @param text\n * \t\tA COS string containing a date.\n * @return The Calendar that the text string represents, or {@code null} if it cannot be parsed.\n */\npublic static Calendar toCalendar(String text) {\n    if ((text == null) || text.trim().isEmpty()) {\n        return null;\n    }\n    ParsePosition where = new ParsePosition(0);\n    skipOptionals(text, where, \" \");\n    skipString(text, \"D:\", where);\n    Calendar calendar = parseDate(text, where);\n    if ((calendar == null) || (where.getIndex() != text.length())) {\n        // the date string is invalid\n        return null;\n    }\n    return calendar;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLink.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLink.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLinkAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDLinkAppearanceHandler appearanceHandler = new PDLinkAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PDFRenderer.renderImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PDFRenderer.renderImage", "org.apache.pdfbox.pdmodel.PDPage.getCropBox", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the given page as an RGB or ARGB image at the given scale.\n *\n * @param pageIndex\n * \t\tthe zero-based index of the page to be converted\n * @param scale\n * \t\tthe scaling factor, where 1 = 72 DPI\n * @param imageType\n * \t\tthe type of image to return\n * @param destination\n * \t\tcontrolling visibility of optional content groups\n * @return the rendered page image\n * @throws IOException\n * \t\tif the PDF cannot be read\n * @throws IllegalStateException\n * \t\tif the requested index isn't found or doesn't point to a valid\n * \t\tpage dictionary\n * @throws IndexOutOfBoundsException\n * \t\tif the requested index is higher than the page count\n */\npublic BufferedImage renderImage(int pageIndex, float scale, ImageType imageType, RenderDestination destination) throws IOException {\n    PDPage page = pageTree.get(pageIndex);\n    PDRectangle cropBox = page.getCropBox();\n    float widthPt = cropBox.getWidth();\n    float heightPt = cropBox.getHeight();\n    // PDFBOX-4306 avoid single blank pixel line on the right or on the bottom\n    int widthPx = ((int) (Math.max(Math.floor(widthPt * scale), 1)));\n    int heightPx = ((int) (Math.max(Math.floor(heightPt * scale), 1)));\n    // PDFBOX-4518 the maximum size (w*h) of a buffered image is limited to Integer.MAX_VALUE\n    if ((((long) (widthPx)) * ((long) (heightPx))) > Integer.MAX_VALUE) {\n        throw new IOException(((((((\"Maximum size of image exceeded (w * h * scale ^ 2) = \"// \n         + widthPt) + \" * \") + heightPt) + \" * \") + scale) + \" ^ 2 > \") + Integer.MAX_VALUE);\n    }\n    int rotationAngle = page.getRotation();\n    int bimType;\n    if ((imageType != ImageType.ARGB) && hasBlendMode(page)) {\n        // PDFBOX-4095: if the PDF has blending on the top level, draw on transparent background\n        // Inspired from PDF.js: if a PDF page uses any blend modes other than Normal,\n        // PDF.js renders everything on a fully transparent RGBA canvas.\n        // Finally when the page has been rendered, PDF.js draws the RGBA canvas on a white canvas.\n        bimType = BufferedImage.TYPE_INT_ARGB;\n    } else {\n        bimType = imageType.toBufferedImageType();\n    }\n    // swap width and height\n    BufferedImage image;\n    if ((rotationAngle == 90) || (rotationAngle == 270)) {\n        image = new BufferedImage(heightPx, widthPx, bimType);\n    } else {\n        image = new BufferedImage(widthPx, heightPx, bimType);\n    }\n    pageImage = image;\n    // use a transparent background if the image type supports alpha\n    Graphics2D g = image.createGraphics();\n    if (image.getType() == BufferedImage.TYPE_INT_ARGB) {\n        g.setBackground(new Color(0, 0, 0, 0));\n    } else {\n        g.setBackground(Color.WHITE);\n    }\n    g.clearRect(0, 0, image.getWidth(), image.getHeight());\n    transform(g, page.getRotation(), cropBox, scale, scale);\n    // the end-user may provide a custom PageDrawer\n    RenderingHints actualRenderingHints = (renderingHints == null) ? createDefaultRenderingHints(g) : renderingHints;\n    PageDrawerParameters parameters = new PageDrawerParameters(this, page, subsamplingAllowed, destination, actualRenderingHints, imageDownscalingOptimizationThreshold);\n    PageDrawer drawer = createPageDrawer(parameters);\n    drawer.drawPage(g, cropBox);\n    g.dispose();\n    if (image.getType() != imageType.toBufferedImageType()) {\n        // PDFBOX-4095: draw temporary transparent image on white background\n        BufferedImage newImage = new BufferedImage(image.getWidth(), image.getHeight(), imageType.toBufferedImageType());\n        Graphics2D dstGraphics = newImage.createGraphics();\n        dstGraphics.setBackground(Color.WHITE);\n        dstGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());\n        dstGraphics.drawImage(image, 0, 0, null);\n        dstGraphics.dispose();\n        image = newImage;\n    }\n    return image;\n}", "/**\n * A rectangle, expressed in default user space units, defining the visible region of default user space. When the\n * page is displayed or printed, its contents are to be clipped (cropped) to this rectangle.\n *\n * @return the cropbox of the page\n */\npublic PDRectangle getCropBox() {\n    COSBase base = PDPageTree.getInheritableAttribute(page, COSName.CROP_BOX);\n    if (base instanceof COSArray) {\n        return clipToMediaBox(new PDRectangle(((COSArray) (base))));\n    } else {\n        return getMediaBox();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFont.encode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFont.encode", "org.apache.pdfbox.pdmodel.font.PDType1Font.encode", "org.apache.pdfbox.pdmodel.font.PDType1Font.getNameInFont", "org.apache.pdfbox.pdmodel.font.PDType1Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Encodes the given string for use in a PDF content stream.\n *\n * @param text\n * \t\tAny Unicode text.\n * @return Array of PDF content stream bytes.\n * @throws IOException\n * \t\tIf the text could not be encoded.\n * @throws IllegalArgumentException\n * \t\tif a character isn't supported by the font.\n */\npublic final byte[] encode(String text) throws IOException {\n    ByteArrayOutputStream out = new ByteArrayOutputStream(Math.max(32, text.length()));\n    int offset = 0;\n    while (offset < text.length()) {\n        int codePoint = text.codePointAt(offset);\n        // multi-byte encoding with 1 to 4 bytes\n        byte[] bytes = encode(codePoint);\n        out.write(bytes);\n        offset += Character.charCount(codePoint);\n    } \n    return out.toByteArray();\n}", "@Override\nprotected byte[] encode(int unicode) throws IOException {\n    byte[] bytes = codeToBytesMap.get(unicode);\n    if (bytes != null) {\n        return bytes;\n    }\n    String name = getGlyphList().codePointToName(unicode);\n    if (isStandard14()) {\n        // genericFont not needed, thus simplified code\n        // this is important on systems with no installed fonts\n        if (!encoding.contains(name)) {\n            throw new IllegalArgumentException(String.format(\"U+%04X ('%s') is not available in the font %s, encoding: %s\", unicode, name, getName(), encoding.getEncodingName()));\n        }\n        if (\".notdef\".equals(name)) {\n            throw new IllegalArgumentException(String.format(\"No glyph for U+%04X in the font %s\", unicode, getName()));\n        }\n    } else {\n        if (!encoding.contains(name)) {\n            throw new IllegalArgumentException(String.format(\"U+%04X ('%s') is not available in the font %s (generic: %s), encoding: %s\", unicode, name, getName(), genericFont.getName(), encoding.getEncodingName()));\n        }\n        String nameInFont = getNameInFont(name);\n        if (\".notdef\".equals(nameInFont) || (!genericFont.hasGlyph(nameInFont))) {\n            throw new IllegalArgumentException(String.format(\"No glyph for U+%04X in the font %s (generic: %s)\", unicode, getName(), genericFont.getName()));\n        }\n    }\n    Map<String, Integer> inverted = encoding.getNameToCodeMap();\n    int code = inverted.get(name);\n    if (code < 0) {\n        throw new IllegalArgumentException(String.format(\"U+%04X ('%s') is not available in the font %s (generic: %s), encoding: %s\", unicode, name, getName(), genericFont.getName(), encoding.getEncodingName()));\n    }\n    bytes = new byte[]{ ((byte) (code)) };\n    codeToBytesMap.put(unicode, bytes);\n    return bytes;\n}", "/**\n * Maps a PostScript glyph name to the name in the underlying font, for example when\n * using a TTF font we might map \"W\" to \"uni0057\".\n */\nprivate String getNameInFont(String name) throws IOException {\n    if (isEmbedded() || genericFont.hasGlyph(name)) {\n        return name;\n    }\n    // try alternative name\n    String altName = ALT_NAMES.get(name);\n    if (((altName != null) && (!name.equals(\".notdef\"))) && genericFont.hasGlyph(altName)) {\n        return altName;\n    }\n    // try unicode name\n    String unicodes = getGlyphList().toUnicode(name);\n    if ((unicodes != null) && (unicodes.length() == 1)) {\n        String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));\n        if (genericFont.hasGlyph(uniName)) {\n            return uniName;\n        }\n        // PDFBOX-4017: no postscript table on Windows 10, and the low uni00NN\n        // names are not found in Symbol font. What works is using the PDF code plus 0xF000\n        // while disregarding encoding from the PDF (because of file from PDFBOX-1606,\n        // makes sense because this segment is about finding the name in a standard font)\n        // TODO bring up better solution than this\n        if (\"SymbolMT\".equals(genericFont.getName())) {\n            Integer code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(name);\n            if (code != null) {\n                uniName = getUniNameOfCodePoint(code + 0xf000);\n                if (genericFont.hasGlyph(uniName)) {\n                    return uniName;\n                }\n            }\n        }\n    }\n    return \".notdef\";\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.<init>", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * Instantiate a new PDFTextStripper object.\n */\npublic PDFTextStripper() {\n    addOperator(new BeginMarkedContentSequenceWithProperties(this));\n    addOperator(new BeginMarkedContentSequence(this));\n    addOperator(new EndMarkedContentSequence(this));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getMetadata",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getMetadata", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the metadata that is part of the document catalog. This will return null if there is\n * no meta data for this object.\n *\n * @return The metadata for this object.\n */\npublic PDMetadata getMetadata() {\n    COSStream metadata = page.getCOSStream(COSName.METADATA);\n    return metadata != null ? new PDMetadata(metadata) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.printing.PDFPageable.getPrintable",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.printing.PDFPageable.getPrintable", "org.apache.pdfbox.printing.PDFPrintable.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Printable getPrintable(int i) {\n    if (i >= numberOfPages) {\n        throw new IndexOutOfBoundsException((i + \" >= \") + numberOfPages);\n    }\n    PDFPrintable printable = new PDFPrintable(document, Scaling.ACTUAL_SIZE, showPageBorder, dpi, center);\n    printable.setSubsamplingAllowed(subsamplingAllowed);\n    printable.setRenderingHints(renderingHints);\n    return printable;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getColor", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the color used in drawing various elements. As of PDF 1.6 these are :\n * <ul>\n * <li>Background of icon when closed</li>\n * <li>Title bar of popup window</li>\n * <li>Border of a link annotation</li>\n * </ul>\n *\n * @return Color object representing the colour\n */\npublic PDColor getColor() {\n    return getColor(COSName.C);\n}", "protected PDColor getColor(COSName itemName) {\n    COSArray cs = this.getCOSObject().getCOSArray(itemName);\n    if (cs != null) {\n        PDColorSpace colorSpace = null;\n        switch (cs.size()) {\n            case 1 :\n                colorSpace = PDDeviceGray.INSTANCE;\n                break;\n            case 3 :\n                colorSpace = PDDeviceRGB.INSTANCE;\n                break;\n            case 4 :\n                colorSpace = PDDeviceCMYK.INSTANCE;\n                break;\n            default :\n                break;\n        }\n        return new PDColor(cs, colorSpace);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setRecipients",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setRecipients", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the Recipients field of the dictionary. This field contains an array\n * of string.\n *\n * @param recipients\n * \t\tthe array of bytes arrays to put in the Recipients field.\n * @throws IOException\n * \t\tIf there is an error setting the data.\n */\npublic void setRecipients(byte[][] recipients) throws IOException {\n    COSArray array = new COSArray();\n    for (byte[] recipient : recipients) {\n        COSString recip = new COSString(recipient);\n        array.add(recip);\n    }\n    dictionary.setItem(COSName.RECIPIENTS, array);\n    array.setDirect(true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.<init>", "org.apache.pdfbox.pdfparser.XrefTrailerResolver.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor for encrypted pdfs.\n *\n * @param source\n * \t\tinput representing the pdf.\n * @param password\n * \t\tpassword to be used for decryption.\n * @param keyStore\n * \t\tkey store to be used for decryption when using public key security\n * @param keyAlias\n * \t\talias to be used for decryption when using public key security\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of the stream cache\n * @throws IOException\n * \t\tif the source data could not be read\n */\npublic COSParser(RandomAccessRead source, String password, InputStream keyStore, String keyAlias, StreamCacheCreateFunction streamCacheCreateFunction) throws IOException {\n    super(source);\n    this.password = password;\n    this.keyAlias = keyAlias;\n    fileLen = source.length();\n    keyStoreInputStream = keyStore;\n    init(streamCacheCreateFunction);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDButton.updateByValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.getWidgets", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the selected option given its index, and try to update the visual appearance.\n *\n * NOTE: this method is only usable if there are export values and used for\n * radio buttons with FLAG_RADIOS_IN_UNISON not set.\n *\n * @param index\n * \t\tindex of option to be selected\n * @throws IOException\n * \t\tif the value could not be set\n * @throws IllegalArgumentException\n * \t\tif the index provided is not a valid index.\n */\npublic void setValue(int index) throws IOException {\n    List<String> exportValues = getExportValues();\n    if ((exportValues.isEmpty() || (index < 0)) || (index >= exportValues.size())) {\n        throw new IllegalArgumentException(((((\"index '\" + index) + \"' is not a valid index for the field \") + getFullyQualifiedName()) + \", valid indices are from 0 to \") + (exportValues.size() - 1));\n    }\n    updateByValue(String.valueOf(index));\n    applyChange();\n}", "private void updateByValue(String value) {\n    getCOSObject().setName(COSName.V, value);\n    // update the appearance state (AS)\n    for (PDAnnotationWidget widget : getWidgets()) {\n        PDAppearanceDictionary appearance = widget.getAppearance();\n        if (appearance == null) {\n            continue;\n        }\n        PDAppearanceEntry appearanceEntry = appearance.getNormalAppearance();\n        if (appearanceEntry.getCOSObject().containsKey(value)) {\n            widget.setAppearanceState(value);\n        } else {\n            widget.setAppearanceState(COSName.Off.getName());\n        }\n    }\n}", "/**\n * Returns the widget annotations associated with this field.\n *\n * @return The list of widget annotations. Be aware that this list is <i>not</i> backed by the\nactual widget collection of the field, so adding or deleting has no effect on the PDF\ndocument until you call {@link #setWidgets(java.util.List) setWidgets()} with the modified\nlist.\n */\n@Override\npublic List<PDAnnotationWidget> getWidgets() {\n    List<PDAnnotationWidget> widgets = new ArrayList<>();\n    COSArray kids = getCOSObject().getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // the field itself is a widget\n        widgets.add(new PDAnnotationWidget(getCOSObject()));\n    } else if (kids.size() > 0) {\n        // there are multiple widgets\n        for (int i = 0; i < kids.size(); i++) {\n            COSBase kid = kids.getObject(i);\n            if (kid instanceof COSDictionary) {\n                widgets.add(new PDAnnotationWidget(((COSDictionary) (kid))));\n            }\n        }\n    }\n    return widgets;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.getNumberOfComponents",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.getNumberOfComponents", "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.<clinit>" ],
    "fullMethods" : [ "@Override\npublic int getNumberOfComponents() {\n    if (numberOfComponents < 0) {\n        numberOfComponents = stream.getCOSObject().getInt(COSName.N);\n        // PDFBOX-4801 correct wrong /N values\n        if (iccProfile != null) {\n            int numIccComponents = iccProfile.getNumComponents();\n            if (numIccComponents != numberOfComponents) {\n                LOG.warn((((\"Using \" + numIccComponents) + \" components from ICC profile info instead of \") + numberOfComponents) + \" components from /N entry\");\n                numberOfComponents = numIccComponents;\n            }\n        }\n    }\n    return numberOfComponents;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.setFontFamily",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.setFontFamily", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the font family.\n *\n * @param fontFamily\n * \t\tThe font family.\n */\npublic void setFontFamily(String fontFamily) {\n    COSString name = null;\n    if (fontFamily != null) {\n        name = new COSString(fontFamily);\n    }\n    dic.setItem(COSName.FONT_FAMILY, name);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationMarkup.setRichContents",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationMarkup.setRichContents", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the rich text stream which is displayed in the popup window.\n *\n * @param rc\n * \t\tthe rich text stream.\n */\npublic void setRichContents(String rc) {\n    getCOSObject().setItem(COSName.RC, new COSString(rc));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.<init>", "org.apache.pdfbox.filter.ASCIIHexFilter.decode", "org.apache.pdfbox.filter.ASCIIHexFilter.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates an inline image from the given parameters and data.\n *\n * @param parameters\n * \t\tthe image parameters\n * @param data\n * \t\tthe image data\n * @param resources\n * \t\tthe current resources\n * @throws IOException\n * \t\tif the stream cannot be decoded\n */\npublic PDInlineImage(COSDictionary parameters, byte[] data, PDResources resources) throws IOException {\n    this.parameters = parameters;\n    this.resources = resources;\n    this.rawData = data;\n    DecodeResult decodeResult = null;\n    List<String> filters = getFilters();\n    if (filters.isEmpty()) {\n        this.decodedData = data;\n    } else {\n        ByteArrayInputStream in = new ByteArrayInputStream(data);\n        ByteArrayOutputStream out = new ByteArrayOutputStream(data.length);\n        byte[] ba = null;\n        for (int i = 0; i < filters.size(); i++) {\n            // TODO handling of abbreviated names belongs here, rather than in other classes\n            out.reset();\n            Filter filter = FilterFactory.INSTANCE.getFilter(filters.get(i));\n            decodeResult = filter.decode(in, out, parameters, i);\n            ba = out.toByteArray();\n            in = new ByteArrayInputStream(ba);\n        }\n        this.decodedData = ba;\n    }\n    // repair parameters\n    if (decodeResult != null) {\n        parameters.addAll(decodeResult.getParameters());\n    }\n}", "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    int value;\n    int firstByte;\n    int secondByte;\n    while ((firstByte = encoded.read()) != (-1)) {\n        // always after first char\n        while (isWhitespace(firstByte)) {\n            firstByte = encoded.read();\n        } \n        if ((firstByte == (-1)) || isEOD(firstByte)) {\n            break;\n        }\n        if (REVERSE_HEX[firstByte] == (-1)) {\n            LOG.error(((\"Invalid hex, int: \" + firstByte) + \" char: \") + ((char) (firstByte)));\n        }\n        value = REVERSE_HEX[firstByte] * 16;\n        secondByte = encoded.read();\n        if ((secondByte == (-1)) || isEOD(secondByte)) {\n            // second value behaves like 0 in case of EOD\n            decoded.write(value);\n            break;\n        }\n        if (REVERSE_HEX[secondByte] == (-1)) {\n            LOG.error(((\"Invalid hex, int: \" + secondByte) + \" char: \") + ((char) (secondByte)));\n        }\n        value += REVERSE_HEX[secondByte];\n        decoded.write(value);\n    } \n    decoded.flush();\n    return new DecodeResult(parameters);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.write",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.write", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will write the pdf document. If signature should be created externally,\n * {@link #writeExternalSignature(byte[])} should be invoked to set signature after calling this method.\n *\n * @param doc\n * \t\tThe document to write.\n * @param signInterface\n * \t\tclass to be used for signing; {@code null} if external signing would be performed\n * \t\tor there will be no signing at all\n * @throws IOException\n * \t\tIf an error occurs while generating the data.\n * @throws IllegalStateException\n * \t\tIf the document has an encryption dictionary but no protection\n * \t\tpolicy.\n */\npublic void write(PDDocument doc, SignatureInterface signInterface) throws IOException {\n    pdDocument = doc;\n    COSDocument cosDoc = pdDocument.getDocument();\n    COSDictionary trailer = cosDoc.getTrailer();\n    if (incrementalUpdate) {\n        trailer.toIncrement().exclude(trailer).forEach(base -> {\n            objectsToWrite.add(base);\n            if (base instanceof COSObject) {\n                actualsAdded.add(((COSObject) (base)).getObject());\n            } else {\n                actualsAdded.add(base);\n            }\n        });\n    }\n    signatureInterface = signInterface;\n    number = pdDocument.getDocument().getHighestXRefObjectNumber();\n    if (incrementalUpdate) {\n        prepareIncrement();\n    }\n    long idTime = (pdDocument.getDocumentId() == null) ? System.currentTimeMillis() : pdDocument.getDocumentId();\n    // if the document says we should remove encryption, then we shouldn't encrypt\n    if (doc.isAllSecurityToBeRemoved()) {\n        willEncrypt = false;\n        // also need to get rid of the \"Encrypt\" in the trailer so readers\n        // don't try to decrypt a document which is not encrypted\n        trailer.removeItem(COSName.ENCRYPT);\n    } else if (pdDocument.getEncryption() != null) {\n        if (!incrementalUpdate) {\n            SecurityHandler<? extends ProtectionPolicy> securityHandler = pdDocument.getEncryption().getSecurityHandler();\n            if (!securityHandler.hasProtectionPolicy()) {\n                throw new IllegalStateException(\"PDF contains an encryption dictionary, please remove it with \" + \"setAllSecurityToBeRemoved() or set a protection policy with protect()\");\n            }\n            securityHandler.prepareDocumentForEncryption(pdDocument);\n        }\n        willEncrypt = true;\n    } else {\n        willEncrypt = false;\n    }\n    COSArray idArray;\n    boolean missingID = true;\n    COSBase base = trailer.getDictionaryObject(COSName.ID);\n    if (base instanceof COSArray) {\n        idArray = ((COSArray) (base));\n        if (idArray.size() == 2) {\n            missingID = false;\n        }\n    } else {\n        idArray = new COSArray();\n    }\n    if (missingID || incrementalUpdate) {\n        MessageDigest sha256;\n        try {\n            sha256 = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            // should never happen\n            throw new RuntimeException(e);\n        }\n        // algorithm says to use time/path/size/values in doc to generate the id.\n        // we don't have path or size, so do the best we can\n        sha256.update(Long.toString(idTime).getBytes(StandardCharsets.ISO_8859_1));\n        COSDictionary info = trailer.getCOSDictionary(COSName.INFO);\n        if (info != null) {\n            for (COSBase cosBase : info.getValues()) {\n                sha256.update(cosBase.toString().getBytes(StandardCharsets.ISO_8859_1));\n            }\n        }\n        // reuse origin documentID if available as first value\n        COSString firstID = (missingID) ? new COSString(sha256.digest()) : ((COSString) (idArray.get(0)));\n        // it's ok to use the same ID for the second part if the ID is created for the first time\n        COSString secondID = (missingID) ? firstID : new COSString(sha256.digest());\n        idArray = new COSArray();\n        idArray.add(firstID);\n        idArray.add(secondID);\n        trailer.setItem(COSName.ID, idArray);\n    }\n    cosDoc.accept(this);\n    if (!incrementalUpdate) {\n        cosDoc.setHighestXRefObjectNumber(number);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPolyline.getInteriorColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPolyline.getInteriorColor", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the interior color with which to fill the annotationâs line endings.\n *\n * @return object representing the color.\n */\npublic PDColor getInteriorColor() {\n    return getColor(COSName.IC);\n}", "protected PDColor getColor(COSName itemName) {\n    COSArray cs = this.getCOSObject().getCOSArray(itemName);\n    if (cs != null) {\n        PDColorSpace colorSpace = null;\n        switch (cs.size()) {\n            case 1 :\n                colorSpace = PDDeviceGray.INSTANCE;\n                break;\n            case 3 :\n                colorSpace = PDDeviceRGB.INSTANCE;\n                break;\n            case 4 :\n                colorSpace = PDDeviceCMYK.INSTANCE;\n                break;\n            default :\n                break;\n        }\n        return new PDColor(cs, colorSpace);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormDefaultsProcessor.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormDefaultsProcessor.process", "org.apache.pdfbox.pdmodel.PDDocument.getDocumentCatalog", "org.apache.pdfbox.pdmodel.PDDocumentCatalog.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process() {\n    /* Get the AcroForm in it's current state.\n\n    Also note: getAcroForm() applies a default fixup which this processor\n    is part of. So keep the null parameter otherwise this will end\n    in an endless recursive call\n     */\n    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm(null);\n    if (acroForm != null) {\n        verifyOrCreateDefaults(acroForm);\n    }\n}", "/**\n * This will get the document CATALOG. This is guaranteed to not return null.\n *\n * @return The documents /Root dictionary\n */\npublic PDDocumentCatalog getDocumentCatalog() {\n    if (documentCatalog == null) {\n        COSDictionary trailer = document.getTrailer();\n        COSDictionary dictionary = trailer.getCOSDictionary(COSName.ROOT);\n        if (dictionary != null) {\n            documentCatalog = new PDDocumentCatalog(this, dictionary);\n        } else {\n            documentCatalog = new PDDocumentCatalog(this);\n        }\n    }\n    return documentCatalog;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDDictionaryWrapper.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDDictionaryWrapper.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor\n */\npublic PDDictionaryWrapper() {\n    this.dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.DCTFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.DCTFilter.decode", "org.apache.pdfbox.filter.DCTFilter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException {\n    ImageReader reader = findRasterReader(\"JPEG\", \"a suitable JAI I/O image filter is not installed\");\n    try (ImageInputStream iis = ImageIO.createImageInputStream(encoded)) {\n        // skip one LF if there\n        if (iis.read() != 0xa) {\n            iis.seek(0);\n        }\n        reader.setInput(iis);\n        ImageReadParam irp = reader.getDefaultReadParam();\n        irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());\n        irp.setSourceRegion(options.getSourceRegion());\n        options.setFilterSubsampled(true);\n        Raster raster = readImageRaster(reader, irp);\n        // special handling for 4-component images\n        if (raster.getNumBands() == 4) {\n            // get APP14 marker\n            Integer transform;\n            try {\n                transform = getAdobeTransform(reader.getImageMetadata(0));\n            } catch (IIOException | NegativeArraySizeException e) {\n                // we really tried asking nicely, now we're using brute force.\n                LOG.debug(\"Couldn't read usÃ­ng getAdobeTransform() - using getAdobeTransformByBruteForce() as fallback\", e);\n                transform = getAdobeTransformByBruteForce(iis);\n            }\n            int colorTransform = (transform != null) ? transform : 0;\n            // 0 = Unknown (RGB or CMYK), 1 = YCbCr, 2 = YCCK\n            // https://exiftool.org/TagNames/JPEG.html#Adobe\n            switch (colorTransform) {\n                case 0 :\n                    // already CMYK\n                    break;\n                case 1 :\n                    LOG.warn(\"There is no 4 channel YCbCr, using YCCK\");\n                    // fallthrough\n                case 2 :\n                    raster = fromYCCKtoCMYK(raster);\n                    break;\n                default :\n                    throw new IllegalArgumentException(\"Unknown colorTransform\");\n            }\n        } else if (raster.getNumBands() == 3) {\n            // BGR to RGB\n            raster = fromBGRtoRGB(raster);\n        }\n        DataBufferByte dataBuffer = ((DataBufferByte) (raster.getDataBuffer()));\n        decoded.write(dataBuffer.getData());\n    } catch (CMMException ex) {\n        // PDFBOX-5732\n        throw new IOException(ex);\n    } finally {\n        reader.dispose();\n    }\n    return new DecodeResult(parameters);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded and subset into a document as a Type 0 font. If you are loading a\n * font for AcroForm, then use the 3-parameter constructor instead.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param file\n * \t\tA TrueType font.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font file.\n */\npublic static PDType0Font load(PDDocument doc, File file) throws IOException {\n    return load(doc, new RandomAccessReadBufferedFile(file), true, false);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFOptionElement.setOption",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFOptionElement.setOption", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the string for an available option.\n *\n * @param opt\n * \t\tOne of the available options.\n */\npublic void setOption(String opt) {\n    option.set(0, new COSString(opt));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.setBaseState",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.setBaseState", "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.getD", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the base state for optional content groups.\n *\n * @param state\n * \t\tthe base state\n */\npublic void setBaseState(BaseState state) {\n    COSDictionary d = getD();\n    d.setItem(COSName.BASE_STATE, state.getName());\n}", "/**\n * Return the the /D dictionary.\n *\n * @return the /D dictionary, never null.\n */\nprivate COSDictionary getD() {\n    COSDictionary d = dict.getCOSDictionary(COSName.D);\n    if (d == null) {\n        d = new COSDictionary();\n        // Name optional but required for PDF/A-3\n        d.setString(COSName.NAME, \"Top\");\n        // D is required\n        dict.setItem(COSName.D, d);\n    }\n    return d;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationText.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationText.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDTextAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDTextAppearanceHandler appearanceHandler = new PDTextAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.showText",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.showText", "org.apache.pdfbox.pdmodel.PDAbstractContentStream.showTextInternal", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * Shows the given text at the location specified by the current text matrix.\n *\n * @param text\n * \t\tThe Unicode text to show.\n * @throws IOException\n * \t\tIf an io exception occurs.\n * @throws IllegalArgumentException\n * \t\tif a character isn't supported by the current font\n */\npublic void showText(String text) throws IOException {\n    showTextInternal(text);\n    write(\" \");\n    writeOperator(OperatorName.SHOW_TEXT);\n}", "/**\n * Outputs a string using the correct encoding and subsetting as required.\n *\n * @param text\n * \t\tThe Unicode text to show.\n * @throws IOException\n * \t\tIf an io exception occurs.\n */\nprotected void showTextInternal(String text) throws IOException {\n    if (!inTextMode) {\n        throw new IllegalStateException(\"Must call beginText() before showText()\");\n    }\n    if (fontStack.isEmpty()) {\n        throw new IllegalStateException(\"Must call setFont() before showText()\");\n    }\n    PDFont font = fontStack.peek();\n    // complex text layout\n    byte[] encodedText = null;\n    if (font instanceof PDType0Font) {\n        GsubWorker gsubWorker = gsubWorkers.get(font);\n        if (gsubWorker != null) {\n            PDType0Font type0Font = ((PDType0Font) (font));\n            Set<Integer> glyphIds = new HashSet<>();\n            encodedText = encodeForGsub(gsubWorker, glyphIds, type0Font, text);\n            if (type0Font.willBeSubset()) {\n                type0Font.addGlyphsToSubset(glyphIds);\n            }\n        }\n    }\n    if (encodedText == null) {\n        encodedText = font.encode(text);\n    }\n    // Unicode code points to keep when subsetting\n    if (font.willBeSubset()) {\n        int offset = 0;\n        while (offset < text.length()) {\n            int codePoint = text.codePointAt(offset);\n            font.addToSubset(codePoint);\n            offset += Character.charCount(codePoint);\n        } \n    }\n    COSWriter.writeString(encodedText, outputStream);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.writeReference",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.writeReference", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * visitFromObjRef method comment.\n *\n * @param obj\n * \t\tThe object that is being visited.\n * @throws IOException\n * \t\tIf there is an exception while visiting this object.\n */\npublic void writeReference(COSBase obj) throws IOException {\n    COSObjectKey key = getObjectKey(obj);\n    getStandardOutput().write(String.valueOf(key.getNumber()).getBytes(StandardCharsets.ISO_8859_1));\n    getStandardOutput().write(SPACE);\n    getStandardOutput().write(String.valueOf(key.getGeneration()).getBytes(StandardCharsets.ISO_8859_1));\n    getStandardOutput().write(SPACE);\n    getStandardOutput().write(REFERENCE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageFormResources",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageFormResources", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createImageFormResources() {\n    PDResources imageFormResources = new PDResources();\n    pdfStructure.setImageFormResources(imageFormResources);\n    LOG.info(\"Created image form resources\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDNonTerminalField.getChildren",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDNonTerminalField.getChildren", "org.apache.pdfbox.pdmodel.interactive.form.PDNonTerminalField.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns this field's children. These may be either terminal or non-terminal fields.\n *\n * @return the list of child fields. Be aware that this list is <i>not</i> backed by the\nchildren of the field, so adding or deleting has no effect on the PDF document until you call\n{@link #setChildren(java.util.List) setChildren()} with the modified list.\n */\npublic List<PDField> getChildren() {\n    // TODO: why not return a COSArrayList like in PDPage.getAnnotations() ?\n    List<PDField> children = new ArrayList<>();\n    COSArray kids = getCOSObject().getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        return children;\n    }\n    for (int i = 0; i < kids.size(); i++) {\n        COSBase kid = kids.getObject(i);\n        if (kid instanceof COSDictionary) {\n            if (kid.getCOSObject() == this.getCOSObject()) {\n                LOG.warn(\"Child field is same object as parent\");\n                continue;\n            }\n            PDField field = PDField.fromDictionary(getAcroForm(), ((COSDictionary) (kid)), this);\n            if (field != null) {\n                children.add(field);\n            }\n        }\n    }\n    return children;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup", "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroupOnGraphics", "org.apache.pdfbox.rendering.PageDrawer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void showTransparencyGroup(PDTransparencyGroup form) throws IOException {\n    showTransparencyGroupOnGraphics(form, graphics);\n}", "/**\n * For advanced users, to extract the transparency group into a separate graphics device.\n *\n * @param form\n * \t\tthe transparency group to be extracted\n * @param graphics\n * \t\tthe target graphics device\n * @throws IOException\n * \t\tif the transparency group could not be extracted\n */\nprotected void showTransparencyGroupOnGraphics(PDTransparencyGroup form, Graphics2D graphics) throws IOException {\n    if (isHiddenOCG(form.getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    TransparencyGroup group = new TransparencyGroup(form, false, getGraphicsState().getCurrentTransformationMatrix(), null);\n    BufferedImage image = group.getImage();\n    if (image == null) {\n        // image is empty, don't bother\n        return;\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    // both the DPI xform and the CTM were already applied to the group, so all we do\n    // here is draw it directly onto the Graphics2D device at the appropriate position\n    AffineTransform savedTransform = graphics.getTransform();\n    AffineTransform transform = new AffineTransform(xform);\n    transform.scale(1.0 / xformScalingFactorX, 1.0 / xformScalingFactorY);\n    graphics.setTransform(transform);\n    // adjust bbox (x,y) position at the initial scale + cropbox\n    PDRectangle bbox = group.getBBox();\n    float x = bbox.getLowerLeftX() - pageSize.getLowerLeftX();\n    float y = pageSize.getUpperRightY() - bbox.getUpperRightY();\n    if (flipTG) {\n        graphics.translate(0, image.getHeight());\n        graphics.scale(1, -1);\n    } else {\n        graphics.translate(x * xformScalingFactorX, y * xformScalingFactorY);\n    }\n    PDSoftMask softMask = getGraphicsState().getSoftMask();\n    if (softMask != null) {\n        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Float(0, 0, image.getWidth(), image.getHeight()));\n        awtPaint = applySoftMaskToPaint(awtPaint, softMask);\n        graphics.setPaint(awtPaint);\n        graphics.fill(new Rectangle2D.Float(0, 0, bbox.getWidth() * xformScalingFactorX, bbox.getHeight() * xformScalingFactorY));\n    } else {\n        try {\n            graphics.drawImage(image, null, null);\n        } catch (InternalError ie) {\n            LOG.error(\"Exception drawing image, see JDK-6689349, \" + \"try rendering into a BufferedImage instead\", ie);\n        }\n    }\n    graphics.setTransform(savedTransform);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeOwnerPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeOwnerPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.truncateOrPad", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * Compute the owner entry in the encryption dictionary.\n *\n * @param ownerPassword\n * \t\tThe plaintext owner password.\n * @param userPassword\n * \t\tThe plaintext user password.\n * @param encRevision\n * \t\tThe revision number of the encryption algorithm.\n * @param length\n * \t\tThe length of the encryption key.\n * @return The o entry of the encryption dictionary.\n * @throws IOException\n * \t\tif the owner password could not be computed\n */\npublic byte[] computeOwnerPassword(byte[] ownerPassword, byte[] userPassword, int encRevision, int length) throws IOException {\n    if ((REVISION_2 == encRevision) && (length != 5)) {\n        throw new IOException(\"Expected length=5 actual=\" + length);\n    }\n    byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);\n    byte[] paddedUser = truncateOrPad(userPassword);\n    ByteArrayOutputStream encrypted = new ByteArrayOutputStream();\n    encryptDataRC4(rc4Key, new ByteArrayInputStream(paddedUser), encrypted);\n    if ((encRevision == REVISION_3) || (encRevision == REVISION_4)) {\n        byte[] iterationKey = new byte[rc4Key.length];\n        for (int i = 1; i < 20; i++) {\n            System.arraycopy(rc4Key, 0, iterationKey, 0, rc4Key.length);\n            for (int j = 0; j < iterationKey.length; j++) {\n                iterationKey[j] = ((byte) (iterationKey[j] ^ ((byte) (i))));\n            }\n            ByteArrayInputStream input = new ByteArrayInputStream(encrypted.toByteArray());\n            encrypted.reset();\n            encryptDataRC4(iterationKey, input, encrypted);\n        }\n    }\n    return encrypted.toByteArray();\n}", "/**\n * This will take the password and truncate or pad it as necessary.\n *\n * @param password\n * \t\tThe password to pad or truncate.\n * @return The padded or truncated password.\n */\nprivate byte[] truncateOrPad(byte[] password) {\n    byte[] padded = new byte[ENCRYPT_PADDING.length];\n    int bytesBeforePad = Math.min(password.length, padded.length);\n    System.arraycopy(password, 0, padded, 0, bytesBeforePad);\n    System.arraycopy(ENCRYPT_PADDING, 0, padded, bytesBeforePad, ENCRYPT_PADDING.length - bytesBeforePad);\n    return padded;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.COSArrayList.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.COSArrayList.add", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic boolean add(E o) {\n    // when adding if there is a parentDict then change the item\n    // in the dictionary from a single item to an array.\n    if (parentDict != null) {\n        parentDict.setItem(dictKey, array);\n        // clear the parent dict so it doesn't happen again, there might be\n        // a usecase for keeping the parentDict around but not now.\n        parentDict = null;\n    }\n    // string is a special case because we can't subclass to be COSObjectable\n    if (o instanceof String) {\n        array.add(new COSString(((String) (o))));\n    } else if (array != null) {\n        array.add(((COSObjectable) (o)).getCOSObject());\n    }\n    return actual.add(o);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.protect",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.protect", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Protects the document with a protection policy. The document content will be really\n * encrypted when it will be saved. This method only marks the document for encryption. It also\n * calls {@link #setAllSecurityToBeRemoved(boolean)} with a false argument if it was set to true\n * previously and logs a warning.\n * <p>\n * Do not use the document after saving, because the structures are encrypted.\n * The same applies if your file was created from parts of another file and that\n * one is to be used after saving.\n *\n * @see org.apache.pdfbox.pdmodel.encryption.StandardProtectionPolicy\n * @see org.apache.pdfbox.pdmodel.encryption.PublicKeyProtectionPolicy\n * @param policy\n * \t\tThe protection policy.\n * @throws IOException\n * \t\tif there isn't any suitable security handler.\n */\npublic void protect(ProtectionPolicy policy) throws IOException {\n    if (isAllSecurityToBeRemoved()) {\n        LOG.warn(\"do not call setAllSecurityToBeRemoved(true) before calling protect(), \" + \"as protect() implies setAllSecurityToBeRemoved(false)\");\n        setAllSecurityToBeRemoved(false);\n    }\n    if (!isEncrypted()) {\n        encryption = new PDEncryption();\n    }\n    SecurityHandler<ProtectionPolicy> securityHandler = SecurityHandlerFactory.INSTANCE.newSecurityHandlerForPolicy(policy);\n    if (securityHandler == null) {\n        throw new IOException(\"No security handler for policy \" + policy);\n    }\n    getEncryption().setSecurityHandler(securityHandler);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.createInputStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.createInputStream", "org.apache.pdfbox.filter.ASCIIHexFilter.decode", "org.apache.pdfbox.filter.ASCIIHexFilter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic InputStream createInputStream(List<String> stopFilters) throws IOException {\n    List<String> filters = getFilters();\n    ByteArrayInputStream in = new ByteArrayInputStream(rawData);\n    ByteArrayOutputStream out = new ByteArrayOutputStream(rawData.length);\n    for (int i = 0; i < filters.size(); i++) {\n        if (stopFilters.contains(filters.get(i))) {\n            break;\n        }\n        // TODO handling of abbreviated names belongs here, rather than in other classes\n        Filter filter = FilterFactory.INSTANCE.getFilter(filters.get(i));\n        out.reset();\n        filter.decode(in, out, parameters, i);\n        in = new ByteArrayInputStream(out.toByteArray());\n    }\n    return in;\n}", "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    int value;\n    int firstByte;\n    int secondByte;\n    while ((firstByte = encoded.read()) != (-1)) {\n        // always after first char\n        while (isWhitespace(firstByte)) {\n            firstByte = encoded.read();\n        } \n        if ((firstByte == (-1)) || isEOD(firstByte)) {\n            break;\n        }\n        if (REVERSE_HEX[firstByte] == (-1)) {\n            LOG.error(((\"Invalid hex, int: \" + firstByte) + \" char: \") + ((char) (firstByte)));\n        }\n        value = REVERSE_HEX[firstByte] * 16;\n        secondByte = encoded.read();\n        if ((secondByte == (-1)) || isEOD(secondByte)) {\n            // second value behaves like 0 in case of EOD\n            decoded.write(value);\n            break;\n        }\n        if (REVERSE_HEX[secondByte] == (-1)) {\n            LOG.error(((\"Invalid hex, int: \" + secondByte) + \" char: \") + ((char) (secondByte)));\n        }\n        value += REVERSE_HEX[secondByte];\n        decoded.write(value);\n    } \n    decoded.flush();\n    return new DecodeResult(parameters);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDFTemplateCreator.buildPDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDFTemplateCreator.buildPDF", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDFTemplateCreator.<clinit>" ],
    "fullMethods" : [ "/**\n * Build a PDF with a visible signature step by step, and return it as a stream.\n *\n * @param properties\n * \t\tproperties to be used for the creation\n * @return InputStream stream containing the pdf holding the visible signature\n * @throws IOException\n * \t\tif the PDF could not be created\n */\npublic InputStream buildPDF(PDVisibleSignDesigner properties) throws IOException {\n    LOG.info(\"pdf building has been started\");\n    PDFTemplateStructure pdfStructure = pdfBuilder.getStructure();\n    // we create array of [Text, ImageB, ImageC, ImageI]\n    pdfBuilder.createProcSetArray();\n    // create page\n    pdfBuilder.createPage(properties);\n    PDPage page = pdfStructure.getPage();\n    // create template\n    pdfBuilder.createTemplate(page);\n    try (PDDocument template = pdfStructure.getTemplate()) {\n        // create /AcroForm\n        pdfBuilder.createAcroForm(template);\n        PDAcroForm acroForm = pdfStructure.getAcroForm();\n        // AcroForm contains signature fields\n        pdfBuilder.createSignatureField(acroForm);\n        PDSignatureField pdSignatureField = pdfStructure.getSignatureField();\n        // create signature\n        // TODO\n        // The line below has no effect with the CreateVisibleSignature example.\n        // The signature field is needed as a \"holder\" for the /AP tree,\n        // but the /P and /V PDSignatureField entries are ignored by PDDocument.addSignature\n        pdfBuilder.createSignature(pdSignatureField, page, \"\");\n        // that is /AcroForm/DR entry\n        pdfBuilder.createAcroFormDictionary(acroForm, pdSignatureField);\n        // create AffineTransform\n        pdfBuilder.createAffineTransform(properties.getTransform());\n        AffineTransform transform = pdfStructure.getAffineTransform();\n        // rectangle, formatter, image. /AcroForm/DR/XObject contains that form\n        pdfBuilder.createSignatureRectangle(pdSignatureField, properties);\n        pdfBuilder.createFormatterRectangle(properties.getFormatterRectangleParameters());\n        PDRectangle bbox = pdfStructure.getFormatterRectangle();\n        pdfBuilder.createSignatureImage(template, properties.getImage());\n        // create form stream, form and  resource.\n        pdfBuilder.createHolderFormStream(template);\n        PDStream holderFormStream = pdfStructure.getHolderFormStream();\n        pdfBuilder.createHolderFormResources();\n        PDResources holderFormResources = pdfStructure.getHolderFormResources();\n        pdfBuilder.createHolderForm(holderFormResources, holderFormStream, bbox);\n        // that is /AP entry the appearance dictionary.\n        pdfBuilder.createAppearanceDictionary(pdfStructure.getHolderForm(), pdSignatureField);\n        // inner form stream, form and resource (holder form contains inner form)\n        pdfBuilder.createInnerFormStream(template);\n        pdfBuilder.createInnerFormResource();\n        PDResources innerFormResource = pdfStructure.getInnerFormResources();\n        pdfBuilder.createInnerForm(innerFormResource, pdfStructure.getInnerFormStream(), bbox);\n        PDFormXObject innerForm = pdfStructure.getInnerForm();\n        // inner form must be in the holder form as we wrote\n        pdfBuilder.insertInnerFormToHolderResources(innerForm, holderFormResources);\n        // Image form is in this structure: /AcroForm/DR/FRM/Resources/XObject/n2\n        pdfBuilder.createImageFormStream(template);\n        PDStream imageFormStream = pdfStructure.getImageFormStream();\n        pdfBuilder.createImageFormResources();\n        PDResources imageFormResources = pdfStructure.getImageFormResources();\n        pdfBuilder.createImageForm(imageFormResources, innerFormResource, imageFormStream, bbox, transform, pdfStructure.getImage());\n        pdfBuilder.createBackgroundLayerForm(innerFormResource, bbox);\n        // now inject procSetArray\n        pdfBuilder.injectProcSetArray(innerForm, page, innerFormResource, imageFormResources, holderFormResources, pdfStructure.getProcSet());\n        COSName imageFormName = pdfStructure.getImageFormName();\n        COSName imageName = pdfStructure.getImageName();\n        COSName innerFormName = pdfStructure.getInnerFormName();\n        // now create Streams of AP\n        pdfBuilder.injectAppearanceStreams(holderFormStream, imageFormStream, imageFormStream, imageFormName, imageName, innerFormName, properties);\n        pdfBuilder.createVisualSignature(template);\n        pdfBuilder.createWidgetDictionary(pdSignatureField, holderFormResources);\n        InputStream in = getVisualSignatureAsStream(pdfStructure.getVisualSignature());\n        LOG.info(\"stream returning started, size= \" + in.available());\n        // return result of the stream\n        return in;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getStrokingJavaComposite",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getStrokingJavaComposite", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.<clinit>" ],
    "fullMethods" : [ "public Composite getStrokingJavaComposite() {\n    return BlendComposite.getInstance(blendMode, ((float) (alphaConstant)));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareForDecryption",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareForDecryption", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * Prepares everything to decrypt the document.\n *\n * Only if decryption of single objects is needed this should be called.\n *\n * @param encryption\n * \t\tencryption dictionary\n * @param documentIDArray\n * \t\tdocument id\n * @param decryptionMaterial\n * \t\tInformation used to decrypt the document.\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\n@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException {\n    if (!(decryptionMaterial instanceof StandardDecryptionMaterial)) {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    // This is only used with security version 4 and 5.\n    if (encryption.getVersion() >= REVISION_4) {\n        setStreamFilterName(encryption.getStreamFilterName());\n        setStringFilterName(encryption.getStringFilterName());\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = ((StandardDecryptionMaterial) (decryptionMaterial));\n    String password = material.getPassword();\n    if (password == null) {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = (encryption.getVersion() == 1) ? 5 : encryption.getLength() / 8;\n    if ((encryption.getVersion() == REVISION_4) || (encryption.getVersion() == REVISION_5)) {\n        // detect whether AES encryption is used. This assumes that the encryption algo is\n        // stored in the PDCryptFilterDictionary\n        // However, crypt filters are used only when V is 4 or 5.\n        PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n        if (stdCryptFilterDictionary != null) {\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            if (COSName.AESV2.equals(cryptFilterMethod)) {\n                dicLength = 128 / 8;\n                setAES(true);\n                if (encryption.getCOSObject().containsKey(COSName.LENGTH)) {\n                    // PDFBOX-5345\n                    int newLength = encryption.getLength() / 8;\n                    if (newLength < dicLength) {\n                        LOG.warn((((\"Using \" + newLength) + \" bytes key length instead of \") + dicLength) + \" in AESV2 encryption?!\");\n                        dicLength = newLength;\n                    }\n                }\n            }\n            if (COSName.AESV3.equals(cryptFilterMethod)) {\n                dicLength = 256 / 8;\n                setAES(true);\n                if (encryption.getCOSObject().containsKey(COSName.LENGTH)) {\n                    // PDFBOX-5345\n                    int newLength = encryption.getLength() / 8;\n                    if (newLength < dicLength) {\n                        LOG.warn((((\"Using \" + newLength) + \" bytes key length instead of \") + dicLength) + \" in AESV3 encryption?!\");\n                        dicLength = newLength;\n                    }\n                }\n            }\n        }\n    }\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    // we need to know whether the meta data was encrypted for password calculation\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null;\n    byte[] oe = null;\n    Charset passwordCharset = StandardCharsets.ISO_8859_1;\n    if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n        passwordCharset = StandardCharsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    if (dicRevision == REVISION_6) {\n        password = SaslPrep.saslPrepQuery(password);// PDFBOX-4155\n\n    }\n    AccessPermission currentAccessPermission;\n    byte[] encryptedKey;\n    byte[] passwordBytes;\n    boolean isOwnerPassword;\n    if (isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n            passwordBytes = password.getBytes(passwordCharset);\n        } else {\n            passwordBytes = getUserPassword234(password.getBytes(passwordCharset), ownerKey, dicRevision, dicLength);\n        }\n        isOwnerPassword = true;\n    } else if (isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {\n        currentAccessPermission = new AccessPermission(dicPermissions);\n        currentAccessPermission.setReadOnly();\n        setCurrentAccessPermission(currentAccessPermission);\n        passwordBytes = password.getBytes(passwordCharset);\n        isOwnerPassword = false;\n    } else {\n        throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n    }\n    encryptedKey = computeEncryptedKey(passwordBytes, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, isOwnerPassword);\n    if ((dicRevision == REVISION_4) && (encryptedKey.length < 16)) {\n        LOG.info(\"PDFBOX-5955: padding RC4 key to length 16\");\n        encryptedKey = Arrays.copyOf(encryptedKey, 16);\n    }\n    setEncryptionKey(encryptedKey);\n    if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n        validatePerms(encryption, dicPermissions, encryptMetadata);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.getDate",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.getDate", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * This is a convenience method that will get the dictionary object that is expected to be a name and convert it to\n * a string. Null is returned if the entry does not exist in the dictionary or if the date was invalid.\n *\n * @param key\n * \t\tThe key to the item in the dictionary.\n * @return The name converted to a date.\n */\npublic Calendar getDate(COSName key) {\n    COSBase base = getDictionaryObject(key);\n    if (base instanceof COSString) {\n        return DateConverter.toCalendar(((COSString) (base)));\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.LayerUtility.importPageAsForm",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.LayerUtility.importPageAsForm", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Imports a page from some PDF file as a Form XObject so it can be placed on another page\n * in the target document.\n * <p>\n * You may want to call {@link #wrapInSaveRestore(PDPage) wrapInSaveRestore(PDPage)} before invoking the Form XObject to\n * make sure that the graphics state is reset.\n *\n * @param sourceDoc\n * \t\tthe source PDF document that contains the page to be copied\n * @param page\n * \t\tthe page in the source PDF document to be copied\n * @return a Form XObject containing the original page's content\n * @throws IOException\n * \t\tif an I/O error occurs\n */\npublic PDFormXObject importPageAsForm(PDDocument sourceDoc, PDPage page) throws IOException {\n    importOcProperties(sourceDoc);\n    PDStream newStream = new PDStream(targetDoc, page.getContents(), COSName.FLATE_DECODE);\n    PDFormXObject form = new PDFormXObject(newStream);\n    // Copy resources\n    PDResources pageRes = page.getResources();\n    PDResources formRes = new PDResources();\n    cloner.cloneMerge(pageRes, formRes);\n    form.setResources(formRes);\n    // Transfer some values from page to form\n    transferDict(page.getCOSObject(), form.getCOSObject(), PAGE_TO_FORM_FILTER);\n    Matrix matrix = form.getMatrix();\n    AffineTransform at = matrix.createAffineTransform();\n    PDRectangle mediaBox = page.getMediaBox();\n    PDRectangle cropBox = page.getCropBox();\n    PDRectangle viewBox = (cropBox != null) ? cropBox : mediaBox;\n    // Handle the /Rotation entry on the page dict\n    int rotation = page.getRotation();\n    // Transform to FOP's user space\n    // at.scale(1 / viewBox.getWidth(), 1 / viewBox.getHeight());\n    at.translate(mediaBox.getLowerLeftX() - viewBox.getLowerLeftX(), mediaBox.getLowerLeftY() - viewBox.getLowerLeftY());\n    switch (rotation) {\n        case 90 :\n            at.scale(viewBox.getWidth() / viewBox.getHeight(), viewBox.getHeight() / viewBox.getWidth());\n            at.translate(0, viewBox.getWidth());\n            at.quadrantRotate(3);// 270\n\n            break;\n        case 180 :\n            at.translate(viewBox.getWidth(), viewBox.getHeight());\n            at.quadrantRotate(2);// 180\n\n            break;\n        case 270 :\n            at.scale(viewBox.getWidth() / viewBox.getHeight(), viewBox.getHeight() / viewBox.getWidth());\n            at.translate(viewBox.getHeight(), 0);\n            at.quadrantRotate(1);// 90\n\n            break;\n        default :\n            // no additional transformations necessary\n    }\n    // Compensate for Crop Boxes not starting at 0,0\n    at.translate(-viewBox.getLowerLeftX(), -viewBox.getLowerLeftY());\n    if (!at.isIdentity()) {\n        form.setMatrix(at);\n    }\n    BoundingBox bbox = new BoundingBox();\n    bbox.setLowerLeftX(viewBox.getLowerLeftX());\n    bbox.setLowerLeftY(viewBox.getLowerLeftY());\n    bbox.setUpperRightX(viewBox.getUpperRightX());\n    bbox.setUpperRightY(viewBox.getUpperRightY());\n    form.setBBox(new PDRectangle(bbox));\n    return form;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadPDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadPDF", "org.apache.pdfbox.pdfparser.PDFParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Parses a PDF.\n *\n * @param randomAccessRead\n * \t\trandom access read representing the pdf to be loaded. To pass an\n * \t\tInputStream, wrap it into a {@link RandomAccessReadBuffer}.\n * @param password\n * \t\tpassword to be used for decryption\n * @param keyStore\n * \t\tkey store to be used for decryption when using public key security\n * @param alias\n * \t\talias to be used for decryption when using public key security\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache to be used for buffering\n * \t\tnew/altered PDF streams\n * @return loaded document\n * @throws IOException\n * \t\tin case of a file reading or parsing error\n */\npublic static PDDocument loadPDF(RandomAccessRead randomAccessRead, String password, InputStream keyStore, String alias, StreamCacheCreateFunction streamCacheCreateFunction) throws IOException {\n    PDFParser parser = new PDFParser(randomAccessRead, password, keyStore, alias, streamCacheCreateFunction);\n    return parser.parse();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.setEmbeddedFile",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.setEmbeddedFile", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the embedded file for this spec. You should also call\n * {@link #setEmbeddedFileUnicode(org.apache.pdfbox.pdmodel.common.filespecification.PDEmbeddedFile) setEmbeddedFileUnicode(PDEmbeddedFile)}\n * for cross-platform and cross-language compatibility.\n *\n * @param file\n * \t\tThe file to be embedded.\n */\npublic void setEmbeddedFile(PDEmbeddedFile file) {\n    COSDictionary ef = getEFDictionary();\n    if ((ef == null) && (file != null)) {\n        ef = new COSDictionary();\n        fs.setItem(COSName.EF, ef);\n    }\n    if (ef != null) {\n        ef.setItem(COSName.F, file);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getValue", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * The name to retrieve.\n *\n * @param name\n * \t\tThe name in the tree.\n * @return The value of the name in the tree.\n * @throws IOException\n * \t\tIf there is a problem creating the destinations.\n */\npublic T getValue(String name) throws IOException {\n    Map<String, T> names = getNames();\n    if (names != null) {\n        return names.get(name);\n    }\n    List<PDNameTreeNode<T>> kids = getKids();\n    if (kids != null) {\n        for (int i = 0; i < kids.size(); i++) {\n            PDNameTreeNode<T> childNode = kids.get(i);\n            String upperLimit = childNode.getUpperLimit();\n            String lowerLimit = childNode.getLowerLimit();\n            if ((((upperLimit == null) || (lowerLimit == null)) || (upperLimit.compareTo(lowerLimit) < 0)) || ((lowerLimit.compareTo(name) <= 0) && (upperLimit.compareTo(name) >= 0))) {\n                return childNode.getValue(name);\n            }\n        }\n    } else {\n        LOG.warn(\"NameTreeNode does not have \\\"names\\\" nor \\\"kids\\\" objects.\");\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings", "org.apache.pdfbox.contentstream.PDFStreamEngine.<clinit>" ],
    "fullMethods" : [ "/**\n * Called when a string of text with spacing adjustments is to be shown.\n *\n * @param array\n * \t\tarray of encoded text strings and adjustments\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextStrings(COSArray array) throws IOException {\n    PDTextState textState = getGraphicsState().getTextState();\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    PDFont font = textState.getFont();\n    boolean isVertical = false;\n    if (font != null) {\n        isVertical = font.isVertical();\n    }\n    for (COSBase obj : array) {\n        if (obj instanceof COSNumber) {\n            float tj = ((COSNumber) (obj)).floatValue();\n            // calculate the combined displacements\n            float tx;\n            float ty;\n            if (isVertical) {\n                tx = 0;\n                ty = ((-tj) / 1000) * fontSize;\n            } else {\n                tx = (((-tj) / 1000) * fontSize) * horizontalScaling;\n                ty = 0;\n            }\n            applyTextAdjustment(tx, ty);\n        } else if (obj instanceof COSString) {\n            byte[] string = ((COSString) (obj)).getBytes();\n            showText(string);\n        } else if (obj instanceof COSArray) {\n            LOG.error(\"Nested arrays are not allowed in an array for TJ operation: \" + obj);\n        } else {\n            LOG.error(((\"Unknown type \" + obj.getClass().getSimpleName()) + \" in array for TJ operation: \") + obj);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSStream.close",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSStream.close", "org.apache.pdfbox.cos.COSStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void close() throws IOException {\n    super.close();\n    setInt(COSName.LENGTH, ((int) (randomAccess.length())));\n    isWriting = false;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType3.toPaint",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType3.toPaint", "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Paint toPaint(Matrix matrix) {\n    return new RadialShadingPaint(this, matrix);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageForm",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageForm", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createImageForm(PDResources imageFormResources, PDResources innerFormResource, PDStream imageFormStream, PDRectangle bbox, AffineTransform at, PDImageXObject img) throws IOException {\n    PDFormXObject imageForm = new PDFormXObject(imageFormStream);\n    imageForm.setBBox(bbox);\n    imageForm.setMatrix(at);\n    imageForm.setResources(imageFormResources);\n    imageForm.setFormType(1);\n    imageFormResources.getCOSObject().setDirect(true);\n    COSName imageFormName = COSName.getPDFName(\"n2\");\n    innerFormResource.put(imageFormName, imageForm);\n    COSName imageName = imageFormResources.add(img, \"img\");\n    pdfStructure.setImageForm(imageForm);\n    pdfStructure.setImageFormName(imageFormName);\n    pdfStructure.setImageName(imageName);\n    LOG.info(\"Created image form\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<init>", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.loadList", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new GlyphList from a glyph list file.\n *\n * @param numberOfEntries\n * \t\tnumber of expected values used to preallocate the correct amount of memory\n * @param input\n * \t\tglyph list in Adobe format\n * @throws IOException\n * \t\tif the glyph list could not be read\n */\npublic GlyphList(InputStream input, int numberOfEntries) throws IOException {\n    nameToUnicode = new HashMap<>(numberOfEntries);\n    unicodeToName = new HashMap<>(numberOfEntries);\n    loadList(input);\n}", "private void loadList(InputStream input) throws IOException {\n    try (BufferedReader in = new BufferedReader(new InputStreamReader(input, StandardCharsets.ISO_8859_1))) {\n        while (in.ready()) {\n            String line = in.readLine();\n            if ((line != null) && (!line.startsWith(\"#\"))) {\n                String[] parts = line.split(\";\");\n                if (parts.length < 2) {\n                    throw new IOException(\"Invalid glyph list entry: \" + line);\n                }\n                String name = parts[0];\n                String[] unicodeList = parts[1].split(\" \");\n                int[] codePoints = new int[unicodeList.length];\n                int index = 0;\n                for (String hex : unicodeList) {\n                    codePoints[index++] = Integer.parseInt(hex, 16);\n                }\n                String string = new String(codePoints, 0, codePoints.length);\n                // forward mapping\n                String oldMapping = nameToUnicode.put(name, string);\n                if (oldMapping != null) {\n                    LOG.warn(((((\"duplicate value for \" + name) + \" -> \") + parts[1]) + \" \") + nameToUnicode.get(name));\n                }\n                // reverse mapping\n                // PDFBOX-3884: take the various standard encodings as canonical,\n                // e.g. tilde over ilde\n                final boolean forceOverride = (((WinAnsiEncoding.INSTANCE.contains(name) || MacRomanEncoding.INSTANCE.contains(name)) || MacExpertEncoding.INSTANCE.contains(name)) || SymbolEncoding.INSTANCE.contains(name)) || ZapfDingbatsEncoding.INSTANCE.contains(name);\n                if (forceOverride) {\n                    unicodeToName.put(string, name);\n                } else {\n                    unicodeToName.putIfAbsent(string, name);\n                }\n            }\n        } \n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureElement.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureElement.<init>", "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureNode.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor with required values.\n *\n * @param structureType\n * \t\tThe structure type. Constants are available in the\n * \t\t{@link StandardStructureTypes} class.\n * @param parent\n * \t\tThe parent structure node.\n */\npublic PDStructureElement(String structureType, PDStructureNode parent) {\n    super(TYPE);\n    this.setStructureType(structureType);\n    this.setParent(parent);\n}", "/**\n * Constructor.\n *\n * @param type\n * \t\tthe type\n */\nprotected PDStructureNode(String type) {\n    this.dictionary = new COSDictionary();\n    this.dictionary.setName(COSName.TYPE, type);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken", "org.apache.pdfbox.pdfparser.PDFStreamParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will parse the next token in the stream.\n *\n * @return The next token in the stream or null if there are no more tokens in the stream.\n * @throws IOException\n * \t\tIf an io error occurs while parsing the stream.\n */\npublic Object parseNextToken() throws IOException {\n    if (source.isClosed()) {\n        return null;\n    }\n    skipSpaces();\n    if (source.isEOF()) {\n        close();\n        return null;\n    }\n    char c = ((char) (source.peek()));\n    switch (c) {\n        case '<' :\n            // pull off first left bracket\n            source.read();\n            // check for second left bracket\n            c = ((char) (source.peek()));\n            // put back first bracket\n            source.rewind(1);\n            if (c == '<') {\n                try {\n                    return parseCOSDictionary(true);\n                } catch (IOException exception) {\n                    LOG.warn(\"Stop reading invalid dictionary from content stream at offset \" + source.getPosition());\n                    close();\n                    return null;\n                }\n            } else {\n                return parseCOSString();\n            }\n        case '[' :\n            // array\n            try {\n                return parseCOSArray();\n            } catch (IOException exception) {\n                LOG.warn(\"Stop reading invalid array from content stream at offset \" + source.getPosition());\n                close();\n                return null;\n            }\n        case '(' :\n            // string\n            return parseCOSString();\n        case '/' :\n            // name\n            return parseCOSName();\n        case 'n' :\n            // null\n            String nullString = readString();\n            if (nullString.equals(\"null\")) {\n                return COSNull.NULL;\n            } else {\n                return Operator.getOperator(nullString);\n            }\n        case 't' :\n        case 'f' :\n            String next = readString();\n            if (next.equals(\"true\")) {\n                return COSBoolean.TRUE;\n            } else if (next.equals(\"false\")) {\n                return COSBoolean.FALSE;\n            } else {\n                return Operator.getOperator(next);\n            }\n        case '0' :\n        case '1' :\n        case '2' :\n        case '3' :\n        case '4' :\n        case '5' :\n        case '6' :\n        case '7' :\n        case '8' :\n        case '9' :\n        case '-' :\n        case '+' :\n        case '.' :\n            /* We will be filling buf with the rest of the number.  Only\n            allow 1 \".\" and \"-\" and \"+\" at start of number.\n             */\n            StringBuilder buf = new StringBuilder();\n            buf.append(c);\n            source.read();\n            // Ignore double negative (this is consistent with Adobe Reader)\n            if ((c == '-') && (source.peek() == c)) {\n                source.read();\n            }\n            boolean dotNotRead = c != '.';\n            while ((Character.isDigit(c = ((char) (source.peek()))) || (dotNotRead && (c == '.'))) || (c == '-')) {\n                if (c != '-') {\n                    // PDFBOX-4064: ignore \"-\" in the middle of a number\n                    buf.append(c);\n                }\n                source.read();\n                if (dotNotRead && (c == '.')) {\n                    dotNotRead = false;\n                }\n            } \n            String s = buf.toString();\n            if (\"+\".equals(s)) {\n                // PDFBOX-5906\n                LOG.warn(\"isolated '+' is ignored\");\n                return COSNull.NULL;\n            }\n            return COSNumber.get(s);\n        case 'B' :\n            String nextOperator = readString();\n            Operator beginImageOP = Operator.getOperator(nextOperator);\n            if (nextOperator.equals(OperatorName.BEGIN_INLINE_IMAGE)) {\n                inlineImageDepth++;\n                if (inlineImageDepth > 1) {\n                    // PDFBOX-6038\n                    throw new IOException(((((\"Nested '\" + OperatorName.BEGIN_INLINE_IMAGE) + \"' operator not allowed at offset \") + source.getPosition()) + \", first: \") + inlineOffset);\n                } else {\n                    inlineOffset = source.getPosition();\n                }\n                COSDictionary imageParams = new COSDictionary();\n                beginImageOP.setImageParameters(imageParams);\n                Object nextToken = null;\n                while ((nextToken = parseNextToken()) instanceof COSName) {\n                    Object value = parseNextToken();\n                    if (!(value instanceof COSBase)) {\n                        LOG.warn(\"Unexpected token in inline image dictionary at offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                        break;\n                    }\n                    imageParams.setItem(((COSName) (nextToken)), ((COSBase) (value)));\n                } \n                // final token will be the image data, maybe??\n                if (nextToken instanceof Operator) {\n                    Operator imageData = ((Operator) (nextToken));\n                    if ((imageData.getImageData() == null) || (imageData.getImageData().length == 0)) {\n                        LOG.warn(\"empty inline image at stream offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                    }\n                    beginImageOP.setImageData(imageData.getImageData());\n                    inlineImageDepth--;\n                } else {\n                    LOG.warn((((((\"nextToken \" + nextToken) + \" at position \") + (source.isClosed() ? \"EOF\" : source.getPosition())) + \", expected \") + OperatorName.BEGIN_INLINE_IMAGE_DATA) + \"?!\");\n                }\n            }\n            return beginImageOP;\n        case 'I' :\n            // Special case for ID operator\n            String id = Character.toString(((char) (source.read()))) + ((char) (source.read()));\n            if (!id.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA)) {\n                long currentPosition = source.getPosition();\n                close();\n                throw new IOException(((\"Error: Expected operator 'ID' actual='\" + id) + \"' at stream offset \") + currentPosition);\n            }\n            ByteArrayOutputStream imageData = new ByteArrayOutputStream();\n            // skip one line break (CR, LF or CRLF) or any one-byte whitespace\n            if ((!skipLinebreak()) && isWhitespace()) {\n                // pull off the whitespace character\n                source.read();\n            }\n            int lastByte = source.read();\n            int currentByte = source.read();\n            // PDF spec is kinda unclear about this. Should a whitespace\n            // always appear before EI? Not sure, so that we just read\n            // until EI<whitespace>.\n            // Be aware not all kind of whitespaces are allowed here. see PDFBOX-1561\n            while ((!((((lastByte == 'E') && (currentByte == 'I')) && hasNextSpaceOrReturn()) && hasNoFollowingBinData())) && (!isEOF())) {\n                imageData.write(lastByte);\n                lastByte = currentByte;\n                currentByte = source.read();\n            } \n            // the EI operator isn't unread, as it won't be processed anyway\n            Operator beginImageDataOP = Operator.getOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);\n            // save the image data to the operator, so that it can be accessed later\n            beginImageDataOP.setImageData(imageData.toByteArray());\n            return beginImageDataOP;\n        case ']' :\n            // some ']' around without its previous '['\n            // this means a PDF is somewhat corrupt but we will continue to parse.\n            source.read();\n            // must be a better solution than null...\n            return COSNull.NULL;\n        default :\n            // we must be an operator\n            String operator = readOperator().trim();\n            if (operator.length() > 0) {\n                return Operator.getOperator(operator);\n            }\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PDFRenderer.renderPageToGraphics",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PDFRenderer.renderPageToGraphics", "org.apache.pdfbox.pdmodel.PDPageTree.get", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Renders a given page to an AWT Graphics2D instance.\n * <p>\n * Known problems:\n * <ul>\n * <li>rendering of PDF files with transparencies is not supported on Ubuntu, see\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-4581\">PDFBOX-4581</a> and\n * <a href=\"https://bugs.openjdk.java.net/browse/JDK-6689349\">JDK-6689349</a>. Rendering will\n * not abort, but the pages will be rendered incorrectly.</li>\n * <li>Clipping the Graphics2D will not work properly, see\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-4583\">PDFBOX-4583</a>.</li>\n * </ul>\n * If you encounter these problems, then you should render into an image by using the\n * {@link #renderImage(int) renderImage} methods.\n *\n * @param pageIndex\n * \t\tthe zero-based index of the page to be converted\n * @param graphics\n * \t\tthe Graphics2D on which to draw the page\n * @param scaleX\n * \t\tthe scale to draw the page at for the x-axis, where 1 = 72 DPI\n * @param scaleY\n * \t\tthe scale to draw the page at for the y-axis, where 1 = 72 DPI\n * @param destination\n * \t\tcontrolling visibility of optional content groups\n * @throws IOException\n * \t\tif the PDF cannot be read\n * @throws IllegalStateException\n * \t\tif the requested index isn't found or doesn't point to a valid\n * \t\tpage dictionary\n * @throws IndexOutOfBoundsException\n * \t\tif the requested index is higher than the page count\n */\npublic void renderPageToGraphics(int pageIndex, Graphics2D graphics, float scaleX, float scaleY, RenderDestination destination) throws IOException {\n    PDPage page = pageTree.get(pageIndex);\n    // TODO need width/height calculations? should these be in PageDrawer?\n    PDRectangle cropBox = page.getCropBox();\n    transform(graphics, page.getRotation(), cropBox, scaleX, scaleY);\n    graphics.clearRect(0, 0, ((int) (cropBox.getWidth())), ((int) (cropBox.getHeight())));\n    // the end-user may provide a custom PageDrawer\n    RenderingHints actualRenderingHints = (renderingHints == null) ? createDefaultRenderingHints(graphics) : renderingHints;\n    PageDrawerParameters parameters = new PageDrawerParameters(this, page, subsamplingAllowed, destination, actualRenderingHints, imageDownscalingOptimizationThreshold);\n    PageDrawer drawer = createPageDrawer(parameters);\n    drawer.drawPage(graphics, cropBox);\n}", "/**\n * Returns the page at the given index.\n *\n * @param index\n * \t\tzero-based index\n * @return the page at the given index\n * @throws IllegalStateException\n * \t\tif the requested index isn't found or doesn't point to a valid page dictionary\n * @throws IndexOutOfBoundsException\n * \t\tif the requested index is higher than the page count\n */\npublic PDPage get(int index) {\n    COSDictionary dict = get(index + 1, root, 0);\n    sanitizeType(dict);\n    ResourceCache resourceCache = (document != null) ? document.getResourceCache() : null;\n    return new PDPage(dict, resourceCache);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.getProcess",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.getProcess", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNProcess.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the DeviceN Process Dictionary, or null if it is missing.\n *\n * @return the DeviceN Process Dictionary, or null if it is missing.\n */\npublic PDDeviceNProcess getProcess() {\n    COSDictionary process = dictionary.getCOSDictionary(COSName.PROCESS);\n    if (process == null) {\n        return null;\n    }\n    return new PDDeviceNProcess(process);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromImage", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new JPEG Image XObject from a BufferedImage, a given quality and dpi metadata.\n * <p>\n * Do not read a JPEG image from a stream/file and call this method; you'll get more speed and\n * quality by calling {@link #createFromStream(org.apache.pdfbox.pdmodel.PDDocument,\n * java.io.InputStream) createFromStream()} instead.\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param image\n * \t\tthe BufferedImage to embed\n * @param quality\n * \t\tThe desired JPEG compression quality; between 0 (best\n * \t\tcompression) and 1 (best image quality). See\n * \t\t{@link ImageWriteParam#setCompressionQuality(float)} for more details.\n * @param dpi\n * \t\tthe desired dpi (resolution) value of the JPEG to be stored in metadata. This\n * \t\tvalue has no influence on image content or size.\n * @return a new Image XObject\n * @throws IOException\n * \t\tif the JPEG data cannot be written\n */\npublic static PDImageXObject createFromImage(PDDocument document, BufferedImage image, float quality, int dpi) throws IOException {\n    return createJPEG(document, image, quality, dpi);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.Filter.encode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.Filter.encode", "org.apache.pdfbox.cos.COSDictionary.asUnmodifiableDictionary", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Encodes data.\n *\n * @param input\n * \t\tthe byte stream to encode\n * @param encoded\n * \t\tthe stream where encoded data will be written\n * @param parameters\n * \t\tthe parameters used for encoding\n * @param index\n * \t\tthe index to the filter being encoded\n * @throws IOException\n * \t\tif the stream cannot be encoded\n */\npublic final void encode(InputStream input, OutputStream encoded, COSDictionary parameters, int index) throws IOException {\n    encode(input, encoded, parameters.asUnmodifiableDictionary());\n}", "/**\n * Returns an unmodifiable view of this dictionary.\n *\n * @return an unmodifiable view of this dictionary\n */\npublic COSDictionary asUnmodifiableDictionary() {\n    return new UnmodifiableCOSDictionary(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.getBytes",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.getBytes", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the bytes corresponding to the ASCII hex encoding of the given bytes.\n *\n * @param bytes\n * \t\tthe bytey to be converted\n * @return the ASCII hex encoding of the given bytes\n */\npublic static byte[] getBytes(byte[] bytes) {\n    byte[] asciiBytes = new byte[bytes.length * 2];\n    for (int i = 0; i < bytes.length; i++) {\n        asciiBytes[i * 2] = HEX_BYTES[getHighNibble(bytes[i])];\n        asciiBytes[(i * 2) + 1] = HEX_BYTES[getLowNibble(bytes[i])];\n    }\n    return asciiBytes;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue", "org.apache.pdfbox.cos.COSDictionary.setString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the selected value of this field, and try to update the visual appearance.\n *\n * @param value\n * \t\tThe name of the selected item.\n * @throws IOException\n * \t\tif the value could not be set\n */\n@Override\npublic void setValue(String value) throws IOException {\n    getCOSObject().setString(COSName.V, value);\n    // remove I key for single valued choice field\n    setSelectedOptionsIndex(null);\n    applyChange();\n}", "/**\n * This is a convenience method that will convert the value to a COSString object. If it is null then the object\n * will be removed.\n *\n * @param key\n * \t\tThe key to the object,\n * @param value\n * \t\tThe string value for the name.\n */\npublic void setString(COSName key, String value) {\n    COSString name = null;\n    if (value != null) {\n        name = new COSString(value);\n    }\n    setItem(key, name);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.getFontMatrix",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.getFontMatrix", "org.apache.pdfbox.pdmodel.font.PDType1CFont.<clinit>" ],
    "fullMethods" : [ "@Override\npublic final Matrix getFontMatrix() {\n    if (fontMatrix == null) {\n        List<Number> numbers = null;\n        try {\n            numbers = genericFont.getFontMatrix();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font matrix - returning default value\", e);\n            fontMatrix = DEFAULT_FONT_MATRIX;\n        }\n        if ((numbers != null) && (numbers.size() == 6)) {\n            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());\n        } else {\n            return super.getFontMatrix();\n        }\n    }\n    return fontMatrix;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.TrueTypeEmbedder.subset",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.TrueTypeEmbedder.subset", "org.apache.pdfbox.pdmodel.font.PDCIDFontType2Embedder.buildSubset", "org.apache.pdfbox.pdmodel.font.PDCIDFontType2Embedder.buildToUnicodeCMap", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void subset() throws IOException {\n    if (!isSubsettingPermitted(ttf)) {\n        throw new IOException(\"This font does not permit subsetting\");\n    }\n    if (!embedSubset) {\n        throw new IllegalStateException(\"Subsetting is disabled\");\n    }\n    // set the GIDs to subset\n    TTFSubsetter subsetter = new TTFSubsetter(ttf, TABLES);\n    subsetter.addAll(subsetCodePoints);\n    subsetter.forceInvisible('â');// ZWSP\n\n    subsetter.forceInvisible('â');// ZWNJ\n\n    subsetter.forceInvisible('â ');// WJ\n\n    subsetter.forceInvisible('ï»¿');// ZWNBSP\n\n    if (!allGlyphIds.isEmpty()) {\n        subsetter.addGlyphIds(allGlyphIds);\n    }\n    // calculate deterministic tag based on the chosen subset\n    Map<Integer, Integer> gidToCid = subsetter.getGIDMap();\n    String tag = getTag(gidToCid);\n    subsetter.setPrefix(tag);\n    // save the subset font\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    subsetter.writeToStream(out);\n    // re-build the embedded font\n    buildSubset(new ByteArrayInputStream(out.toByteArray()), tag, gidToCid);\n    ttf.close();\n}", "/**\n * Rebuild a font subset.\n */\n@Override\nprotected void buildSubset(InputStream ttfSubset, String tag, Map<Integer, Integer> gidToCid) throws IOException {\n    // build CID2GIDMap, because the content stream has been written with the old GIDs\n    TreeMap<Integer, Integer> cidToGid = new TreeMap<>();\n    gidToCid.forEach((newGID, oldGID) -> cidToGid.put(oldGID, newGID));\n    // build unicode mapping before subsetting as the subsetted font won't have a cmap\n    buildToUnicodeCMap(gidToCid);\n    // build vertical metrics before subsetting as the subsetted font won't have vhea, vmtx\n    if (vertical) {\n        buildVerticalMetrics(cidToGid);\n    }\n    // rebuild the relevant part of the font\n    buildFontFile2(ttfSubset);\n    addNameTag(tag);\n    buildWidths(cidToGid);\n    buildCIDToGIDMap(cidToGid);\n    buildCIDSet(cidToGid);\n}", "private void buildToUnicodeCMap(Map<Integer, Integer> newGIDToOldCID) throws IOException {\n    ToUnicodeWriter toUniWriter = new ToUnicodeWriter();\n    boolean hasSurrogates = false;\n    for (int gid = 1, max = ttf.getMaximumProfile().getNumGlyphs(); gid <= max; gid++) {\n        // optional CID2GIDMap for subsetting\n        int cid;\n        if (newGIDToOldCID != null) {\n            if (!newGIDToOldCID.containsKey(gid)) {\n                continue;\n            } else {\n                cid = newGIDToOldCID.get(gid);\n            }\n        } else {\n            cid = gid;\n        }\n        // skip composite glyph components that have no code point\n        List<Integer> codes = cmapLookup.getCharCodes(cid);// old GID -> Unicode\n\n        if (codes != null) {\n            // use the first entry even for ambiguous mappings\n            int codePoint = codes.get(0);\n            if (codePoint > 0xffff) {\n                hasSurrogates = true;\n            }\n            toUniWriter.add(cid, new String(new int[]{ codePoint }, 0, 1));\n        }\n    }\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    toUniWriter.writeTo(out);\n    InputStream cMapStream = new ByteArrayInputStream(out.toByteArray());\n    PDStream stream = new PDStream(document, cMapStream, COSName.FLATE_DECODE);\n    // surrogate code points, requires PDF 1.5\n    if (hasSurrogates) {\n        float version = document.getVersion();\n        if (version < 1.5) {\n            document.setVersion(1.5F);\n        }\n    }\n    dict.setItem(COSName.TO_UNICODE, stream);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.visitFromDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.visitFromDictionary", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void visitFromDictionary(COSDictionary obj) throws IOException {\n    detectPossibleSignature(obj);\n    getStandardOutput().write(DICT_OPEN);\n    getStandardOutput().writeEOL();\n    for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {\n        COSBase value = entry.getValue();\n        if (value != null) {\n            entry.getKey().accept(this);\n            getStandardOutput().write(SPACE);\n            if (value instanceof COSDictionary) {\n                COSDictionary dict = ((COSDictionary) (value));\n                if (!incrementalUpdate) {\n                    // write all XObjects as direct objects, this will save some size\n                    // PDFBOX-3684: but avoid dictionary that references itself\n                    COSBase item = dict.getItem(COSName.XOBJECT);\n                    if ((item != null) && (!COSName.XOBJECT.equals(entry.getKey()))) {\n                        item.setDirect(true);\n                    }\n                    item = dict.getItem(COSName.RESOURCES);\n                    if ((item != null) && (!COSName.RESOURCES.equals(entry.getKey()))) {\n                        item.setDirect(true);\n                    }\n                }\n                writeDictionary(dict);\n            } else if (value instanceof COSObject) {\n                addObjectToWrite(value);\n                writeReference(value);\n            } else // If we reach the pdf signature, we need to determinate the position of the\n            // content and byterange\n            if (reachedSignature && COSName.CONTENTS.equals(entry.getKey())) {\n                signatureOffset = getStandardOutput().getPos();\n                value.accept(this);\n                signatureLength = getStandardOutput().getPos() - signatureOffset;\n            } else if (reachedSignature && COSName.BYTERANGE.equals(entry.getKey())) {\n                byteRangeArray = ((COSArray) (entry.getValue()));\n                byteRangeOffset = getStandardOutput().getPos() + 1;\n                value.accept(this);\n                byteRangeLength = (getStandardOutput().getPos() - 1) - byteRangeOffset;\n                reachedSignature = false;\n            } else if (value instanceof COSArray) {\n                writeArray(((COSArray) (value)));\n            } else {\n                value.accept(this);\n            }\n            getStandardOutput().writeEOL();\n        } else {\n            // then we won't write anything, there are a couple cases\n            // were the value of an entry in the COSDictionary will\n            // be a dangling reference that points to nothing\n            // so we will just not write out the entry if that is the case\n        }\n    }\n    getStandardOutput().write(DICT_CLOSE);\n    getStandardOutput().writeEOL();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationUnderline.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationUnderline.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDUnderlineAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDUnderlineAppearanceHandler appearanceHandler = new PDUnderlineAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.decreaseLevel",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.decreaseLevel", "org.apache.pdfbox.contentstream.PDFStreamEngine.<clinit>" ],
    "fullMethods" : [ "/**\n * Decrease the level. Call this after running a potentially recursive operation. A log message\n * is shown if the level is below 0. This can happen if the level is not decreased after an\n * operation is done, e.g. by using a \"finally\" block.\n */\npublic void decreaseLevel() {\n    --level;\n    if (level < 0) {\n        LOG.error(\"level is \" + level);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.<clinit>" ],
    "fullMethods" : [ "/**\n * Refreshes the appearance streams and appearance dictionaries for the widget annotations of the specified fields.\n *\n * @param fields\n * \t\ta list of fields to be refreshed\n * @throws IOException\n * \t\tif the appearance streams could not be refreshed\n */\npublic void refreshAppearances(List<PDField> fields) throws IOException {\n    for (PDField field : fields) {\n        if (field instanceof PDTerminalField) {\n            ((PDTerminalField) (field)).constructAppearances();\n        }\n    }\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * This will decrypt a stream.\n *\n * @param stream\n * \t\tThe stream to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void decryptStream(COSStream stream, long objNum, long genNum) throws IOException {\n    // Stream encrypted with identity filter\n    if (COSName.IDENTITY.equals(streamFilterName)) {\n        return;\n    }\n    COSBase type = stream.getCOSName(COSName.TYPE);\n    if ((!decryptMetadata) && COSName.METADATA.equals(type)) {\n        return;\n    }\n    // \"The cross-reference stream shall not be encrypted\"\n    if (COSName.XREF.equals(type)) {\n        return;\n    }\n    if (COSName.METADATA.equals(type)) {\n        byte[] buf;\n        // PDFBOX-3229 check case where metadata is not encrypted despite /EncryptMetadata missing\n        try (InputStream is = stream.createRawInputStream()) {\n            buf = new byte[10];\n            long isResult = IOUtils.populateBuffer(is, buf);\n            if (Long.compare(isResult, buf.length) != 0) {\n                LOG.debug((((\"Tried reading \" + buf.length) + \" bytes but only \") + isResult) + \" bytes read\");\n            }\n        }\n        if (Arrays.equals(buf, \"<?xpacket \".getBytes(StandardCharsets.ISO_8859_1))) {\n            LOG.warn(\"Metadata is not encrypted, but was expected to be\");\n            LOG.warn(\"Read PDF specification about EncryptMetadata (default value: true)\");\n            return;\n        }\n    }\n    decryptDictionary(stream, objNum, genNum);\n    // the input and the output stream of a still encrypted COSStream aren't no longer based\n    // on the same object so that it is safe to omit the intermediate ByteArrayStream\n    // \n    try (InputStream encryptedStream = stream.createRawInputStream();OutputStream output = stream.createRawOutputStream()) {\n        /* decrypt */\n        encryptData(objNum, genNum, encryptedStream, output, true);\n    } catch (IOException ex) {\n        LOG.error(((((ex.getClass().getSimpleName() + \" thrown when decrypting object \") + objNum) + \" \") + genNum) + \" obj\");\n        throw ex;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument", "org.apache.pdfbox.multipdf.PDFCloneUtility.<clinit>" ],
    "fullMethods" : [ "/**\n * append all pages from source to destination.\n *\n * @param destination\n * \t\tthe document to receive the pages\n * @param source\n * \t\tthe document originating the new pages\n * @throws IOException\n * \t\tIf there is an error accessing data from either\n * \t\tdocument.\n */\npublic void appendDocument(PDDocument destination, PDDocument source) throws IOException {\n    PDFCloneUtility cloner = new PDFCloneUtility(destination);\n    if (source.getDocument().isClosed()) {\n        throw new IOException(\"Error: source PDF is closed.\");\n    }\n    if (destination.getDocument().isClosed()) {\n        throw new IOException(\"Error: destination PDF is closed.\");\n    }\n    PDDocumentCatalog srcCatalog = source.getDocumentCatalog();\n    if (isDynamicXfa(srcCatalog.getAcroForm())) {\n        throw new IOException(\"Error: can't merge source document containing dynamic XFA form content.\");\n    }\n    PDDocumentInformation destInfo = destination.getDocumentInformation();\n    PDDocumentInformation srcInfo = source.getDocumentInformation();\n    mergeInto(srcInfo.getCOSObject(), destInfo.getCOSObject(), cloner, Collections.emptySet());\n    // use the highest version number for the resulting pdf\n    float destVersion = destination.getVersion();\n    float srcVersion = source.getVersion();\n    if (destVersion < srcVersion) {\n        destination.setVersion(srcVersion);\n    }\n    PDDocumentCatalog destCatalog = destination.getDocumentCatalog();\n    mergeAcroForm(cloner, destCatalog, srcCatalog);\n    COSArray destThreads = destCatalog.getCOSObject().getCOSArray(COSName.THREADS);\n    COSArray srcThreads = cloner.cloneForNewDocument(destCatalog.getCOSObject().getCOSArray(COSName.THREADS));\n    if (destThreads == null) {\n        destCatalog.getCOSObject().setItem(COSName.THREADS, srcThreads);\n    } else {\n        destThreads.addAll(srcThreads);\n    }\n    PDDocumentNameDictionary destNames = destCatalog.getNames();\n    PDDocumentNameDictionary srcNames = srcCatalog.getNames();\n    if (srcNames != null) {\n        if (destNames == null) {\n            destCatalog.getCOSObject().setItem(COSName.NAMES, cloner.cloneForNewDocument(srcNames.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcNames, destNames);\n        }\n    }\n    if ((destNames != null) && destNames.getCOSObject().containsKey(COSName.ID_TREE)) {\n        // found in 001031.pdf from PDFBOX-4417 and doesn't belong there\n        destNames.getCOSObject().removeItem(COSName.ID_TREE);\n        LOG.warn(\"Removed /IDTree from /Names dictionary, doesn't belong there\");\n    }\n    PDDocumentNameDestinationDictionary srcDests = srcCatalog.getDests();\n    if (srcDests != null) {\n        PDDocumentNameDestinationDictionary destDests = destCatalog.getDests();\n        if (destDests == null) {\n            destCatalog.getCOSObject().setItem(COSName.DESTS, cloner.cloneForNewDocument(srcDests.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcDests, destDests);\n        }\n    }\n    PDDocumentOutline srcOutline = srcCatalog.getDocumentOutline();\n    if (srcOutline != null) {\n        PDDocumentOutline destOutline = destCatalog.getDocumentOutline();\n        if ((destOutline == null) || (destOutline.getFirstChild() == null)) {\n            PDDocumentOutline cloned = new PDDocumentOutline(cloner.cloneForNewDocument(srcOutline.getCOSObject()));\n            destCatalog.setDocumentOutline(cloned);\n        } else {\n            // search last sibling for dest, because /Last entry is sometimes wrong\n            PDOutlineItem destLastOutlineItem = destOutline.getFirstChild();\n            while (true) {\n                PDOutlineItem outlineItem = destLastOutlineItem.getNextSibling();\n                if (outlineItem == null) {\n                    break;\n                }\n                destLastOutlineItem = outlineItem;\n            } \n            for (PDOutlineItem item : srcOutline.children()) {\n                // get each child, clone its dictionary, remove siblings info,\n                // append outline item created from there\n                COSDictionary clonedDict = cloner.cloneForNewDocument(item.getCOSObject());\n                clonedDict.removeItem(COSName.PREV);\n                clonedDict.removeItem(COSName.NEXT);\n                PDOutlineItem clonedItem = new PDOutlineItem(clonedDict);\n                destLastOutlineItem.insertSiblingAfter(clonedItem);\n                destLastOutlineItem = destLastOutlineItem.getNextSibling();\n            }\n        }\n    }\n    PageMode destPageMode = destCatalog.getPageMode();\n    if (destPageMode == null) {\n        PageMode srcPageMode = srcCatalog.getPageMode();\n        destCatalog.setPageMode(srcPageMode);\n    }\n    COSDictionary srcLabels = srcCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n    if (srcLabels != null) {\n        int destPageCount = destination.getNumberOfPages();\n        COSArray destNums;\n        COSDictionary destLabels = destCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n        if (destLabels == null) {\n            destLabels = new COSDictionary();\n            destNums = new COSArray();\n            destLabels.setItem(COSName.NUMS, destNums);\n            destCatalog.getCOSObject().setItem(COSName.PAGE_LABELS, destLabels);\n        } else {\n            destNums = destLabels.getCOSArray(COSName.NUMS);\n        }\n        COSArray srcNums = srcLabels.getCOSArray(COSName.NUMS);\n        if (srcNums != null) {\n            int startSize = destNums.size();\n            for (int i = 0; i < srcNums.size(); i += 2) {\n                COSBase base = srcNums.getObject(i);\n                if (!(base instanceof COSNumber)) {\n                    LOG.error(((\"page labels ignored, index \" + i) + \" should be a number, but is \") + base);\n                    // remove what we added\n                    while (destNums.size() > startSize) {\n                        destNums.remove(startSize);\n                    } \n                    break;\n                }\n                COSNumber labelIndex = ((COSNumber) (base));\n                long labelIndexValue = labelIndex.intValue();\n                destNums.add(COSInteger.get(labelIndexValue + destPageCount));\n                destNums.add(cloner.cloneForNewDocument(srcNums.getObject(i + 1)));\n            }\n        }\n    }\n    COSStream destMetadata = destCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    COSStream srcMetadata = srcCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    if ((destMetadata == null) && (srcMetadata != null)) {\n        try {\n            PDStream newStream = new PDStream(destination, srcMetadata.createInputStream(), ((COSName) (null)));\n            mergeInto(srcMetadata, newStream.getCOSObject(), cloner, new HashSet<>(Arrays.asList(COSName.FILTER, COSName.LENGTH)));\n            destCatalog.getCOSObject().setItem(COSName.METADATA, newStream);\n        } catch (IOException ex) {\n            // PDFBOX-4227 cleartext XMP stream with /Flate\n            LOG.error(\"Metadata skipped because it could not be read\", ex);\n        }\n    }\n    COSDictionary destOCP = destCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    COSDictionary srcOCP = srcCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    if ((destOCP == null) && (srcOCP != null)) {\n        destCatalog.getCOSObject().setItem(COSName.OCPROPERTIES, cloner.cloneForNewDocument(srcOCP));\n    } else if ((destOCP != null) && (srcOCP != null)) {\n        cloner.cloneMerge(srcOCP, destOCP);\n    }\n    mergeOutputIntents(srcCatalog, destCatalog, cloner);\n    // merge logical structure hierarchy\n    boolean mergeStructTree = false;\n    int destParentTreeNextKey = -1;\n    Map<Integer, COSObjectable> srcNumberTreeAsMap = null;\n    Map<Integer, COSObjectable> destNumberTreeAsMap = null;\n    PDStructureTreeRoot srcStructTree = srcCatalog.getStructureTreeRoot();\n    PDStructureTreeRoot destStructTree = destCatalog.getStructureTreeRoot();\n    if ((destStructTree == null) && (srcStructTree != null)) {\n        // create a dummy structure tree in the destination, so that the source\n        // tree is cloned. (We can't just copy the tree reference due to PDFBOX-3999)\n        destStructTree = new PDStructureTreeRoot();\n        destCatalog.setStructureTreeRoot(destStructTree);\n        destStructTree.setParentTree(new PDNumberTreeNode(PDParentTreeValue.class));\n        // PDFBOX-4429: remove bogus StructParent(s)\n        for (PDPage page : destCatalog.getPages()) {\n            page.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : page.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n    }\n    if (destStructTree != null) {\n        PDNumberTreeNode destParentTree = destStructTree.getParentTree();\n        destParentTreeNextKey = destStructTree.getParentTreeNextKey();\n        if (destParentTree != null) {\n            destNumberTreeAsMap = getNumberTreeAsMap(destParentTree);\n            if (destParentTreeNextKey < 0) {\n                if (destNumberTreeAsMap.isEmpty()) {\n                    destParentTreeNextKey = 0;\n                } else {\n                    destParentTreeNextKey = Collections.max(destNumberTreeAsMap.keySet()) + 1;\n                }\n            }\n            if ((destParentTreeNextKey >= 0) && (srcStructTree != null)) {\n                PDNumberTreeNode srcParentTree = srcStructTree.getParentTree();\n                if (srcParentTree != null) {\n                    srcNumberTreeAsMap = getNumberTreeAsMap(srcParentTree);\n                    if (!srcNumberTreeAsMap.isEmpty()) {\n                        mergeStructTree = true;\n                    }\n                }\n            }\n        }\n    }\n    Map<COSDictionary, COSDictionary> objMapping = new HashMap<>();\n    PDPageTree destinationPageTree = destination.getPages();// cache PageTree\n\n    for (PDPage page : srcCatalog.getPages()) {\n        PDPage newPage = new PDPage(cloner.cloneForNewDocument(page.getCOSObject()));\n        if (!mergeStructTree) {\n            // PDFBOX-4429: remove bogus StructParent(s)\n            newPage.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : newPage.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n        newPage.setCropBox(page.getCropBox());\n        newPage.setMediaBox(page.getMediaBox());\n        newPage.setRotation(page.getRotation());\n        PDResources resources = page.getResources();\n        if (resources != null) {\n            // this is smart enough to just create references for resources that are used on multiple pages\n            newPage.setResources(new PDResources(cloner.cloneForNewDocument(resources.getCOSObject())));\n        } else {\n            newPage.setResources(new PDResources());\n        }\n        if (mergeStructTree) {\n            // add the value of the destination ParentTreeNextKey to every source element\n            // StructParent(s) value so that these don't overlap with the existing values\n            updateStructParentEntries(newPage, destParentTreeNextKey);\n            objMapping.put(page.getCOSObject(), newPage.getCOSObject());\n            List<PDAnnotation> oldAnnots = page.getAnnotations();\n            List<PDAnnotation> newAnnots = newPage.getAnnotations();\n            for (int i = 0; i < oldAnnots.size(); i++) {\n                objMapping.put(oldAnnots.get(i).getCOSObject(), newAnnots.get(i).getCOSObject());\n            }\n            // TODO update mapping for XObjects\n        }\n        destinationPageTree.add(newPage);\n    }\n    mergeOpenAction(srcCatalog, destCatalog, cloner);\n    if (mergeStructTree) {\n        updatePageReferences(cloner, srcNumberTreeAsMap, objMapping);\n        int maxSrcKey = -1;\n        for (Map.Entry<Integer, COSObjectable> entry : srcNumberTreeAsMap.entrySet()) {\n            int srcKey = entry.getKey();\n            maxSrcKey = Math.max(srcKey, maxSrcKey);\n            COSObjectable value = entry.getValue();\n            if (value != null) {\n                value = cloner.cloneForNewDocument(value.getCOSObject());\n                destNumberTreeAsMap.put(destParentTreeNextKey + srcKey, value);\n            }\n        }\n        destParentTreeNextKey += maxSrcKey + 1;\n        PDNumberTreeNode newParentTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);\n        // Note that all elements are stored flatly. This could become a problem for large files\n        // when these are opened in a viewer that uses the tagging information.\n        // If this happens, then PDNumberTreeNode should be improved with a convenience method that\n        // stores the map into a B+Tree, see https://en.wikipedia.org/wiki/B+_tree\n        newParentTreeNode.setNumbers(destNumberTreeAsMap);\n        destStructTree.setParentTree(newParentTreeNode);\n        destStructTree.setParentTreeNextKey(destParentTreeNextKey);\n        mergeKEntries(cloner, srcStructTree, destStructTree);\n        mergeRoleMap(srcStructTree, destStructTree, cloner);\n        mergeIDTree(cloner, srcStructTree, destStructTree);\n        mergeMarkInfo(destCatalog, srcCatalog);\n        mergeLanguage(destCatalog, srcCatalog);\n        mergeViewerPreferences(destCatalog, srcCatalog, cloner);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShading.create",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShading.create", "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4.<clinit>" ],
    "fullMethods" : [ "/**\n * Create the correct PD Model shading based on the COS base shading.\n *\n * @param shadingDictionary\n * \t\tthe COS shading dictionary\n * @return the newly created shading resources object\n * @throws IOException\n * \t\tif we are unable to create the PDShading object\n */\npublic static PDShading create(COSDictionary shadingDictionary) throws IOException {\n    PDShading shading = null;\n    int shadingType = shadingDictionary.getInt(COSName.SHADING_TYPE, 0);\n    switch (shadingType) {\n        case SHADING_TYPE1 :\n            shading = new PDShadingType1(shadingDictionary);\n            break;\n        case SHADING_TYPE2 :\n            shading = new PDShadingType2(shadingDictionary);\n            break;\n        case SHADING_TYPE3 :\n            shading = new PDShadingType3(shadingDictionary);\n            break;\n        case SHADING_TYPE4 :\n            shading = new PDShadingType4(shadingDictionary);\n            break;\n        case SHADING_TYPE5 :\n            shading = new PDShadingType5(shadingDictionary);\n            break;\n        case SHADING_TYPE6 :\n            shading = new PDShadingType6(shadingDictionary);\n            break;\n        case SHADING_TYPE7 :\n            shading = new PDShadingType7(shadingDictionary);\n            break;\n        default :\n            throw new IOException(\"Error: Unknown shading type \" + shadingType);\n    }\n    return shading;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDPropBuildDataDict.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDPropBuildDataDict.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDPropBuildDataDict() {\n    dictionary = new COSDictionary();\n    // the specification claim to use direct objects\n    dictionary.setDirect(true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureRectangle",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureRectangle", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createSignatureRectangle(PDSignatureField signatureField, PDVisibleSignDesigner properties) throws IOException {\n    PDRectangle rect = new PDRectangle();\n    rect.setUpperRightX(properties.getxAxis() + properties.getWidth());\n    rect.setUpperRightY(properties.getTemplateHeight() - properties.getyAxis());\n    rect.setLowerLeftY((properties.getTemplateHeight() - properties.getyAxis()) - properties.getHeight());\n    rect.setLowerLeftX(properties.getxAxis());\n    signatureField.getWidgets().get(0).setRectangle(rect);\n    pdfStructure.setSignatureRectangle(rect);\n    LOG.info(\"Signature rectangle has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getStencilImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getStencilImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n * The returned images are not cached.\n */\n@Override\npublic BufferedImage getStencilImage(Paint paint) throws IOException {\n    if (!isStencil()) {\n        throw new IllegalStateException(\"Image is not a stencil\");\n    }\n    return SampledImageReader.getStencilImage(this, paint);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.insertSiblingBefore",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.insertSiblingBefore", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getParent", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Insert a single sibling before this node.\n *\n * @param newSibling\n * \t\tThe item to insert.\n * @throws IllegalArgumentException\n * \t\tif the given sibling node is part of a list\n * \t\t(i.e. if it has a previous or a next sibling)\n */\npublic void insertSiblingBefore(PDOutlineItem newSibling) {\n    requireSingleNode(newSibling);\n    PDOutlineNode parent = getParent();\n    newSibling.setParent(parent);\n    PDOutlineItem previous = getPreviousSibling();\n    setPreviousSibling(newSibling);\n    newSibling.setNextSibling(this);\n    if (previous != null) {\n        previous.setNextSibling(newSibling);\n        newSibling.setPreviousSibling(previous);\n    } else if (parent != null) {\n        getParent().setFirstChild(newSibling);\n    }\n    updateParentOpenCountForAddedChild(newSibling);\n}", "/**\n *\n * @return The parent of this node or null if there is no parent.\n */\nPDOutlineNode getParent() {\n    COSDictionary parent = getCOSObject().getCOSDictionary(COSName.PARENT);\n    if (parent != null) {\n        if (COSName.OUTLINES.equals(parent.getCOSName(COSName.TYPE))) {\n            return new PDDocumentOutline(parent);\n        }\n        return new PDOutlineItem(parent);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getKids",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getKids", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Return the children of this node.  This list will contain PDNameTreeNode objects.\n *\n * @return The list of children or null if there are no children.\n */\npublic List<PDNameTreeNode<T>> getKids() {\n    List<PDNameTreeNode<T>> retval = null;\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids != null) {\n        List<PDNameTreeNode<T>> pdObjects = new ArrayList<>(kids.size());\n        for (int i = 0; i < kids.size(); i++) {\n            COSBase base = kids.getObject(i);\n            PDNameTreeNode<T> childNode;\n            if (base instanceof COSDictionary) {\n                childNode = createChildNode(((COSDictionary) (base)));\n            } else {\n                LOG.warn(\"Bad child node at position \" + i);\n                childNode = createChildNode(new COSDictionary());\n            }\n            pdObjects.add(childNode);\n        }\n        retval = new COSArrayList<>(pdObjects, kids);\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.FlateFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.FlateFilter.decode", "org.apache.pdfbox.filter.FlateFilterDecoderStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    final COSDictionary decodeParams = getDecodeParams(parameters, index);\n    try (FlateFilterDecoderStream decoderStream = new FlateFilterDecoderStream(encoded)) {\n        OutputStream wrapPredictor = Predictor.wrapPredictor(decoded, decodeParams);\n        IOUtils.copy(decoderStream, wrapPredictor);\n        wrapPredictor.flush();\n    }\n    return new DecodeResult(parameters);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.get",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.get", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the page at the given index.\n *\n * @param index\n * \t\tzero-based index\n * @return the page at the given index\n * @throws IllegalStateException\n * \t\tif the requested index isn't found or doesn't point to a valid page dictionary\n * @throws IndexOutOfBoundsException\n * \t\tif the requested index is higher than the page count\n */\npublic PDPage get(int index) {\n    COSDictionary dict = get(index + 1, root, 0);\n    sanitizeType(dict);\n    ResourceCache resourceCache = (document != null) ? document.getResourceCache() : null;\n    return new PDPage(dict, resourceCache);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param doc\n * \t\tThe document that this form is part of.\n */\npublic PDAcroForm(PDDocument doc) {\n    document = doc;\n    dictionary = new COSDictionary();\n    dictionary.setItem(COSName.FIELDS, new COSArray());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.getGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.getGroup", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the G entry of the soft mask object\n *\n * @return form containing the transparency group\n * @throws IOException\n * \t\tif the group could not be read\n */\npublic PDTransparencyGroup getGroup() throws IOException {\n    if (group == null) {\n        COSBase cosGroup = getCOSObject().getDictionaryObject(COSName.G);\n        if (cosGroup != null) {\n            PDResources resources = new PDResources(new COSDictionary(), resourceCache);\n            PDXObject x = PDXObject.createXObject(cosGroup, resources);\n            if (x instanceof PDTransparencyGroup) {\n                group = ((PDTransparencyGroup) (x));\n            }\n        }\n    }\n    return group;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFileUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFileUnicode", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the embedded unicode file.\n *\n * @return The embedded unicode file for this file spec.\n */\npublic PDEmbeddedFile getEmbeddedFileUnicode() {\n    COSBase base = getObjectFromEFDictionary(COSName.UF);\n    if (base instanceof COSStream) {\n        return new PDEmbeddedFile(((COSStream) (base)));\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.printing.PDFPageable.getPageFormat",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.printing.PDFPageable.getPageFormat", "org.apache.pdfbox.printing.PDFPrintable.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n *\n * Returns the actual physical size of the pages in the PDF file. May not fit the local printer.\n */\n@Override\npublic PageFormat getPageFormat(int pageIndex) {\n    PDPage page = document.getPage(pageIndex);\n    PDRectangle mediaBox = PDFPrintable.getRotatedMediaBox(page);\n    PDRectangle cropBox = PDFPrintable.getRotatedCropBox(page);\n    // Java does not seem to understand landscape paper sizes, i.e. where width > height, it\n    // always crops the imageable area as if the page were in portrait. I suspect that this is\n    // a JDK bug but it might be by design, see PDFBOX-2922.\n    // \n    // As a workaround, we normalise all Page(s) to be portrait, then flag them as landscape in\n    // the PageFormat.\n    Paper paper;\n    boolean isLandscape;\n    if (mediaBox.getWidth() > mediaBox.getHeight()) {\n        // rotate\n        paper = new Paper();\n        paper.setSize(mediaBox.getHeight(), mediaBox.getWidth());\n        paper.setImageableArea(cropBox.getLowerLeftY(), cropBox.getLowerLeftX(), cropBox.getHeight(), cropBox.getWidth());\n        isLandscape = true;\n    } else {\n        paper = new Paper();\n        paper.setSize(mediaBox.getWidth(), mediaBox.getHeight());\n        paper.setImageableArea(cropBox.getLowerLeftX(), cropBox.getLowerLeftY(), cropBox.getWidth(), cropBox.getHeight());\n        isLandscape = false;\n    }\n    PageFormat format = new PageFormat();\n    format.setPaper(paper);\n    // auto portrait/landscape\n    switch (orientation) {\n        case AUTO :\n            format.setOrientation(isLandscape ? PageFormat.LANDSCAPE : PageFormat.PORTRAIT);\n            break;\n        case LANDSCAPE :\n            format.setOrientation(PageFormat.LANDSCAPE);\n            break;\n        case REVERSE_LANDSCAPE :\n            format.setOrientation(PageFormat.REVERSE_LANDSCAPE);\n            break;\n        case PORTRAIT :\n            format.setOrientation(PageFormat.PORTRAIT);\n            break;\n        default :\n            break;\n    }\n    return format;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerCoordinate",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerCoordinate", "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.<clinit>" ],
    "fullMethods" : [ "/**\n * The bits per coordinate of this shading. This will return -1 if one has\n * not been set.\n *\n * @return the number of bits per coordinate\n */\npublic int getBitsPerCoordinate() {\n    if (bitsPerCoordinate == (-1)) {\n        bitsPerCoordinate = getCOSObject().getInt(COSName.BITS_PER_COORDINATE, -1);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"bitsPerCoordinate: \" + (Math.pow(2, bitsPerCoordinate) - 1));\n        }\n    }\n    return bitsPerCoordinate;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFField.setValue", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * You should pass a String, or a List&lt;String&gt; to set the value.\n *\n * @param value\n * \t\tThe value that should populate when imported.\n * @throws IOException\n * \t\tIf there is an error setting the value.\n */\npublic void setValue(Object value) throws IOException {\n    COSBase cos = null;\n    if (value instanceof List) {\n        cos = COSArray.ofCOSStrings(((List<String>) (value)));\n    } else if (value instanceof String) {\n        cos = new COSString(((String) (value)));\n    } else if (value instanceof COSObjectable) {\n        cos = ((COSObjectable) (value)).getCOSObject();\n    } else if (value != null) {\n        throw new IOException(\"Error: Unknown type for field import: \" + value);\n    }\n    field.setItem(COSName.V, cos);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.getBytes",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.getBytes", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the bytes corresponding to the ASCII hex encoding of the given byte.\n *\n * @param b\n * \t\tthe byte to be converted\n * @return the ASCII hex encoding of the given byte\n */\npublic static byte[] getBytes(byte b) {\n    return new byte[]{ HEX_BYTES[getHighNibble(b)], HEX_BYTES[getLowNibble(b)] };\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFCatalog.getFDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFCatalog.getFDF", "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get the FDF dictionary.\n *\n * @return The FDF dictionary.\n */\npublic FDFDictionary getFDF() {\n    COSDictionary fdf = catalog.getCOSDictionary(COSName.FDF);\n    FDFDictionary retval;\n    if (fdf != null) {\n        retval = new FDFDictionary(fdf);\n    } else {\n        retval = new FDFDictionary();\n        setFDF(retval);\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getMetadata",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getMetadata", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the metadata associated with this XObject, or null if there is none.\n *\n * @return the metadata associated with this object.\n */\npublic PDMetadata getMetadata() {\n    COSStream cosStream = getCOSObject().getCOSStream(COSName.METADATA);\n    if (cosStream != null) {\n        return new PDMetadata(cosStream);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.flatten",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.flatten", "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.<clinit>" ],
    "fullMethods" : [ "/**\n * This will flatten the specified form fields.\n *\n * <p>\n * Flattening a form field will take the current appearance and make that part of the pages content stream. All form\n * fields and annotations associated are removed.\n * </p>\n *\n * <p>\n * Invisible and hidden fields will be skipped and will not become part of the page content stream\n * </p>\n *\n * @param fields\n * \t\ta list of fields to be flattened\n * @param refreshAppearances\n * \t\tif set to true the appearances for the form field widgets will be updated\n * @throws IOException\n * \t\tif something went wrong flattening the fields\n */\npublic void flatten(List<PDField> fields, boolean refreshAppearances) throws IOException {\n    // Nothing to flatten if there are no fields provided\n    if (fields.isEmpty()) {\n        return;\n    }\n    if ((!refreshAppearances) && getNeedAppearances()) {\n        LOG.warn(\"acroForm.getNeedAppearances() returns true, \" + \"visual field appearances may not have been set\");\n        LOG.warn(\"call acroForm.refreshAppearances() or \" + \"use the flatten() method with refreshAppearances parameter\");\n    }\n    // for dynamic XFA forms there is no flatten as this would mean to do a rendering\n    // from the XFA content into a static PDF.\n    if (xfaIsDynamic()) {\n        LOG.warn(\"Flatten for a dynamix XFA form is not supported\");\n        return;\n    }\n    // refresh the appearances if set\n    if (refreshAppearances) {\n        refreshAppearances(fields);\n    }\n    PDPageTree pages = document.getPages();\n    Map<COSDictionary, Set<COSDictionary>> pagesWidgetsMap = buildPagesWidgetsMap(fields, pages);\n    // preserve all non widget annotations\n    for (PDPage page : pages) {\n        Set<COSDictionary> widgetsForPageMap = pagesWidgetsMap.get(page.getCOSObject());\n        // indicates if the original content stream\n        // has been wrapped in a q...Q pair.\n        boolean isContentStreamWrapped = false;\n        List<PDAnnotation> annotations = new ArrayList<>();\n        for (PDAnnotation annotation : page.getAnnotations()) {\n            if ((widgetsForPageMap == null) || (!widgetsForPageMap.contains(annotation.getCOSObject()))) {\n                annotations.add(annotation);\n            } else if (isVisibleAnnotation(annotation)) {\n                try (PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, true, !isContentStreamWrapped)) {\n                    isContentStreamWrapped = true;\n                    PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n                    PDFormXObject fieldObject = new PDFormXObject(appearanceStream.getCOSObject());\n                    contentStream.saveGraphicsState();\n                    // see https://stackoverflow.com/a/54091766/1729265 for an explanation\n                    // of the steps required\n                    // this will transform the appearance stream form object into the rectangle of the\n                    // annotation bbox and map the coordinate systems\n                    Matrix transformationMatrix = resolveTransformationMatrix(annotation, appearanceStream);\n                    contentStream.transform(transformationMatrix);\n                    contentStream.drawForm(fieldObject);\n                    contentStream.restoreGraphicsState();\n                }\n            }\n        }\n        page.setAnnotations(annotations);\n    }\n    // remove the fields\n    removeFields(fields);\n    // remove XFA for hybrid forms\n    dictionary.removeItem(COSName.XFA);\n    // remove SigFlags if no signature left\n    if (this.document.getSignatureDictionaries().isEmpty()) {\n        this.getCOSObject().removeItem(COSName.SIG_FLAGS);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.setStartPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.setStartPage", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the first page to be extracted by this class.\n *\n * @param startPageValue\n * \t\tNew value of 1-based startPage property.\n */\npublic void setStartPage(int startPageValue) {\n    if (startPageValue <= 0) {\n        LOG.warn(\"Parameter must be 1-based, but is \" + startPageValue);\n    }\n    startPage = startPageValue;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.setString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.setString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This is a convenience method that will convert the value to a COSString object. If it is null then the object\n * will be removed.\n *\n * @param key\n * \t\tThe key to the object,\n * @param value\n * \t\tThe string value for the name.\n */\npublic void setString(COSName key, String value) {\n    COSString name = null;\n    if (value != null) {\n        name = new COSString(value);\n    }\n    setItem(key, name);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.getPath",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.getPath", "org.apache.pdfbox.pdmodel.font.PDType1Font.getNameInFont", "org.apache.pdfbox.pdmodel.font.PDType1Font.<clinit>" ],
    "fullMethods" : [ "@Override\npublic GeneralPath getPath(String name) throws IOException {\n    // Acrobat does not draw .notdef for Type 1 fonts, see PDFBOX-2421\n    // I suspect that it does do this for embedded fonts though, but this is untested\n    if (name.equals(\".notdef\") && (!isEmbedded)) {\n        return new GeneralPath();\n    } else {\n        return genericFont.getPath(getNameInFont(name));\n    }\n}", "/**\n * Maps a PostScript glyph name to the name in the underlying font, for example when\n * using a TTF font we might map \"W\" to \"uni0057\".\n */\nprivate String getNameInFont(String name) throws IOException {\n    if (isEmbedded() || genericFont.hasGlyph(name)) {\n        return name;\n    }\n    // try alternative name\n    String altName = ALT_NAMES.get(name);\n    if (((altName != null) && (!name.equals(\".notdef\"))) && genericFont.hasGlyph(altName)) {\n        return altName;\n    }\n    // try unicode name\n    String unicodes = getGlyphList().toUnicode(name);\n    if ((unicodes != null) && (unicodes.length() == 1)) {\n        String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));\n        if (genericFont.hasGlyph(uniName)) {\n            return uniName;\n        }\n        // PDFBOX-4017: no postscript table on Windows 10, and the low uni00NN\n        // names are not found in Symbol font. What works is using the PDF code plus 0xF000\n        // while disregarding encoding from the PDF (because of file from PDFBOX-1606,\n        // makes sense because this segment is about finding the name in a standard font)\n        // TODO bring up better solution than this\n        if (\"SymbolMT\".equals(genericFont.getName())) {\n            Integer code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(name);\n            if (code != null) {\n                uniName = getUniNameOfCodePoint(code + 0xf000);\n                if (genericFont.hasGlyph(uniName)) {\n                    return uniName;\n                }\n            }\n        }\n    }\n    return \".notdef\";\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.compress.COSWriterObjectStream.writeObjectsToStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.compress.COSWriterObjectStream.writeObjectsToStream", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * Writes all prepared {@link COSObject}s to the given {@link COSStream}.\n *\n * @param stream\n * \t\tThe stream for the compressed objects.\n * @return The given {@link COSStream} of this object stream.\n * @throws IOException\n * \t\tShall be thrown, if writing the object stream failed.\n */\npublic COSStream writeObjectsToStream(COSStream stream) throws IOException {\n    int objectCount = preparedKeys.size();\n    stream.setItem(COSName.TYPE, COSName.OBJ_STM);\n    stream.setInt(COSName.N, objectCount);\n    // Prepare the compressible objects for writing.\n    List<Long> objectNumbers = new ArrayList<>(objectCount);\n    List<byte[]> objectsBuffer = new ArrayList<>(objectCount);\n    for (int i = 0; i < objectCount; i++) {\n        try (ByteArrayOutputStream partialOutput = new ByteArrayOutputStream()) {\n            objectNumbers.add(preparedKeys.get(i).getNumber());\n            COSBase base = preparedObjects.get(i);\n            writeObject(partialOutput, base, true);\n            objectsBuffer.add(partialOutput.toByteArray());\n        }\n    }\n    // Deduce the object stream byte offset map.\n    byte[] offsetsMapBuffer;\n    long nextObjectOffset = 0;\n    try (ByteArrayOutputStream partialOutput = new ByteArrayOutputStream()) {\n        for (int i = 0; i < objectNumbers.size(); i++) {\n            partialOutput.write(String.valueOf(objectNumbers.get(i)).getBytes(StandardCharsets.ISO_8859_1));\n            partialOutput.write(COSWriter.SPACE);\n            partialOutput.write(String.valueOf(nextObjectOffset).getBytes(StandardCharsets.ISO_8859_1));\n            partialOutput.write(COSWriter.SPACE);\n            nextObjectOffset += objectsBuffer.get(i).length;\n        }\n        offsetsMapBuffer = partialOutput.toByteArray();\n    }\n    // Write Flate compressed object stream data.\n    try (OutputStream output = stream.createOutputStream(COSName.FLATE_DECODE)) {\n        output.write(offsetsMapBuffer);\n        stream.setInt(COSName.FIRST, offsetsMapBuffer.length);\n        for (byte[] rawObject : objectsBuffer) {\n            output.write(rawObject);\n        }\n    }\n    return stream;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given extended graphics state to the resources of the current page and returns the\n * name for the new resources. Returns the existing resource name if the given item already exists.\n *\n * @param extGState\n * \t\tthe extended graphics state to add\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDExtendedGraphicsState extGState) {\n    return add(COSName.EXT_G_STATE, \"gs\", extGState);\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.create",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.create", "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new soft mask.\n *\n * @param dictionary\n * \t\tSMask\n * @param resourceCache\n * \t\tResource cache, may be null.\n * @return the newly created instance of PDSoftMask\n */\npublic static PDSoftMask create(COSBase dictionary, ResourceCache resourceCache) {\n    if (dictionary instanceof COSName) {\n        if (COSName.NONE.equals(dictionary)) {\n            return null;\n        } else {\n            LOG.warn(\"Invalid SMask \" + dictionary);\n            return null;\n        }\n    } else if (dictionary instanceof COSDictionary) {\n        return new PDSoftMask(((COSDictionary) (dictionary)), resourceCache);\n    } else {\n        LOG.warn(\"Invalid SMask \" + dictionary);\n        return null;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.getAnnotations",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.getAnnotations", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get the list of FDF Annotations. This will return a list of FDFAnnotation objects or null if the entry\n * is not set.\n *\n * @return A list of FDF annotations.\n * @throws IOException\n * \t\tIf there is an error creating the annotation list.\n */\npublic List<FDFAnnotation> getAnnotations() throws IOException {\n    List<FDFAnnotation> retval = null;\n    COSArray annotArray = fdf.getCOSArray(COSName.ANNOTS);\n    if (annotArray != null) {\n        List<FDFAnnotation> annots = new ArrayList<>(annotArray.size());\n        for (int i = 0; i < annotArray.size(); i++) {\n            annots.add(FDFAnnotation.create(((COSDictionary) (annotArray.getObject(i)))));\n        }\n        retval = new COSArrayList<>(annots, annotArray);\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4.toPaint",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4.toPaint", "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Paint toPaint(Matrix matrix) {\n    return new Type4ShadingPaint(this, matrix);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentNameDictionary.getDests",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentNameDictionary.getDests", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the destination named tree node. The values in this name tree will be\n * PDPageDestination objects.\n *\n * @return The destination name tree node.\n */\npublic PDDestinationNameTreeNode getDests() {\n    COSDictionary dic = nameDictionary.getCOSDictionary(COSName.DESTS);\n    // The document catalog also contains the Dests entry sometimes\n    // so check there as well.\n    if (dic == null) {\n        dic = catalog.getCOSObject().getCOSDictionary(COSName.DESTS);\n    }\n    return dic != null ? new PDDestinationNameTreeNode(dic) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.setVisualSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.setVisualSignature", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.initFromRandomAccessRead", "org.apache.pdfbox.pdfparser.PDFParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Reads the visual signature from the given input stream.\n *\n * @param is\n * \t\tthe input stream containing the visual signature\n * @throws IOException\n * \t\twhen something went wrong during parsing\n */\npublic void setVisualSignature(InputStream is) throws IOException {\n    initFromRandomAccessRead(new RandomAccessReadBuffer(is));\n}", "private void initFromRandomAccessRead(RandomAccessRead rar) throws IOException {\n    pdfSource = rar;\n    PDFParser parser = new PDFParser(pdfSource);\n    visualSignature = parser.parse().getDocument();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.getWidgets",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.getWidgets", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the widget annotations associated with this field.\n *\n * @return The list of widget annotations. Be aware that this list is <i>not</i> backed by the\nactual widget collection of the field, so adding or deleting has no effect on the PDF\ndocument until you call {@link #setWidgets(java.util.List) setWidgets()} with the modified\nlist.\n */\n@Override\npublic List<PDAnnotationWidget> getWidgets() {\n    List<PDAnnotationWidget> widgets = new ArrayList<>();\n    COSArray kids = getCOSObject().getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // the field itself is a widget\n        widgets.add(new PDAnnotationWidget(getCOSObject()));\n    } else if (kids.size() > 0) {\n        // there are multiple widgets\n        for (int i = 0; i < kids.size(); i++) {\n            COSBase kid = kids.getObject(i);\n            if (kid instanceof COSDictionary) {\n                widgets.add(new PDAnnotationWidget(((COSDictionary) (kid))));\n            }\n        }\n    }\n    return widgets;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a PDColor containing the given color component values and pattern name.\n *\n * @param components\n * \t\tarray of color component values\n * @param patternName\n * \t\tthe name of a pattern in a pattern dictionary\n * @param colorSpace\n * \t\tcolor space in which the pattern/components are defined\n */\npublic PDColor(float[] components, COSName patternName, PDColorSpace colorSpace) {\n    this.components = components.clone();\n    this.patternName = patternName;\n    this.colorSpace = colorSpace;\n    if (colorSpace instanceof PDPattern) {\n        PDColorSpace ucs = ((PDPattern) (colorSpace)).getUnderlyingColorSpace();\n        if ((ucs != null) && (ucs.getNumberOfComponents() != components.length)) {\n            // PDFBOX-5882\n            LOG.warn(((\"Pattern colorspace component count \" + ucs.getNumberOfComponents()) + \" doesn't match components length \") + components.length);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationInk.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationInk.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationInk.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationInk(COSDictionary a) {\n    super(a);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a vertical Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param file\n * \t\tA TrueType font.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font file.\n */\npublic static PDType0Font loadVertical(PDDocument doc, File file) throws IOException {\n    return load(doc, new RandomAccessReadBufferedFile(file), true, true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new JPEG Image XObject from a byte array containing JPEG data.\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param byteArray\n * \t\tbytes of JPEG image\n * @return a new Image XObject\n * @throws IOException\n * \t\tif the input stream cannot be read\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray) throws IOException {\n    // copy stream\n    ByteArrayInputStream byteStream = new ByteArrayInputStream(byteArray);\n    Dimensions meta = retrieveDimensions(byteStream);\n    PDColorSpace colorSpace;\n    switch (meta.numComponents) {\n        case 1 :\n            colorSpace = PDDeviceGray.INSTANCE;\n            break;\n        case 3 :\n            colorSpace = PDDeviceRGB.INSTANCE;\n            break;\n        case 4 :\n            colorSpace = PDDeviceCMYK.INSTANCE;\n            break;\n        default :\n            throw new UnsupportedOperationException(\"number of data elements not supported: \" + meta.numComponents);\n    }\n    // create PDImageXObject from stream\n    PDImageXObject pdImage = new PDImageXObject(document, byteStream, COSName.DCT_DECODE, meta.width, meta.height, 8, colorSpace);\n    if (colorSpace instanceof PDDeviceCMYK) {\n        COSArray decode = new COSArray();\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        pdImage.setDecode(decode);\n    }\n    return pdImage;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tThe FDF annotation.\n */\npublic FDFAnnotation(COSDictionary a) {\n    annot = a;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.addKeyUsage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.addKeyUsage", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * (Optional; PDF 1.7) specifies an acceptable key-usage extension that must be presennt in the\n * signing certificate for works like {@link #setKeyUsage(List)} but takes only one string\n *\n * @param keyUsageExtension\n * \t\tString that consist only of {0, 1, X}\n */\npublic void addKeyUsage(String keyUsageExtension) {\n    String allowedChars = \"01X\";\n    for (int c = 0; c < keyUsageExtension.length(); c++) {\n        if (allowedChars.indexOf(keyUsageExtension.charAt(c)) == (-1)) {\n            throw new IllegalArgumentException(\"characters can only be 0, 1, X\");\n        }\n    }\n    COSArray array = dictionary.getCOSArray(COSName.KEY_USAGE);\n    if (array == null) {\n        array = new COSArray();\n    }\n    array.add(new COSString(keyUsageExtension));\n    dictionary.setItem(COSName.KEY_USAGE, array);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerComponent",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerComponent", "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.<clinit>" ],
    "fullMethods" : [ "/**\n * The bits per component of this shading. This will return -1 if one has not been set.\n *\n * @return the number of bits per component\n */\npublic int getBitsPerComponent() {\n    if (bitsPerColorComponent == (-1)) {\n        bitsPerColorComponent = getCOSObject().getInt(COSName.BITS_PER_COMPONENT, -1);\n        LOG.debug(\"bitsPerColorComponent: \" + bitsPerColorComponent);\n    }\n    return bitsPerColorComponent;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDExternalDataDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDExternalDataDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDExternalDataDictionary() {\n    this.dataDictionary = new COSDictionary();\n    this.dataDictionary.setName(COSName.TYPE, \"ExData\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getCIDFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getCIDFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.<clinit>" ],
    "fullMethods" : [ "/**\n * Finds a CFF CID-Keyed font with the given PostScript name, or a suitable substitute, or null.\n * This method can also map CJK fonts via their CIDSystemInfo (ROS).\n *\n * @param fontDescriptor\n * \t\tFontDescriptor\n * @param cidSystemInfo\n * \t\tthe CID system info, e.g. \"Adobe-Japan1\", if any.\n */\n@Override\npublic CIDFontMapping getCIDFont(String baseFont, PDFontDescriptor fontDescriptor, PDCIDSystemInfo cidSystemInfo) {\n    // try name match or substitute with OTF\n    OpenTypeFont otf1 = ((OpenTypeFont) (findFont(FontFormat.OTF, baseFont)));\n    if (otf1 != null) {\n        return new CIDFontMapping(otf1, null, false);\n    }\n    // try name match or substitute with TTF\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, baseFont)));\n    if (ttf != null) {\n        return new CIDFontMapping(null, ttf, false);\n    }\n    if (cidSystemInfo != null) {\n        // \"In Acrobat 3.0.1 and later, Type 0 fonts that use a CMap whose CIDSystemInfo\n        // dictionary defines the Adobe-GB1, Adobe-CNS1 Adobe-Japan1, or Adobe-Korea1 character\n        // collection can also be substituted.\" - Adobe Supplement to the ISO 32000\n        String collection = (cidSystemInfo.getRegistry() + \"-\") + cidSystemInfo.getOrdering();\n        if (((collection.equals(\"Adobe-GB1\") || collection.equals(\"Adobe-CNS1\")) || collection.equals(\"Adobe-Japan1\")) || collection.equals(\"Adobe-Korea1\")) {\n            // try automatic substitutes via character collection\n            PriorityQueue<FontMatch> queue = getFontMatches(fontDescriptor, cidSystemInfo);\n            FontMatch bestMatch = queue.poll();\n            if (bestMatch != null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(((\"Best match for '\" + baseFont) + \"': \") + bestMatch.info);\n                }\n                FontBoxFont font = bestMatch.info.getFont();\n                if (font instanceof OpenTypeFont) {\n                    return new CIDFontMapping(((OpenTypeFont) (font)), null, true);\n                } else if (font != null) {\n                    return new CIDFontMapping(null, font, true);\n                }\n            }\n        }\n    }\n    // last-resort fallback\n    return new CIDFontMapping(null, lastResortFont, true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.setVersion",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.setVersion", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the PDF specification version for this document.\n *\n * @param newVersion\n * \t\tthe new PDF version (e.g. 1.4f)\n */\npublic void setVersion(float newVersion) {\n    float currentVersion = getVersion();\n    // nothing to do?\n    if (Float.compare(newVersion, currentVersion) == 0) {\n        return;\n    }\n    // the version can't be downgraded\n    if (newVersion < currentVersion) {\n        LOG.error(\"It's not allowed to downgrade the version of a pdf.\");\n        return;\n    }\n    // update the catalog version if the document version is >= 1.4\n    if (getDocument().getVersion() >= 1.4F) {\n        getDocumentCatalog().setVersion(Float.toString(newVersion));\n    } else {\n        // versions < 1.4f have a version header only\n        getDocument().setVersion(newVersion);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.getContentStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.getContentStream", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "public PDStream getContentStream() {\n    return new PDStream(getCOSObject());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setNonStrokingColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setNonStrokingColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the non-stroking color using an AWT color. Conversion uses the default sRGB color space.\n *\n * @param color\n * \t\tThe color to set.\n * @throws IOException\n * \t\tIf an IO error occurs while writing to the stream.\n */\npublic void setNonStrokingColor(Color color) throws IOException {\n    float[] components = new float[]{ color.getRed() / 255.0F, color.getGreen() / 255.0F, color.getBlue() / 255.0F };\n    PDColor pdColor = new PDColor(components, PDDeviceRGB.INSTANCE);\n    setNonStrokingColor(pdColor);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.getCIDSet",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.getCIDSet", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the CIDSet stream.\n *\n * @return A stream containing a CIDSet.\n */\npublic PDStream getCIDSet() {\n    COSStream cidSet = dic.getCOSStream(COSName.CID_SET);\n    return cidSet != null ? new PDStream(cidSet) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.setSubjectDN",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.setSubjectDN", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * (Optional; PDF 1.7) A list of maps, where each map contains key value pairs, that specify the\n * Subject Distinguished Name (DN) that must be present within the certificate for it to be\n * acceptable for signing. The certificate must at a minimum contain all the attributes\n * specified in one of the maps entered.\n *\n * @param subjectDN\n * \t\tlist of maps that contains subject distinguished names\n */\npublic void setSubjectDN(List<Map<String, String>> subjectDN) {\n    List<COSDictionary> subjectDNDict = new LinkedList<>();\n    for (Map<String, String> subjectDNItem : subjectDN) {\n        COSDictionary dict = new COSDictionary();\n        subjectDNItem.forEach((key, value) -> dict.setItem(key, new COSString(value)));\n        subjectDNDict.add(dict);\n    }\n    dictionary.setItem(COSName.SUBJECT_DN, new COSArray(subjectDNDict));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getCropBox",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getCropBox", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * A rectangle, expressed in default user space units, defining the visible region of default user space. When the\n * page is displayed or printed, its contents are to be clipped (cropped) to this rectangle.\n *\n * @return the cropbox of the page\n */\npublic PDRectangle getCropBox() {\n    COSBase base = PDPageTree.getInheritableAttribute(page, COSName.CROP_BOX);\n    if (base instanceof COSArray) {\n        return clipToMediaBox(new PDRectangle(((COSArray) (base))));\n    } else {\n        return getMediaBox();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.<init>", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @see PDField#PDField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroform.\n */\npublic PDChoice(PDAcroForm acroForm) {\n    super(acroForm);\n    getCOSObject().setItem(COSName.FT, COSName.CH);\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDSimpleFileSpecification.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDSimpleFileSpecification.<init>", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDSimpleFileSpecification() {\n    file = new COSString(\"\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDStream.getMetadata",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDStream.getMetadata", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the metadata that is part of the document catalog. This will return\n * null if there is no meta data for this object.\n *\n * @return The metadata for this object.\n * @throws IllegalStateException\n * \t\tif the value of the metadata entry is different from a stream\n * \t\tor null\n */\npublic PDMetadata getMetadata() {\n    PDMetadata retval = null;\n    COSBase mdStream = stream.getDictionaryObject(COSName.METADATA);\n    if (mdStream instanceof COSStream) {\n        retval = new PDMetadata(((COSStream) (mdStream)));\n    } else if (mdStream instanceof COSNull) {\n        // null is authorized\n    } else if (mdStream != null) {\n        throw new IllegalStateException(\"Expected a COSStream but was a \" + mdStream.getClass().getSimpleName());\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDocument.close",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDocument.close", "org.apache.pdfbox.cos.COSDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will close all storage and delete the tmp files.\n *\n * @throws IOException\n * \t\tIf there is an error close resources.\n */\n@Override\npublic void close() throws IOException {\n    if (closed) {\n        return;\n    }\n    // Make sure that:\n    // - first Exception is kept\n    // - all COSStreams are closed\n    // - stream cache is closed\n    // - there's a way to see which errors occurred\n    IOException firstException = null;\n    // close all open I/O streams\n    for (COSObject object : objectPool.values()) {\n        if (!object.isObjectNull()) {\n            COSBase cosObject = object.getObject();\n            if (cosObject instanceof COSStream) {\n                firstException = IOUtils.closeAndLogException(((COSStream) (cosObject)), LOG, \"COSStream\", firstException);\n            }\n        }\n    }\n    for (COSStream stream : streams) {\n        firstException = IOUtils.closeAndLogException(stream, LOG, \"COSStream\", firstException);\n    }\n    if (streamCache != null) {\n        firstException = IOUtils.closeAndLogException(streamCache, LOG, \"Stream Cache\", firstException);\n    }\n    closed = true;\n    // rethrow first exception to keep method contract\n    if (firstException != null) {\n        throw firstException;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.getContents",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.getContents", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.getConvertedContents", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Will return the embedded signature between the byterange gap.\n *\n * @param pdfFile\n * \t\tThe signed pdf file as InputStream. It will be closed in this method.\n * @return a byte array containing the signature\n * @throws IOException\n * \t\tif the pdfFile can't be read\n * @throws IndexOutOfBoundsException\n * \t\tif the byterange array is not long enough\n */\npublic byte[] getContents(InputStream pdfFile) throws IOException {\n    int[] byteRange = getByteRange();\n    int begin = (byteRange[0] + byteRange[1]) + 1;\n    int len = byteRange[2] - begin;\n    return getConvertedContents(new COSFilterInputStream(pdfFile, new int[]{ begin, len }));\n}", "private byte[] getConvertedContents(InputStream is) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n    byte[] buffer = new byte[1024];\n    int readLen;\n    while ((readLen = is.read(buffer)) != (-1)) {\n        int writeLen = readLen;\n        int start = 0;\n        // Filter < and (\n        if ((buffer[0] == 0x3c) || (buffer[0] == 0x28)) {\n            ++start;\n            --writeLen;\n        }\n        // Filter > and ) at the end\n        if ((buffer[readLen - 1] == 0x3e) || (buffer[readLen - 1] == 0x29)) {\n            --writeLen;\n        }\n        baos.write(buffer, start, writeLen);\n    } \n    is.close();\n    return COSString.parseHex(baos.toString(StandardCharsets.ISO_8859_1.name())).getBytes();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the entry \"V\" to the given values. Requires {@link #isMultiSelect()} to be true.\n *\n * @param values\n * \t\tthe list of values\n * @throws IOException\n * \t\tif the appearance couldn't be generated.\n */\npublic void setValue(List<String> values) throws IOException {\n    if ((values != null) && (!values.isEmpty())) {\n        if (!isMultiSelect()) {\n            throw new IllegalArgumentException(\"The list box does not allow multiple selections.\");\n        }\n        List<String> options = getOptions();\n        if (!options.containsAll(values)) {\n            throw new IllegalArgumentException(\"The values are not contained in the selectable options.\");\n        }\n        getCOSObject().setItem(COSName.V, COSArray.ofCOSStrings(values));\n        updateSelectedOptionsIndex(values, options);\n    } else {\n        getCOSObject().removeItem(COSName.V);\n        getCOSObject().removeItem(COSName.I);\n    }\n    applyChange();\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getRotation",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getRotation", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the rotation angle in degrees by which the page should be rotated\n * clockwise when displayed or printed. Valid values in a PDF must be a\n * multiple of 90.\n *\n * @return The rotation angle in degrees in normalized form (0, 90, 180 or\n270) or 0 if invalid or not set at this level.\n */\npublic int getRotation() {\n    COSBase obj = PDPageTree.getInheritableAttribute(page, COSName.ROTATE);\n    if (obj instanceof COSNumber) {\n        int rotationAngle = ((COSNumber) (obj)).intValue();\n        if ((rotationAngle % 90) == 0) {\n            return ((rotationAngle % 360) + 360) % 360;\n        }\n    }\n    return 0;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.COSArrayList.set",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.COSArrayList.set", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic E set(int index, E element) {\n    if (isFiltered) {\n        throw new UnsupportedOperationException(\"Replacing an element in a filtered List is not permitted\");\n    }\n    if (element instanceof String) {\n        COSString item = new COSString(((String) (element)));\n        if ((parentDict != null) && (index == 0)) {\n            parentDict.setItem(dictKey, item);\n        }\n        array.set(index, item);\n    } else {\n        COSBase cosObject = ((COSObjectable) (element)).getCOSObject();\n        if ((parentDict != null) && (index == 0)) {\n            parentDict.setItem(dictKey, cosObject);\n        }\n        array.set(index, cosObject);\n    }\n    return actual.set(index, element);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default Constructor.\n */\npublic PDComplexFileSpecification() {\n    fs = new COSDictionary();\n    fs.setItem(COSName.TYPE, COSName.FILESPEC);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPolygon.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPolygon.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolygonAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDPolygonAppearanceHandler appearanceHandler = new PDPolygonAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.ASCIIHexFilter.encode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.ASCIIHexFilter.encode", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException {\n    int byteRead;\n    while ((byteRead = input.read()) != (-1)) {\n        Hex.writeHexByte(((byte) (byteRead)), encoded);\n    } \n    encoded.flush();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<init>", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fdfDictionary\n * \t\tThe FDF documents catalog.\n */\npublic FDFDictionary(COSDictionary fdfDictionary) {\n    fdf = fdfDictionary;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageContentStream.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageContentStream.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Create a new PDPage content stream.\n *\n * @param document\n * \t\tThe document the page is part of.\n * @param sourcePage\n * \t\tThe page to write the contents to.\n * @param appendContent\n * \t\tIndicates whether content will be overwritten, appended or prepended.\n * @param compress\n * \t\tTell if the content stream should compress the page contents.\n * @param resetContext\n * \t\tTell if the graphic context should be reset. This is only relevant when\n * \t\tthe appendContent parameter is set to {@link AppendMode#APPEND}. You should use this when\n * \t\tappending to an existing stream, because the existing stream may have changed graphic\n * \t\tproperties (e.g. scaling, rotation).\n * @throws IOException\n * \t\tIf there is an error writing to the page contents.\n */\npublic PDPageContentStream(PDDocument document, PDPage sourcePage, AppendMode appendContent, boolean compress, boolean resetContext) throws IOException {\n    this(document, sourcePage, appendContent, compress, resetContext, new PDStream(document), sourcePage.getResources() != null ? sourcePage.getResources() : new PDResources());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.getFontFile3",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.getFontFile3", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * A stream containing a font program that is not true type or type 1.\n *\n * @return A stream containing a font program.\n */\npublic PDStream getFontFile3() {\n    COSStream stream = dic.getCOSStream(COSName.FONT_FILE3);\n    return stream != null ? new PDStream(stream) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDestinationNameTreeNode.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDestinationNameTreeNode.<init>", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDDestinationNameTreeNode() {\n}", "/**\n * Constructor.\n */\nprotected PDNameTreeNode() {\n    node = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.measurement.PDNumberFormatDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.measurement.PDNumberFormatDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDNumberFormatDictionary() {\n    this.numberFormatDictionary = new COSDictionary();\n    this.numberFormatDictionary.setName(COSName.TYPE, TYPE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor for embedding.\n */\npublic PDPageTree() {\n    root = new COSDictionary();\n    root.setItem(COSName.TYPE, COSName.PAGES);\n    root.setItem(COSName.KIDS, new COSArray());\n    root.setItem(COSName.COUNT, COSInteger.ZERO);\n    document = null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFileByExtension",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFileByExtension", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image file. The file format is determined by the file name\n * suffix. The following suffixes are supported: JPG, JPEG, TIF, TIFF, GIF, BMP and PNG. This is\n * a convenience method that calls {@link JPEGFactory#createFromStream},\n * {@link CCITTFactory#createFromFile} or {@link ImageIO#read} combined with\n * {@link LosslessFactory#createFromImage}. (The later can also be used to create a\n * PDImageXObject from a BufferedImage). Starting with 2.0.18, this call will create an image\n * directly from a PNG file without decoding it (when possible), which is faster. However the\n * result size depends on the compression skill of the software that created the PNG file. If\n * file size or bandwidth are important to you or to your clients, then create your PNG files\n * with a tool that has implemented the\n * <a href=\"https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/\">Zopfli\n * algorithm</a>, or use the two-step process mentioned above.\n *\n * @param file\n * \t\tthe image file.\n * @param doc\n * \t\tthe document that shall use this PDImageXObject.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromFileByExtension(File file, PDDocument doc) throws IOException {\n    String name = file.getName();\n    int dot = name.lastIndexOf('.');\n    if (dot == (-1)) {\n        throw new IllegalArgumentException(\"Image type not supported: \" + name);\n    }\n    String ext = name.substring(dot + 1).toLowerCase();\n    if (\"jpg\".equals(ext) || \"jpeg\".equals(ext)) {\n        try (FileInputStream fis = new FileInputStream(file)) {\n            return JPEGFactory.createFromStream(doc, fis);\n        }\n    }\n    if (\"tif\".equals(ext) || \"tiff\".equals(ext)) {\n        try {\n            return CCITTFactory.createFromFile(doc, file);\n        } catch (IOException ex) {\n            LOG.debug(\"Reading as TIFF failed, setting fileType to PNG\", ex);\n            // Plan B: try reading with ImageIO\n            // common exception:\n            // First image in tiff is not CCITT T4 or T6 compressed\n            ext = \"png\";\n        }\n    }\n    if ((\"gif\".equals(ext) || \"bmp\".equals(ext)) || \"png\".equals(ext)) {\n        BufferedImage bim = ImageIO.read(file);\n        return LosslessFactory.createFromImage(doc, bim);\n    }\n    throw new IllegalArgumentException(\"Image type not supported: \" + name);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject", "org.apache.pdfbox.pdfparser.COSParser.parseObjectDynamically", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic COSBase dereferenceCOSObject(COSObject obj) throws IOException {\n    long currentPos = source.getPosition();\n    COSObjectKey key = obj.getKey();\n    COSBase parsedObj = parseObjectDynamically(key, false);\n    if (parsedObj != null) {\n        parsedObj.setDirect(false);\n        parsedObj.setKey(key);\n    }\n    if (currentPos > 0) {\n        source.seek(currentPos);\n    }\n    return parsedObj;\n}", "/**\n * Parse the object for the given object key.\n *\n * @param objKey\n * \t\tkey of object to be parsed\n * @param requireExistingNotCompressedObj\n * \t\tif <code>true</code> the object to be parsed must be defined in xref\n * \t\t(comment: null objects may be missing from xref) and it must not be a compressed object within object stream\n * \t\t(this is used to circumvent being stuck in a loop in a malicious PDF)\n * @return the parsed object (which is also added to document object)\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprotected synchronized COSBase parseObjectDynamically(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    COSObject pdfObject = document.getObjectFromPool(objKey);\n    if (!pdfObject.isObjectNull()) {\n        return pdfObject.getObject();\n    }\n    Long offsetOrObjstmObNr = getObjectOffset(objKey, requireExistingNotCompressedObj);\n    COSBase referencedObject = null;\n    if (offsetOrObjstmObNr != null) {\n        if (offsetOrObjstmObNr > 0) {\n            referencedObject = parseFileObject(offsetOrObjstmObNr, objKey);\n        } else {\n            // xref value is object nr of object stream containing object to be parsed\n            // since our object was not found it means object stream was not parsed so far\n            referencedObject = parseObjectStreamObject(-offsetOrObjstmObNr, objKey);\n        }\n    }\n    if ((referencedObject == null) || (referencedObject instanceof COSNull)) {\n        // not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)\n        // or some other issue with dereferencing\n        // remove parser to avoid endless recursion\n        pdfObject.setToNull();\n    }\n    return referencedObject;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDEmbeddedFile.setMacCreator",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDEmbeddedFile.setMacCreator", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the mac Creator.\n *\n * @param macCreator\n * \t\tThe mac Creator.\n */\npublic void setMacCreator(String macCreator) {\n    COSDictionary params = getCOSObject().getCOSDictionary(COSName.PARAMS);\n    if ((params == null) && (macCreator != null)) {\n        params = new COSDictionary();\n        getCOSObject().setItem(COSName.PARAMS, params);\n    }\n    if (params != null) {\n        params.setEmbeddedString(COSName.MAC, COSName.CREATOR, macCreator);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDWindowsLaunchParams.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDWindowsLaunchParams.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDWindowsLaunchParams() {\n    params = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.DictionaryEncoding.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.DictionaryEncoding.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new DictionaryEncoding for embedding.\n *\n * @param baseEncoding\n * \t\tthe base encoding of this encoding\n * @param differences\n * \t\tthe differences of this encoding with regard to the base encoding\n */\npublic DictionaryEncoding(COSName baseEncoding, COSArray differences) {\n    encoding = new COSDictionary();\n    encoding.setItem(COSName.NAME, COSName.ENCODING);\n    encoding.setItem(COSName.DIFFERENCES, differences);\n    if (baseEncoding != COSName.STANDARD_ENCODING) {\n        encoding.setItem(COSName.BASE_ENCODING, baseEncoding);\n        this.baseEncoding = Encoding.getInstance(baseEncoding);\n    } else {\n        this.baseEncoding = Encoding.getInstance(baseEncoding);\n    }\n    if (this.baseEncoding == null) {\n        throw new IllegalArgumentException(\"Invalid encoding: \" + baseEncoding);\n    }\n    codeToName.putAll(this.baseEncoding.codeToName);\n    inverted.putAll(this.baseEncoding.inverted);\n    applyDifferences();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.closeNode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.closeNode", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.switchNodeCount", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Close this node.\n */\npublic void closeNode() {\n    if (isNodeOpen()) {\n        switchNodeCount();\n    }\n}", "private void switchNodeCount() {\n    int openCount = getOpenCount();\n    setOpenCount(-openCount);\n    updateParentOpenCount(-openCount);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.getString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.getString", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns a hex string of the given byte.\n *\n * @param b\n * \t\tthe byte to be converted\n * @return the hex string representing the given byte\n */\npublic static String getString(byte b) {\n    char[] chars = new char[]{ HEX_CHARS[getHighNibble(b)], HEX_CHARS[getLowNibble(b)] };\n    return new String(chars);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFPageInfo.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFPageInfo.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFPageInfo() {\n    pageInfo = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType5.toPaint",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType5.toPaint", "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Paint toPaint(Matrix matrix) {\n    return new Type5ShadingPaint(this, matrix);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<init>", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.loadList", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new GlyphList from a glyph list file.\n *\n * @param numberOfEntries\n * \t\tnumber of expected values used to preallocate the correct amount of memory\n * @param input\n * \t\tglyph list in Adobe format\n * @throws IOException\n * \t\tif the glyph list could not be read\n */\npublic GlyphList(InputStream input, int numberOfEntries) throws IOException {\n    nameToUnicode = new HashMap<>(numberOfEntries);\n    unicodeToName = new HashMap<>(numberOfEntries);\n    loadList(input);\n}", "private void loadList(InputStream input) throws IOException {\n    try (BufferedReader in = new BufferedReader(new InputStreamReader(input, StandardCharsets.ISO_8859_1))) {\n        while (in.ready()) {\n            String line = in.readLine();\n            if ((line != null) && (!line.startsWith(\"#\"))) {\n                String[] parts = line.split(\";\");\n                if (parts.length < 2) {\n                    throw new IOException(\"Invalid glyph list entry: \" + line);\n                }\n                String name = parts[0];\n                String[] unicodeList = parts[1].split(\" \");\n                int[] codePoints = new int[unicodeList.length];\n                int index = 0;\n                for (String hex : unicodeList) {\n                    codePoints[index++] = Integer.parseInt(hex, 16);\n                }\n                String string = new String(codePoints, 0, codePoints.length);\n                // forward mapping\n                String oldMapping = nameToUnicode.put(name, string);\n                if (oldMapping != null) {\n                    LOG.warn(((((\"duplicate value for \" + name) + \" -> \") + parts[1]) + \" \") + nameToUnicode.get(name));\n                }\n                // reverse mapping\n                // PDFBOX-3884: take the various standard encodings as canonical,\n                // e.g. tilde over ilde\n                final boolean forceOverride = (((WinAnsiEncoding.INSTANCE.contains(name) || MacRomanEncoding.INSTANCE.contains(name)) || MacExpertEncoding.INSTANCE.contains(name)) || SymbolEncoding.INSTANCE.contains(name)) || ZapfDingbatsEncoding.INSTANCE.contains(name);\n                if (forceOverride) {\n                    unicodeToName.put(string, name);\n                } else {\n                    unicodeToName.putIfAbsent(string, name);\n                }\n            }\n        } \n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.setCharacterSet",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.setCharacterSet", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the character set for the font.\n *\n * @param charSet\n * \t\tThe new character set for the font.\n */\npublic void setCharacterSet(String charSet) {\n    COSString name = null;\n    if (charSet != null) {\n        name = new COSString(charSet);\n    }\n    dic.setItem(COSName.CHAR_SET, name);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDHighlightAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDHighlightAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.PDAbstractContentStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationHighlight annotation = ((PDAnnotationHighlight) (getAnnotation()));\n    float[] pathsArray = annotation.getQuadPoints();\n    if (pathsArray == null) {\n        return;\n    }\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    // TODO in a class structure this should be overridable\n    // this is similar to polyline but different data type\n    // TODO padding should consider the curves too; needs to know in advance where the curve is\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    // get the delta used for curves and use it for padding\n    float maxDelta = 0;\n    for (int i = 0; i < (pathsArray.length / 8); ++i) {\n        // one of the two is 0, depending whether the rectangle is\n        // horizontal or vertical\n        // if it is diagonal then... uh...\n        float delta = Math.max((pathsArray[i + 0] - pathsArray[i + 4]) / 4, (pathsArray[i + 1] - pathsArray[i + 5]) / 4);\n        maxDelta = Math.max(delta, maxDelta);\n    }\n    rect.setLowerLeftX(Math.min((minX - (ab.width / 2)) - maxDelta, rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min((minY - (ab.width / 2)) - maxDelta, rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max((maxX + ab.width) + maxDelta, rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max((maxY + ab.width) + maxDelta, rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        PDExtendedGraphicsState r0 = new PDExtendedGraphicsState();\n        PDExtendedGraphicsState r1 = new PDExtendedGraphicsState();\n        r0.setAlphaSourceFlag(false);\n        r0.setStrokingAlphaConstant(annotation.getConstantOpacity());\n        r0.setNonStrokingAlphaConstant(annotation.getConstantOpacity());\n        r1.setAlphaSourceFlag(false);\n        r1.setBlendMode(BlendMode.MULTIPLY);\n        cs.setGraphicsStateParameters(r0);\n        cs.setGraphicsStateParameters(r1);\n        PDFormXObject frm1 = new PDFormXObject(createCOSStream());\n        PDFormXObject frm2 = new PDFormXObject(createCOSStream());\n        frm1.setResources(new PDResources());\n        try (PDFormContentStream mwfofrmCS = new PDFormContentStream(frm1)) {\n            mwfofrmCS.drawForm(frm2);\n        }\n        frm1.setBBox(annotation.getRectangle());\n        frm1.setGroup(new PDTransparencyGroupAttributes());\n        cs.drawForm(frm1);\n        frm2.setBBox(annotation.getRectangle());\n        try (PDFormContentStream frm2CS = new PDFormContentStream(frm2)) {\n            frm2CS.setNonStrokingColor(color);\n            int of = 0;\n            while ((of + 7) < pathsArray.length) {\n                // quadpoints spec sequence is incorrect, correct one is (4,5 0,1 2,3 6,7)\n                // https://stackoverflow.com/questions/9855814/pdf-spec-vs-acrobat-creation-quadpoints\n                // for \"curvy\" highlighting, two BÃ©zier control points are used that seem to have a\n                // distance of about 1/4 of the height.\n                // note that curves won't appear if outside of the rectangle\n                float delta = 0;\n                if ((((Float.compare(pathsArray[of + 0], pathsArray[of + 4]) == 0) && (Float.compare(pathsArray[of + 1], pathsArray[of + 3]) == 0)) && (Float.compare(pathsArray[of + 2], pathsArray[of + 6]) == 0)) && (Float.compare(pathsArray[of + 5], pathsArray[of + 7]) == 0)) {\n                    // horizontal highlight\n                    delta = (pathsArray[of + 1] - pathsArray[of + 5]) / 4;\n                } else if ((((Float.compare(pathsArray[of + 1], pathsArray[of + 5]) == 0) && (Float.compare(pathsArray[of + 0], pathsArray[of + 2]) == 0)) && (Float.compare(pathsArray[of + 3], pathsArray[of + 7]) == 0)) && (Float.compare(pathsArray[of + 4], pathsArray[of + 6]) == 0)) {\n                    // vertical highlight\n                    delta = (pathsArray[of + 0] - pathsArray[of + 4]) / 4;\n                }\n                frm2CS.moveTo(pathsArray[of + 4], pathsArray[of + 5]);\n                if (Float.compare(pathsArray[of + 0], pathsArray[of + 4]) == 0) {\n                    // horizontal highlight\n                    frm2CS.curveTo(pathsArray[of + 4] - delta, pathsArray[of + 5] + delta, pathsArray[of + 0] - delta, pathsArray[of + 1] - delta, pathsArray[of + 0], pathsArray[of + 1]);\n                } else if (Float.compare(pathsArray[of + 5], pathsArray[of + 1]) == 0) {\n                    // vertical highlight\n                    frm2CS.curveTo(pathsArray[of + 4] + delta, pathsArray[of + 5] + delta, pathsArray[of + 0] - delta, pathsArray[of + 1] + delta, pathsArray[of + 0], pathsArray[of + 1]);\n                } else {\n                    frm2CS.lineTo(pathsArray[of + 0], pathsArray[of + 1]);\n                }\n                frm2CS.lineTo(pathsArray[of + 2], pathsArray[of + 3]);\n                if (Float.compare(pathsArray[of + 2], pathsArray[of + 6]) == 0) {\n                    // horizontal highlight\n                    frm2CS.curveTo(pathsArray[of + 2] + delta, pathsArray[of + 3] - delta, pathsArray[of + 6] + delta, pathsArray[of + 7] + delta, pathsArray[of + 6], pathsArray[of + 7]);\n                } else if (Float.compare(pathsArray[of + 3], pathsArray[of + 7]) == 0) {\n                    // vertical highlight\n                    frm2CS.curveTo(pathsArray[of + 2] - delta, pathsArray[of + 3] - delta, pathsArray[of + 6] + delta, pathsArray[of + 7] - delta, pathsArray[of + 6], pathsArray[of + 7]);\n                } else {\n                    frm2CS.lineTo(pathsArray[of + 6], pathsArray[of + 7]);\n                }\n                frm2CS.fill();\n                of += 8;\n            } \n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType2Embedder.getCIDFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType2Embedder.getCIDFont", "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the descendant CIDFont.\n */\npublic PDCIDFont getCIDFont() throws IOException {\n    return new PDCIDFontType2(cidFont, parent, ttf);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.setDate",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.setDate", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the date object.\n *\n * @param key\n * \t\tThe key to the date.\n * @param date\n * \t\tThe date to set.\n */\npublic void setDate(COSName key, Calendar date) {\n    setString(key, DateConverter.toString(date));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.COSDictionaryMap.convert",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.COSDictionaryMap.convert", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * This will take a map&lt;java.lang.String,org.apache.pdfbox.pdmodel.COSObjectable&gt;\n * and convert it into a COSDictionary.\n *\n * @param someMap\n * \t\tA map containing COSObjectables\n * @return A proper COSDictionary\n */\npublic static COSDictionary convert(Map<String, ?> someMap) {\n    COSDictionary dic = new COSDictionary();\n    someMap.forEach((name, objectable) -> {\n        COSObjectable object = ((COSObjectable) (objectable));\n        dic.setItem(COSName.getPDFName(name), object.getCOSObject());\n    });\n    return dic;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.measurement.PDRectlinearMeasureDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.measurement.PDRectlinearMeasureDictionary.<init>", "org.apache.pdfbox.pdmodel.interactive.measurement.PDMeasureDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDRectlinearMeasureDictionary() {\n    this.setSubtype(SUBTYPE);\n}", "/**\n * Constructor.\n */\nprotected PDMeasureDictionary() {\n    this.measureDictionary = new COSDictionary();\n    this.getCOSObject().setName(COSName.TYPE, TYPE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.getFontMatrix",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.getFontMatrix", "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<clinit>" ],
    "fullMethods" : [ "@Override\npublic final Matrix getFontMatrix() {\n    if (fontMatrix == null) {\n        List<Number> numbers;\n        if (cidFont != null) {\n            numbers = cidFont.getFontMatrix();\n        } else {\n            try {\n                numbers = t1Font.getFontMatrix();\n            } catch (IOException e) {\n                LOG.debug(\"Couldn't get font matrix - returning default value\", e);\n                return new Matrix(0.001F, 0, 0, 0.001F, 0, 0);\n            }\n        }\n        if ((numbers != null) && (numbers.size() == 6)) {\n            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());\n        } else {\n            fontMatrix = new Matrix(0.001F, 0, 0, 0.001F, 0, 0);\n        }\n    }\n    return fontMatrix;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueMDP.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueMDP.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDSeedValueMDP() {\n    dictionary = new COSDictionary();\n    dictionary.setDirect(true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDAnnotation() {\n    dictionary = new COSDictionary();\n    dictionary.setItem(COSName.TYPE, COSName.ANNOT);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.getCharsUTF16BE",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.getCharsUTF16BE", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Takes the characters in the given string, convert it to bytes in UTF16-BE format\n * and build a char array that corresponds to the ASCII hex encoding of the resulting\n * bytes.\n *\n * Example:\n * <pre>\n *   getCharsUTF16BE(\"ab\") == new char[]{'0','0','6','1','0','0','6','2'}\n * </pre>\n *\n * @param text\n * \t\tThe string to convert\n * @return The string converted to hex\n */\npublic static char[] getCharsUTF16BE(String text) {\n    // Note that the internal representation of string in Java is already UTF-16. Therefore\n    // we do not need to use an encoder to convert the string to its byte representation.\n    char[] hex = new char[text.length() * 4];\n    for (int stringIdx = 0, charIdx = 0; stringIdx < text.length(); stringIdx++) {\n        char c = text.charAt(stringIdx);\n        hex[charIdx++] = HEX_CHARS[(c >> 12) & 0xf];\n        hex[charIdx++] = HEX_CHARS[(c >> 8) & 0xf];\n        hex[charIdx++] = HEX_CHARS[(c >> 4) & 0xf];\n        hex[charIdx++] = HEX_CHARS[c & 0xf];\n    }\n    return hex;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.visitFromStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.visitFromStream", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void visitFromStream(COSStream obj) throws IOException {\n    if (willEncrypt) {\n        pdDocument.getEncryption().getSecurityHandler().encryptStream(obj, currentObjectKey.getNumber(), currentObjectKey.getGeneration());\n    }\n    InputStream input = null;\n    try {\n        // write the stream content\n        visitFromDictionary(obj);\n        getStandardOutput().write(STREAM);\n        getStandardOutput().writeCRLF();\n        if (obj.hasData()) {\n            input = obj.createRawInputStream();\n            IOUtils.copy(input, getStandardOutput());\n        }\n        getStandardOutput().writeCRLF();\n        getStandardOutput().write(ENDSTREAM);\n        getStandardOutput().writeEOL();\n    } finally {\n        if (input != null) {\n            input.close();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.iterator",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.iterator", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.<init>", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.<init>", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.enqueueKids", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns an iterator which walks all pages in the tree, in order.\n */\n@Override\npublic Iterator<PDPage> iterator() {\n    return new PageIterator(root);\n}", "private PageIterator(COSDictionary node) {\n    enqueueKids(node);\n    set = null;// release memory, we don't use this anymore\n\n}", "private PageIterator(COSDictionary node) {\n    enqueueKids(node);\n    set = null;// release memory, we don't use this anymore\n\n}", "private void enqueueKids(COSDictionary node) {\n    if (isPageTreeNode(node)) {\n        List<COSDictionary> kids = getKids(node);\n        for (COSDictionary kid : kids) {\n            if (set.contains(kid)) {\n                // PDFBOX-5009, PDFBOX-3953: prevent stack overflow with malformed PDFs\n                LOG.error(\"This page tree node has already been visited\");\n                continue;\n            } else if (kid.containsKey(COSName.KIDS)) {\n                set.add(kid);\n            }\n            enqueueKids(kid);\n        }\n    } else if ((node != null) && COSName.PAGE.equals(node.getCOSName(COSName.TYPE))) {\n        queue.add(node);\n    } else {\n        LOG.error(\"Page skipped due to an invalid or missing type \" + (node == null ? \"(null)\" : node.getCOSName(COSName.TYPE)));\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDMarkInfo.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDMarkInfo.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default Constructor.\n */\npublic PDMarkInfo() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getNames",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getNames", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * This will return a map of names on this level. The key will be a string,\n * and the value will depend on where this class is being used.\n *\n * @return ordered map of COS objects or <code>null</code> if the dictionary\ncontains no 'Names' entry on this level.\n * @throws IOException\n * \t\tIf there is an error while creating the sub types.\n * @see #getKids()\n */\npublic Map<String, T> getNames() throws IOException {\n    COSArray namesArray = node.getCOSArray(COSName.NAMES);\n    if (namesArray != null) {\n        int size = namesArray.size();\n        Map<String, T> names = new LinkedHashMap<>(size);\n        if ((namesArray.size() % 2) != 0) {\n            LOG.warn(\"Names array has odd size: \" + size);\n        }\n        for (int i = 0; (i + 1) < size; i += 2) {\n            COSBase base = namesArray.getObject(i);\n            if (!(base instanceof COSString)) {\n                throw new IOException(((\"Expected string, found \" + base) + \" in name tree at index \") + i);\n            }\n            COSString key = ((COSString) (base));\n            COSBase cosValue = namesArray.getObject(i + 1);\n            names.put(key.getString(), convertCOSToPD(cosValue));\n        }\n        return Collections.unmodifiableMap(names);\n    } else {\n        return null;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.writeString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.writeString", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * This will output the given byte getString as a PDF object.\n *\n * @param string\n * \t\tCOSString to be written\n * @param output\n * \t\tThe stream to write to.\n * @throws IOException\n * \t\tIf there is an error writing to the stream.\n */\npublic static void writeString(COSString string, OutputStream output) throws IOException {\n    writeString(string.getBytes(), string.getForceHexForm(), output);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType3Font.readEncoding", "org.apache.pdfbox.pdmodel.font.PDType3Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param resourceCache\n * \t\tResource cache, can be null.\n * @throws IOException\n * \t\tif the font could not be created\n */\npublic PDType3Font(COSDictionary fontDictionary, ResourceCache resourceCache) throws IOException {\n    super(fontDictionary);\n    this.resourceCache = resourceCache;\n    readEncoding();\n}", "@Override\nprotected final void readEncoding() throws IOException {\n    COSBase encodingBase = dict.getDictionaryObject(COSName.ENCODING);\n    if (encodingBase instanceof COSName) {\n        COSName encodingName = ((COSName) (encodingBase));\n        encoding = Encoding.getInstance(encodingName);\n        if (encoding == null) {\n            LOG.warn(\"Unknown encoding: \" + encodingName.getName());\n        }\n    } else if (encodingBase instanceof COSDictionary) {\n        encoding = new DictionaryEncoding(((COSDictionary) (encodingBase)));\n    }\n    glyphList = GlyphList.getAdobeGlyphList();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDCalRGB.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDCalRGB.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new CalRGB color space using the given COS array.\n *\n * @param rgb\n * \t\tthe cos array which represents this color space\n */\npublic PDCalRGB(COSArray rgb) {\n    super(rgb);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDIndexed.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDIndexed.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new indexed color space from the given PDF array.\n *\n * @param indexedArray\n * \t\tthe array containing the indexed parameters\n * @param resources\n * \t\tthe resources, can be null. Allows to use its cache for the colorspace.\n * @throws IOException\n * \t\tif the colorspace could not be created\n */\npublic PDIndexed(COSArray indexedArray, PDResources resources) throws IOException {\n    array = indexedArray;\n    // don't call getObject(1), we want to pass a reference if possible\n    // to profit from caching (PDFBOX-4149)\n    baseColorSpace = PDColorSpace.create(array.get(1), resources);\n    readColorTable();\n    initRgbColorTable();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n * <p>\n * The method returns null if there was an error opening the font.\n */\n@Override\npublic synchronized FontBoxFont getFont() {\n    // synchronized to avoid race condition on cache access,\n    // which could result in an unreferenced but open font\n    FontBoxFont cached = parent.cache.getFont(this);\n    if (cached != null) {\n        return cached;\n    } else {\n        FontBoxFont font;\n        switch (format) {\n            case PFB :\n                font = getType1Font(postScriptName, file);\n                break;\n            case TTF :\n                font = getTrueTypeFont(postScriptName, file);\n                break;\n            case OTF :\n                font = getOTFFont(postScriptName, file);\n                break;\n            default :\n                throw new RuntimeException(\"can't happen\");\n        }\n        if (font != null) {\n            parent.cache.addFont(this, font);\n        }\n        return font;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showForm",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showForm", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStream", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.PDFStreamParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Shows a form from the content stream.\n *\n * @param form\n * \t\tform XObject\n * @throws IOException\n * \t\tif the form cannot be processed\n */\npublic void showForm(PDFormXObject form) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    if (form.getCOSObject().getLength() > 0) {\n        processStream(form);\n    }\n}", "/**\n * Process a content stream.\n *\n * @param contentStream\n * \t\tthe content stream\n * @throws IOException\n * \t\tif there is an exception while processing the stream\n */\nprivate void processStream(PDContentStream contentStream) throws IOException {\n    PDResources parent = pushResources(contentStream);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(contentStream.getMatrix());\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // clip to bounding box\n    PDRectangle bbox = contentStream.getBBox();\n    clipToRect(bbox);\n    try {\n        processStreamOperators(contentStream);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeUserPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeUserPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * This will compute the user password hash.\n *\n * @param password\n * \t\tThe plain text password.\n * @param owner\n * \t\tThe owner password hash.\n * @param permissions\n * \t\tThe document permissions.\n * @param id\n * \t\tThe document id.\n * @param encRevision\n * \t\tThe revision of the encryption.\n * @param keyLengthInBytes\n * \t\tThe length of the encryption key in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata\n * @return The user password.\n * @throws IOException\n * \t\tif the password could not be computed\n */\npublic byte[] computeUserPassword(byte[] password, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException {\n    // TODO!?!?\n    if ((encRevision == REVISION_5) || (encRevision == REVISION_6)) {\n        return new byte[0];\n    }\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\n    byte[] encKey = computeEncryptedKeyRev234(password, owner, permissions, id, encryptMetadata, keyLengthInBytes, encRevision);\n    if (encRevision == REVISION_2) {\n        encryptDataRC4(encKey, ENCRYPT_PADDING, result);\n    } else if ((encRevision == REVISION_3) || (encRevision == REVISION_4)) {\n        MessageDigest md = MessageDigests.getMD5();\n        md.update(ENCRYPT_PADDING);\n        md.update(id);\n        result.write(md.digest());\n        byte[] iterationKey = new byte[encKey.length];\n        for (int i = 0; i < 20; i++) {\n            System.arraycopy(encKey, 0, iterationKey, 0, iterationKey.length);\n            for (int j = 0; j < iterationKey.length; j++) {\n                iterationKey[j] = ((byte) (iterationKey[j] ^ i));\n            }\n            ByteArrayInputStream input = new ByteArrayInputStream(result.toByteArray());\n            result.reset();\n            encryptDataRC4(iterationKey, input, result);\n        }\n        byte[] finalResult = new byte[32];\n        System.arraycopy(result.toByteArray(), 0, finalResult, 0, 16);\n        System.arraycopy(ENCRYPT_PADDING, 0, finalResult, 16, 16);\n        result.reset();\n        result.write(finalResult);\n    }\n    return result.toByteArray();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFCatalog.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFCatalog.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param cat\n * \t\tThe FDF documents catalog.\n */\npublic FDFCatalog(COSDictionary cat) {\n    catalog = cat;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.process", "org.apache.pdfbox.pdmodel.PDDocument.getDocumentCatalog", "org.apache.pdfbox.pdmodel.PDDocumentCatalog.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process() {\n    /* Get the AcroForm in it's current state.\n\n    Also note: getAcroForm() applies a default fixup which this processor\n    is part of. So keep the null parameter otherwise this will end\n    in an endless recursive call\n     */\n    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm(null);\n    if (acroForm != null) {\n        resolveFieldsFromWidgets(acroForm);\n    }\n}", "/**\n * This will get the document CATALOG. This is guaranteed to not return null.\n *\n * @return The documents /Root dictionary\n */\npublic PDDocumentCatalog getDocumentCatalog() {\n    if (documentCatalog == null) {\n        COSDictionary trailer = document.getTrailer();\n        COSDictionary dictionary = trailer.getCOSDictionary(COSName.ROOT);\n        if (dictionary != null) {\n            documentCatalog = new PDDocumentCatalog(this, dictionary);\n        } else {\n            documentCatalog = new PDDocumentCatalog(this);\n        }\n    }\n    return documentCatalog;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setOwnerKey",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setOwnerKey", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the O entry in the standard encryption dictionary.\n *\n * @param o\n * \t\tA 32 byte array or null if there is no owner key.\n * @throws IOException\n * \t\tIf there is an error setting the data.\n */\npublic void setOwnerKey(byte[] o) throws IOException {\n    dictionary.setItem(COSName.O, new COSString(o));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.DrawObject.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.DrawObject.process", "org.apache.pdfbox.contentstream.operator.graphics.DrawObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.isEmpty()) {\n        throw new MissingOperandException(operator, operands);\n    }\n    COSBase base0 = operands.get(0);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    COSName objectName = ((COSName) (base0));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    PDXObject xobject = context.getResources().getXObject(objectName);\n    if (xobject == null) {\n        throw new MissingResourceException(\"Missing XObject: \" + objectName.getName());\n    } else if (xobject instanceof PDImageXObject) {\n        PDImageXObject image = ((PDImageXObject) (xobject));\n        if ((!image.isStencil()) && (!context.isShouldProcessColorOperators())) {\n            return;\n        }\n        context.drawImage(image);\n    } else if (xobject instanceof PDFormXObject) {\n        try {\n            context.increaseLevel();\n            if (context.getLevel() > 50) {\n                LOG.error(\"recursion is too deep, skipping form XObject\");\n                return;\n            }\n            if (xobject instanceof PDTransparencyGroup) {\n                context.showTransparencyGroup(((PDTransparencyGroup) (xobject)));\n            } else {\n                context.showForm(((PDFormXObject) (xobject)));\n            }\n        } finally {\n            context.decreaseLevel();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.ClosePath.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.ClosePath.process", "org.apache.pdfbox.contentstream.operator.graphics.ClosePath.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    if (context.getCurrentPoint() == null) {\n        LOG.warn(\"ClosePath without initial MoveTo\");\n        return;\n    }\n    context.closePath();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given image to the resources of the current page and returns the name for the\n * new resources. Returns the existing resource name if the given item already exists.\n *\n * @param image\n * \t\tthe image to add\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDImageXObject image) {\n    return add(COSName.XOBJECT, \"Im\", image);\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.addFirst",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.addFirst", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCountForAddedChild", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given node to the top of the children list.\n *\n * @param newChild\n * \t\tThe node to add.\n * @throws IllegalArgumentException\n * \t\tif the given node is part of a list (i.e. if it has a previous or a next\n * \t\tsibling)\n */\npublic void addFirst(PDOutlineItem newChild) {\n    requireSingleNode(newChild);\n    prepend(newChild);\n    updateParentOpenCountForAddedChild(newChild);\n}", "void updateParentOpenCountForAddedChild(PDOutlineItem newChild) {\n    int delta = 1;\n    if (newChild.isNodeOpen()) {\n        delta += newChild.getOpenCount();\n    }\n    newChild.updateParentOpenCount(delta);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createWidgetDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createWidgetDictionary", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createWidgetDictionary(PDSignatureField signatureField, PDResources holderFormResources) throws IOException {\n    COSDictionary widgetDict = signatureField.getWidgets().get(0).getCOSObject();\n    widgetDict.setNeedToBeUpdated(true);\n    widgetDict.setItem(COSName.DR, holderFormResources.getCOSObject());\n    pdfStructure.setWidgetDictionary(widgetDict);\n    LOG.info(\"WidgetDictionary has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDJavascriptNameTreeNode.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDJavascriptNameTreeNode.<init>", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDJavascriptNameTreeNode() {\n}", "/**\n * Constructor.\n */\nprotected PDNameTreeNode() {\n    node = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDStream.getDecodeParms",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDStream.getDecodeParms", "org.apache.pdfbox.pdmodel.common.PDStream.internalGetDecodeParams", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the list of decode parameters. Each entry in the list will refer to\n * an entry in the filters list.\n *\n * @return The list of decode parameters.\n * @throws IOException\n * \t\tif there is an error retrieving the parameters.\n */\npublic List<Object> getDecodeParms() throws IOException {\n    // See PDF Ref 1.5 implementation note 7, /DP is sometimes used instead.\n    return internalGetDecodeParams(COSName.DECODE_PARMS, COSName.DP);\n}", "private List<Object> internalGetDecodeParams(COSName name1, COSName name2) throws IOException {\n    COSBase dp = stream.getDictionaryObject(name1, name2);\n    if (dp instanceof COSDictionary) {\n        Map<?, ?> map = COSDictionaryMap.convertBasicTypesToMap(((COSDictionary) (dp)));\n        return new COSArrayList<>(map, dp, stream, name1);\n    }\n    if (dp instanceof COSArray) {\n        COSArray array = ((COSArray) (dp));\n        List<Object> actuals = new ArrayList<>(array.size());\n        for (int i = 0; i < array.size(); i++) {\n            COSBase base = array.getObject(i);\n            if (base instanceof COSDictionary) {\n                actuals.add(COSDictionaryMap.convertBasicTypesToMap(((COSDictionary) (base))));\n            } else {\n                LOG.warn((\"Expected COSDictionary, got \" + base) + \", ignored\");\n            }\n        }\n        return new COSArrayList<>(actuals, array);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.JPXFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.JPXFilter.decode", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException {\n    DecodeResult result = new DecodeResult(new COSDictionary());\n    result.getParameters().addAll(parameters);\n    BufferedImage image = readJPX(encoded, options, result);\n    Raster raster = image.getRaster();\n    switch (raster.getDataBuffer().getDataType()) {\n        case DataBuffer.TYPE_BYTE :\n            DataBufferByte byteBuffer = ((DataBufferByte) (raster.getDataBuffer()));\n            decoded.write(byteBuffer.getData());\n            return result;\n        case DataBuffer.TYPE_USHORT :\n            DataBufferUShort wordBuffer = ((DataBufferUShort) (raster.getDataBuffer()));\n            for (short w : wordBuffer.getData()) {\n                decoded.write(w >> 8);\n                decoded.write(w);\n            }\n            return result;\n        case DataBuffer.TYPE_INT :\n            // not yet used (as of October 2018) but works as fallback\n            // if we decide to convert to BufferedImage.TYPE_INT_RGB\n            int[] ar = new int[raster.getNumBands()];\n            for (int y = 0; y < image.getHeight(); ++y) {\n                for (int x = 0; x < image.getWidth(); ++x) {\n                    raster.getPixel(x, y, ar);\n                    for (int i = 0; i < ar.length; ++i) {\n                        decoded.write(ar[i]);\n                    }\n                }\n            }\n            return result;\n        default :\n            throw new IOException((\"Data type \" + raster.getDataBuffer().getDataType()) + \" not implemented\");\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDEncryption.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDEncryption.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * creates a new empty encryption dictionary.\n */\npublic PDEncryption() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFileUnix",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFileUnix", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the embedded Unix file.\n *\n * @return The embedded file for this file spec.\n */\npublic PDEmbeddedFile getEmbeddedFileUnix() {\n    COSBase base = getObjectFromEFDictionary(COSName.UNIX);\n    if (base instanceof COSStream) {\n        return new PDEmbeddedFile(((COSStream) (base)));\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    if (((region == null) && (subsampling == cachedImageSubsampling)) && (cachedImage != null)) {\n        BufferedImage cached = cachedImage.get();\n        if (cached != null) {\n            return cached;\n        }\n    }\n    initJPXValues();\n    // get RGB image w/o reference because applyMask might modify it, take long time and a lot of memory.\n    final BufferedImage image;\n    final PDImageXObject softMask = getSoftMask();\n    final PDImageXObject mask = getMask();\n    if (jpxSMask != null) {\n        // PDFBOX-5657: handle JPEG2000 SMaskInData\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), jpxSMask, false, true, null);\n    } else if (softMask != null) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), softMask.getOpaqueImage(region, subsampling), softMask.getInterpolate(), true, extractMatte(softMask));\n    } else if ((mask != null) && mask.isStencil()) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), mask.getOpaqueImage(region, subsampling), mask.getInterpolate(), false, null);\n    } else {\n        image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());\n    }\n    if ((region == null) && (subsampling <= cachedImageSubsampling)) {\n        // only cache full-image renders, and prefer lower subsampling frequency, as lower\n        // subsampling means higher quality and longer render times.\n        cachedImageSubsampling = subsampling;\n        cachedImage = new SoftReference<>(image);\n    }\n    return image;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createVisualSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createVisualSignature", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createVisualSignature(PDDocument template) {\n    pdfStructure.setVisualSignature(template.getDocument());\n    LOG.info(\"Visible signature has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getNumbers",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getNumbers", "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * This will return a map of numbers on this level. The key will be a java.lang.Integer, the\n * value will depend on where this class is being used.\n *\n * @return A map of COS objects.\n * @throws IOException\n * \t\tIf there is a problem creating the values.\n */\npublic Map<Integer, COSObjectable> getNumbers() throws IOException {\n    Map<Integer, COSObjectable> indices = null;\n    COSArray numbersArray = node.getCOSArray(COSName.NUMS);\n    if (numbersArray != null) {\n        int size = numbersArray.size();\n        indices = new HashMap<>();\n        if ((size % 2) != 0) {\n            LOG.warn(\"Numbers array has odd size: \" + size);\n        }\n        for (int i = 0; (i + 1) < size; i += 2) {\n            COSBase base = numbersArray.getObject(i);\n            if (!(base instanceof COSInteger)) {\n                LOG.error(((\"page labels ignored, index \" + i) + \" should be a number, but is \") + base);\n                return null;\n            }\n            COSInteger key = ((COSInteger) (base));\n            COSBase cosValue = numbersArray.getObject(i + 1);\n            indices.put(key.intValue(), cosValue == null ? null : convertCOSToPD(cosValue));\n        }\n        indices = Collections.unmodifiableMap(indices);\n    }\n    return indices;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a vertical Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param ttf\n * \t\tA TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font loadVertical(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException {\n    return new PDType0Font(doc, ttf, embedSubset, false, true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.toPaint",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.toPaint", "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Paint toPaint(Matrix matrix) {\n    return new Type6ShadingPaint(this, matrix);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.<init>", "org.apache.pdfbox.pdmodel.graphics.PDXObject.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a Form XObject for reading.\n *\n * @param stream\n * \t\tThe XObject stream\n */\npublic PDFormXObject(PDStream stream) {\n    super(stream, COSName.FORM);\n    cache = null;\n}", "/**\n * Creates a new XObject from the given stream and subtype.\n *\n * @param stream\n * \t\tThe stream to read.\n * @param subtype\n * \t\tthe subtype to be used for this XObject\n */\nprotected PDXObject(COSStream stream, COSName subtype) {\n    this.stream = new PDStream(stream);\n    // could be used for writing:\n    stream.setName(COSName.TYPE, COSName.XOBJECT.getName());\n    stream.setName(COSName.SUBTYPE, subtype.getName());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.getContents",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.getContents", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.getConvertedContents", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Will return the embedded signature between the byterange gap.\n *\n * @param pdfFile\n * \t\tThe signed pdf file as byte array\n * @return a byte array containing the signature\n * @throws IOException\n * \t\tif the pdfFile can't be read\n * @throws IndexOutOfBoundsException\n * \t\tif the byterange array is not long enough\n */\npublic byte[] getContents(byte[] pdfFile) throws IOException {\n    int[] byteRange = getByteRange();\n    int begin = (byteRange[0] + byteRange[1]) + 1;\n    int len = (byteRange[2] - begin) - 1;\n    return getConvertedContents(new ByteArrayInputStream(pdfFile, begin, len));\n}", "private byte[] getConvertedContents(InputStream is) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n    byte[] buffer = new byte[1024];\n    int readLen;\n    while ((readLen = is.read(buffer)) != (-1)) {\n        int writeLen = readLen;\n        int start = 0;\n        // Filter < and (\n        if ((buffer[0] == 0x3c) || (buffer[0] == 0x28)) {\n            ++start;\n            --writeLen;\n        }\n        // Filter > and ) at the end\n        if ((buffer[readLen - 1] == 0x3e) || (buffer[readLen - 1] == 0x29)) {\n            --writeLen;\n        }\n        baos.write(buffer, start, writeLen);\n    } \n    is.close();\n    return COSString.parseHex(baos.toString(StandardCharsets.ISO_8859_1.name())).getBytes();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.getFontFile2",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontDescriptor.getFontFile2", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * A stream containing a true type font program.\n *\n * @return A stream containing a true type font program.\n */\npublic PDStream getFontFile2() {\n    COSStream stream = dic.getCOSStream(COSName.FONT_FILE2);\n    return stream != null ? new PDStream(stream) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.prepareDocumentForEncryption",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.prepareDocumentForEncryption", "org.apache.pdfbox.pdmodel.encryption.PDEncryption.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Prepare the document for encryption.\n *\n * @param doc\n * \t\tThe document that will be encrypted.\n * @throws IOException\n * \t\tIf there is an error while encrypting.\n */\n@Override\npublic void prepareDocumentForEncryption(PDDocument doc) throws IOException {\n    try {\n        PDEncryption dictionary = doc.getEncryption();\n        if (dictionary == null) {\n            dictionary = new PDEncryption();\n        }\n        dictionary.setFilter(FILTER);\n        dictionary.setLength(getKeyLength());\n        int version = computeVersionNumber();\n        dictionary.setVersion(version);\n        // remove CF, StmF, and StrF entries that may be left from a previous encryption\n        dictionary.removeV45filters();\n        // create the 20 bytes seed\n        byte[] seed = new byte[20];\n        KeyGenerator key;\n        try {\n            key = KeyGenerator.getInstance(\"AES\");\n        } catch (NoSuchAlgorithmException e) {\n            // should never happen\n            throw new RuntimeException(e);\n        }\n        key.init(192, new SecureRandom());\n        SecretKey sk = key.generateKey();\n        // create the 20 bytes seed\n        System.arraycopy(sk.getEncoded(), 0, seed, 0, 20);\n        byte[][] recipientsFields = computeRecipientsField(seed);\n        int shaInputLength = seed.length;\n        for (byte[] field : recipientsFields) {\n            shaInputLength += field.length;\n        }\n        byte[] shaInput = new byte[shaInputLength];\n        System.arraycopy(seed, 0, shaInput, 0, 20);\n        int shaInputOffset = 20;\n        for (byte[] recipientsField : recipientsFields) {\n            System.arraycopy(recipientsField, 0, shaInput, shaInputOffset, recipientsField.length);\n            shaInputOffset += recipientsField.length;\n        }\n        byte[] mdResult;\n        switch (version) {\n            case 4 :\n                dictionary.setSubFilter(SUBFILTER5);\n                mdResult = MessageDigests.getSHA1().digest(shaInput);\n                prepareEncryptionDictAES(dictionary, COSName.AESV2, recipientsFields);\n                break;\n            case 5 :\n                dictionary.setSubFilter(SUBFILTER5);\n                mdResult = MessageDigests.getSHA256().digest(shaInput);\n                prepareEncryptionDictAES(dictionary, COSName.AESV3, recipientsFields);\n                break;\n            default :\n                dictionary.setSubFilter(SUBFILTER4);\n                mdResult = MessageDigests.getSHA1().digest(shaInput);\n                dictionary.setRecipients(recipientsFields);\n                break;\n        }\n        setEncryptionKey(new byte[getKeyLength() / 8]);\n        System.arraycopy(mdResult, 0, getEncryptionKey(), 0, getKeyLength() / 8);\n        doc.setEncryptionDictionary(dictionary);\n        doc.getDocument().setEncryptionDictionary(dictionary.getCOSObject());\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n}", "/**\n * creates a new empty encryption dictionary.\n */\npublic PDEncryption() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptString", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptData", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptDataAES256", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * This will encrypt a string.\n *\n * @param string\n * \t\tthe string to encrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf an error occurs writing the new string.\n */\npublic void encryptString(COSString string, long objNum, int genNum) throws IOException {\n    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    /* encrypt */\n    encryptData(objNum, genNum, data, buffer, false);\n    string.setValue(buffer.toByteArray());\n}", "/**\n * Encrypt or decrypt a set of data.\n *\n * @param objectNumber\n * \t\tThe data object number.\n * @param genNumber\n * \t\tThe data generation number.\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptData(long objectNumber, long genNumber, InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    // Determine whether we're using Algorithm 1 (for RC4 and AES-128), or 1.A (for AES-256)\n    if (useAES && (encryptionKey.length == 32)) {\n        encryptDataAES256(data, output, decrypt);\n    } else {\n        byte[] finalKey = calcFinalKey(objectNumber, genNumber);\n        if (useAES) {\n            encryptDataAESother(finalKey, data, output, decrypt);\n        } else {\n            encryptDataRC4(finalKey, data, output);\n        }\n    }\n    output.flush();\n}", "/**\n * Encrypt or decrypt data with AES256.\n *\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptDataAES256(InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    byte[] iv = new byte[16];\n    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {\n        return;\n    }\n    Cipher cipher;\n    try {\n        cipher = createCipher(this.encryptionKey, iv, decrypt);\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n    try (CipherInputStream cis = new CipherInputStream(data, cipher)) {\n        IOUtils.copy(cis, output);\n    } catch (IOException exception) {\n        // starting with java 8 the JVM wraps an IOException around a GeneralSecurityException\n        // it should be safe to swallow a GeneralSecurityException\n        if (!(exception.getCause() instanceof GeneralSecurityException)) {\n            throw exception;\n        }\n        LOG.debug(\"A GeneralSecurityException occurred when decrypting some stream data\", exception);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDSignature() {\n    dictionary = new COSDictionary();\n    dictionary.setItem(COSName.TYPE, COSName.SIG);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getHeight",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getHeight", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic int getHeight() {\n    initJPXValues();\n    return getCOSObject().getInt(COSName.HEIGHT);\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getContentsForRandomAccess",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getContentsForRandomAccess", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "@Override\npublic RandomAccessRead getContentsForRandomAccess() throws IOException {\n    COSStream contentStream = page.getCOSStream(COSName.CONTENTS);\n    if (contentStream != null) {\n        try {\n            return contentStream.createView();\n        } catch (IOException exception) {\n            LOG.warn(\"skipped malformed content stream\");\n            return new RandomAccessReadBuffer(DELIMITER);\n        }\n    }\n    COSArray array = page.getCOSArray(COSName.CONTENTS);\n    if (array != null) {\n        List<COSStream> streams = // \n        // \n        // \n        // \n        array.toList().stream().map(o -> o instanceof COSObject ? ((COSObject) (o)).getObject() : o).filter(COSStream.class::isInstance).map(b -> ((COSStream) (b))).collect(Collectors.toList());\n        List<RandomAccessRead> inputStreams = new ArrayList<>();\n        streams.forEach(stream -> {\n            try {\n                inputStreams.add(stream.createView());\n                inputStreams.add(new RandomAccessReadBuffer(DELIMITER));\n            } catch (IOException exception) {\n                LOG.warn(\"malformed substream of content stream skipped\");\n            }\n        });\n        if (!inputStreams.isEmpty()) {\n            return new SequenceRandomAccessRead(inputStreams);\n        }\n    }\n    return new RandomAccessReadBuffer(new byte[0]);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFontCache",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFontCache", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the font cache associated with this FontMapper. This method is needed by\n * FontProvider subclasses.\n */\npublic FontCache getFontCache() {\n    return fontCache;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setCryptFilterDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setCryptFilterDictionary", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the crypt filter with the given name.\n *\n * @param cryptFilterName\n * \t\tthe name of the crypt filter\n * @param cryptFilterDictionary\n * \t\tthe crypt filter to set\n */\npublic void setCryptFilterDictionary(COSName cryptFilterName, PDCryptFilterDictionary cryptFilterDictionary) {\n    COSDictionary cfDictionary = dictionary.getCOSDictionary(COSName.CF);\n    if (cfDictionary == null) {\n        cfDictionary = new COSDictionary();\n        dictionary.setItem(COSName.CF, cfDictionary);\n    }\n    cfDictionary.setDirect(true);// PDFBOX-4436 direct obj needed for Adobe Reader on Android\n\n    cfDictionary.setItem(cryptFilterName, cryptFilterDictionary.getCOSObject());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingContext.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new AxialShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDObjectStream.createStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDObjectStream.createStream", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * This will create a new PDObjectStream object.\n *\n * @param document\n * \t\tThe document that the stream will be part of.\n * @return A new stream object.\n */\npublic static PDObjectStream createStream(PDDocument document) {\n    COSStream cosStream = document.getDocument().createCOSStream();\n    PDObjectStream strm = new PDObjectStream(cosStream);\n    strm.getCOSObject().setItem(COSName.TYPE, COSName.OBJ_STM);\n    return strm;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType1Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.setEmbeddedInt",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.setEmbeddedInt", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * This is a convenience method that will convert the value to a COSInteger object.\n *\n * @param embeddedDictionary\n * \t\tThe embedded dictionary.\n * @param key\n * \t\tThe key to the object,\n * @param value\n * \t\tThe int value for the name.\n */\npublic void setEmbeddedInt(COSName embeddedDictionary, COSName key, int value) {\n    COSDictionary embedded = getCOSDictionary(embeddedDictionary);\n    if (embedded == null) {\n        embedded = new COSDictionary();\n        setItem(embeddedDictionary, embedded);\n    }\n    embedded.setInt(key, value);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.writeHexBytes",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.writeHexBytes", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Writes the given byte array as hex value to the given output stream.\n *\n * @param bytes\n * \t\tthe byte array to be written\n * @param output\n * \t\tthe output stream to be written to\n * @throws IOException\n * \t\texception if anything went wrong\n */\npublic static void writeHexBytes(byte[] bytes, OutputStream output) throws IOException {\n    for (byte b : bytes) {\n        writeHexByte(b, output);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDRadioButton.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDRadioButton.<init>", "org.apache.pdfbox.pdmodel.interactive.form.PDButton.<init>", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @see PDField#PDField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroform.\n */\npublic PDRadioButton(PDAcroForm acroForm) {\n    super(acroForm);\n    getCOSObject().setFlag(COSName.FF, FLAG_RADIO, true);\n}", "/**\n *\n * @see PDField#PDField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroform.\n */\nPDButton(PDAcroForm acroForm) {\n    super(acroForm);\n    getCOSObject().setItem(COSName.FT, COSName.BTN);\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDSeparation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDSeparation.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new Separation color space.\n */\npublic PDSeparation() {\n    array = new COSArray();\n    array.add(COSName.SEPARATION);\n    array.add(COSName.getPDFName(\"\"));\n    // add some placeholder\n    array.add(COSNull.NULL);\n    array.add(COSNull.NULL);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAcroFormDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAcroFormDictionary", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createAcroFormDictionary(PDAcroForm acroForm, PDSignatureField signatureField) throws IOException {\n    @SuppressWarnings(\"unchecked\")\n    List<PDField> acroFormFields = acroForm.getFields();\n    COSDictionary acroFormDict = acroForm.getCOSObject();\n    acroForm.setSignaturesExist(true);\n    acroForm.setAppendOnly(true);\n    acroFormDict.setDirect(true);\n    acroFormFields.add(signatureField);\n    // WTF sylfaen?\n    acroForm.setDefaultAppearance(\"/sylfaen 0 Tf 0 g\");\n    pdfStructure.setAcroFormFields(acroFormFields);\n    pdfStructure.setAcroFormDictionary(acroFormDict);\n    LOG.info(\"AcroForm dictionary has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setNonStrokingColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setNonStrokingColor", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB.<clinit>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the non-stroking color in the DeviceRGB color space. Range is 0..1.\n *\n * @param r\n * \t\tThe red value.\n * @param g\n * \t\tThe green value.\n * @param b\n * \t\tThe blue value.\n * @throws IOException\n * \t\tIf an IO error occurs while writing to the stream.\n * @throws IllegalArgumentException\n * \t\tIf the parameters are invalid.\n */\npublic void setNonStrokingColor(float r, float g, float b) throws IOException {\n    if ((isOutsideOneInterval(r) || isOutsideOneInterval(g)) || isOutsideOneInterval(b)) {\n        throw new IllegalArgumentException(\"Parameters must be within 0..1, but are \" + String.format(\"(%.2f,%.2f,%.2f)\", r, g, b));\n    }\n    writeOperand(r);\n    writeOperand(g);\n    writeOperand(b);\n    writeOperator(OperatorName.NON_STROKING_RGB);\n    setNonStrokingColorSpaceStack(PDDeviceRGB.INSTANCE);\n}", "", "private PDDeviceRGB() {\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigProperties.buildSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigProperties.buildSignature", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "/**\n * start building of visible signature\n *\n * @throws IOException\n * \t\tif the output could not be written\n */\npublic void buildSignature() throws IOException {\n    PDFTemplateBuilder builder = new PDVisibleSigBuilder();\n    PDFTemplateCreator creator = new PDFTemplateCreator(builder);\n    setVisibleSignature(creator.buildPDF(getPdVisibleSignature()));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.injectProcSetArray",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.injectProcSetArray", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void injectProcSetArray(PDFormXObject innerForm, PDPage page, PDResources innerFormResources, PDResources imageFormResources, PDResources holderFormResources, COSArray procSet) {\n    innerForm.getResources().getCOSObject().setItem(COSName.PROC_SET, procSet);\n    page.getCOSObject().setItem(COSName.PROC_SET, procSet);\n    innerFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);\n    imageFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);\n    holderFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);\n    LOG.info(\"Inserted ProcSet to PDF\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getStructureTreeRoot",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getStructureTreeRoot", "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the document's structure tree root, or null if none exists.\n *\n * @return the structure tree root if present, otherwise null\n */\npublic PDStructureTreeRoot getStructureTreeRoot() {\n    COSDictionary dict = root.getCOSDictionary(COSName.STRUCT_TREE_ROOT);\n    return dict == null ? null : new PDStructureTreeRoot(dict);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSString.parseHex",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSString.parseHex", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * This will create a COS string from a string of hex characters.\n *\n * @param hex\n * \t\tA hex string.\n * @return A cos string with the hex characters converted to their actual bytes.\n * @throws IOException\n * \t\tIf there is an error with the hex string.\n */\npublic static COSString parseHex(String hex) throws IOException {\n    // skip leading and trailing whitespace\n    int end = hex.length();\n    while ((end > 0) && Character.isWhitespace(hex.charAt(end - 1))) {\n        end--;\n    } \n    int start = 0;\n    while ((start < end) && Character.isWhitespace(hex.charAt(start))) {\n        start++;\n    } \n    int length = end - start;\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream((length + 1) / 2);\n    boolean isLengthUneven = (length % 2) != 0;\n    if (isLengthUneven) {\n        length--;\n    }\n    for (int i = 0; i < length; i += 2) {\n        int value = (16 * Hex.getHexValue(hex.charAt(i))) + Hex.getHexValue(hex.charAt(i + 1));\n        if (value >= 0) {\n            bytes.write(value);\n        } else if (FORCE_PARSING) {\n            LOG.warn(\"Encountered a malformed hex string\");\n            bytes.write('?');// todo: what does Acrobat do? Any example PDFs?\n\n        } else {\n            throw new IOException(\"Invalid hex string: \" + hex);\n        }\n    }\n    if (isLengthUneven) {\n        int value = 16 * Hex.getHexValue(hex.charAt(length));\n        if (value >= 0) {\n            bytes.write(value);\n        } else if (FORCE_PARSING) {\n            LOG.warn(\"Encountered a malformed hex string\");\n            bytes.write('?');// todo: what does Acrobat do? Any example PDFs?\n\n        } else {\n            throw new IOException(\"Invalid hex string: \" + hex);\n        }\n    }\n    return new COSString(bytes.toByteArray());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new ICC color space with an empty stream.\n *\n * @param doc\n * \t\tthe document to store the ICC data\n */\npublic PDICCBased(PDDocument doc) {\n    array = new COSArray();\n    array.add(COSName.ICCBASED);\n    stream = new PDStream(doc);\n    array.add(stream);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    return SampledImageReader.getRGBImage(this, region, subsampling, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageContentStream.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageContentStream.<init>", "org.apache.pdfbox.pdmodel.PDPageContentStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Create a new PDPage content stream. This constructor overwrites all existing content streams\n * of this page.\n *\n * @param document\n * \t\tThe document the page is part of.\n * @param sourcePage\n * \t\tThe page to write the contents to.\n * @throws IOException\n * \t\tIf there is an error writing to the page contents.\n */\npublic PDPageContentStream(PDDocument document, PDPage sourcePage) throws IOException {\n    this(document, sourcePage, AppendMode.OVERWRITE, true, false);\n    if (sourcePageHadContents) {\n        LOG.warn(\"You are overwriting an existing content, you should use the append mode\");\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDDocumentCatalogAdditionalActions.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDDocumentCatalogAdditionalActions.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDDocumentCatalogAdditionalActions() {\n    actions = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given shading to the resources of the current page and returns the name for the\n * new resources. Returns the existing resource name if the given item already exists.\n *\n * @param shading\n * \t\tthe shading to add\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDShading shading) {\n    return add(COSName.SHADING, \"sh\", shading);\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.addSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.addSignature", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will add a signature to the document. If the 0-based page number in the options\n * parameter is smaller than 0 or larger than max, the nearest valid page number will be used\n * (i.e. 0 or max) and no exception will be thrown.\n * <p>\n * Only one signature may be added in a document. To sign several times,\n * load document, add signature, save incremental and close again.\n *\n * @param sigObject\n * \t\tis the PDSignatureField model\n * @param signatureInterface\n * \t\tis an interface whose implementation provides\n * \t\tsigning capabilities. Can be null if external signing if used.\n * @param options\n * \t\tsignature options\n * @throws IOException\n * \t\tif there is an error creating required fields\n * @throws IllegalStateException\n * \t\tif one attempts to add several signature\n * \t\tfields.\n */\npublic void addSignature(PDSignature sigObject, SignatureInterface signatureInterface, SignatureOptions options) throws IOException {\n    if (signatureAdded) {\n        throw new IllegalStateException(\"Only one signature may be added in a document\");\n    }\n    signatureAdded = true;\n    // Reserve content\n    // We need to reserve some space for the signature. Some signatures including\n    // big certificate chain and we need enough space to store it.\n    int preferredSignatureSize = options.getPreferredSignatureSize();\n    if (preferredSignatureSize > 0) {\n        sigObject.setContents(new byte[preferredSignatureSize]);\n    } else {\n        sigObject.setContents(new byte[SignatureOptions.DEFAULT_SIGNATURE_SIZE]);\n    }\n    // Reserve ByteRange, will be overwritten in COSWriter\n    sigObject.setByteRange(RESERVE_BYTE_RANGE);\n    signInterface = signatureInterface;\n    // Create SignatureForm for signature and append it to the document\n    // Get the first valid page\n    PDPageTree pageTree = getPages();\n    int pageCount = pageTree.getCount();\n    if (pageCount == 0) {\n        throw new IllegalStateException(\"Cannot sign an empty document\");\n    }\n    // Get the AcroForm from the Root-Dictionary and append the annotation\n    PDDocumentCatalog catalog = getDocumentCatalog();\n    PDAcroForm acroForm = catalog.getAcroForm(null);\n    catalog.getCOSObject().setNeedToBeUpdated(true);\n    if (acroForm == null) {\n        acroForm = new PDAcroForm(this);\n        catalog.setAcroForm(acroForm);\n    } else {\n        acroForm.getCOSObject().setNeedToBeUpdated(true);\n    }\n    PDSignatureField signatureField = null;\n    COSArray fieldArray = acroForm.getCOSObject().getCOSArray(COSName.FIELDS);\n    if (fieldArray != null) {\n        fieldArray.setNeedToBeUpdated(true);\n        signatureField = findSignatureField(acroForm.getFieldIterator(), sigObject);\n    } else {\n        acroForm.getCOSObject().setItem(COSName.FIELDS, new COSArray());\n    }\n    PDAnnotationWidget firstWidget;\n    PDPage page;\n    if (signatureField == null) {\n        signatureField = new PDSignatureField(acroForm);\n        // append the signature object\n        signatureField.setValue(sigObject);\n        firstWidget = signatureField.getWidgets().get(0);\n        int startIndex = Math.min(Math.max(options.getPage(), 0), pageCount - 1);\n        page = pageTree.get(startIndex);\n        // backward linking\n        firstWidget.setPage(page);\n    } else {\n        firstWidget = signatureField.getWidgets().get(0);\n        sigObject.getCOSObject().setNeedToBeUpdated(true);\n        page = null;\n    }\n    // TODO This \"overwrites\" the settings of the original signature field which might not be intended by the user\n    // better make it configurable (not all users need/want PDF/A but their own setting):\n    // to conform PDF/A-1 requirement:\n    // The /F key's Print flag bit shall be set to 1 and\n    // its Hidden, Invisible and NoView flag bits shall be set to 0\n    firstWidget.setPrinted(true);\n    // This may be troublesome if several form fields are signed,\n    // see thread from PDFBox users mailing list 17.2.2021 - 19.2.2021\n    // https://mail-archives.apache.org/mod_mbox/pdfbox-users/202102.mbox/thread\n    // better set the printed flag in advance\n    // Set the AcroForm Fields\n    List<PDField> acroFormFields = acroForm.getFields();\n    acroForm.getCOSObject().setDirect(true);\n    acroForm.setSignaturesExist(true);\n    acroForm.setAppendOnly(true);\n    boolean checkFields = checkSignatureField(acroForm.getFieldIterator(), signatureField);\n    if (checkFields) {\n        signatureField.getCOSObject().setNeedToBeUpdated(true);\n    } else {\n        acroFormFields.add(signatureField);\n    }\n    // Get the object from the visual signature\n    COSDocument visualSignature = options.getVisualSignature();\n    // Distinction of case for visual and non-visual signature\n    if (visualSignature == null) {\n        prepareNonVisibleSignature(firstWidget);\n    } else {\n        prepareVisibleSignature(firstWidget, acroForm, visualSignature);\n    }\n    if (page != null) {\n        // Create Annotation / Field for signature\n        List<PDAnnotation> annotations = page.getAnnotations();\n        // Get the annotations of the page and append the signature-annotation to it\n        // take care that page and acroforms do not share the same array (if so, we don't need to add it twice)\n        if (!(((checkFields && (annotations instanceof COSArrayList)) && (acroFormFields instanceof COSArrayList)) && ((COSArrayList) (annotations)).toList().equals(((COSArrayList) (acroFormFields)).toList()))) {\n            // use check to prevent the annotation widget from appearing twice\n            if (checkSignatureAnnotation(annotations, firstWidget)) {\n                firstWidget.getCOSObject().setNeedToBeUpdated(true);\n            } else {\n                annotations.add(firstWidget);\n            }\n        }\n        // Make /Annots a direct object by reassigning it,\n        // to avoid problem if it is an existing indirect object:\n        // it would not be updated in incremental save, and if we'd set the /Annots array \"to be updated\"\n        // while keeping it indirect, Adobe Reader would claim that the document had been modified.\n        page.setAnnotations(annotations);\n        page.getCOSObject().setNeedToBeUpdated(true);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFMarkedContentExtractor.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFMarkedContentExtractor.<init>", "org.apache.pdfbox.contentstream.operator.markedcontent.DrawObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor. Will apply encoding-specific conversions to the output text.\n *\n * @param encoding\n * \t\tThe encoding that the output will be written in.\n */\npublic PDFMarkedContentExtractor(String encoding) {\n    addOperator(new BeginMarkedContentSequenceWithProperties(this));\n    addOperator(new BeginMarkedContentSequence(this));\n    addOperator(new EndMarkedContentSequence(this));\n    addOperator(new DrawObject(this));\n    addOperator(new MarkedContentPoint(this));\n    addOperator(new MarkedContentPointWithProperties(this));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFCatalog.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFCatalog.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFCatalog() {\n    catalog = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFont.getFontMatrix",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFont.getFontMatrix", "org.apache.pdfbox.pdmodel.font.PDFont.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Matrix getFontMatrix() {\n    return DEFAULT_FONT_MATRIX;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingContext.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new RadialShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDStructureElementNameTreeNode.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDStructureElementNameTreeNode.<init>", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDStructureElementNameTreeNode() {\n    // just calls super()\n}", "/**\n * Constructor.\n */\nprotected PDNameTreeNode() {\n    node = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSStream.createView",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSStream.createView", "org.apache.pdfbox.filter.Filter.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns a new RandomAccessRead which reads the decoded stream data.\n *\n * @return RandomAccessRead containing decoded stream data.\n * @throws IOException\n * \t\tIf the stream could not be read.\n */\npublic RandomAccessRead createView() throws IOException {\n    List<Filter> filterList = getFilterList();\n    if (filterList.isEmpty()) {\n        if ((randomAccess == null) && (randomAccessReadView != null)) {\n            return new RandomAccessReadView(randomAccessReadView, 0, randomAccessReadView.length());\n        } else {\n            return new RandomAccessReadBuffer(createRawInputStream());\n        }\n    }\n    return Filter.decode(createRawInputStream(), filterList, this, DecodeOptions.DEFAULT, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.getAdobeGlyphList",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.getAdobeGlyphList", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the Adobe Glyph List (AGL).\n *\n * @return the Adobe glyph list\n */\npublic static GlyphList getAdobeGlyphList() {\n    return DEFAULT;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingContext.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingContext.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tthe bounds of the area to paint, in device units\n * @throws IOException\n * \t\tif there is an error getting the color space or doing color conversion.\n */\npublic AxialShadingContext(PDShadingType2 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    this.axialShadingType = shading;\n    coords = shading.getCoords().toFloatArray();\n    // domain values\n    if (shading.getDomain() != null) {\n        domain = shading.getDomain().toFloatArray();\n    } else {\n        // set default values\n        domain = new float[]{ 0, 1 };\n    }\n    // extend values\n    COSArray extendValues = shading.getExtend();\n    if (extendValues != null) {\n        extend = new boolean[2];\n        extend[0] = ((COSBoolean) (extendValues.getObject(0))).getValue();\n        extend[1] = ((COSBoolean) (extendValues.getObject(1))).getValue();\n    } else {\n        // set default values\n        extend = new boolean[]{ false, false };\n    }\n    // calculate some constants to be used in getRaster\n    x1x0 = coords[2] - coords[0];\n    y1y0 = coords[3] - coords[1];\n    d1d0 = domain[1] - domain[0];\n    denom = Math.pow(x1x0, 2) + Math.pow(y1y0, 2);\n    try {\n        // get inverse transform to be independent of current user / device space\n        // when handling actual pixels in getRaster()\n        rat = matrix.createAffineTransform().createInverse();\n        rat.concatenate(xform.createInverse());\n    } catch (NoninvertibleTransformException ex) {\n        LOG.error((ex.getMessage() + \", matrix: \") + matrix, ex);\n        rat = new AffineTransform();\n    }\n    // shading space -> device space\n    AffineTransform shadingToDevice = ((AffineTransform) (xform.clone()));\n    shadingToDevice.concatenate(matrix.createAffineTransform());\n    // worst case for the number of steps is opposite diagonal corners, so use that\n    double dist = Math.sqrt(Math.pow(deviceBounds.getMaxX() - deviceBounds.getMinX(), 2) + Math.pow(deviceBounds.getMaxY() - deviceBounds.getMinY(), 2));\n    factor = ((int) (Math.ceil(dist)));\n    // build the color table for the given number of steps\n    colorTable = calcColorTable();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationFreeText.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationFreeText.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDFreeTextAppearanceHandler appearanceHandler = new PDFreeTextAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.state.SetGraphicsStateParameters.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.state.SetGraphicsStateParameters.process", "org.apache.pdfbox.contentstream.operator.state.SetGraphicsStateParameters.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    if (arguments.isEmpty()) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    // set parameters from graphics state parameter dictionary\n    COSName graphicsName = ((COSName) (base0));\n    PDFStreamEngine context = getContext();\n    PDExtendedGraphicsState gs = context.getResources().getExtGState(graphicsName);\n    if (gs == null) {\n        LOG.error(\"name for 'gs' operator not found in resources: /\" + graphicsName.getName());\n        return;\n    }\n    gs.copyIntoGraphicsState(context.getGraphicsState());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createBackgroundLayerForm",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createBackgroundLayerForm", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createBackgroundLayerForm(PDResources innerFormResource, PDRectangle bbox) throws IOException {\n    // create blank n0 background layer form\n    PDFormXObject n0Form = new PDFormXObject(pdfStructure.getTemplate().getDocument().createCOSStream());\n    n0Form.setBBox(bbox);\n    n0Form.setResources(new PDResources());\n    n0Form.setFormType(1);\n    innerFormResource.put(COSName.getPDFName(\"n0\"), n0Form);\n    LOG.info(\"Created background layer form\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDNonTerminalField.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDNonTerminalField.<init>", "org.apache.pdfbox.pdmodel.interactive.form.PDField.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param acroForm\n * \t\tThe form that this field is part of.\n */\npublic PDNonTerminalField(PDAcroForm acroForm) {\n    super(acroForm);\n}", "/**\n * Constructor.\n *\n * @param acroForm\n * \t\tThe form that this field is part of.\n */\nPDField(PDAcroForm acroForm) {\n    this(acroForm, new COSDictionary(), null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.IntPoint.equals",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.IntPoint.equals", "org.apache.pdfbox.pdmodel.graphics.shading.IntPoint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        if (obj instanceof Point2D) {\n            // hitting this branch means that the warning on top of the class wasn't read\n            LOG.error(\"IntPoint should not be used together with its base class\");\n        }\n        return false;\n    }\n    final IntPoint other = ((IntPoint) (obj));\n    return (this.x == other.x) && (this.y == other.y);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.addOID",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.addOID", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * works like {@link #setOID(List)} but for one object\n *\n * @param oid\n * \t\tObject Identifier of a certificate policy to be added\n */\npublic void addOID(byte[] oid) {\n    COSArray array = dictionary.getCOSArray(COSName.OID);\n    if (array == null) {\n        array = new COSArray();\n    }\n    array.add(new COSString(oid));\n    dictionary.setItem(COSName.OID, array);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setXRef",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setXRef", "org.apache.pdfbox.pdfparser.XrefTrailerResolver.<clinit>" ],
    "fullMethods" : [ "/**\n * Populate XRef HashMap of current XRef object.\n * Will add an Xreftable entry that maps ObjectKeys to byte offsets in the file.\n *\n * @param objKey\n * \t\tThe objkey, with id and gen numbers\n * @param offset\n * \t\tThe byte offset in this file\n */\npublic void setXRef(COSObjectKey objKey, long offset) {\n    if (curXrefTrailerObj == null) {\n        // should not happen...\n        LOG.warn((\"Cannot add XRef entry for '\" + objKey.getNumber()) + \"' because XRef start was not signalled.\");\n        return;\n    }\n    // PDFBOX-3506 check before adding to the map, to avoid entries from the table being\n    // overwritten by obsolete entries in hybrid files (/XRefStm entry)\n    if (!curXrefTrailerObj.xrefTable.containsKey(objKey)) {\n        curXrefTrailerObj.xrefTable.put(objKey, offset);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getActions",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getActions", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @return The Additional Actions for this Document\n */\npublic PDDocumentCatalogAdditionalActions getActions() {\n    COSDictionary addAction = root.getCOSDictionary(COSName.AA);\n    if (addAction == null) {\n        addAction = new COSDictionary();\n        root.setItem(COSName.AA, addAction);\n    }\n    return new PDDocumentCatalogAdditionalActions(addAction);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.toPaint",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.toPaint", "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Paint toPaint(Matrix matrix) {\n    return new Type7ShadingPaint(this, matrix);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getStencilImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getStencilImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "@Override\npublic BufferedImage getStencilImage(Paint paint) throws IOException {\n    if (!isStencil()) {\n        throw new IllegalStateException(\"Image is not a stencil\");\n    }\n    return SampledImageReader.getStencilImage(this, paint);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquareAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquareAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquareAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    float lineWidth = getLineWidth();\n    PDAnnotationSquare annotation = ((PDAnnotationSquare) (getAnnotation()));\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());\n        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());\n            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            annotation.setRectDifference(cloudyBorder.getRectDifference());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            PDRectangle borderBox = handleBorderBox(annotation, lineWidth);\n            contentStream.addRect(borderBox.getLowerLeftX(), borderBox.getLowerLeftY(), borderBox.getWidth(), borderBox.getHeight());\n        }\n        contentStream.drawShape(lineWidth, hasStroke, hasBackground);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDCalGray.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDCalGray.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new CalGray color space using the given COS array.\n *\n * @param array\n * \t\tthe COS array which represents this color space\n */\npublic PDCalGray(COSArray array) {\n    super(array);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceGray.<clinit>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceGray.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor with a given page size to initialize the clipping path.\n *\n * @param page\n * \t\tthe size of the page\n */\npublic PDGraphicsState(PDRectangle page) {\n    clippingPaths.add(new Path2D.Double(page.toGeneralPath()));\n}", "", "private PDDeviceGray() {\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the content of the given image as an AWT buffered image with an RGB color space.\n * If a color key mask is provided then an ARGB image is returned instead.\n * This method never returns null.\n *\n * @param pdImage\n * \t\tthe image to read\n * @param colorKey\n * \t\tan optional color key mask\n * @return content of this image as an RGB buffered image\n * @throws IOException\n * \t\tif the image cannot be read\n */\npublic static BufferedImage getRGBImage(PDImage pdImage, COSArray colorKey) throws IOException {\n    return getRGBImage(pdImage, null, 1, colorKey);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3Font.getCharProc",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3Font.getCharProc", "org.apache.pdfbox.pdmodel.font.PDType3CharProc.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the stream of the glyph for the given character code\n *\n * @param code\n * \t\tcharacter code\n * @return the stream to be used to render the glyph\n */\npublic PDType3CharProc getCharProc(int code) {\n    if ((getEncoding() == null) || (getCharProcs() == null)) {\n        return null;\n    }\n    String name = getEncoding().getName(code);\n    COSStream stream = getCharProcs().getCOSStream(COSName.getPDFName(name));\n    return stream != null ? new PDType3CharProc(this, stream) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFileMac",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFileMac", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the embedded Mac file.\n *\n * @return The embedded Mac file for this file spec.\n */\npublic PDEmbeddedFile getEmbeddedFileMac() {\n    COSBase base = getObjectFromEFDictionary(COSName.MAC);\n    if (base instanceof COSStream) {\n        return new PDEmbeddedFile(((COSStream) (base)));\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getAnnotations",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getAnnotations", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * This will return a list of the annotations for this page.\n *\n * @param annotationFilter\n * \t\tthe annotation filter provided allowing to filter out specific annotations\n * @return List of the PDAnnotation objects, never null. The returned list is backed by the\nannotations COSArray, so any adding or deleting in this list will change the document too.\n * @throws IOException\n * \t\tIf there is an error while creating the annotation list.\n */\npublic List<PDAnnotation> getAnnotations(AnnotationFilter annotationFilter) throws IOException {\n    COSArray annots = page.getCOSArray(COSName.ANNOTS);\n    if (annots == null) {\n        return new COSArrayList<>(page, COSName.ANNOTS);\n    }\n    List<PDAnnotation> actuals = new ArrayList<>();\n    for (int i = 0; i < annots.size(); i++) {\n        COSBase item = annots.getObject(i);\n        if (item == null) {\n            continue;\n        }\n        PDAnnotation createdAnnotation = PDAnnotation.createAnnotation(item);\n        if (annotationFilter.accept(createdAnnotation)) {\n            actuals.add(createdAnnotation);\n        }\n    }\n    return new COSArrayList<>(actuals, annots);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDStrikeoutAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDStrikeoutAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDStrikeoutAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationStrikeout annotation = ((PDAnnotationStrikeout) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getQuadPoints();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    if (Float.compare(ab.width, 0) == 0) {\n        // value found in adobe reader\n        ab.width = 1.5F;\n    }\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    // TODO in a class structure this should be overridable\n    // this is similar to polyline but different data type\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    rect.setLowerLeftX(Math.min(minX - (ab.width / 2), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width / 2), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width / 2), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width / 2), rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        cs.setStrokingColor(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        // spec is incorrect\n        // https://stackoverflow.com/questions/9855814/pdf-spec-vs-acrobat-creation-quadpoints\n        for (int i = 0; i < (pathsArray.length / 8); ++i) {\n            // get mid point between bounds, subtract the line width to approximate what Adobe is doing\n            // See e.g. CTAN-example-Annotations.pdf and PLPDF.com-MarkupAnnotations.pdf\n            // and https://bugs.ghostscript.com/show_bug.cgi?id=693664\n            // do the math for diagonal annotations with this weird old trick:\n            // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n            float len0 = ((float) (Math.sqrt(Math.pow(pathsArray[i * 8] - pathsArray[(i * 8) + 4], 2) + Math.pow(pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5], 2))));\n            float x0 = pathsArray[(i * 8) + 4];\n            float y0 = pathsArray[(i * 8) + 5];\n            if (Float.compare(len0, 0) != 0) {\n                // only if both coordinates are not identical to avoid divide by zero\n                x0 += ((pathsArray[i * 8] - pathsArray[(i * 8) + 4]) / len0) * ((len0 / 2) - ab.width);\n                y0 += ((pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5]) / len0) * ((len0 / 2) - ab.width);\n            }\n            float len1 = ((float) (Math.sqrt(Math.pow(pathsArray[(i * 8) + 2] - pathsArray[(i * 8) + 6], 2) + Math.pow(pathsArray[(i * 8) + 3] - pathsArray[(i * 8) + 7], 2))));\n            float x1 = pathsArray[(i * 8) + 6];\n            float y1 = pathsArray[(i * 8) + 7];\n            if (Float.compare(len1, 0) != 0) {\n                // only if both coordinates are not identical to avoid divide by zero\n                x1 += ((pathsArray[(i * 8) + 2] - pathsArray[(i * 8) + 6]) / len1) * ((len1 / 2) - ab.width);\n                y1 += ((pathsArray[(i * 8) + 3] - pathsArray[(i * 8) + 7]) / len1) * ((len1 / 2) - ab.width);\n            }\n            cs.moveTo(x0, y0);\n            cs.lineTo(x1, y1);\n        }\n        cs.stroke();\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.insertInnerFormToHolderResources",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.insertInnerFormToHolderResources", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void insertInnerFormToHolderResources(PDFormXObject innerForm, PDResources holderFormResources) {\n    holderFormResources.put(COSName.FRM, innerForm);\n    pdfStructure.setInnerFormName(COSName.FRM);\n    LOG.info(\"Now inserted inner form inside holder form\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSStream.createOutputStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSStream.createOutputStream", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns a new OutputStream for writing stream data, using and the given filters.\n *\n * @param filters\n * \t\tCOSArray or COSName of filters to be used.\n * @return OutputStream for un-encoded stream data.\n * @throws IOException\n * \t\tIf the output stream could not be created.\n */\npublic OutputStream createOutputStream(COSBase filters) throws IOException {\n    checkClosed();\n    if (isWriting) {\n        throw new IllegalStateException(\"Cannot have more than one open stream writer.\");\n    }\n    // apply filters, if any\n    if (filters != null) {\n        setItem(COSName.FILTER, filters);\n    }\n    if (randomAccess != null)\n        randomAccess.clear();\n    else\n        randomAccess = getStreamCache().createBuffer();\n\n    OutputStream randomOut = new RandomAccessOutputStream(randomAccess);\n    OutputStream cosOut = new COSOutputStream(getFilterList(), this, randomOut, getStreamCache());\n    isWriting = true;\n    return new FilterOutputStream(cosOut) {\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            this.out.write(b, off, len);\n        }\n\n        @Override\n        public void close() throws IOException {\n            super.close();\n            setInt(COSName.LENGTH, ((int) (randomAccess.length())));\n            isWriting = false;\n        }\n    };\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new DeviceN colour space attributes dictionary.\n */\npublic PDDeviceNAttributes() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDLab.getInitialColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDLab.getInitialColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PDColor getInitialColor() {\n    if (initialColor == null) {\n        initialColor = new PDColor(new float[]{ 0, Math.max(0, getARange().getMin()), Math.max(0, getBRange().getMin()) }, this);\n    }\n    return initialColor;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeTokens",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeTokens", "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeObject", "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeObject", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * Writes a series of tokens followed by a new line.\n *\n * @param tokens\n * \t\tThe tokens to write to the stream.\n * @throws IOException\n * \t\tIf there is an error writing to the stream.\n */\npublic void writeTokens(Object... tokens) throws IOException {\n    for (Object token : tokens) {\n        writeObject(token);\n    }\n    output.write(\"\\n\".getBytes(StandardCharsets.US_ASCII));\n}", "private void writeObject(Object o) throws IOException {\n    if (o instanceof COSBase) {\n        writeObject(((COSBase) (o)));\n    } else if (o instanceof Operator) {\n        writeObject(((Operator) (o)));\n    } else {\n        throw new IOException(\"Error:Unknown type in content stream:\" + o);\n    }\n}", "private void writeObject(COSBase o) throws IOException {\n    if (o instanceof COSString) {\n        COSWriter.writeString(((COSString) (o)), output);\n        output.write(SPACE);\n    } else if (o instanceof COSFloat) {\n        ((COSFloat) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSInteger) {\n        ((COSInteger) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSBoolean) {\n        ((COSBoolean) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSName) {\n        ((COSName) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSArray) {\n        COSArray array = ((COSArray) (o));\n        output.write(COSWriter.ARRAY_OPEN);\n        for (int i = 0; i < array.size(); i++) {\n            writeObject(array.get(i));\n        }\n        output.write(COSWriter.ARRAY_CLOSE);\n        output.write(SPACE);\n    } else if (o instanceof COSDictionary) {\n        COSDictionary obj = ((COSDictionary) (o));\n        output.write(COSWriter.DICT_OPEN);\n        for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {\n            if (entry.getValue() != null) {\n                writeObject(entry.getKey());\n                writeObject(entry.getValue());\n            }\n        }\n        output.write(COSWriter.DICT_CLOSE);\n        output.write(SPACE);\n    } else if (o instanceof COSNull) {\n        output.write(\"null\".getBytes(StandardCharsets.US_ASCII));\n        output.write(SPACE);\n    } else {\n        throw new IOException(\"Error:Unknown type in content stream:\" + o);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationSquare.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationSquare.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquareAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDSquareAppearanceHandler appearanceHandler = new PDSquareAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.getParentTree",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.getParentTree", "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the parent tree.<p>\n * The keys correspond to a single page of the document or to an individual object, e.g. an\n * annotation or an XObject, which have a <b>/StructParent</b> or <b>/StructParents</b>\n * entry.<p>\n * The values of type {@link PDParentTreeValue} are either a dictionary or an array. It's a\n * dictionary for individual objects like an annotation or an XObject, and an array for a page\n * object or a content stream containing marked-content sequences identified by an MCID.\n *\n * @return the parent tree.\n */\npublic PDNumberTreeNode getParentTree() {\n    COSDictionary parentTree = getCOSObject().getCOSDictionary(COSName.PARENT_TREE);\n    return parentTree != null ? new PDNumberTreeNode(parentTree, PDParentTreeValue.class) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a vertical Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param input\n * \t\tA TrueType font. It will be closed before returning.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font loadVertical(PDDocument doc, InputStream input) throws IOException {\n    return load(doc, RandomAccessReadBuffer.createBufferFromStream(input), true, true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormGenerateAppearancesProcessor.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormGenerateAppearancesProcessor.process", "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormGenerateAppearancesProcessor.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process() {\n    /* Get the AcroForm in it's current state.\n\n    Also note: getAcroForm() applies a default fixup which this processor\n    is part of. So keep the null parameter otherwise this will end\n    in an endless recursive call\n     */\n    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm(null);\n    if (acroForm != null) {\n        try {\n            LOG.debug(\"trying to generate appearance streams for fields as NeedAppearances is true()\");\n            acroForm.refreshAppearances();\n            acroForm.setNeedAppearances(false);\n        } catch (IOException | IllegalArgumentException ex) {\n            LOG.debug(\"couldn't generate appearance stream for some fields - check output\");\n            LOG.debug(ex.getMessage());\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.<init>", "org.apache.pdfbox.pdmodel.graphics.PDXObject.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a Form XObject for reading.\n *\n * @param stream\n * \t\tThe XObject stream\n * @param cache\n * \t\tthe cache to be used for the resources\n */\npublic PDFormXObject(COSStream stream, ResourceCache cache) {\n    super(stream, COSName.FORM);\n    this.cache = cache;\n}", "/**\n * Creates a new XObject from the given stream and subtype.\n *\n * @param stream\n * \t\tThe stream to read.\n * @param subtype\n * \t\tthe subtype to be used for this XObject\n */\nprotected PDXObject(COSStream stream, COSName subtype) {\n    this.stream = new PDStream(stream);\n    // could be used for writing:\n    stream.setName(COSName.TYPE, COSName.XOBJECT.getName());\n    stream.setName(COSName.SUBTYPE, subtype.getName());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.FDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.FDFParser.parse", "org.apache.pdfbox.pdmodel.fdf.FDFDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the FDFDocument object.\n *\n * @return the parsed FDFDocument\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic FDFDocument parse() throws IOException {\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        if (!parseFDFHeader()) {\n            throw new IOException(\"Error: Header doesn't contain versioninfo\");\n        }\n        initialParse();\n        exceptionOccurred = false;\n        return new FDFDocument(document, source);\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<init>", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor, creates PDF template structure.\n */\npublic PDVisibleSigBuilder() {\n    pdfStructure = new PDFTemplateStructure();\n    LOG.info(\"PDF Structure has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.pagenavigation.PDThreadBead.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.pagenavigation.PDThreadBead.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDThreadBead() {\n    bead = new COSDictionary();\n    bead.setItem(COSName.TYPE, COSName.BEAD);\n    setNextBead(this);\n    setPreviousBead(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    return getBounds(xform, matrix, 12);\n}", "Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    Rectangle2D bounds = null;\n    for (Patch patch : collectPatches(xform, matrix, controlPoints)) {\n        for (ShadedTriangle shadedTriangle : patch.listOfTriangles) {\n            if (bounds == null) {\n                bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n            }\n            bounds.add(shadedTriangle.corner[0]);\n            bounds.add(shadedTriangle.corner[1]);\n            bounds.add(shadedTriangle.corner[2]);\n        }\n    }\n    return bounds;\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.SoftMask.SoftPaintContext.getColorModel",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.SoftMask.SoftPaintContext.getColorModel", "org.apache.pdfbox.rendering.SoftMask.<clinit>" ],
    "fullMethods" : [ "@Override\npublic ColorModel getColorModel() {\n    return ARGB_COLOR_MODEL;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decrypt",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decrypt", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptString", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * This will dispatch to the correct method.\n *\n * @param obj\n * \t\tThe object to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation Number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void decrypt(COSBase obj, long objNum, long genNum) throws IOException {\n    // PDFBOX-4477: only cache strings and streams, this improves speed and memory footprint\n    if (obj instanceof COSString) {\n        if (objects.contains(obj)) {\n            return;\n        }\n        objects.add(obj);\n        decryptString(((COSString) (obj)), objNum, genNum);\n    } else if (obj instanceof COSStream) {\n        if (objects.contains(obj)) {\n            return;\n        }\n        objects.add(obj);\n        decryptStream(((COSStream) (obj)), objNum, genNum);\n    } else if (obj instanceof COSDictionary) {\n        decryptDictionary(((COSDictionary) (obj)), objNum, genNum);\n    } else if (obj instanceof COSArray) {\n        decryptArray(((COSArray) (obj)), objNum, genNum);\n    }\n}", "/**\n * This will decrypt a string.\n *\n * @param string\n * \t\tthe string to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n */\nprivate void decryptString(COSString string, long objNum, long genNum) {\n    // String encrypted with identity filter\n    if (COSName.IDENTITY.equals(stringFilterName)) {\n        return;\n    }\n    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    try {\n        /* decrypt */\n        encryptData(objNum, genNum, data, outputStream, true);\n        string.setValue(outputStream.toByteArray());\n    } catch (IOException ex) {\n        LOG.error(((((\"Failed to decrypt COSString of length \" + string.getBytes().length) + \" in object \") + objNum) + \": \") + ex.getMessage(), ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setStrokingColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setStrokingColor", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceGray.<clinit>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceGray.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the stroking color in the DeviceGray color space. Range is 0..1.\n *\n * @param g\n * \t\tThe gray value.\n * @throws IOException\n * \t\tIf an IO error occurs while writing to the stream.\n * @throws IllegalArgumentException\n * \t\tIf the parameter is invalid.\n */\npublic void setStrokingColor(float g) throws IOException {\n    if (isOutsideOneInterval(g)) {\n        throw new IllegalArgumentException(\"Parameter must be within 0..1, but is \" + g);\n    }\n    writeOperand(g);\n    writeOperator(OperatorName.STROKING_COLOR_GRAY);\n    setStrokingColorSpaceStack(PDDeviceGray.INSTANCE);\n}", "", "private PDDeviceGray() {\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDPageDestination.retrievePageNumber",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDPageDestination.retrievePageNumber", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDPageDestination.indexOfPageTree", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the page number for this destination, regardless of whether this is a page number or\n * a reference to a page.\n *\n * @see org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem\n * @return the 0-based page number, or -1 if the destination type is unknown.\n */\npublic int retrievePageNumber() {\n    int retval = -1;\n    if (array.size() > 0) {\n        COSBase page = array.getObject(0);\n        if (page instanceof COSNumber) {\n            retval = ((COSNumber) (page)).intValue();\n        } else if (page instanceof COSDictionary) {\n            return indexOfPageTree(((COSDictionary) (page)));\n        }\n    }\n    return retval;\n}", "// climb up the page tree up to the top to be able to call PageTree.indexOf for a page dictionary\nprivate int indexOfPageTree(COSDictionary pageDict) {\n    COSDictionary parent = pageDict;\n    while (true) {\n        COSDictionary prevParent = parent.getCOSDictionary(COSName.PARENT, COSName.P);\n        if (prevParent == null) {\n            break;\n        }\n        parent = prevParent;\n    } \n    if (parent.containsKey(COSName.KIDS) && COSName.PAGES.equals(parent.getCOSName(COSName.TYPE))) {\n        // now parent is the highest pages node\n        PDPageTree pages = new PDPageTree(parent);\n        return pages.indexOf(new PDPage(pageDict));\n    }\n    return -1;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.DateConverter.toISO8601",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.DateConverter.toISO8601", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * Converts the date to ISO 8601 string format:\n *     yyyy-mm-ddThh:MM:ss#hh:mm    (where '#\" is '+' or '-').\n *\n * @param cal\n * \t\tThe date to convert.  Must not be null.\n * \t\tThe DST_OFFSET is included in the output value.\n * @return The date represented as an ISO 8601 string.\n */\npublic static String toISO8601(Calendar cal) {\n    String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET), \":\");\n    return // time zone\n    String.format(Locale.US, ((((\"%1$4tY\"// yyyy\n     + \"-%1$2tm\")// -mm  (%tm adds one to cal month value)\n     + \"-%1$2td\")// -dd  (%tm adds one to cal month value)\n     + \"T\") + // T\n    \"%1$2tH:%1$2tM:%1$2tS\")// HHmmss\n     + \"%2$s\", cal, offset);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDOutputIntent.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDOutputIntent.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "public PDOutputIntent(PDDocument doc, InputStream colorProfile) throws IOException {\n    dictionary = new COSDictionary();\n    dictionary.setItem(COSName.TYPE, COSName.OUTPUT_INTENT);\n    dictionary.setItem(COSName.S, COSName.GTS_PDFA1);\n    PDStream destOutputIntent = configureOutputProfile(doc, colorProfile);\n    dictionary.setItem(COSName.DEST_OUTPUT_PROFILE, destOutputIntent);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a vertical Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param input\n * \t\tA TrueType font. It will be closed before returning.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font loadVertical(PDDocument doc, InputStream input, boolean embedSubset) throws IOException {\n    return load(doc, RandomAccessReadBuffer.createBufferFromStream(input), embedSubset, true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDBorderStyleDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDBorderStyleDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDBorderStyleDictionary() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param ttf\n * \t\tA TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding. Set this to false when creating a font for\n * \t\tAcroForm.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font load(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException {\n    return new PDType0Font(doc, ttf, embedSubset, false, false);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMappers.instance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMappers.instance", "org.apache.pdfbox.pdmodel.font.FontMappers.DefaultFontMapper.<clinit>", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the singleton FontMapper instance.\n *\n * @return a singleton FontMapper instance\n */\npublic static FontMapper instance() {\n    if (instance == null) {\n        instance = DefaultFontMapper.INSTANCE;\n    }\n    return instance;\n}", "", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.addLast",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.addLast", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCountForAddedChild", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given node to the bottom of the children list.\n *\n * @param newChild\n * \t\tThe node to add.\n * @throws IllegalArgumentException\n * \t\tif the given node is part of a list (i.e. if it has a previous or a next\n * \t\tsibling)\n */\npublic void addLast(PDOutlineItem newChild) {\n    requireSingleNode(newChild);\n    append(newChild);\n    updateParentOpenCountForAddedChild(newChild);\n}", "void updateParentOpenCountForAddedChild(PDOutlineItem newChild) {\n    int delta = 1;\n    if (newChild.isNodeOpen()) {\n        delta += newChild.getOpenCount();\n    }\n    newChild.updateParentOpenCount(delta);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.getUserPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.getUserPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.getUserPassword234", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeRC4key", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.truncateOrPad", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the user password based on the owner password.\n *\n * @param ownerPassword\n * \t\tThe plaintext owner password.\n * @param owner\n * \t\tThe o entry of the encryption dictionary.\n * @param encRevision\n * \t\tThe encryption revision number.\n * @param length\n * \t\tThe key length.\n * @return The u entry of the encryption dictionary.\n * @throws IOException\n * \t\tIf there is an error accessing data while generating the user password.\n */\npublic byte[] getUserPassword(byte[] ownerPassword, byte[] owner, int encRevision, int length) throws IOException {\n    // TODO ?!?!\n    if ((encRevision == REVISION_5) || (encRevision == REVISION_6)) {\n        return new byte[0];\n    } else {\n        return getUserPassword234(ownerPassword, owner, encRevision, length);\n    }\n}", "private byte[] getUserPassword234(byte[] ownerPassword, byte[] owner, int encRevision, int length) throws IOException {\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\n    byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);\n    if (encRevision == REVISION_2) {\n        encryptDataRC4(rc4Key, owner, result);\n    } else if ((encRevision == REVISION_3) || (encRevision == REVISION_4)) {\n        byte[] iterationKey = new byte[rc4Key.length];\n        byte[] otemp = new byte[owner.length];\n        System.arraycopy(owner, 0, otemp, 0, owner.length);\n        for (int i = 19; i >= 0; i--) {\n            System.arraycopy(rc4Key, 0, iterationKey, 0, rc4Key.length);\n            for (int j = 0; j < iterationKey.length; j++) {\n                iterationKey[j] = ((byte) (iterationKey[j] ^ ((byte) (i))));\n            }\n            result.reset();\n            encryptDataRC4(iterationKey, otemp, result);\n            otemp = result.toByteArray();\n        }\n    }\n    return result.toByteArray();\n}", "// steps (a) to (d) of \"Algorithm 3: Computing the encryption dictionaryâs O (owner password) value\".\nprivate byte[] computeRC4key(byte[] ownerPassword, int encRevision, int length) {\n    MessageDigest md = MessageDigests.getMD5();\n    byte[] digest = md.digest(truncateOrPad(ownerPassword));\n    if ((encRevision == REVISION_3) || (encRevision == REVISION_4)) {\n        for (int i = 0; i < 50; i++) {\n            // this deviates from the spec - however, omitting the length\n            // parameter prevents the file to be opened in Adobe Reader\n            // with the owner password when the key length is 40 bit (= 5 bytes)\n            md.update(digest, 0, length);\n            digest = md.digest();\n        }\n    }\n    byte[] rc4Key = new byte[length];\n    System.arraycopy(digest, 0, rc4Key, 0, length);\n    return rc4Key;\n}", "/**\n * This will take the password and truncate or pad it as necessary.\n *\n * @param password\n * \t\tThe password to pad or truncate.\n * @return The padded or truncated password.\n */\nprivate byte[] truncateOrPad(byte[] password) {\n    byte[] padded = new byte[ENCRYPT_PADDING.length];\n    int bytesBeforePad = Math.min(password.length, padded.length);\n    System.arraycopy(password, 0, padded, 0, bytesBeforePad);\n    System.arraycopy(ENCRYPT_PADDING, 0, padded, bytesBeforePad, ENCRYPT_PADDING.length - bytesBeforePad);\n    return padded;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFTemplate.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFTemplate.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFTemplate() {\n    template = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLineAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLineAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLineAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationLine annotation = ((PDAnnotationLine) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getLine();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    float ll = annotation.getLeaderLineLength();\n    float lle = annotation.getLeaderLineExtensionLength();\n    float llo = annotation.getLeaderLineOffsetLength();\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    // Leader lines\n    if (ll < 0) {\n        // /LLO and /LLE go in the same direction as /LL\n        llo = -llo;\n        lle = -lle;\n    }\n    // observed with diagonal line of AnnotationSample.Standard.pdf\n    // for line endings, very small widths must be treated as size 1.\n    // However the border of the line ending shapes is not drawn.\n    float lineEndingSize = (ab.width < 1.0E-5) ? 1 : ab.width;\n    // add/subtract with, font height, and arrows\n    // arrow length is 9 * width at about 30Â° => 10 * width seems to be enough\n    // but need to consider /LL, /LLE and /LLO too\n    // TODO find better way to calculate padding\n    float max = Math.max(lineEndingSize * 10, Math.abs((llo + ll) + lle));\n    rect.setLowerLeftX(Math.min(minX - max, rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - max, rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + max, rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + max, rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        // Tested with Adobe Reader:\n        // text is written first (TODO)\n        // width 0 is used by Adobe as such (but results in a visible line in rendering)\n        // empty color array results in an invisible line (\"n\" operator) but the rest is visible\n        // empty content is like no caption\n        boolean hasStroke = cs.setStrokingColorOnDemand(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        float x1 = pathsArray[0];\n        float y1 = pathsArray[1];\n        float x2 = pathsArray[2];\n        float y2 = pathsArray[3];\n        // if there are leader lines, then the /L coordinates represent\n        // the endpoints of the leader lines rather than the endpoints of the line itself.\n        // so for us, llo + ll is the vertical offset for the line.\n        float y = llo + ll;\n        String contents = annotation.getContents();\n        if (contents == null) {\n            contents = \"\";\n        }\n        cs.saveGraphicsState();\n        double angle = Math.atan2(y2 - y1, x2 - x1);\n        cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n        float lineLength = ((float) (Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)))));\n        // Leader lines\n        cs.moveTo(0, llo);\n        cs.lineTo(0, (llo + ll) + lle);\n        cs.moveTo(lineLength, llo);\n        cs.lineTo(lineLength, (llo + ll) + lle);\n        if (annotation.hasCaption() && (!contents.isEmpty())) {\n            // Note that Adobe places the text as a caption even if /CP is not set\n            // when the text is so long that it would cross arrows, but we ignore this for now\n            // and stick to the specification.\n            PDFont font = getDefaultFont();\n            // TODO: support newlines!!!!!\n            // see https://www.pdfill.com/example/pdf_commenting_new.pdf\n            float contentLength = 0;\n            try {\n                contentLength = (font.getStringWidth(annotation.getContents()) / 1000) * FONT_SIZE;\n                // TODO How to decide the size of the font?\n                // 9 seems to be standard, but if the text doesn't fit, a scaling is done\n                // see AnnotationSample.Standard.pdf, diagonal line\n            } catch (IllegalArgumentException ex) {\n                // Adobe Reader displays placeholders instead\n                LOG.error((\"line text '\" + annotation.getContents()) + \"' can't be shown\", ex);\n            }\n            float xOffset = (lineLength - contentLength) / 2;\n            float yOffset;\n            String captionPositioning = annotation.getCaptionPositioning();\n            // draw the line horizontally, using the rotation CTM to get to correct final position\n            // that's the easiest way to calculate the positions for the line before and after inline caption\n            if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.moveTo(lineEndingSize, y);\n            } else {\n                cs.moveTo(0, y);\n            }\n            if (\"Top\".equals(captionPositioning)) {\n                // this arbitrary number is from Adobe\n                yOffset = 1.908F;\n            } else {\n                // Inline\n                // this arbitrary number is from Adobe\n                yOffset = -2.6F;\n                cs.lineTo(xOffset - lineEndingSize, y);\n                cs.moveTo((lineLength - xOffset) + lineEndingSize, y);\n            }\n            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.lineTo(lineLength - lineEndingSize, y);\n            } else {\n                cs.lineTo(lineLength, y);\n            }\n            cs.drawShape(lineEndingSize, hasStroke, false);\n            // /CO entry (caption offset)\n            float captionHorizontalOffset = annotation.getCaptionHorizontalOffset();\n            float captionVerticalOffset = annotation.getCaptionVerticalOffset();\n            // check contentLength so we don't show if there was trouble before\n            if (contentLength > 0) {\n                cs.beginText();\n                cs.setFont(font, FONT_SIZE);\n                cs.newLineAtOffset(xOffset + captionHorizontalOffset, (y + yOffset) + captionVerticalOffset);\n                cs.showText(annotation.getContents());\n                cs.endText();\n            }\n            if (Float.compare(captionVerticalOffset, 0) != 0) {\n                // Adobe paints vertical bar to the caption\n                cs.moveTo(0 + (lineLength / 2), y);\n                cs.lineTo(0 + (lineLength / 2), y + captionVerticalOffset);\n                cs.drawShape(lineEndingSize, hasStroke, false);\n            }\n        } else {\n            if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.moveTo(lineEndingSize, y);\n            } else {\n                cs.moveTo(0, y);\n            }\n            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.lineTo(lineLength - lineEndingSize, y);\n            } else {\n                cs.lineTo(lineLength, y);\n            }\n            cs.drawShape(lineEndingSize, hasStroke, false);\n        }\n        cs.restoreGraphicsState();\n        // paint the styles here and not before showing the text, or the text would appear\n        // with the interior color\n        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        // observed with diagonal line of file AnnotationSample.Standard.pdf\n        // when width is very small, the border of the line ending shapes\n        // is not drawn.\n        if (ab.width < 1.0E-5) {\n            hasStroke = false;\n        }\n        // check for LE_NONE only needed to avoid q cm Q for that case\n        if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {\n            cs.saveGraphicsState();\n            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n                drawStyle(annotation.getStartPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, false);\n            } else {\n                // Support of non-angled styles is more difficult than in the other handlers\n                // because the lines do not always go from (x1,y1) to (x2,y2) due to the leader lines\n                // when the \"y\" value above is not 0.\n                // We use the angle we already know and the distance y to translate to the new coordinate.\n                float xx1 = x1 - ((float) (y * Math.sin(angle)));\n                float yy1 = y1 + ((float) (y * Math.cos(angle)));\n                drawStyle(annotation.getStartPointEndingStyle(), cs, xx1, yy1, lineEndingSize, hasStroke, hasBackground, false);\n            }\n            cs.restoreGraphicsState();\n        }\n        // check for LE_NONE only needed to avoid q cm Q for that case\n        if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {\n            // save / restore not needed because it's the last one\n            if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.transform(Matrix.getRotateInstance(angle, x2, y2));\n                drawStyle(annotation.getEndPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, true);\n            } else {\n                // Support of non-angled styles is more difficult than in the other handlers\n                // because the lines do not always go from (x1,y1) to (x2,y2) due to the leader lines\n                // when the \"y\" value above is not 0.\n                // We use the angle we already know and the distance y to translate to the new coordinate.\n                float xx2 = x2 - ((float) (y * Math.sin(angle)));\n                float yy2 = y2 + ((float) (y * Math.cos(angle)));\n                drawStyle(annotation.getEndPointEndingStyle(), cs, xx2, yy2, lineEndingSize, hasStroke, hasBackground, true);\n            }\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setStrokingColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setStrokingColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the stroking color using an AWT color. Conversion uses the default sRGB color space.\n *\n * @param color\n * \t\tThe color to set.\n * @throws IOException\n * \t\tIf an IO error occurs while writing to the stream.\n */\npublic void setStrokingColor(Color color) throws IOException {\n    float[] components = new float[]{ color.getRed() / 255.0F, color.getGreen() / 255.0F, color.getBlue() / 255.0F };\n    PDColor pdColor = new PDColor(components, PDDeviceRGB.INSTANCE);\n    setStrokingColor(pdColor);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setUserKey",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setUserKey", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the U entry in the standard encryption dictionary.\n *\n * @param u\n * \t\tA 32 byte array.\n * @throws IOException\n * \t\tIf there is an error setting the data.\n */\npublic void setUserKey(byte[] u) throws IOException {\n    dictionary.setItem(COSName.U, new COSString(u));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingContext.getRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingContext.getRaster", "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingContext.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Raster getRaster(int x, int y, int w, int h) {\n    WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);\n    int[] data = new int[(w * h) * 4];\n    float[] values = new float[2];\n    for (int j = 0; j < h; j++) {\n        for (int i = 0; i < w; i++) {\n            int index = ((j * w) + i) * 4;\n            boolean useBackground = false;\n            values[0] = x + i;\n            values[1] = y + j;\n            rat.transform(values, 0, values, 0, 1);\n            if ((((values[0] < domain[0]) || (values[0] > domain[1])) || (values[1] < domain[2])) || (values[1] > domain[3])) {\n                if (getBackground() == null) {\n                    continue;\n                }\n                useBackground = true;\n            }\n            // evaluate function\n            float[] tmpValues;// \"values\" can't be reused due to different length\n\n            if (useBackground) {\n                tmpValues = getBackground();\n            } else {\n                try {\n                    tmpValues = type1ShadingType.evalFunction(values);\n                } catch (IOException e) {\n                    LOG.error(\"error while processing a function\", e);\n                    continue;\n                }\n            }\n            // convert color values from shading color space to RGB\n            PDColorSpace shadingColorSpace = getShadingColorSpace();\n            if (shadingColorSpace != null) {\n                try {\n                    tmpValues = shadingColorSpace.toRGB(tmpValues);\n                } catch (IOException e) {\n                    LOG.error(\"error processing color space\", e);\n                    continue;\n                }\n            }\n            data[index] = ((int) (tmpValues[0] * 255));\n            data[index + 1] = ((int) (tmpValues[1] * 255));\n            data[index + 2] = ((int) (tmpValues[2] * 255));\n            data[index + 3] = 255;\n        }\n    }\n    raster.setPixels(0, 0, w, h, data);\n    return raster;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.function.PDFunction.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.function.PDFunction.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param function\n * \t\tThe function stream.\n */\npublic PDFunction(COSBase function) {\n    if (function instanceof COSStream) {\n        functionStream = new PDStream(((COSStream) (function)));\n        functionStream.getCOSObject().setItem(COSName.TYPE, COSName.FUNCTION);\n    } else if (function instanceof COSDictionary) {\n        functionDictionary = ((COSDictionary) (function));\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDExtendedGraphicsState.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDExtendedGraphicsState.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor, creates blank graphics state.\n */\npublic PDExtendedGraphicsState() {\n    dict = new COSDictionary();\n    dict.setItem(COSName.TYPE, COSName.EXT_G_STATE);\n    cache = null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.saveIncrementalForExternalSigning",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.saveIncrementalForExternalSigning", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Save PDF incrementally without closing for external signature creation scenario. The general sequence is:\n *\n * <pre>\n *    PDDocument pdDocument = ...;\n *    OutputStream outputStream = ...;\n *    SignatureOptions signatureOptions = ...; // options to specify fine tuned signature options or null for defaults\n *    PDSignature pdSignature = ...;\n *\n *    // add signature parameters to be used when creating signature dictionary\n *    pdDocument.addSignature(pdSignature, signatureOptions);\n *    // prepare PDF for signing and obtain helper class to be used\n *    ExternalSigningSupport externalSigningSupport = pdDocument.saveIncrementalForExternalSigning(outputStream);\n *    // get data to be signed\n *    InputStream dataToBeSigned = externalSigningSupport.getContent();\n *    // invoke signature service\n *    byte[] signature = sign(dataToBeSigned);\n *    // set resulted CMS signature\n *    externalSigningSupport.setSignature(signature);\n *\n *    // last step is to close the document\n *    pdDocument.close();\n * </pre>\n * <p>\n * Note that after calling this method, only {@code close()} method may invoked for {@code PDDocument} instance and\n * only AFTER {@link ExternalSigningSupport} instance is used.\n * </p>\n * <p>\n * Don't use the input file as target as this will produce a corrupted file.\n *\n * @param output\n * \t\tstream to write the final PDF. It will be closed when the document is closed. It <i><b>must\n * \t\tnever</b></i> point to the source file or that one will be harmed!\n * @return instance to be used for external signing and setting CMS signature\n * @throws IOException\n * \t\tif the output could not be written\n * @throws IllegalStateException\n * \t\tif the document was not loaded from a file or a stream or signature options were\n * \t\tnot set.\n */\npublic ExternalSigningSupport saveIncrementalForExternalSigning(OutputStream output) throws IOException {\n    subsetDesignatedFonts();\n    if (pdfSource == null) {\n        throw new IllegalStateException(\"document was not loaded from a file or a stream\");\n    }\n    // PDFBOX-3978: getLastSignatureDictionary() not helpful if signing into a template\n    // that is not the last signature. So give higher priority to signature with update flag.\n    PDSignature foundSignature = null;\n    for (PDSignature sig : getSignatureDictionaries()) {\n        foundSignature = sig;\n        if (sig.getCOSObject().isNeedToBeUpdated()) {\n            break;\n        }\n    }\n    if (foundSignature == null) {\n        throw new IllegalStateException(\"document does not contain signature fields\");\n    }\n    int[] byteRange = foundSignature.getByteRange();\n    if (!Arrays.equals(byteRange, RESERVE_BYTE_RANGE)) {\n        throw new IllegalStateException(\"signature reserve byte range has been changed \" + \"after addSignature(), please set the byte range that existed after addSignature()\");\n    }\n    COSWriter writer = new COSWriter(output, pdfSource);\n    writer.write(this);\n    signingSupport = new SigningSupport(writer);\n    return signingSupport;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.Splitter.split",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.Splitter.split", "org.apache.pdfbox.multipdf.Splitter.cloneStructureTree", "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.<clinit>" ],
    "fullMethods" : [ "/**\n * This will take a document and split into several other documents.\n *\n * @param document\n * \t\tThe document to split.\n * @return A list of all the split documents. These should all be saved before closing any\ndocuments, including the source document. Any further operations should be made after\nreloading them, to avoid problems due to resource sharing. For the same reason, they should\nnot be saved with encryption.\n * @throws IOException\n * \t\tIf there is an IOError\n */\npublic List<PDDocument> split(PDDocument document) throws IOException {\n    // reset the currentPageNumber for a case if the split method will be used several times\n    currentPageNumber = 0;\n    destinationDocuments = new ArrayList<>();\n    sourceDocument = document;\n    pageDictMaps = new ArrayList<>();\n    annotDictMaps = new ArrayList<>();\n    destToFixMap = new HashMap<>();\n    idSet = new HashSet<>();\n    roleSet = new HashSet<>();\n    processPages();\n    for (int i = 0; i < destinationDocuments.size(); ++i) {\n        PDDocument destinationDocument = destinationDocuments.get(i);\n        pageDictMap = pageDictMaps.get(i);\n        annotDictMap = annotDictMaps.get(i);\n        cloneStructureTree(destinationDocument);\n        fixDestinations(destinationDocument);\n    }\n    return destinationDocuments;\n}", "/**\n * Clone the structure tree from the source to the current destination document. This must be\n * called after all pages are processed.\n *\n * @param destinationDocument\n * @throws IOException\n */\nprivate void cloneStructureTree(PDDocument destinationDocument) throws IOException {\n    PDStructureTreeRoot srcStructureTreeRoot = sourceDocument.getDocumentCatalog().getStructureTreeRoot();\n    if (srcStructureTreeRoot == null) {\n        return;\n    }\n    structDictMap = new HashMap<>();\n    PDStructureTreeRoot dstStructureTreeRoot = new PDStructureTreeRoot();\n    PDPageTree dstPageTree = destinationDocument.getPages();\n    // clone /K, also fills dictMap\n    COSBase k1 = srcStructureTreeRoot.getK();\n    COSBase k2 = new KCloner(dstPageTree).createClone(k1, dstStructureTreeRoot.getCOSObject(), null);\n    dstStructureTreeRoot.setK(k2);\n    // transfer ParentTree using the map because the dictionaries are all found in the /K structure.\n    PDNumberTreeNode srcParentTree = srcStructureTreeRoot.getParentTree();\n    Map<Integer, COSObjectable> srcNumberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(srcParentTree);\n    Map<Integer, COSObjectable> dstNumberTreeAsMap = new LinkedHashMap<>();\n    for (int p = 0; p < dstPageTree.getCount(); ++p) {\n        PDPage page = dstPageTree.get(p);\n        int sp1 = page.getStructParents();\n        if (sp1 != (-1)) {\n            cloneTreeElement(srcNumberTreeAsMap, dstNumberTreeAsMap, sp1);\n        }\n        for (PDAnnotation ann : page.getAnnotations()) {\n            int sp2 = ann.getStructParent();\n            if (sp2 != (-1)) {\n                cloneTreeElement(srcNumberTreeAsMap, dstNumberTreeAsMap, sp2);\n            }\n            PDAppearanceStream normalAppearanceStream = ann.getNormalAppearanceStream();\n            if (normalAppearanceStream != null) {\n                processResources(normalAppearanceStream.getResources(), srcNumberTreeAsMap, dstNumberTreeAsMap, new HashSet<>());\n            }\n        }\n        processResources(page.getResources(), srcNumberTreeAsMap, dstNumberTreeAsMap, new HashSet<>());\n    }\n    PDNumberTreeNode dstNumberTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);\n    dstNumberTreeNode.setNumbers(dstNumberTreeAsMap);\n    dstStructureTreeRoot.setParentTree(dstNumberTreeNode);\n    Integer upperLimit = dstNumberTreeNode.getUpperLimit();\n    if (upperLimit != null) {\n        dstStructureTreeRoot.setParentTreeNextKey(upperLimit + 1);\n    }\n    dstStructureTreeRoot.setClassMap(srcStructureTreeRoot.getClassMap());\n    cloneRoleMap(srcStructureTreeRoot, dstStructureTreeRoot);\n    cloneIDTree(srcStructureTreeRoot, dstStructureTreeRoot);\n    destinationDocument.getDocumentCatalog().setStructureTreeRoot(dstStructureTreeRoot);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLine.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLine.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLineAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDLineAppearanceHandler appearanceHandler = new PDLineAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationPolygon.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationPolygon.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationPolygon(COSDictionary a) {\n    super(a);\n}", "/**\n * Constructor.\n *\n * @param a\n * \t\tThe FDF annotation.\n */\npublic FDFAnnotation(COSDictionary a) {\n    annot = a;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.close",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.close", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will close the underlying COSDocument object.\n *\n * @throws IOException\n * \t\tIf there is an error releasing resources.\n */\n@Override\npublic void close() throws IOException {\n    if (!document.isClosed()) {\n        // Make sure that:\n        // - first Exception is kept\n        // - all IO resources are closed\n        // - there's a way to see which errors occurred\n        IOException firstException = null;\n        // close resources and COSWriter\n        if (signingSupport != null) {\n            firstException = IOUtils.closeAndLogException(signingSupport, LOG, \"SigningSupport\", firstException);\n        }\n        // close all intermediate I/O streams\n        firstException = IOUtils.closeAndLogException(document, LOG, \"COSDocument\", firstException);\n        // close the source PDF stream, if we read from one\n        if (pdfSource != null) {\n            firstException = IOUtils.closeAndLogException(pdfSource, LOG, \"RandomAccessRead pdfSource\", firstException);\n        }\n        // close fonts\n        for (TrueTypeFont ttf : fontsToClose) {\n            firstException = IOUtils.closeAndLogException(ttf, LOG, \"TrueTypeFont\", firstException);\n        }\n        // rethrow first exception to keep method contract\n        if (firstException != null) {\n            throw firstException;\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.PDPostScriptXObject.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.PDPostScriptXObject.<init>", "org.apache.pdfbox.pdmodel.graphics.PDXObject.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a PostScript XObject.\n *\n * @param stream\n * \t\tThe XObject stream\n */\npublic PDPostScriptXObject(COSStream stream) {\n    super(stream, COSName.PS);\n}", "/**\n * Creates a new XObject from the given stream and subtype.\n *\n * @param stream\n * \t\tThe stream to read.\n * @param subtype\n * \t\tthe subtype to be used for this XObject\n */\nprotected PDXObject(COSStream stream, COSName subtype) {\n    this.stream = new PDStream(stream);\n    // could be used for writing:\n    stream.setName(COSName.TYPE, COSName.XOBJECT.getName());\n    stream.setName(COSName.SUBTYPE, subtype.getName());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getColorSpace",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getColorSpace", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PDColorSpace getColorSpace() throws IOException {\n    if (colorSpace == null) {\n        COSBase cosBase = getCOSObject().getItem(COSName.COLORSPACE, COSName.CS);\n        if (cosBase != null) {\n            COSObject indirect = null;\n            if (((cosBase instanceof COSObject) && (resources != null)) && (resources.getResourceCache() != null)) {\n                // PDFBOX-4022: use the resource cache because several images\n                // might have the same colorspace indirect object.\n                indirect = ((COSObject) (cosBase));\n                colorSpace = resources.getResourceCache().getColorSpace(indirect);\n                if (colorSpace != null) {\n                    return colorSpace;\n                }\n            }\n            colorSpace = PDColorSpace.create(cosBase, resources);\n            if (indirect != null) {\n                resources.getResourceCache().put(indirect, colorSpace);\n            }\n        } else if (isStencil()) {\n            // stencil mask color space must be gray, it is often missing\n            colorSpace = PDDeviceGray.INSTANCE;\n        } else {\n            initJPXValues();\n        }\n        if (colorSpace == null) {\n            // an image without a color space is always broken\n            throw new IOException(\"could not determine color space\");\n        }\n    }\n    return colorSpace;\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.CurveTo.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.CurveTo.process", "org.apache.pdfbox.contentstream.operator.graphics.CurveTo.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.size() < 6) {\n        throw new MissingOperandException(operator, operands);\n    }\n    if (!checkArrayTypesClass(operands, COSNumber.class)) {\n        return;\n    }\n    COSNumber x1 = ((COSNumber) (operands.get(0)));\n    COSNumber y1 = ((COSNumber) (operands.get(1)));\n    COSNumber x2 = ((COSNumber) (operands.get(2)));\n    COSNumber y2 = ((COSNumber) (operands.get(3)));\n    COSNumber x3 = ((COSNumber) (operands.get(4)));\n    COSNumber y3 = ((COSNumber) (operands.get(5)));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    Point2D.Float point1 = context.transformedPoint(x1.floatValue(), y1.floatValue());\n    Point2D.Float point2 = context.transformedPoint(x2.floatValue(), y2.floatValue());\n    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());\n    if (context.getCurrentPoint() == null) {\n        LOG.warn((((\"curveTo (\" + point3.x) + \",\") + point3.y) + \") without initial MoveTo\");\n        context.moveTo(point3.x, point3.y);\n    } else {\n        context.curveTo(point1.x, point1.y, point2.x, point2.y, point3.x, point3.y);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.BlendCompositeContext.compose",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.BlendCompositeContext.compose", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void compose(Raster src, Raster dstIn, WritableRaster dstOut) {\n    int x0 = src.getMinX();\n    int y0 = src.getMinY();\n    int width = Math.min(Math.min(src.getWidth(), dstIn.getWidth()), dstOut.getWidth());\n    int height = Math.min(Math.min(src.getHeight(), dstIn.getHeight()), dstOut.getHeight());\n    int x1 = x0 + width;\n    int y1 = y0 + height;\n    int dstInXShift = dstIn.getMinX() - x0;\n    int dstInYShift = dstIn.getMinY() - y0;\n    int dstOutXShift = dstOut.getMinX() - x0;\n    int dstOutYShift = dstOut.getMinY() - y0;\n    ColorSpace srcColorSpace = srcColorModel.getColorSpace();\n    int numSrcColorComponents = srcColorModel.getNumColorComponents();\n    int numSrcComponents = src.getNumBands();\n    boolean srcHasAlpha = numSrcComponents > numSrcColorComponents;\n    ColorSpace dstColorSpace = dstColorModel.getColorSpace();\n    int numDstColorComponents = dstColorModel.getNumColorComponents();\n    int numDstComponents = dstIn.getNumBands();\n    boolean dstHasAlpha = numDstComponents > numDstColorComponents;\n    int srcColorSpaceType = srcColorSpace.getType();\n    int dstColorSpaceType = dstColorSpace.getType();\n    boolean subtractive = (dstColorSpaceType != ColorSpace.TYPE_RGB) && (dstColorSpaceType != ColorSpace.TYPE_GRAY);\n    boolean blendModeIsSeparable = blendMode.isSeparableBlendMode();\n    boolean needsColorConversion = !srcColorSpace.equals(dstColorSpace);\n    Object srcPixel = null;\n    Object dstPixel = null;\n    float[] srcComponents = new float[numSrcComponents];\n    // PDFBOX-3501 let getNormalizedComponents allocate to avoid\n    // ArrayIndexOutOfBoundsException for bitonal target\n    float[] dstComponents = null;\n    float[] srcColor = new float[numSrcColorComponents];\n    float[] srcConverted;\n    float[] dstConverted;\n    float[] rgbResult = (blendModeIsSeparable) ? null : new float[dstHasAlpha ? 4 : 3];\n    for (int y = y0; y < y1; y++) {\n        for (int x = x0; x < x1; x++) {\n            srcPixel = src.getDataElements(x, y, srcPixel);\n            dstPixel = dstIn.getDataElements(dstInXShift + x, dstInYShift + y, dstPixel);\n            srcComponents = srcColorModel.getNormalizedComponents(srcPixel, srcComponents, 0);\n            dstComponents = dstColorModel.getNormalizedComponents(dstPixel, dstComponents, 0);\n            float srcAlpha = (srcHasAlpha) ? srcComponents[numSrcColorComponents] : 1.0F;\n            float dstAlpha = (dstHasAlpha) ? dstComponents[numDstColorComponents] : 1.0F;\n            srcAlpha = srcAlpha * constantAlpha;\n            float resultAlpha = (dstAlpha + srcAlpha) - (srcAlpha * dstAlpha);\n            float srcAlphaRatio = (resultAlpha > 0) ? srcAlpha / resultAlpha : 0;\n            if (blendModeIsSeparable) {\n                // convert color\n                System.arraycopy(srcComponents, 0, srcColor, 0, numSrcColorComponents);\n                if (needsColorConversion) {\n                    // TODO - very very slow - Hash results???\n                    float[] cieXYZ = srcColorSpace.toCIEXYZ(srcColor);\n                    srcConverted = dstColorSpace.fromCIEXYZ(cieXYZ);\n                } else {\n                    srcConverted = srcColor;\n                }\n                for (int k = 0; k < numDstColorComponents; k++) {\n                    float srcValue = srcConverted[k];\n                    float dstValue = dstComponents[k];\n                    if (subtractive) {\n                        srcValue = 1 - srcValue;\n                        dstValue = 1 - dstValue;\n                    }\n                    float value = blendMode.getBlendChannelFunction().blendChannel(srcValue, dstValue);\n                    value = srcValue + (dstAlpha * (value - srcValue));\n                    value = dstValue + (srcAlphaRatio * (value - dstValue));\n                    if (subtractive) {\n                        value = 1 - value;\n                    }\n                    dstComponents[k] = value;\n                }\n            } else {\n                // Nonseparable blend modes are computed in RGB color space.\n                // TODO - CMYK color spaces need special treatment.\n                if (srcColorSpaceType == ColorSpace.TYPE_RGB) {\n                    srcConverted = srcComponents;\n                } else {\n                    srcConverted = srcColorSpace.toRGB(srcComponents);\n                }\n                if (dstColorSpaceType == ColorSpace.TYPE_RGB) {\n                    dstConverted = dstComponents;\n                } else {\n                    dstConverted = dstColorSpace.toRGB(dstComponents);\n                }\n                blendMode.getBlendFunction().blend(srcConverted, dstConverted, rgbResult);\n                for (int k = 0; k < 3; k++) {\n                    float srcValue = srcConverted[k];\n                    float dstValue = dstConverted[k];\n                    float value = rgbResult[k];\n                    value = Math.max(Math.min(value, 1.0F), 0.0F);\n                    value = srcValue + (dstAlpha * (value - srcValue));\n                    value = dstValue + (srcAlphaRatio * (value - dstValue));\n                    rgbResult[k] = value;\n                }\n                if (dstColorSpaceType == ColorSpace.TYPE_RGB) {\n                    System.arraycopy(rgbResult, 0, dstComponents, 0, dstComponents.length);\n                } else {\n                    float[] temp = dstColorSpace.fromRGB(rgbResult);\n                    System.arraycopy(temp, 0, dstComponents, 0, Math.min(dstComponents.length, temp.length));\n                }\n            }\n            if (dstHasAlpha) {\n                dstComponents[numDstColorComponents] = resultAlpha;\n            }\n            dstPixel = dstColorModel.getDataElements(dstComponents, 0, dstPixel);\n            dstOut.setDataElements(dstOutXShift + x, dstOutYShift + y, dstPixel);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.create",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.create", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * Create the correct FDFAnnotation.\n *\n * @param fdfDic\n * \t\tThe FDF dictionary.\n * @return A newly created FDFAnnotation\n */\npublic static FDFAnnotation create(COSDictionary fdfDic) {\n    FDFAnnotation retval = null;\n    if (fdfDic != null) {\n        String fdfDicName = fdfDic.getNameAsString(COSName.SUBTYPE);\n        if (FDFAnnotationText.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationText(fdfDic);\n        } else if (FDFAnnotationCaret.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationCaret(fdfDic);\n        } else if (FDFAnnotationFreeText.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationFreeText(fdfDic);\n        } else if (FDFAnnotationFileAttachment.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationFileAttachment(fdfDic);\n        } else if (FDFAnnotationHighlight.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationHighlight(fdfDic);\n        } else if (FDFAnnotationInk.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationInk(fdfDic);\n        } else if (FDFAnnotationLine.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationLine(fdfDic);\n        } else if (FDFAnnotationLink.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationLink(fdfDic);\n        } else if (FDFAnnotationCircle.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationCircle(fdfDic);\n        } else if (FDFAnnotationSquare.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationSquare(fdfDic);\n        } else if (FDFAnnotationPolygon.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationPolygon(fdfDic);\n        } else if (FDFAnnotationPolyline.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationPolyline(fdfDic);\n        } else if (FDFAnnotationSound.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationSound(fdfDic);\n        } else if (FDFAnnotationSquiggly.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationSquiggly(fdfDic);\n        } else if (FDFAnnotationStamp.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationStamp(fdfDic);\n        } else if (FDFAnnotationStrikeOut.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationStrikeOut(fdfDic);\n        } else if (FDFAnnotationUnderline.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationUnderline(fdfDic);\n        } else {\n            LOG.warn((\"Unknown or unsupported annotation type '\" + fdfDicName) + \"'\");\n        }\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPolygon.getInteriorColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPolygon.getInteriorColor", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the interior color.\n *\n * @return object representing the color.\n */\npublic PDColor getInteriorColor() {\n    return getColor(COSName.IC);\n}", "protected PDColor getColor(COSName itemName) {\n    COSArray cs = this.getCOSObject().getCOSArray(itemName);\n    if (cs != null) {\n        PDColorSpace colorSpace = null;\n        switch (cs.size()) {\n            case 1 :\n                colorSpace = PDDeviceGray.INSTANCE;\n                break;\n            case 3 :\n                colorSpace = PDDeviceRGB.INSTANCE;\n                break;\n            case 4 :\n                colorSpace = PDDeviceCMYK.INSTANCE;\n                break;\n            default :\n                break;\n        }\n        return new PDColor(cs, colorSpace);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFAnnotation() {\n    annot = new COSDictionary();\n    annot.setItem(COSName.TYPE, COSName.ANNOT);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.setClassMap",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.setClassMap", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the ClassMap.\n *\n * @param classMap\n * \t\tnull, or a map whose elements are either {@link PDAttributeObject} or lists\n * \t\tof it.\n */\npublic void setClassMap(Map<String, Object> classMap) {\n    if ((classMap == null) || classMap.isEmpty()) {\n        this.getCOSObject().removeItem(COSName.CLASS_MAP);\n        return;\n    }\n    COSDictionary classMapDictionary = new COSDictionary();\n    classMap.forEach((name, object) -> {\n        if (object instanceof PDAttributeObject) {\n            classMapDictionary.setItem(name, ((PDAttributeObject) (object)).getCOSObject());\n        } else if (object instanceof List) {\n            classMapDictionary.setItem(name, new COSArray(((List<PDAttributeObject>) (object))));\n        }\n    });\n    this.getCOSObject().setItem(COSName.CLASS_MAP, classMapDictionary);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.SoftMask.SoftPaintContext.getRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.SoftMask.SoftPaintContext.getRaster", "org.apache.pdfbox.rendering.SoftMask.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Raster getRaster(int x1, int y1, int w, int h) {\n    Raster raster = context.getRaster(x1, y1, w, h);\n    ColorModel rasterCM = context.getColorModel();\n    float[] input = null;\n    Float[] map = null;\n    if (transferFunction != null) {\n        map = new Float[256];\n        input = new float[1];\n    }\n    // buffer\n    WritableRaster output = getColorModel().createCompatibleWritableRaster(w, h);\n    // the soft mask has its own bbox\n    x1 = x1 - ((int) (bboxDevice.getX()));\n    y1 = y1 - ((int) (bboxDevice.getY()));\n    int[] gray = new int[4];\n    Object pixelInput = null;\n    int[] pixelOutput = new int[4];\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            pixelInput = raster.getDataElements(x, y, pixelInput);\n            pixelOutput[0] = rasterCM.getRed(pixelInput);\n            pixelOutput[1] = rasterCM.getGreen(pixelInput);\n            pixelOutput[2] = rasterCM.getBlue(pixelInput);\n            pixelOutput[3] = rasterCM.getAlpha(pixelInput);\n            // get the alpha value from the gray mask, if within mask bounds\n            gray[0] = 0;\n            if (((((x1 + x) >= 0) && ((y1 + y) >= 0)) && ((x1 + x) < mask.getWidth())) && ((y1 + y) < mask.getHeight())) {\n                mask.getRaster().getPixel(x1 + x, y1 + y, gray);\n                int g = gray[0];\n                if (transferFunction != null) {\n                    // apply transfer function\n                    try {\n                        if (map[g] != null) {\n                            // was calculated before\n                            pixelOutput[3] = Math.round(pixelOutput[3] * map[g]);\n                        } else {\n                            // calculate and store in map\n                            input[0] = g / 255.0F;\n                            float f = transferFunction.eval(input)[0];\n                            map[g] = f;\n                            pixelOutput[3] = Math.round(pixelOutput[3] * f);\n                        }\n                    } catch (IOException ex) {\n                        // ignore exception, treat as outside\n                        LOG.debug(\"Couldn't apply transferFunction - treating as outside\", ex);\n                        pixelOutput[3] = Math.round(pixelOutput[3] * (bc / 255.0F));\n                    }\n                } else {\n                    pixelOutput[3] = Math.round(pixelOutput[3] * (g / 255.0F));\n                }\n            } else {\n                pixelOutput[3] = Math.round(pixelOutput[3] * (bc / 255.0F));\n            }\n            output.setPixel(x, y, pixelOutput);\n        }\n    }\n    return output;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.put",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the shading resource with the given name.\n *\n * @param name\n * \t\tthe name of the resource\n * @param shading\n * \t\tthe shading to be added\n */\npublic void put(COSName name, PDShading shading) {\n    put(COSName.SHADING, name, shading);\n}", "/**\n * Sets the value of a given named resource.\n */\nprivate void put(COSName kind, COSName name, COSObjectable object) {\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if (dict == null) {\n        dict = new COSDictionary();\n        resources.setItem(kind, dict);\n    }\n    dict.setItem(name, object);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAffineTransform",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAffineTransform", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createAffineTransform(AffineTransform affineTransform) {\n    pdfStructure.setAffineTransform(affineTransform);\n    LOG.info(\"Matrix has been added\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.save",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.save", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * Save the document using the given compression.\n * <p>\n * Don't use the input file as target as this will produce a corrupted file.\n * <p>\n * If encryption has been activated (with {@link #protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy)\n * protect(ProtectionPolicy)}), do not use the document after saving because the contents are now encrypted.\n * The same applies if your file was created from parts of another file and that\n * one is to be used after saving.\n *\n * @param output\n * \t\tThe stream to write to. It is recommended to wrap it in a {@link java.io.BufferedOutputStream},\n * \t\tunless it is already buffered.\n * @param compressParameters\n * \t\tThe parameters for the document's compression.\n * @throws IOException\n * \t\tif the output could not be written\n */\npublic void save(OutputStream output, CompressParameters compressParameters) throws IOException {\n    if (document.isClosed()) {\n        throw new IOException(\"Cannot save a document which has been closed\");\n    }\n    // object stream compression requires a cross reference stream.\n    document.setIsXRefStream((compressParameters != null)// \n     && (CompressParameters.NO_COMPRESSION != compressParameters));\n    subsetDesignatedFonts();\n    // save PDF\n    COSWriter writer = new COSWriter(output, compressParameters);\n    writer.write(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.function.PDFunctionType0.eval",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.function.PDFunctionType0.eval", "org.apache.pdfbox.cos.COSArray.toFloatArray", "org.apache.pdfbox.cos.COSArray.getObject", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic float[] eval(float[] input) throws IOException {\n    // This involves linear interpolation based on a set of sample points.\n    // Theoretically it's not that difficult ... see section 3.9.1 of the PDF Reference.\n    float[] sizeValues = getSize().toFloatArray();\n    int bitsPerSample = getBitsPerSample();\n    float maxSample = ((float) (Math.pow(2, bitsPerSample) - 1.0));\n    int numberOfInputValues = input.length;\n    int numberOfOutputValues = getNumberOfOutputParameters();\n    int[] inputPrev = new int[numberOfInputValues];\n    int[] inputNext = new int[numberOfInputValues];\n    input = input.clone();// PDFBOX-4461\n\n    for (int i = 0; i < numberOfInputValues; i++) {\n        PDRange domain = getDomainForInput(i);\n        PDRange encodeValues = getEncodeForParameter(i);\n        float min = domain.getMin();\n        float max = domain.getMax();\n        input[i] = clipToRange(input[i], min, max);\n        input[i] = interpolate(input[i], min, max, encodeValues.getMin(), encodeValues.getMax());\n        input[i] = clipToRange(input[i], 0, sizeValues[i] - 1);\n        inputPrev[i] = ((int) (Math.floor(input[i])));\n        inputNext[i] = ((int) (Math.ceil(input[i])));\n    }\n    float[] outputValues = new Rinterpol(input, inputPrev, inputNext).rinterpolate();\n    for (int i = 0; i < numberOfOutputValues; i++) {\n        PDRange range = getRangeForOutput(i);\n        PDRange decodeValues = getDecodeForParameter(i);\n        if (decodeValues == null) {\n            throw new IOException(\"Range missing in function /Decode entry\");\n        }\n        outputValues[i] = interpolate(outputValues[i], 0, maxSample, decodeValues.getMin(), decodeValues.getMax());\n        outputValues[i] = clipToRange(outputValues[i], range.getMin(), range.getMax());\n    }\n    return outputValues;\n}", "/**\n * This will take an COSArray of numbers and convert it to a float[].\n *\n * @return This COSArray as an array of float numbers.\n */\npublic float[] toFloatArray() {\n    float[] retval = new float[size()];\n    for (int i = 0; i < retval.length; i++) {\n        COSBase base = getObject(i);\n        retval[i] = (base instanceof COSNumber) ? ((COSNumber) (base)).floatValue() : 0;\n    }\n    return retval;\n}", "/**\n * This will get an object from the array.  This will dereference the object.\n * If the object is COSNull then null will be returned.\n *\n * @param index\n * \t\tThe index into the array to get the object.\n * @return The object at the requested index.\n */\npublic COSBase getObject(int index) {\n    COSBase obj = objects.get(index);\n    if (obj instanceof COSObject) {\n        obj = ((COSObject) (obj)).getObject();\n    }\n    if (obj instanceof COSNull) {\n        obj = null;\n    }\n    return obj;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.put",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the property list resource with the given name.\n *\n * @param name\n * \t\tthe name of the resource\n * @param properties\n * \t\tthe property list to be added\n */\npublic void put(COSName name, PDPropertyList properties) {\n    put(COSName.PROPERTIES, name, properties);\n}", "/**\n * Sets the value of a given named resource.\n */\nprivate void put(COSName kind, COSName name, COSObjectable object) {\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if (dict == null) {\n        dict = new COSDictionary();\n        resources.setItem(kind, dict);\n    }\n    dict.setItem(name, object);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getSuffix",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getSuffix", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get the suffix for this image type, e.g. jpg/png.\n *\n * @return The image suffix or null if not available.\n */\n@Override\npublic String getSuffix() {\n    List<COSName> filters = getStream().getFilters();\n    if (filters.isEmpty()) {\n        return \"png\";\n    } else if (filters.contains(COSName.DCT_DECODE)) {\n        return \"jpg\";\n    } else if (filters.contains(COSName.JPX_DECODE)) {\n        return \"jpx\";\n    } else if (filters.contains(COSName.CCITTFAX_DECODE)) {\n        return \"tiff\";\n    } else if ((filters.contains(COSName.FLATE_DECODE) || filters.contains(COSName.LZW_DECODE)) || filters.contains(COSName.RUN_LENGTH_DECODE)) {\n        return \"png\";\n    } else if (filters.contains(COSName.JBIG2_DECODE)) {\n        return \"jb2\";\n    } else {\n        LOG.warn(\"getSuffix() returns null, filters: \" + filters);\n        return null;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4.collectTriangles", "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    Rectangle2D bounds = null;\n    for (ShadedTriangle shadedTriangle : collectTriangles(xform, matrix)) {\n        if (bounds == null) {\n            bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n        }\n        bounds.add(shadedTriangle.corner[0]);\n        bounds.add(shadedTriangle.corner[1]);\n        bounds.add(shadedTriangle.corner[2]);\n    }\n    if (bounds == null) {\n        // Speeds up files where triangles are empty, e.g. ghostscript file 690425\n        return new Rectangle2D.Float();\n    }\n    return bounds;\n}", "@SuppressWarnings(\"squid:S1166\")\n@Override\nList<ShadedTriangle> collectTriangles(AffineTransform xform, Matrix matrix) throws IOException {\n    int bitsPerFlag = getBitsPerFlag();\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<ShadedTriangle> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            byte flag = ((byte) (0));\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n            }\n            boolean eof = false;\n            while (!eof) {\n                Vertex p0;\n                Vertex p1;\n                Vertex p2;\n                Point2D[] ps;\n                float[][] cs;\n                int lastIndex;\n                try {\n                    switch (flag) {\n                        case 0 :\n                            p0 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            if (flag != 0) {\n                                LOG.error(\"bad triangle: \" + flag);\n                            }\n                            p1 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            mciis.readBits(bitsPerFlag);\n                            if (flag != 0) {\n                                LOG.error(\"bad triangle: \" + flag);\n                            }\n                            p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            ps = new Point2D[]{ p0.point, p1.point, p2.point };\n                            cs = new float[][]{ p0.color, p1.color, p2.color };\n                            list.add(new ShadedTriangle(ps, cs));\n                            flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            break;\n                        case 1 :\n                        case 2 :\n                            lastIndex = list.size() - 1;\n                            if (lastIndex < 0) {\n                                LOG.error((\"broken data stream: \" + list.size()) + \", aborting\");\n                                eof = true;\n                            } else {\n                                ShadedTriangle preTri = list.get(lastIndex);\n                                p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                                ps = new Point2D[]{ flag == 1 ? preTri.corner[1] : preTri.corner[0], preTri.corner[2], p2.point };\n                                cs = new float[][]{ flag == 1 ? preTri.color[1] : preTri.color[0], preTri.color[2], p2.color };\n                                list.add(new ShadedTriangle(ps, cs));\n                                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            }\n                            break;\n                        default :\n                            LOG.error((\"bad flag \" + flag) + \", aborting\");\n                            eof = true;\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.getFieldTree",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.getFieldTree", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Return the field tree representing all form fields\n *\n * @return the field tree representing all form fields\n */\npublic PDFieldTree getFieldTree() {\n    return new PDFieldTree(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.codeToGID",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.codeToGID", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the GID for the given character code.\n *\n * @param code\n * \t\tcharacter code\n * @return GID (glyph index)\n * @throws IOException\n * \t\tif the data could not be read\n */\npublic int codeToGID(int code) throws IOException {\n    extractCmapTable();\n    int gid = 0;\n    // non-symbolic\n    if (!isSymbolic()) {\n        String name = encoding.getName(code);\n        if (\".notdef\".equals(name)) {\n            return 0;\n        } else {\n            // (3, 1) - (Windows, Unicode)\n            if (cmapWinUnicode != null) {\n                String unicode = GlyphList.getAdobeGlyphList().toUnicode(name);\n                if (unicode != null) {\n                    int uni = unicode.codePointAt(0);\n                    gid = cmapWinUnicode.getGlyphId(uni);\n                }\n            }\n            // (1, 0) - (Macintosh, Roman)\n            if ((gid == 0) && (cmapMacRoman != null)) {\n                Integer macCode = INVERTED_MACOS_ROMAN.get(name);\n                if (macCode != null) {\n                    gid = cmapMacRoman.getGlyphId(macCode);\n                }\n            }\n            // 'post' table\n            if (gid == 0) {\n                gid = ttf.nameToGID(name);\n            }\n        }\n    } else // symbolic\n    {\n        // PDFBOX-4755 / PDF.js #5501\n        // PDFBOX-3965: fallback for font has that the symbol flag but isn't\n        if (cmapWinUnicode != null) {\n            if ((encoding instanceof WinAnsiEncoding) || (encoding instanceof MacRomanEncoding)) {\n                String name = encoding.getName(code);\n                if (\".notdef\".equals(name)) {\n                    return 0;\n                }\n                String unicode = GlyphList.getAdobeGlyphList().toUnicode(name);\n                if (unicode != null) {\n                    int uni = unicode.codePointAt(0);\n                    gid = cmapWinUnicode.getGlyphId(uni);\n                }\n            } else {\n                gid = cmapWinUnicode.getGlyphId(code);\n            }\n        }\n        // (3, 0) - (Windows, Symbol)\n        if ((gid == 0) && (cmapWinSymbol != null)) {\n            gid = cmapWinSymbol.getGlyphId(code);\n            if ((code >= 0) && (code <= 0xff)) {\n                // the CMap may use one of the following code ranges,\n                // so that we have to add the high byte to get the\n                // mapped value\n                if (gid == 0) {\n                    // F000 - F0FF\n                    gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F000);\n                }\n                if (gid == 0) {\n                    // F100 - F1FF\n                    gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F100);\n                }\n                if (gid == 0) {\n                    // F200 - F2FF\n                    gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F200);\n                }\n            }\n        }\n        // (1, 0) - (Mac, Roman)\n        if ((gid == 0) && (cmapMacRoman != null)) {\n            gid = cmapMacRoman.getGlyphId(code);\n        }\n    }\n    return gid;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.<clinit>" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    return getBounds(xform, matrix, 16);\n}", "Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    Rectangle2D bounds = null;\n    for (Patch patch : collectPatches(xform, matrix, controlPoints)) {\n        for (ShadedTriangle shadedTriangle : patch.listOfTriangles) {\n            if (bounds == null) {\n                bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n            }\n            bounds.add(shadedTriangle.corner[0]);\n            bounds.add(shadedTriangle.corner[1]);\n            bounds.add(shadedTriangle.corner[2]);\n        }\n    }\n    return bounds;\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.taggedpdf.PDExportFormatAttributeObject.setHeaders",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.taggedpdf.PDExportFormatAttributeObject.setHeaders", "org.apache.pdfbox.pdmodel.documentinterchange.taggedpdf.PDStandardAttributeObject.setArrayOfString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the headers (Headers). An array of byte strings, where each string\n * shall be the element identifier (see the\n * {@link org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureElement#getElementIdentifier()}) for a TH structure\n * element that shall be used as a header associated with this cell.\n *\n * @param headers\n * \t\tthe headers\n */\npublic void setHeaders(String[] headers) {\n    this.setArrayOfString(PDTableAttributeObject.HEADERS, headers);\n}", "/**\n * Sets an array of strings.\n *\n * @param name\n * \t\tthe attribute name\n * @param values\n * \t\tthe array of strings\n */\nprotected void setArrayOfString(String name, String[] values) {\n    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);\n    COSArray array = new COSArray();\n    for (String value : values) {\n        array.add(new COSString(value));\n    }\n    this.getCOSObject().setItem(name, array);\n    COSBase newBase = this.getCOSObject().getDictionaryObject(name);\n    this.potentiallyNotifyChanged(oldBase, newBase);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getColorSpace",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getColorSpace", "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.createColorSpace", "org.apache.pdfbox.cos.COSArray.set", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PDColorSpace getColorSpace() throws IOException {\n    COSBase cs = parameters.getDictionaryObject(COSName.CS, COSName.COLORSPACE);\n    if (cs != null) {\n        return createColorSpace(cs);\n    } else if (isStencil()) {\n        // stencil mask color space must be gray, it is often missing\n        return PDDeviceGray.INSTANCE;\n    } else {\n        // an image without a color space is always broken\n        throw new IOException(\"could not determine inline image color space\");\n    }\n}", "private PDColorSpace createColorSpace(COSBase cs) throws IOException {\n    if (cs instanceof COSName) {\n        return PDColorSpace.create(toLongName(cs), resources);\n    }\n    if ((cs instanceof COSArray) && (((COSArray) (cs)).size() > 1)) {\n        COSArray srcArray = ((COSArray) (cs));\n        COSBase csType = srcArray.get(0);\n        if (COSName.I.equals(csType) || COSName.INDEXED.equals(csType)) {\n            COSArray dstArray = new COSArray();\n            dstArray.addAll(srcArray);\n            dstArray.set(0, COSName.INDEXED);\n            dstArray.set(1, toLongName(srcArray.get(1)));\n            return PDColorSpace.create(dstArray, resources);\n        }\n        throw new IOException(\"Illegal type of inline image color space: \" + csType);\n    }\n    throw new IOException(\"Illegal type of object for inline image color space: \" + cs);\n}", "/**\n * This will set an object at a specific index.\n *\n * @param index\n * \t\tzero based index into array.\n * @param object\n * \t\tThe object to set.\n */\npublic void set(int index, COSBase object) {\n    // wrap indirect objects\n    if ((((object instanceof COSDictionary) || (object instanceof COSArray)) && (!object.isDirect())) && (object.getKey() != null)) {\n        COSObject cosObject = new COSObject(object, object.getKey());\n        objects.set(index, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        objects.set(index, object);\n        getUpdateState().update(object);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.visitFromArray",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.visitFromArray", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void visitFromArray(COSArray array) throws IOException {\n    int count = 0;\n    getStandardOutput().write(ARRAY_OPEN);\n    for (Iterator<COSBase> i = array.iterator(); i.hasNext();) {\n        COSBase current = i.next();\n        if (current instanceof COSDictionary) {\n            writeDictionary(((COSDictionary) (current)));\n        } else if (current instanceof COSArray) {\n            writeArray(((COSArray) (current)));\n        } else if (current instanceof COSObject) {\n            addObjectToWrite(current);\n            writeReference(current);\n        } else if (current == null) {\n            COSNull.NULL.accept(this);\n        } else {\n            current.accept(this);\n        }\n        count++;\n        if (i.hasNext()) {\n            if ((count % 10) == 0) {\n                getStandardOutput().writeEOL();\n            } else {\n                getStandardOutput().write(SPACE);\n            }\n        }\n    }\n    getStandardOutput().write(ARRAY_CLOSE);\n    getStandardOutput().writeEOL();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<init>", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates an Image XObject in the given document using the given filtered stream. This\n * constructor is for internal PDFBox use and is not for PDF generation. Users who want to\n * create images should look at {@link #createFromFileByExtension(File, PDDocument)}.\n *\n * @param document\n * \t\tthe current document\n * @param encodedStream\n * \t\tan encoded stream of image data\n * @param cosFilter\n * \t\tthe filter or a COSArray of filters\n * @param width\n * \t\tthe image width\n * @param height\n * \t\tthe image height\n * @param bitsPerComponent\n * \t\tthe bits per component\n * @param initColorSpace\n * \t\tthe color space\n * @throws IOException\n * \t\tif there is an error creating the XObject.\n */\npublic PDImageXObject(PDDocument document, InputStream encodedStream, COSBase cosFilter, int width, int height, int bitsPerComponent, PDColorSpace initColorSpace) throws IOException {\n    super(createRawStream(document, encodedStream), COSName.IMAGE);\n    getCOSObject().setItem(COSName.FILTER, cosFilter);\n    resources = null;\n    colorSpace = null;\n    setBitsPerComponent(bitsPerComponent);\n    setWidth(width);\n    setHeight(height);\n    setColorSpace(initColorSpace);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.getColorants",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.getColorants", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns a map of colorants and their associated Separation color space.\n *\n * @param resources\n * \t\tresources, can be null.\n * @return map of colorants to color spaces, never null.\n * @throws IOException\n * \t\tIf there is an error reading a color space\n */\npublic Map<String, PDSeparation> getColorants(PDResources resources) throws IOException {\n    Map<String, PDSeparation> actuals = new HashMap<>();\n    COSDictionary colorants = dictionary.getCOSDictionary(COSName.COLORANTS);\n    if (colorants == null) {\n        colorants = new COSDictionary();\n        dictionary.setItem(COSName.COLORANTS, colorants);\n    } else {\n        for (COSName name : colorants.keySet()) {\n            COSBase value = colorants.getDictionaryObject(name);\n            actuals.put(name.getName(), ((PDSeparation) (PDColorSpace.create(value, resources))));\n        }\n    }\n    return new COSDictionaryMap<>(actuals, colorants);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDMarkedContentReference.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDMarkedContentReference.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor\n */\npublic PDMarkedContentReference() {\n    this.dictionary = new COSDictionary();\n    this.dictionary.setName(COSName.TYPE, TYPE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationSquareCircle.getInteriorColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationSquareCircle.getInteriorColor", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the interior color of the drawn area color is in DeviceRGB color space.\n *\n * @return object representing the color.\n */\npublic PDColor getInteriorColor() {\n    return getColor(COSName.IC);\n}", "protected PDColor getColor(COSName itemName) {\n    COSArray cs = this.getCOSObject().getCOSArray(itemName);\n    if (cs != null) {\n        PDColorSpace colorSpace = null;\n        switch (cs.size()) {\n            case 1 :\n                colorSpace = PDDeviceGray.INSTANCE;\n                break;\n            case 3 :\n                colorSpace = PDDeviceRGB.INSTANCE;\n                break;\n            case 4 :\n                colorSpace = PDDeviceCMYK.INSTANCE;\n                break;\n            default :\n                break;\n        }\n        return new PDColor(cs, colorSpace);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDTargetDirectory.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDTargetDirectory.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor, creates target directory.\n */\npublic PDTargetDirectory() {\n    dict = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getFirstChild",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getFirstChild", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getOutlineItem", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @return The first child or null if there is no child.\n */\npublic PDOutlineItem getFirstChild() {\n    return getOutlineItem(COSName.FIRST);\n}", "PDOutlineItem getOutlineItem(COSName name) {\n    COSDictionary outline = getCOSObject().getCOSDictionary(name);\n    return outline != null ? new PDOutlineItem(outline) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationInk.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationInk.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDInkAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDInkAppearanceHandler appearanceHandler = new PDInkAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromStream", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new JPEG Image XObject from an input stream containing JPEG data.\n *\n * The input stream data will be preserved and embedded in the PDF file without modification.\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param stream\n * \t\ta stream of JPEG data\n * @return a new Image XObject\n * @throws IOException\n * \t\tif the input stream cannot be read\n */\npublic static PDImageXObject createFromStream(PDDocument document, InputStream stream) throws IOException {\n    return createFromByteArray(document, IOUtils.toByteArray(stream));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDCalRGB.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDCalRGB.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new CalRGB color space.\n */\npublic PDCalRGB() {\n    super(COSName.CALRGB);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDAction.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDAction.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDAction() {\n    action = new COSDictionary();\n    setType(TYPE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.setRichContents",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.setRichContents", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the rich text stream which is displayed in the popup window.\n *\n * @param rc\n * \t\tthe rich text stream.\n */\npublic final void setRichContents(String rc) {\n    annot.setItem(COSName.RC, new COSString(rc));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationHighlight.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationHighlight.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDHighlightAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDHighlightAppearanceHandler appearanceHandler = new PDHighlightAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<clinit>" ],
    "fullMethods" : [ "/**\n * This is the public method for setting the appearance stream.\n *\n * @param apValue\n * \t\tthe String value which the appearance should represent\n * @throws IOException\n * \t\tIf there is an error creating the stream.\n */\npublic void setAppearanceValue(String apValue) throws IOException {\n    value = getFormattedValue(apValue);\n    // Treat multiline field values in single lines as single lime values.\n    // This is in line with how Adobe Reader behaves when entering text\n    // interactively but NOT how it behaves when the field value has been\n    // set programmatically and Reader is forced to generate the appearance\n    // using PDAcroForm.setNeedAppearances\n    // see PDFBOX-3911\n    if ((field instanceof PDTextField) && (!((PDTextField) (field)).isMultiline())) {\n        value = value.replaceAll(\"\\\\u000D\\\\u000A|[\\\\u000A\\\\u000B\\\\u000C\\\\u000D\\\\u0085\\\\u2028\\\\u2029]\", \" \");\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        if (widget.getCOSObject().containsKey(\"PMD\")) {\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" is a PaperMetaData widget, no appearance stream created\");\n            continue;\n        }\n        // some fields have the /Da at the widget level if the\n        // widgets differ in layout.\n        PDDefaultAppearanceString acroFormAppearance = defaultAppearance;\n        if (widget.getCOSObject().getDictionaryObject(COSName.DA) != null) {\n            defaultAppearance = getWidgetDefaultAppearanceString(widget);\n        }\n        PDRectangle rect = widget.getRectangle();\n        if (rect == null) {\n            widget.getCOSObject().removeItem(COSName.AP);\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" has no rectangle, no appearance stream created\");\n            continue;\n        }\n        PDAppearanceDictionary appearanceDict = widget.getAppearance();\n        if (appearanceDict == null) {\n            appearanceDict = new PDAppearanceDictionary();\n            widget.setAppearance(appearanceDict);\n        }\n        PDAppearanceEntry appearance = appearanceDict.getNormalAppearance();\n        // TODO support appearances other than \"normal\"\n        PDAppearanceStream appearanceStream;\n        if (isValidAppearanceStream(appearance)) {\n            appearanceStream = appearance.getAppearanceStream();\n        } else {\n            appearanceStream = prepareNormalAppearanceStream(widget);\n            appearanceDict.setNormalAppearance(appearanceStream);\n            // TODO support appearances other than \"normal\"\n        }\n        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();\n        /* Adobe Acrobat always recreates the complete appearance stream if there is an appearance characteristics\n        entry (the widget dictionaries MK entry). In addition if there is no content yet also create the appearance\n        stream from the entries.\n         */\n        if ((appearanceCharacteristics != null) || (appearanceStream.getContentStream().getLength() == 0)) {\n            initializeAppearanceContent(widget, appearanceCharacteristics, appearanceStream);\n        }\n        setAppearanceContent(widget, appearanceStream);\n        // restore the field level appearance\n        defaultAppearance = acroFormAppearance;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFCloneUtility.cloneForNewDocument",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFCloneUtility.cloneForNewDocument", "org.apache.pdfbox.multipdf.PDFCloneUtility.cloneCOSBaseForNewDocument", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Deep-clones the given object for inclusion into a different PDF document identified by the destination parameter.\n *\n * Expert use only, donât use it if you donât know exactly what you are doing.\n *\n * @param <TCOSBase>\n * \t\tThe type to be returned.\n * @param base\n * \t\tthe initial object as the root of the deep-clone operation\n * @return the cloned instance of the base object\n * @throws IOException\n * \t\tif an I/O error occurs\n */\n@SuppressWarnings(\"unchecked\")\npublic <TCOSBase extends COSBase> TCOSBase cloneForNewDocument(TCOSBase base) throws IOException {\n    if (base == null) {\n        return null;\n    }\n    COSBase retval = clonedVersion.get(base);\n    if (retval != null) {\n        // we are done, it has already been converted.\n        return ((TCOSBase) (retval));\n    }\n    if (clonedValues.contains(base)) {\n        // Don't clone a clone\n        return base;\n    }\n    retval = cloneCOSBaseForNewDocument(base);\n    clonedVersion.put(base, retval);\n    clonedValues.add(retval);\n    return ((TCOSBase) (retval));\n}", "private COSBase cloneCOSBaseForNewDocument(COSBase base) throws IOException {\n    if (base instanceof COSObject) {\n        return cloneForNewDocument(((COSObject) (base)).getObject());\n    }\n    if (base instanceof COSArray) {\n        return cloneCOSArray(((COSArray) (base)));\n    }\n    if (base instanceof COSStream) {\n        return cloneCOSStream(((COSStream) (base)));\n    }\n    if (base instanceof COSDictionary) {\n        return cloneCOSDictionary(((COSDictionary) (base)));\n    }\n    return base;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureNode.getKids",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureNode.getKids", "org.apache.pdfbox.cos.COSDictionary.getDictionaryObject", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns a list of objects for the kids (K).\n *\n * @return a list of objects for the kids, never null.\n */\npublic List<Object> getKids() {\n    List<Object> kidObjects = new ArrayList<>();\n    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);\n    if (k instanceof COSArray) {\n        for (COSBase kid : ((COSArray) (k))) {\n            Object kidObject = this.createObject(kid);\n            if (kidObject != null) {\n                kidObjects.add(kidObject);\n            }\n        }\n    } else {\n        Object kidObject = this.createObject(k);\n        if (kidObject != null) {\n            kidObjects.add(kidObject);\n        }\n    }\n    return kidObjects;\n}", "/**\n * This will get an object from this dictionary. If the object is a reference then it will dereference it and get it\n * from the document. If the object is COSNull then null will be returned.\n *\n * @param key\n * \t\tThe key to the object that we are getting.\n * @return The object that matches the key.\n */\npublic COSBase getDictionaryObject(COSName key) {\n    COSBase retval = items.get(key);\n    if (retval instanceof COSObject) {\n        retval = ((COSObject) (retval)).getObject();\n    }\n    if (retval instanceof COSNull) {\n        retval = null;\n    }\n    return retval;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFPage.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFPage.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFPage() {\n    page = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setNonStrokingColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setNonStrokingColor", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceCMYK.<clinit>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceCMYK.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the non-stroking color in the DeviceCMYK color space. Range is 0..1.\n *\n * @param c\n * \t\tThe cyan value.\n * @param m\n * \t\tThe magenta value.\n * @param y\n * \t\tThe yellow value.\n * @param k\n * \t\tThe black value.\n * @throws IOException\n * \t\tIf an IO error occurs while writing to the stream.\n */\npublic void setNonStrokingColor(float c, float m, float y, float k) throws IOException {\n    if (((isOutsideOneInterval(c) || isOutsideOneInterval(m)) || isOutsideOneInterval(y)) || isOutsideOneInterval(k)) {\n        throw new IllegalArgumentException(\"Parameters must be within 0..1, but are \" + String.format(\"(%.2f,%.2f,%.2f,%.2f)\", c, m, y, k));\n    }\n    writeOperand(c);\n    writeOperand(m);\n    writeOperand(y);\n    writeOperand(k);\n    writeOperator(OperatorName.NON_STROKING_CMYK);\n    setNonStrokingColorSpaceStack(PDDeviceCMYK.INSTANCE);\n}", "", "protected PDDeviceCMYK() {\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.pagenavigation.PDThread.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.pagenavigation.PDThread.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDThread() {\n    thread = new COSDictionary();\n    thread.setItem(COSName.TYPE, COSName.THREAD);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.getHeight",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.getHeight", "org.apache.pdfbox.pdmodel.font.PDType1CFont.<clinit>" ],
    "fullMethods" : [ "@Override\npublic float getHeight(int code) throws IOException {\n    String name = codeToName(code);\n    float height;\n    if (!glyphHeights.containsKey(name)) {\n        if (cffFont == null) {\n            LOG.warn(\"No embedded CFF font, returning 0\");\n            return 0;\n        }\n        height = ((float) (cffFont.getType1CharString(name).getBounds().getHeight()));\n        glyphHeights.put(name, height);\n    } else {\n        height = glyphHeights.get(name);\n    }\n    return height;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getGlyphBBox",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getGlyphBBox", "org.apache.pdfbox.pdfparser.PDFStreamParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Calculate the bounding box of this glyph. This will work only if the first operator in the\n * stream is d1.\n *\n * @return the bounding box of this glyph, or null if the first operator is not d1.\n * @throws IOException\n * \t\tIf an io error occurs while parsing the stream.\n */\npublic PDRectangle getGlyphBBox() throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(this);\n    Object token = parser.parseNextToken();\n    while (token != null) {\n        if (token instanceof Operator) {\n            if (((Operator) (token)).getName().equals(\"d1\") && (arguments.size() == 6)) {\n                for (int i = 0; i < 6; ++i) {\n                    if (!(arguments.get(i) instanceof COSNumber)) {\n                        return null;\n                    }\n                }\n                float x = ((COSNumber) (arguments.get(2))).floatValue();\n                float y = ((COSNumber) (arguments.get(3))).floatValue();\n                return new PDRectangle(x, y, ((COSNumber) (arguments.get(4))).floatValue() - x, ((COSNumber) (arguments.get(5))).floatValue() - y);\n            } else {\n                return null;\n            }\n        } else {\n            arguments.add(((COSBase) (token)));\n        }\n        token = parser.parseNextToken();\n    } \n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<init>", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param dict\n * \t\tThe annotations dictionary.\n */\npublic PDAnnotation(COSDictionary dict) {\n    dictionary = dict;\n    COSBase type = dict.getDictionaryObject(COSName.TYPE);\n    if (type == null) {\n        dictionary.setItem(COSName.TYPE, COSName.ANNOT);\n    } else if (!COSName.ANNOT.equals(type)) {\n        LOG.warn((\"Annotation has type \" + type) + \", further mayhem may follow\");\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.writeString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.writeString", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * This will output the given text/byte getString as a PDF object.\n *\n * @param bytes\n * \t\tbyte array representation of a string to be written\n * @param output\n * \t\tThe stream to write to.\n * @throws IOException\n * \t\tIf there is an error writing to the stream.\n */\npublic static void writeString(byte[] bytes, OutputStream output) throws IOException {\n    writeString(bytes, false, output);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.LayerUtility.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.LayerUtility.<init>", "org.apache.pdfbox.multipdf.PDFCloneUtility.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new instance.\n *\n * @param targetDoc\n * \t\tthe PDF document to modify\n */\npublic LayerUtility(PDDocument targetDoc) {\n    this.targetDoc = targetDoc;\n    this.cloner = new PDFCloneUtility(targetDoc);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setStrokingColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setStrokingColor", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB.<clinit>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the stroking color in the DeviceRGB color space. Range is 0..1.\n *\n * @param r\n * \t\tThe red value.\n * @param g\n * \t\tThe green value.\n * @param b\n * \t\tThe blue value.\n * @throws IOException\n * \t\tIf an IO error occurs while writing to the stream.\n * @throws IllegalArgumentException\n * \t\tIf the parameters are invalid.\n */\npublic void setStrokingColor(float r, float g, float b) throws IOException {\n    if ((isOutsideOneInterval(r) || isOutsideOneInterval(g)) || isOutsideOneInterval(b)) {\n        throw new IllegalArgumentException(\"Parameters must be within 0..1, but are \" + String.format(\"(%.2f,%.2f,%.2f)\", r, g, b));\n    }\n    writeOperand(r);\n    writeOperand(g);\n    writeOperand(b);\n    writeOperator(OperatorName.STROKING_COLOR_RGB);\n    setStrokingColorSpaceStack(PDDeviceRGB.INSTANCE);\n}", "", "private PDDeviceRGB() {\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fixup.AcroFormDefaultFixup.apply",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fixup.AcroFormDefaultFixup.apply", "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void apply() {\n    new AcroFormDefaultsProcessor(document).process();\n    /* Get the AcroForm in it's current state.\n\n    Also note: getAcroForm() applies a default fixup which this processor\n    is part of. So keep the null parameter otherwise this will end\n    in an endless recursive call\n     */\n    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm(null);\n    // PDFBOX-4985\n    // build the visual appearance as there is none for the widgets\n    if ((acroForm != null) && acroForm.getNeedAppearances()) {\n        if (acroForm.getFields().isEmpty()) {\n            new AcroFormOrphanWidgetsProcessor(document).process();\n        }\n        // PDFBOX-4985\n        // build the visual appearance as there is none for the widgets\n        new AcroFormGenerateAppearancesProcessor(document).process();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setKids",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setKids", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the children of this named tree.\n *\n * @param kids\n * \t\tThe children of this named tree. These have to be in sorted order. Because of\n * \t\tthat, it is usually easier to call {@link #setNames(Map)} with a map and pass a single\n * \t\telement list here.\n */\npublic void setKids(List<? extends PDNameTreeNode<T>> kids) {\n    if ((kids != null) && (!kids.isEmpty())) {\n        kids.forEach(kidsNode -> kidsNode.setParent(this));\n        node.setItem(COSName.KIDS, new COSArray(kids));\n        // root nodes with kids don't have Names\n        if (isRootNode()) {\n            node.setItem(COSName.NAMES, null);\n        }\n    } else {\n        // remove kids\n        node.setItem(COSName.KIDS, null);\n        // remove Limits\n        node.setItem(COSName.LIMITS, null);\n    }\n    calculateLimits();\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.Filter.getCompressionLevel",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.Filter.getCompressionLevel", "org.apache.pdfbox.filter.Filter.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @return the ZIP compression level configured for PDFBox\n */\npublic static int getCompressionLevel() {\n    int compressionLevel = Deflater.DEFAULT_COMPRESSION;\n    try {\n        compressionLevel = Integer.parseInt(System.getProperty(Filter.SYSPROP_DEFLATELEVEL, \"-1\"));\n    } catch (NumberFormatException ex) {\n        LOG.warn(ex.getMessage(), ex);\n    }\n    return Math.max(-1, Math.min(Deflater.BEST_COMPRESSION, compressionLevel));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDVariableText.setDefaultStyleString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDVariableText.setDefaultStyleString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the default style string.\n *\n * Providing null as the value will remove the default style string.\n *\n * @param defaultStyleString\n * \t\ta string describing the default style.\n */\npublic void setDefaultStyleString(String defaultStyleString) {\n    if (defaultStyleString != null) {\n        getCOSObject().setItem(COSName.DS, new COSString(defaultStyleString));\n    } else {\n        getCOSObject().removeItem(COSName.DS);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFJavaScript.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFJavaScript.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFJavaScript() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "@Override\npublic BufferedImage getImage() throws IOException {\n    return SampledImageReader.getRGBImage(this, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateFinalPoint.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateFinalPoint.process", "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateFinalPoint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.size() < 4) {\n        throw new MissingOperandException(operator, operands);\n    }\n    if (!checkArrayTypesClass(operands, COSNumber.class)) {\n        return;\n    }\n    COSNumber x1 = ((COSNumber) (operands.get(0)));\n    COSNumber y1 = ((COSNumber) (operands.get(1)));\n    COSNumber x3 = ((COSNumber) (operands.get(2)));\n    COSNumber y3 = ((COSNumber) (operands.get(3)));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    Point2D currentPoint = context.getCurrentPoint();\n    Point2D.Float point1 = context.transformedPoint(x1.floatValue(), y1.floatValue());\n    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());\n    if (currentPoint == null) {\n        LOG.warn((((\"curveTo (\" + point3.x) + \",\") + point3.y) + \") without initial MoveTo\");\n        context.moveTo(point3.x, point3.y);\n    } else {\n        context.curveTo(point1.x, point1.y, point3.x, point3.y, point3.x, point3.y);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.Standard14Fonts.getGlyphPath",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.Standard14Fonts.getGlyphPath", "org.apache.pdfbox.pdmodel.font.Standard14Fonts.getMappedFont", "org.apache.pdfbox.pdmodel.font.PDType1Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the path for the character with the given name for the specified Standard 14 font. The mapped font is\n * cached. The path may differ in different environments as it depends on the mapped font.\n *\n * @param baseName\n * \t\tname of the standard 14 font\n * @param glyphName\n * \t\tname of glyph\n * @return the mapped font\n * @throws IOException\n * \t\tif the data could not be read\n */\npublic static GeneralPath getGlyphPath(FontName baseName, String glyphName) throws IOException {\n    // copied and adapted from PDType1Font.getNameInFont(String)\n    if (!glyphName.equals(\".notdef\")) {\n        FontBoxFont mappedFont = getMappedFont(baseName);\n        if (mappedFont != null) {\n            if (mappedFont.hasGlyph(glyphName)) {\n                return mappedFont.getPath(glyphName);\n            }\n            String unicodes = getGlyphList(baseName).toUnicode(glyphName);\n            if ((unicodes != null) && (unicodes.length() == 1)) {\n                String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));\n                if (mappedFont.hasGlyph(uniName)) {\n                    return mappedFont.getPath(uniName);\n                }\n            }\n            if (\"SymbolMT\".equals(mappedFont.getName())) {\n                Integer code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(glyphName);\n                if (code != null) {\n                    String uniName = getUniNameOfCodePoint(code + 0xf000);\n                    if (mappedFont.hasGlyph(uniName)) {\n                        return mappedFont.getPath(uniName);\n                    }\n                }\n            }\n        }\n    }\n    return new GeneralPath();\n}", "/**\n * Returns the mapped font for the specified Standard 14 font. The mapped font is cached.\n *\n * @param baseName\n * \t\tname of the standard 14 font\n * @return the mapped font\n */\nprivate static FontBoxFont getMappedFont(FontName baseName) {\n    if (!GENERIC_FONTS.containsKey(baseName)) {\n        synchronized(GENERIC_FONTS) {\n            if (!GENERIC_FONTS.containsKey(baseName)) {\n                PDType1Font type1Font = new PDType1Font(baseName);\n                GENERIC_FONTS.put(baseName, type1Font.getFontBoxFont());\n            }\n        }\n    }\n    return GENERIC_FONTS.get(baseName);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.indexOf",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.indexOf", "org.apache.pdfbox.pdmodel.PDPageTree.findPage", "org.apache.pdfbox.pdmodel.PDPageTree.getKids", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the index of the given page, or -1 if it does not exist.\n *\n * @param page\n * \t\tThe page to search for.\n * @return the zero-based index of the given page, or -1 if the page is not found.\n */\npublic int indexOf(PDPage page) {\n    SearchContext context = new SearchContext(page);\n    if (findPage(context, root)) {\n        return context.index;\n    }\n    return -1;\n}", "private boolean findPage(SearchContext context, COSDictionary node) {\n    for (COSDictionary kid : getKids(node)) {\n        if (context.found) {\n            break;\n        }\n        if (isPageTreeNode(kid)) {\n            findPage(context, kid);\n        } else {\n            context.visitPage(kid);\n        }\n    }\n    return context.found;\n}", "/**\n * Helper to get kids from malformed PDFs.\n *\n * @param node\n * \t\tpage tree node\n * @return list of kids\n */\nprivate List<COSDictionary> getKids(COSDictionary node) {\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // probably a malformed PDF\n        return Collections.emptyList();\n    }\n    int size = kids.size();\n    List<COSDictionary> result = new ArrayList<>(size);\n    for (int i = 0; i < size; i++) {\n        COSBase base = kids.getObject(i);\n        if (base instanceof COSDictionary) {\n            result.add(((COSDictionary) (base)));\n        } else if (base == null) {\n            LOG.warn(\"replaced null entry with an empty page\");\n            COSDictionary emptyPage = new COSDictionary();\n            emptyPage.setItem(COSName.TYPE, COSName.PAGE);\n            kids.set(i, emptyPage);\n            result.add(emptyPage);\n        } else {\n            LOG.warn(\"COSDictionary expected, but got \" + base.getClass().getSimpleName());\n        }\n    }\n    return result;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSStream.toTextString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSStream.toTextString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the contents of the stream as a PDF \"text string\".\n *\n * @return the PDF string representation of the stream content\n */\npublic String toTextString() {\n    try (InputStream input = createInputStream()) {\n        byte[] array = IOUtils.toByteArray(input);\n        COSString string = new COSString(array);\n        return string.getString();\n    } catch (IOException e) {\n        LOG.debug(\"An exception occurred trying to get the content - returning empty string instead\", e);\n        return \"\";\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureImage", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createSignatureImage(PDDocument template, BufferedImage image) throws IOException {\n    pdfStructure.setImage(LosslessFactory.createFromImage(template, image));\n    LOG.info(\"Visible Signature Image has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.setItem",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationPolyline.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationPolyline.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationPolyline(COSDictionary a) {\n    super(a);\n}", "/**\n * Constructor.\n *\n * @param a\n * \t\tThe FDF annotation.\n */\npublic FDFAnnotation(COSDictionary a) {\n    annot = a;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationCaret.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationCaret.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCaretAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDCaretAppearanceHandler appearanceHandler = new PDCaretAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateInitialPoint.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateInitialPoint.process", "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateInitialPoint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.size() < 4) {\n        throw new MissingOperandException(operator, operands);\n    }\n    if (!checkArrayTypesClass(operands, COSNumber.class)) {\n        return;\n    }\n    COSNumber x2 = ((COSNumber) (operands.get(0)));\n    COSNumber y2 = ((COSNumber) (operands.get(1)));\n    COSNumber x3 = ((COSNumber) (operands.get(2)));\n    COSNumber y3 = ((COSNumber) (operands.get(3)));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    Point2D currentPoint = context.getCurrentPoint();\n    Point2D.Float point2 = context.transformedPoint(x2.floatValue(), y2.floatValue());\n    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());\n    if (currentPoint == null) {\n        LOG.warn((((\"curveTo (\" + point3.x) + \",\") + point3.y) + \") without initial MoveTo\");\n        context.moveTo(point3.x, point3.y);\n    } else {\n        context.curveTo(((float) (currentPoint.getX())), ((float) (currentPoint.getY())), point2.x, point2.y, point3.x, point3.y);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDocument.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDocument.<init>", "org.apache.pdfbox.cos.COSDocument.getStreamCache", "org.apache.pdfbox.cos.COSDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor that will use the provided function to create a stream cache for the storage of the PDF streams.\n *\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache\n * @param parser\n * \t\tParser to be used to parse the document on demand\n */\npublic COSDocument(StreamCacheCreateFunction streamCacheCreateFunction, ICOSParser parser) {\n    streamCache = getStreamCache(streamCacheCreateFunction);\n    this.parser = parser;\n}", "private RandomAccessStreamCache getStreamCache(StreamCacheCreateFunction streamCacheCreateFunction) {\n    if (streamCacheCreateFunction == null) {\n        return null;\n    }\n    try {\n        return streamCacheCreateFunction.create();\n    } catch (IOException exception1) {\n        LOG.warn(\"An error occurred when creating stream cache. Using memory only cache as fallback.\", exception1);\n    }\n    try {\n        return IOUtils.createMemoryOnlyStreamCache().create();\n    } catch (IOException exception2) {\n        LOG.warn(\"An error occurred when creating stream cache for fallback.\", exception2);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureField",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureField", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createSignatureField(PDAcroForm acroForm) throws IOException {\n    PDSignatureField sf = new PDSignatureField(acroForm);\n    pdfStructure.setSignatureField(sf);\n    LOG.info(\"Signature field has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getMask",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getMask", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the Mask Image XObject associated with this image, or null if there is none.\n *\n * @return Mask Image XObject\n * @throws java.io.IOException\n * \t\tif the mask data could not be read\n */\npublic PDImageXObject getMask() throws IOException {\n    COSArray mask = getCOSObject().getCOSArray(COSName.MASK);\n    if (mask != null) {\n        // color key mask, no explicit mask to return\n        return null;\n    } else {\n        COSStream cosStream = getCOSObject().getCOSStream(COSName.MASK);\n        if (cosStream != null) {\n            // always DeviceGray\n            return new PDImageXObject(new PDStream(cosStream), null);\n        }\n        return null;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.put",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the font resource with the given name.\n *\n * @param name\n * \t\tthe name of the resource\n * @param font\n * \t\tthe font to be added\n */\npublic void put(COSName name, PDFont font) {\n    put(COSName.FONT, name, font);\n}", "/**\n * Sets the value of a given named resource.\n */\nprivate void put(COSName kind, COSName name, COSObjectable object) {\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if (dict == null) {\n        dict = new COSDictionary();\n        resources.setItem(kind, dict);\n    }\n    dict.setItem(name, object);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.shadingFill",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.shadingFill", "org.apache.pdfbox.rendering.PageDrawer.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void shadingFill(COSName shadingName) throws IOException {\n    if (!isContentRendered()) {\n        return;\n    }\n    PDShading shading = getResources().getShading(shadingName);\n    if (shading == null) {\n        LOG.error((\"shading \" + shadingName) + \" does not exist in resources dictionary\");\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    Shape savedClip = graphics.getClip();\n    graphics.setClip(null);\n    lastClips = null;\n    // get the transformed BBox and intersect with current clipping path\n    // need to do it here and not in shading getRaster() because it may have been rotated\n    PDRectangle bbox = shading.getBBox();\n    Area area;\n    if (bbox != null) {\n        area = new Area(bbox.transform(ctm));\n        area.intersect(getGraphicsState().getCurrentClippingPath());\n    } else {\n        Rectangle2D bounds = shading.getBounds(new AffineTransform(), ctm);\n        if (bounds != null) {\n            bounds.add(new Point2D.Double(Math.floor(bounds.getMinX() - 1), Math.floor(bounds.getMinY() - 1)));\n            bounds.add(new Point2D.Double(Math.ceil(bounds.getMaxX() + 1), Math.ceil(bounds.getMaxY() + 1)));\n            area = new Area(bounds);\n            area.intersect(getGraphicsState().getCurrentClippingPath());\n        } else {\n            area = getGraphicsState().getCurrentClippingPath();\n        }\n    }\n    if (!area.isEmpty()) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        Paint paint = shading.toPaint(ctm);\n        paint = applySoftMaskToPaint(paint, getGraphicsState().getSoftMask());\n        graphics.setPaint(paint);\n        graphics.fill(area);\n    }\n    graphics.setClip(savedClip);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.getDocumentCatalog",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.getDocumentCatalog", "org.apache.pdfbox.pdmodel.PDDocumentCatalog.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get the document CATALOG. This is guaranteed to not return null.\n *\n * @return The documents /Root dictionary\n */\npublic PDDocumentCatalog getDocumentCatalog() {\n    if (documentCatalog == null) {\n        COSDictionary trailer = document.getTrailer();\n        COSDictionary dictionary = trailer.getCOSDictionary(COSName.ROOT);\n        if (dictionary != null) {\n            documentCatalog = new PDDocumentCatalog(this, dictionary);\n        } else {\n            documentCatalog = new PDDocumentCatalog(this);\n        }\n    }\n    return documentCatalog;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageFormStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageFormStream", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createImageFormStream(PDDocument template) {\n    PDStream imageFormStream = new PDStream(template);\n    pdfStructure.setImageFormStream(imageFormStream);\n    LOG.info(\"Created image form stream\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a PDColor containing the given color value.\n *\n * @param array\n * \t\ta COS array containing the color value\n * @param colorSpace\n * \t\tcolor space in which the color value is defined\n */\npublic PDColor(COSArray array, PDColorSpace colorSpace) {\n    if ((array.size() > 0) && (array.get(array.size() - 1) instanceof COSName)) {\n        // color components (optional), for the color of an uncoloured tiling pattern\n        components = new float[array.size() - 1];\n        initComponents(array);\n        // pattern name (required)\n        COSBase base = array.get(array.size() - 1);\n        if (base instanceof COSName) {\n            patternName = ((COSName) (base));\n        } else {\n            LOG.warn((\"pattern name in \" + array) + \" isn't a name, ignored\");\n            patternName = COSName.getPDFName(\"Unknown\");\n        }\n    } else {\n        // color components only\n        components = new float[array.size()];\n        initComponents(array);\n        patternName = null;\n    }\n    this.colorSpace = colorSpace;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.removeKeyUsage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.removeKeyUsage", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Removes a key usage extension\n *\n * @param keyUsageExtension\n * \t\tASCII string that consists of {0, 1, X}\n */\npublic void removeKeyUsage(String keyUsageExtension) {\n    COSArray array = dictionary.getCOSArray(COSName.KEY_USAGE);\n    if (array != null) {\n        array.remove(new COSString(keyUsageExtension));\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getResources",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getResources", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * A dictionary containing any resources required by the page.\n */\n@Override\npublic PDResources getResources() {\n    if (pageResources == null) {\n        COSBase base = PDPageTree.getInheritableAttribute(page, COSName.RESOURCES);\n        // note: it's an error for resources to not be present\n        if (base instanceof COSDictionary) {\n            pageResources = new PDResources(((COSDictionary) (base)), resourceCache);\n        }\n    }\n    return pageResources;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createThumbnail",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createThumbnail", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a thumbnail Image XObject from the given COSBase and name.\n *\n * @param cosStream\n * \t\tthe COS stream\n * @return an XObject\n * @throws IOException\n * \t\tif there is an error creating the XObject.\n */\npublic static PDImageXObject createThumbnail(COSStream cosStream) throws IOException {\n    // thumbnails are special, any non-null subtype is treated as being \"Image\"\n    PDStream pdStream = new PDStream(cosStream);\n    return new PDImageXObject(pdStream, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.TrueTypeEmbedder.buildFontFile2",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.TrueTypeEmbedder.buildFontFile2", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "public final void buildFontFile2(InputStream ttfStream) throws IOException {\n    PDStream stream = new PDStream(document, ttfStream, COSName.FLATE_DECODE);\n    // as the stream was closed within the PDStream constructor, we have to recreate it\n    try (InputStream input = stream.createInputStream()) {\n        ttf = new TTFParser().parseEmbedded(input);\n        if (!isEmbeddingPermitted(ttf)) {\n            throw new IOException(\"This font does not permit embedding\");\n        }\n        if (fontDescriptor == null) {\n            fontDescriptor = createFontDescriptor(ttf);\n        }\n    }\n    stream.getCOSObject().setLong(COSName.LENGTH1, ttf.getOriginalDataSize());\n    fontDescriptor.setFontFile2(stream);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.hasGlyph",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.hasGlyph", "org.apache.pdfbox.pdmodel.font.PDType1Font.getNameInFont", "org.apache.pdfbox.pdmodel.font.PDType1Font.<clinit>" ],
    "fullMethods" : [ "@Override\npublic boolean hasGlyph(String name) throws IOException {\n    return genericFont.hasGlyph(getNameInFont(name));\n}", "/**\n * Maps a PostScript glyph name to the name in the underlying font, for example when\n * using a TTF font we might map \"W\" to \"uni0057\".\n */\nprivate String getNameInFont(String name) throws IOException {\n    if (isEmbedded() || genericFont.hasGlyph(name)) {\n        return name;\n    }\n    // try alternative name\n    String altName = ALT_NAMES.get(name);\n    if (((altName != null) && (!name.equals(\".notdef\"))) && genericFont.hasGlyph(altName)) {\n        return altName;\n    }\n    // try unicode name\n    String unicodes = getGlyphList().toUnicode(name);\n    if ((unicodes != null) && (unicodes.length() == 1)) {\n        String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));\n        if (genericFont.hasGlyph(uniName)) {\n            return uniName;\n        }\n        // PDFBOX-4017: no postscript table on Windows 10, and the low uni00NN\n        // names are not found in Symbol font. What works is using the PDF code plus 0xF000\n        // while disregarding encoding from the PDF (because of file from PDFBOX-1606,\n        // makes sense because this segment is about finding the name in a standard font)\n        // TODO bring up better solution than this\n        if (\"SymbolMT\".equals(genericFont.getName())) {\n            Integer code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(name);\n            if (code != null) {\n                uniName = getUniNameOfCodePoint(code + 0xf000);\n                if (genericFont.hasGlyph(uniName)) {\n                    return uniName;\n                }\n            }\n        }\n    }\n    return \".notdef\";\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getAcroForm",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getAcroForm", "org.apache.pdfbox.pdmodel.PDDocumentCatalog.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the documents AcroForm. This will return null if no AcroForm is part of the document.\n *\n * Dependent on setting <code>acroFormFixup</code> some fixing/changes will be done to the AcroForm.\n * If you need to ensure that there are no fixes applied call <code>getAcroForm</code> with <code>null</code>.\n *\n * Using <code>getAcroForm(PDDocumentFixup acroFormFixup)</code> might change the original content and\n * subsequent calls with <code>getAcroForm(null)</code> will return the changed content.\n *\n * @param acroFormFixup\n * \t\tthe fix up action or null\n * @return The document's AcroForm.\n */\npublic PDAcroForm getAcroForm(PDDocumentFixup acroFormFixup) {\n    if ((acroFormFixup != null) && (acroFormFixup != acroFormFixupApplied)) {\n        acroFormFixup.apply();\n        cachedAcroForm = null;\n        acroFormFixupApplied = acroFormFixup;\n    } else if (acroFormFixupApplied != null) {\n        LOG.debug(\"AcroForm content has already been retrieved with fixes applied - original content changed because of that\");\n    }\n    if (cachedAcroForm == null) {\n        COSDictionary dict = root.getCOSDictionary(COSName.ACRO_FORM);\n        cachedAcroForm = (dict == null) ? null : new PDAcroForm(document, dict);\n    }\n    return cachedAcroForm;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDSimpleFont.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDSimpleFont.toUnicode", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String toUnicode(int code) {\n    return toUnicode(code, GlyphList.getAdobeGlyphList());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDPageLabels.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDPageLabels.<init>", "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates an page label dictionary for a document using the information in\n * the given COS dictionary.\n *\n * <p>\n * Note that the page label dictionary won't be automatically added to the\n * document; you will still need to do it manually (see\n * {@link org.apache.pdfbox.pdmodel.PDDocumentCatalog#setPageLabels(PDPageLabels)}.\n * </p>\n *\n * @param document\n * \t\tThe document the page label dictionary is created for.\n * @param dict\n * \t\tan existing page label dictionary\n * @see org.apache.pdfbox.pdmodel.PDDocumentCatalog#setPageLabels(PDPageLabels)\n * @throws IOException\n * \t\tIf something goes wrong during the number tree conversion.\n */\npublic PDPageLabels(PDDocument document, COSDictionary dict) throws IOException {\n    this(document);\n    if (dict == null) {\n        return;\n    }\n    PDNumberTreeNode root = new PDNumberTreeNode(dict, PDPageLabelRange.class);\n    findLabels(root);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFOptionElement.setDefaultAppearanceString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFOptionElement.setDefaultAppearanceString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the default appearance string.\n *\n * @param da\n * \t\tThe default appearance string.\n */\npublic void setDefaultAppearanceString(String da) {\n    option.set(1, new COSString(da));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.getDocumentInformation",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.getDocumentInformation", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get the document info dictionary. If it doesn't exist, an empty document info\n * dictionary is created in the document trailer.\n * <p>\n * In PDF 2.0 this is deprecated except for two entries, /CreationDate and /ModDate. For any other\n * document level metadata, a metadata stream should be used instead, see\n * {@link PDDocumentCatalog#getMetadata()}.\n *\n * @return The documents /Info dictionary, never null.\n */\npublic PDDocumentInformation getDocumentInformation() {\n    if (documentInformation == null) {\n        COSDictionary trailer = document.getTrailer();\n        COSDictionary infoDic = trailer.getCOSDictionary(COSName.INFO);\n        if (infoDic == null) {\n            infoDic = new COSDictionary();\n            trailer.setItem(COSName.INFO, infoDic);\n        }\n        documentInformation = new PDDocumentInformation(infoDic);\n    }\n    return documentInformation;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDocument.createCOSStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDocument.createCOSStream", "org.apache.pdfbox.cos.COSStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new COSStream using the current configuration for scratch files. Not for public use.\n * Only COSParser should call this method.\n *\n * @param dictionary\n * \t\tthe corresponding dictionary\n * @param startPosition\n * \t\tthe start position within the source\n * @param streamLength\n * \t\tthe stream length\n * @return the new COSStream\n * @throws IOException\n * \t\tif the random access view can't be read\n */\npublic COSStream createCOSStream(COSDictionary dictionary, long startPosition, long streamLength) throws IOException {\n    COSStream stream = new COSStream(streamCache, parser.createRandomAccessReadView(startPosition, streamLength));\n    dictionary.forEach(stream::setItem);\n    stream.setKey(dictionary.getKey());\n    return stream;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLinkAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLinkAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationLink annotation = ((PDAnnotationLink) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        // 660402-p1-AnnotationEmptyRect.pdf has /Rect entry with 0 elements\n        return;\n    }\n    // Adobe doesn't generate an appearance for a link annotation\n    float lineWidth = getLineWidth();\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        PDColor color = annotation.getColor();\n        if (color == null) {\n            // spec is unclear, but black is what Adobe does\n            color = new PDColor(new float[]{ 0 }, PDDeviceGray.INSTANCE);\n        }\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(color);\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        // Acrobat applies a padding to each side of the bbox so the line is completely within\n        // the bbox.\n        PDRectangle borderEdge = getPaddedRectangle(getRectangle(), lineWidth / 2);\n        float[] pathsArray = annotation.getQuadPoints();\n        if (pathsArray != null) {\n            // QuadPoints shall be ignored if any coordinate in the array lies outside\n            // the region specified by Rect.\n            for (int i = 0; i < (pathsArray.length / 2); ++i) {\n                if (!rect.contains(pathsArray[i * 2], pathsArray[(i * 2) + 1])) {\n                    LOG.warn((((((\"At least one /QuadPoints entry (\" + pathsArray[i * 2]) + \";\") + pathsArray[(i * 2) + 1]) + \") is outside of rectangle, \") + rect) + \", /QuadPoints are ignored and /Rect is used instead\");\n                    pathsArray = null;\n                    break;\n                }\n            }\n        }\n        if (pathsArray == null) {\n            // Convert rectangle coordinates as if it was a /QuadPoints entry\n            pathsArray = new float[8];\n            pathsArray[0] = borderEdge.getLowerLeftX();\n            pathsArray[1] = borderEdge.getLowerLeftY();\n            pathsArray[2] = borderEdge.getUpperRightX();\n            pathsArray[3] = borderEdge.getLowerLeftY();\n            pathsArray[4] = borderEdge.getUpperRightX();\n            pathsArray[5] = borderEdge.getUpperRightY();\n            pathsArray[6] = borderEdge.getLowerLeftX();\n            pathsArray[7] = borderEdge.getUpperRightY();\n        }\n        boolean underlined = false;\n        if (pathsArray.length >= 8) {\n            PDBorderStyleDictionary borderStyleDic = annotation.getBorderStyle();\n            if (borderStyleDic != null) {\n                underlined = PDBorderStyleDictionary.STYLE_UNDERLINE.equals(borderStyleDic.getStyle());\n            }\n        }\n        int of = 0;\n        while ((of + 7) < pathsArray.length) {\n            contentStream.moveTo(pathsArray[of], pathsArray[of + 1]);\n            contentStream.lineTo(pathsArray[of + 2], pathsArray[of + 3]);\n            if (!underlined) {\n                contentStream.lineTo(pathsArray[of + 4], pathsArray[of + 5]);\n                contentStream.lineTo(pathsArray[of + 6], pathsArray[of + 7]);\n                contentStream.closePath();\n            }\n            of += 8;\n        } \n        contentStream.drawShape(lineWidth, hasStroke, false);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFJavaScript.setAfter",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFJavaScript.setAfter", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the javascript code the will get execute after the import.\n *\n * @param after\n * \t\tA reference to some javascript code.\n */\npublic void setAfter(String after) {\n    dictionary.setItem(COSName.AFTER, new COSString(after));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.getInstance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.getInstance", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a blend composite\n *\n * @param blendMode\n * \t\tDesired blend mode\n * @param constantAlpha\n * \t\tConstant alpha, must be in the inclusive range\n * \t\t[0.0...1.0] or it will be clipped.\n * @return a blend composite.\n * @throws IllegalArgumentException\n * \t\tif blendMode is null.\n */\npublic static Composite getInstance(BlendMode blendMode, float constantAlpha) {\n    if (constantAlpha < 0) {\n        LOG.warn(\"using 0 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 0;\n    } else if (constantAlpha > 1) {\n        LOG.warn(\"using 1 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 1;\n    }\n    if (blendMode == null) {\n        throw new IllegalArgumentException(\"blendMode parameter cannot be null\");\n    }\n    if (blendMode == BlendMode.NORMAL) {\n        return AlphaComposite.getInstance(AlphaComposite.SRC_OVER, constantAlpha);\n    } else {\n        return new BlendComposite(blendMode, constantAlpha);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSArray.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSArray.add", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Add the specified object at the ith location and push the rest to the\n * right.\n *\n * @param i\n * \t\tThe index to add at.\n * @param object\n * \t\tThe object to add at that index.\n */\npublic void add(int i, COSBase object) {\n    // wrap indirect objects\n    if ((((object instanceof COSDictionary) || (object instanceof COSArray)) && (!object.isDirect())) && (object.getKey() != null)) {\n        COSObject cosObject = new COSObject(object, object.getKey());\n        objects.add(i, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        objects.add(i, object);\n        getUpdateState().update(object);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderFormResources",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderFormResources", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createHolderFormResources() {\n    PDResources holderFormResources = new PDResources();\n    pdfStructure.setHolderFormResources(holderFormResources);\n    LOG.info(\"Holder form resources have been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.create",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.create", "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new soft mask.\n *\n * @param dictionary\n * \t\tSMask\n * @return the newly created instance of PDSoftMask\n */\npublic static PDSoftMask create(COSBase dictionary) {\n    return create(dictionary, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image byte array. This overloaded version allows providing\n * a custom factory to handle specific image formats, such as BMP and GIF, or to act as a\n * fallback strategy when the default converters (e.g., for PNG or TIFF) fail.\n *\n * @param document\n * \t\tthe document that shall use this PDImageXObject.\n * @param byteArray\n * \t\tbytes from an image file.\n * @param name\n * \t\tname of image file for exception messages, can be null.\n * @param customFactory\n * \t\toptional factory used to handle BMP, GIF, or fallback cases\n * \t\t(e.g., for PNG or TIFF). If {@code null}, this method delegates to\n * \t\t{@link #createFromByteArray(PDDocument, byte[], String)}.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray, String name, CustomFactory customFactory) throws IOException {\n    FileType fileType = FileTypeDetector.detectFileType(byteArray);\n    if (fileType == null) {\n        throw new IllegalArgumentException(\"Image type not supported: \" + name);\n    }\n    if (fileType == FileType.JPEG) {\n        return JPEGFactory.createFromByteArray(document, byteArray);\n    }\n    if (fileType == FileType.PNG) {\n        // Try to directly convert the image without recoding it.\n        PDImageXObject image = PNGConverter.convertPNGImage(document, byteArray);\n        if (image != null) {\n            return image;\n        }\n    }\n    if (fileType == FileType.TIFF) {\n        try {\n            return CCITTFactory.createFromByteArray(document, byteArray);\n        } catch (IOException ex) {\n            LOG.debug(\"Reading as TIFF failed, setting fileType to PNG\", ex);\n            // Plan B: try reading with ImageIO\n            // common exception:\n            // First image in tiff is not CCITT T4 or T6 compressed\n            fileType = FileType.PNG;\n        }\n    }\n    if (((fileType == FileType.BMP) || (fileType == FileType.GIF)) || (fileType == FileType.PNG)) {\n        if (customFactory != null) {\n            return customFactory.createFromByteArray(document, byteArray);\n        }\n        ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);\n        BufferedImage bim = ImageIO.read(bais);\n        return LosslessFactory.createFromImage(document, bim);\n    }\n    throw new IllegalArgumentException(((\"Image type \" + fileType) + \" not supported: \") + name);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDSeedValueCertificate() {\n    dictionary = new COSDictionary();\n    dictionary.setItem(COSName.TYPE, COSName.SV_CERT);\n    dictionary.setDirect(true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDLab.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDLab.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDCIEDictionaryBasedColorSpace.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new Lab color space.\n */\npublic PDLab() {\n    super(COSName.LAB);\n}", "protected PDCIEDictionaryBasedColorSpace(COSName cosName) {\n    array = new COSArray();\n    dictionary = new COSDictionary();\n    array.add(cosName);\n    array.add(dictionary);\n    fillWhitepointCache(getWhitepoint());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PageExtractor.extract",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PageExtractor.extract", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will take a document and extract the desired pages into a new\n * document.  Both startPage and endPage are included in the extracted\n * document.  If the endPage is greater than the number of pages in the\n * source document, it will go to the end of the document.  If startPage is\n * less than 1, it'll start with page 1.  If startPage is greater than\n * endPage or greater than the number of pages in the source document, a\n * blank document will be returned.\n *\n * @return The extracted document\n * @throws IOException\n * \t\tIf there is an IOError\n */\npublic PDDocument extract() throws IOException {\n    if (((endPage - startPage) + 1) <= 0) {\n        return new PDDocument();\n    }\n    Splitter splitter = new Splitter();\n    splitter.setStartPage(Math.max(startPage, 1));\n    splitter.setEndPage(Math.min(endPage, sourceDocument.getNumberOfPages()));\n    splitter.setSplitAtPage((getEndPage() - getStartPage()) + 1);\n    List<PDDocument> splitted = splitter.split(sourceDocument);\n    return splitted.get(0);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setOwnerEncryptionKey",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setOwnerEncryptionKey", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the OE entry in the standard encryption dictionary.\n *\n * @param oe\n * \t\tA 32 byte array or null if there is no owner encryption key.\n * @throws IOException\n * \t\tIf there is an error setting the data.\n */\npublic void setOwnerEncryptionKey(byte[] oe) throws IOException {\n    dictionary.setItem(COSName.OE, new COSString(oe));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentNameDictionary.getEmbeddedFiles",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentNameDictionary.getEmbeddedFiles", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the embedded files named tree node. The values in this name tree will\n * be PDComplexFileSpecification objects.\n *\n * @return The embedded files name tree node.\n */\npublic PDEmbeddedFilesNameTreeNode getEmbeddedFiles() {\n    COSDictionary dic = nameDictionary.getCOSDictionary(COSName.EMBEDDED_FILES);\n    return dic != null ? new PDEmbeddedFilesNameTreeNode(dic) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureNode.create",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureNode.create", "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a node in the structure tree. Can be either a structure tree root,\n *  or a structure element.\n *\n * @param node\n * \t\tthe node dictionary\n * @return the structure node\n */\npublic static PDStructureNode create(COSDictionary node) {\n    String type = node.getNameAsString(COSName.TYPE);\n    if (\"StructTreeRoot\".equals(type)) {\n        return new PDStructureTreeRoot(node);\n    }\n    if ((type == null) || \"StructElem\".equals(type)) {\n        return new PDStructureElement(node);\n    }\n    throw new IllegalArgumentException(\"Dictionary must not include a Type entry with a value that is neither StructTreeRoot nor StructElem.\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFDictionary() {\n    fdf = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Search for/parse the object with the given object number. The stream is closed after parsing the object with the\n * given number.\n *\n * @param objectNumber\n * \t\tthe number of the object to b e parsed\n * @return the parsed object or null if the object with the given number can't be found\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic COSBase parseObject(long objectNumber) throws IOException {\n    COSBase streamObject = null;\n    try {\n        Integer objectOffset = privateReadObjectNumbers().get(objectNumber);\n        if (objectOffset != null) {\n            // jump to the offset of the first object\n            long currentPosition = source.getPosition();\n            if ((firstObject > 0) && (currentPosition < firstObject)) {\n                source.skip(firstObject - ((int) (currentPosition)));\n            }\n            // jump to the offset of the object to be parsed\n            source.skip(objectOffset);\n            streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return streamObject;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNProcess.toString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNProcess.toString", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNProcess.<clinit>" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(\"Process{\");\n    try {\n        sb.append(getColorSpace());\n        for (String component : getComponents()) {\n            sb.append(\" \\\"\");\n            sb.append(component);\n            sb.append('\\\"');\n        }\n    } catch (IOException e) {\n        LOG.debug(\"Couldn't get the colorants information - returning 'ERROR' instead'\", e);\n        sb.append(\"ERROR\");\n    }\n    sb.append('}');\n    return sb.toString();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.DrawObject.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.DrawObject.process", "org.apache.pdfbox.contentstream.operator.DrawObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    if (arguments.isEmpty()) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    COSName name = ((COSName) (base0));\n    PDFStreamEngine context = getContext();\n    if (context.getResources().isImageXObject(name)) {\n        // we're done here, don't decode images when doing text extraction\n        return;\n    }\n    PDXObject xobject = context.getResources().getXObject(name);\n    if (xobject instanceof PDFormXObject) {\n        try {\n            context.increaseLevel();\n            if (context.getLevel() > 50) {\n                LOG.error(\"recursion is too deep, skipping form XObject\");\n                return;\n            }\n            if (xobject instanceof PDTransparencyGroup) {\n                context.showTransparencyGroup(((PDTransparencyGroup) (xobject)));\n            } else {\n                context.showForm(((PDFormXObject) (xobject)));\n            }\n        } finally {\n            context.decreaseLevel();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont", "org.apache.pdfbox.pdmodel.font.PDFontFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new PDFont instance with the appropriate subclass.\n *\n * @param dictionary\n * \t\ta font dictionary\n * @param resourceCache\n * \t\tresource cache, only useful for type 3 fonts, can be null\n * @return a PDFont instance, based on the SubType entry of the dictionary\n * @throws IOException\n * \t\tif something goes wrong\n */\npublic static PDFont createFont(COSDictionary dictionary, ResourceCache resourceCache) throws IOException {\n    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);\n    if (!COSName.FONT.equals(type)) {\n        LOG.error((\"Expected 'Font' dictionary but found '\" + type.getName()) + \"'\");\n    }\n    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);\n    if (COSName.TYPE1.equals(subType)) {\n        COSDictionary fd = dictionary.getCOSDictionary(COSName.FONT_DESC);\n        if ((fd != null) && fd.containsKey(COSName.FONT_FILE3)) {\n            return new PDType1CFont(dictionary);\n        }\n        return new PDType1Font(dictionary);\n    } else if (COSName.MM_TYPE1.equals(subType)) {\n        COSDictionary fd = dictionary.getCOSDictionary(COSName.FONT_DESC);\n        if ((fd != null) && fd.containsKey(COSName.FONT_FILE3)) {\n            return new PDType1CFont(dictionary);\n        }\n        return new PDMMType1Font(dictionary);\n    } else if (COSName.TRUE_TYPE.equals(subType)) {\n        return new PDTrueTypeFont(dictionary);\n    } else if (COSName.TYPE3.equals(subType)) {\n        return new PDType3Font(dictionary, resourceCache);\n    } else if (COSName.TYPE0.equals(subType)) {\n        COSDictionary fontDescriptor = getFontDescriptor(dictionary);\n        FontType fontTypeFromFont = getFontTypeFromFont(fontDescriptor, subType);\n        if (fontTypeFromFont != null) {\n            COSDictionary descendantFont = getDescendantFont(dictionary);\n            COSName descFontType = (descendantFont != null) ? descendantFont.getCOSName(COSName.SUBTYPE) : null;\n            if ((descFontType != null) && (!fontTypeFromFont.isCIDSubtype(descFontType))) {\n                fixType0Subtype(descendantFont, fontDescriptor, fontTypeFromFont.getSubtype());\n            }\n        }\n        return new PDType0Font(dictionary);\n    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {\n        throw new IOException(\"Type 0 descendant font not allowed\");\n    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {\n        throw new IOException(\"Type 2 descendant font not allowed\");\n    } else {\n        // assuming Type 1 font (see PDFBOX-1988) because it seems that Adobe Reader does this\n        // however, we may need more sophisticated logic perhaps looking at the FontFile\n        LOG.warn((\"Invalid font subtype '\" + subType) + \"'\");\n        return new PDType1Font(dictionary);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPages",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPages", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns all pages in the document, as a page tree.\n *\n * @return PDPageTree providing all pages of the document\n */\npublic PDPageTree getPages() {\n    // todo: cache me?\n    return new PDPageTree(root.getCOSDictionary(COSName.PAGES), document);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.setContents",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature.setContents", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the contents.\n *\n * @param bytes\n * \t\tcontents to be used\n */\npublic void setContents(byte[] bytes) {\n    COSString string = new COSString(bytes, true);\n    dictionary.setItem(COSName.CONTENTS, string);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.removeIssuer",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.removeIssuer", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Removes an issuer from the issuers list\n *\n * @param issuer\n * \t\tA byte array containing DER-encoded X.509v3 certificate\n */\npublic void removeIssuer(byte[] issuer) {\n    COSArray array = dictionary.getCOSArray(COSName.ISSUER);\n    if (array != null) {\n        array.remove(new COSString(issuer));\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.getBaseState",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.getBaseState", "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.getD", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the base state for optional content groups.\n *\n * @return the base state, never null.\n */\npublic BaseState getBaseState() {\n    COSDictionary d = getD();\n    COSName name = d.getCOSName(COSName.BASE_STATE, COSName.ON);\n    return BaseState.valueOf(name);\n}", "/**\n * Return the the /D dictionary.\n *\n * @return the /D dictionary, never null.\n */\nprivate COSDictionary getD() {\n    COSDictionary d = dict.getCOSDictionary(COSName.D);\n    if (d == null) {\n        d = new COSDictionary();\n        // Name optional but required for PDF/A-3\n        d.setString(COSName.NAME, \"Top\");\n        // D is required\n        dict.setItem(COSName.D, d);\n    }\n    return d;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createFormatterRectangle",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createFormatterRectangle", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createFormatterRectangle(int[] params) {\n    PDRectangle formatterRectangle = new PDRectangle();\n    formatterRectangle.setLowerLeftX(Math.min(params[0], params[2]));\n    formatterRectangle.setLowerLeftY(Math.min(params[1], params[3]));\n    formatterRectangle.setUpperRightX(Math.max(params[0], params[2]));\n    formatterRectangle.setUpperRightY(Math.max(params[1], params[3]));\n    pdfStructure.setFormatterRectangle(formatterRectangle);\n    LOG.info(\"Formatter rectangle has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.prepress.PDBoxStyle.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.prepress.PDBoxStyle.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default Constructor.\n */\npublic PDBoxStyle() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.createFromRandomAccessImpl", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new CCITT Fax compressed image XObject from a specific image of a TIFF file stored\n * in a byte array. Only single-strip CCITT T4 or T6 compressed TIFF files are supported. If\n * you're not sure what TIFF files you have, use\n * {@link LosslessFactory#createFromImage(PDDocument, BufferedImage)}\n * or {@link CCITTFactory#createFromImage(PDDocument, BufferedImage)}\n * instead.\n *\n * @param document\n * \t\tthe document to create the image as part of.\n * @param byteArray\n * \t\tthe TIFF file in a byte array which contains a suitable CCITT compressed\n * \t\timage\n * @param number\n * \t\tTIFF image number, starting from 0\n * @return a new Image XObject\n * @throws IOException\n * \t\tif there is an error reading the TIFF data.\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray, int number) throws IOException {\n    try (RandomAccessRead raf = new RandomAccessReadBuffer(byteArray)) {\n        return createFromRandomAccessImpl(document, raf, number);\n    }\n}", "/**\n * Creates a new CCITT Fax compressed image XObject from a TIFF file.\n *\n * @param document\n * \t\tthe document to create the image as part of.\n * @param reader\n * \t\tthe random access TIFF file which contains a suitable CCITT\n * \t\tcompressed image\n * @param number\n * \t\tTIFF image number, starting from 0\n * @return a new Image XObject, or null if no such page\n * @throws IOException\n * \t\tif there is an error reading the TIFF data.\n */\nprivate static PDImageXObject createFromRandomAccessImpl(PDDocument document, RandomAccessRead reader, int number) throws IOException {\n    COSDictionary decodeParms = new COSDictionary();\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    extractFromTiff(reader, bos, decodeParms, number);\n    if (bos.size() == 0) {\n        return null;\n    }\n    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(bos.toByteArray());\n    PDImageXObject pdImage = new PDImageXObject(document, encodedByteStream, COSName.CCITTFAX_DECODE, decodeParms.getInt(COSName.COLUMNS), decodeParms.getInt(COSName.ROWS), 1, PDDeviceGray.INSTANCE);\n    COSDictionary dict = pdImage.getCOSObject();\n    dict.setItem(COSName.DECODE_PARMS, decodeParms);\n    return pdImage;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCaretAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCaretAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCaretAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationCaret annotation = ((PDAnnotationCaret) (getAnnotation()));\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        PDColor color = getColor();\n        contentStream.setStrokingColor(color);\n        contentStream.setNonStrokingColor(color);\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        PDRectangle rect = getRectangle();\n        float rectWidth = rect.getWidth();\n        float rectHeight = rect.getHeight();\n        PDRectangle bbox = new PDRectangle(rectWidth, rectHeight);\n        PDAppearanceStream pdAppearanceStream = annotation.getNormalAppearanceStream();\n        if (!annotation.getCOSObject().containsKey(COSName.RD)) {\n            // Adobe creates the /RD entry with a number that is decided\n            // by dividing the height by 10, with a maximum result of 5.\n            // That number is then used to enlarge the bbox and the rectangle and added to the\n            // translation values in the matrix and also used for the line width\n            // (not here because it has no effect, see comment near fill() ).\n            // The curves are based on the original rectangle.\n            float rd = Math.min(rectHeight / 10, 5);\n            annotation.setRectDifferences(rd);\n            bbox = new PDRectangle(-rd, -rd, rectWidth + (2 * rd), rectHeight + (2 * rd));\n            Matrix matrix = pdAppearanceStream.getMatrix();\n            pdAppearanceStream.setMatrix(matrix.createAffineTransform());\n            PDRectangle rect2 = new PDRectangle(rect.getLowerLeftX() - rd, rect.getLowerLeftY() - rd, rectWidth + (2 * rd), rectHeight + (2 * rd));\n            annotation.setRectangle(rect2);\n        }\n        pdAppearanceStream.setBBox(bbox);\n        float halfX = rectWidth / 2;\n        float halfY = rectHeight / 2;\n        contentStream.moveTo(0, 0);\n        contentStream.curveTo(halfX, 0, halfX, halfY, halfX, rectHeight);\n        contentStream.curveTo(halfX, halfY, halfX, 0, rectWidth, 0);\n        contentStream.closePath();\n        contentStream.fill();\n        // Adobe has an additional stroke, but it has no effect\n        // because fill \"consumes\" the path.\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.DecodeResult.createDefault",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.DecodeResult.createDefault", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Return a default DecodeResult.\n *\n * @return a default instance of DecodeResult\n */\npublic static DecodeResult createDefault() {\n    return new DecodeResult(new COSDictionary());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.LayerUtility.appendFormAsLayer",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.LayerUtility.appendFormAsLayer", "org.apache.pdfbox.multipdf.LayerUtility.<clinit>" ],
    "fullMethods" : [ "/**\n * Places the given form over the existing content of the indicated page (like an overlay).\n * The form is enveloped in a marked content section to indicate that it's part of an\n * optional content group (OCG), here used as a layer. This optional group is returned and\n * can be enabled and disabled through methods on {@link PDOptionalContentProperties}.\n * <p>\n * You may want to call {@link #wrapInSaveRestore(PDPage) wrapInSaveRestore(PDPage)} before calling this method to make\n * sure that the graphics state is reset.\n *\n * @param targetPage\n * \t\tthe target page\n * @param form\n * \t\tthe form to place\n * @param transform\n * \t\tthe transformation matrix that controls the placement of your form. You'll\n * \t\tneed this if your page has a crop box different than the media box, or if these have negative\n * \t\tcoordinates, or if you want to scale or adjust your form.\n * @param layerName\n * \t\tthe name for the layer/OCG to produce\n * @return the optional content group that was generated for the form usage\n * @throws IOException\n * \t\tif an I/O error occurs\n */\npublic PDOptionalContentGroup appendFormAsLayer(PDPage targetPage, PDFormXObject form, AffineTransform transform, String layerName) throws IOException {\n    PDDocumentCatalog catalog = targetDoc.getDocumentCatalog();\n    PDOptionalContentProperties ocprops = catalog.getOCProperties();\n    if (ocprops == null) {\n        ocprops = new PDOptionalContentProperties();\n        catalog.setOCProperties(ocprops);\n    }\n    if (ocprops.hasGroup(layerName)) {\n        throw new IllegalArgumentException(\"Optional group (layer) already exists: \" + layerName);\n    }\n    PDRectangle cropBox = targetPage.getCropBox();\n    if (((cropBox.getLowerLeftX() < 0) || (cropBox.getLowerLeftY() < 0)) && transform.isIdentity()) {\n        // PDFBOX-4044\n        LOG.warn((\"Negative cropBox \" + cropBox) + \" and identity transform may make your form invisible\");\n    }\n    PDOptionalContentGroup layer = new PDOptionalContentGroup(layerName);\n    ocprops.addGroup(layer);\n    try (PDPageContentStream contentStream = new PDPageContentStream(targetDoc, targetPage, AppendMode.APPEND, !DEBUG)) {\n        contentStream.beginMarkedContent(COSName.OC, layer);\n        contentStream.saveGraphicsState();\n        contentStream.transform(new Matrix(transform));\n        contentStream.drawForm(form);\n        contentStream.restoreGraphicsState();\n        contentStream.endMarkedContent();\n    }\n    return layer;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentInformation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentInformation.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default Constructor.\n */\npublic PDDocumentInformation() {\n    info = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getLastChild",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getLastChild", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getOutlineItem", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @return The last child or null if there is no child.\n */\npublic PDOutlineItem getLastChild() {\n    return getOutlineItem(COSName.LAST);\n}", "PDOutlineItem getOutlineItem(COSName name) {\n    COSDictionary outline = getCOSObject().getCOSDictionary(name);\n    return outline != null ? new PDOutlineItem(outline) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.strokePath",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.strokePath", "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getStrokingJavaComposite", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void strokePath() throws IOException {\n    if (isContentRendered()) {\n        graphics.setComposite(getGraphicsState().getStrokingJavaComposite());\n        graphics.setPaint(getStrokingPaint());\n        graphics.setStroke(getStroke());\n        setClip();\n        graphics.draw(linePath);\n    }\n    linePath.reset();\n}", "public Composite getStrokingJavaComposite() {\n    return BlendComposite.getInstance(blendMode, ((float) (alphaConstant)));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setNames",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setNames", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the names for this node. This method will set the appropriate upper and lower limits\n * based on the keys in the map and take care of the ordering.\n *\n * @param names\n * \t\tmap of names to objects, or <code>null</code> for nothing.\n */\npublic void setNames(Map<String, T> names) {\n    if (names == null) {\n        node.setItem(COSName.NAMES, ((COSObjectable) (null)));\n        node.setItem(COSName.LIMITS, ((COSObjectable) (null)));\n    } else {\n        COSArray array = new COSArray();\n        List<String> keys = new ArrayList<>(names.keySet());\n        Collections.sort(keys);\n        for (String key : keys) {\n            array.add(new COSString(key));\n            array.add(names.get(key));\n        }\n        node.setItem(COSName.NAMES, array);\n        calculateLimits();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.getVersion",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.getVersion", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the PDF specification version this document conforms to.\n *\n * @return the PDF version (e.g. 1.4f)\n */\npublic float getVersion() {\n    float headerVersionFloat = getDocument().getVersion();\n    // there may be a second version information in the document catalog starting with 1.4\n    if (headerVersionFloat >= 1.4F) {\n        String catalogVersion = getDocumentCatalog().getVersion();\n        float catalogVersionFloat = -1;\n        if (catalogVersion != null) {\n            try {\n                catalogVersionFloat = Float.parseFloat(catalogVersion);\n            } catch (NumberFormatException exception) {\n                LOG.error(\"Can't extract the version number of the document catalog.\", exception);\n            }\n        }\n        // the most recent version is the correct one\n        return Math.max(catalogVersionFloat, headerVersionFloat);\n    } else {\n        return headerVersionFloat;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded and subset into a document as a Type 0 font. If you are loading a\n * font for AcroForm, then use the 3-parameter constructor instead.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param input\n * \t\tAn input stream of a TrueType font. It will be closed before returning.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font load(PDDocument doc, InputStream input) throws IOException {\n    return load(doc, input, true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.JBIG2Filter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.JBIG2Filter.decode", "org.apache.pdfbox.filter.JBIG2Filter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException {\n    ImageReader reader = findImageReader(\"JBIG2\", \"jbig2-imageio is not installed\");\n    if (reader.getClass().getName().contains(\"levigo\")) {\n        logLevigoDonated();\n    }\n    int bits = parameters.getInt(COSName.BITS_PER_COMPONENT, 1);\n    COSDictionary params = getDecodeParams(parameters, index);\n    ImageReadParam irp = reader.getDefaultReadParam();\n    irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());\n    irp.setSourceRegion(options.getSourceRegion());\n    options.setFilterSubsampled(true);\n    InputStream source = encoded;\n    if (params != null) {\n        COSStream globals = params.getCOSStream(COSName.JBIG2_GLOBALS);\n        if (globals != null) {\n            source = new SequenceInputStream(globals.createInputStream(), encoded);\n        }\n    }\n    try (ImageInputStream iis = ImageIO.createImageInputStream(source)) {\n        reader.setInput(iis);\n        BufferedImage image;\n        try {\n            image = reader.read(0, irp);\n        } catch (Exception e) {\n            // wrap and rethrow any exceptions\n            throw new IOException(\"Could not read JBIG2 image\", e);\n        }\n        // I am assuming since JBIG2 is always black and white\n        // depending on your renderer this might or might be needed\n        if (image.getColorModel().getPixelSize() != bits) {\n            if (bits != 1) {\n                LOG.warn(\"Attempting to handle a JBIG2 with more than 1-bit depth\");\n            }\n            BufferedImage packedImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);\n            Graphics graphics = packedImage.getGraphics();\n            graphics.drawImage(image, 0, 0, null);\n            graphics.dispose();\n            image = packedImage;\n        }\n        DataBuffer dBuf = image.getData().getDataBuffer();\n        if (dBuf.getDataType() == DataBuffer.TYPE_BYTE) {\n            decoded.write(((DataBufferByte) (dBuf)).getData());\n        } else {\n            throw new IOException(\"Unexpected image buffer type\");\n        }\n    } finally {\n        reader.dispose();\n    }\n    return new DecodeResult(parameters);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSString.toHexString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSString.toHexString", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * This will take this string and create a hex representation of the bytes that make the string.\n *\n * @return A hex string representing the bytes in this string.\n */\npublic String toHexString() {\n    return Hex.getString(bytes);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueTimeStamp.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueTimeStamp.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDSeedValueTimeStamp() {\n    dictionary = new COSDictionary();\n    dictionary.setDirect(true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.getStringWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.getStringWidth", "org.apache.pdfbox.pdmodel.font.PDType1CFont.<clinit>" ],
    "fullMethods" : [ "@Override\npublic float getStringWidth(String string) throws IOException {\n    if (cffFont == null) {\n        LOG.warn(\"No embedded CFF font, returning 0\");\n        return 0;\n    }\n    float width = 0;\n    for (int i = 0; i < string.length(); i++) {\n        int codePoint = string.codePointAt(i);\n        String name = getGlyphList().codePointToName(codePoint);\n        if (!cffFont.hasGlyph(name)) {\n            throw new IllegalArgumentException(String.format(\"U+%04X ('%s') is not available in font %s\", codePoint, name, getName()));\n        }\n        width += cffFont.getType1CharString(name).getWidth();\n    }\n    return width;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationMarkup.getPopup",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationMarkup.getPopup", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPopup.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the popup annotation used for entering/editing the text for this annotation.\n *\n * @return the popup annotation.\n */\npublic PDAnnotationPopup getPopup() {\n    COSDictionary popup = getCOSObject().getCOSDictionary(COSName.POPUP);\n    return popup != null ? new PDAnnotationPopup(popup) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.getFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.getFont", "org.apache.pdfbox.pdmodel.font.PDFontFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the font resource with the given name, or null if none exists.\n *\n * @param name\n * \t\tName of the font resource.\n * @return the font with the given name or null\n * @throws IOException\n * \t\tif something went wrong.\n */\npublic PDFont getFont(COSName name) throws IOException {\n    COSObject indirect = getIndirect(COSName.FONT, name);\n    if ((cache != null) && (indirect != null)) {\n        PDFont cached = cache.getFont(indirect);\n        if (cached != null) {\n            return cached;\n        }\n    } else if (indirect == null) {\n        SoftReference<PDFont> ref = directFontCache.get(name);\n        if (ref != null) {\n            PDFont cached = ref.get();\n            if (cached != null) {\n                return cached;\n            }\n        }\n    }\n    PDFont font = null;\n    COSBase base = get(COSName.FONT, name);\n    if (base instanceof COSDictionary) {\n        font = PDFontFactory.createFont(((COSDictionary) (base)), cache);\n    }\n    if ((cache != null) && (indirect != null)) {\n        cache.put(indirect, font);\n    } else if (indirect == null) {\n        directFontCache.put(name, new SoftReference<>(font));\n    }\n    return font;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.<init>", "org.apache.pdfbox.cos.COSDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates an empty PDF document. You need to add at least one page for the document to be valid.\n *\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache for buffering PDF streams\n */\npublic PDDocument(StreamCacheCreateFunction streamCacheCreateFunction) {\n    document = new COSDocument(streamCacheCreateFunction);\n    document.getDocumentState().setParsing(false);\n    pdfSource = null;\n    // First we need a trailer\n    COSDictionary trailer = new COSDictionary();\n    document.setTrailer(trailer);\n    // Next we need the root dictionary.\n    COSDictionary rootDictionary = new COSDictionary();\n    trailer.setItem(COSName.ROOT, rootDictionary);\n    rootDictionary.setItem(COSName.TYPE, COSName.CATALOG);\n    rootDictionary.setItem(COSName.VERSION, COSName.getPDFName(\"1.4\"));\n    // next we need the pages tree structure\n    COSDictionary pages = new COSDictionary();\n    rootDictionary.setItem(COSName.PAGES, pages);\n    pages.setItem(COSName.TYPE, COSName.PAGES);\n    COSArray kidsArray = new COSArray();\n    pages.setItem(COSName.KIDS, kidsArray);\n    pages.setItem(COSName.COUNT, COSInteger.ZERO);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDSeparation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDSeparation.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new Separation color space from a PDF color space array.\n *\n * @param separation\n * \t\tan array containing all separation information.\n * @param resources\n * \t\tresources, can be null.\n * @throws IOException\n * \t\tif the color space or the function could not be created.\n */\npublic PDSeparation(COSArray separation, PDResources resources) throws IOException {\n    array = separation;\n    alternateColorSpace = PDColorSpace.create(array.getObject(ALTERNATE_CS), resources);\n    tintTransform = PDFunction.create(array.getObject(TINT_TRANSFORM));\n    int numberOfOutputParameters = tintTransform.getNumberOfOutputParameters();\n    if ((numberOfOutputParameters > 0) && (numberOfOutputParameters < alternateColorSpace.getNumberOfComponents())) {\n        throw new IOException((((((\"The tint transform function has less output parameters (\" + tintTransform.getNumberOfOutputParameters()) + \") than the alternate colorspace \") + alternateColorSpace) + \" (\") + alternateColorSpace.getNumberOfComponents()) + \")\");\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getValue", "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the value corresponding to an index in the number tree.\n *\n * @param index\n * \t\tThe index in the number tree.\n * @return The value corresponding to the index.\n * @throws IOException\n * \t\tIf there is a problem creating the values.\n */\npublic Object getValue(Integer index) throws IOException {\n    Map<Integer, COSObjectable> numbers = getNumbers();\n    if (numbers != null) {\n        return numbers.get(index);\n    }\n    Object retval = null;\n    List<PDNumberTreeNode> kids = getKids();\n    if (kids != null) {\n        for (int i = 0; (i < kids.size()) && (retval == null); i++) {\n            PDNumberTreeNode childNode = kids.get(i);\n            if ((childNode.getLowerLimit().compareTo(index) <= 0) && (childNode.getUpperLimit().compareTo(index) >= 0)) {\n                retval = childNode.getValue(index);\n            }\n        }\n    } else {\n        LOG.warn(\"NumberTreeNode does not have \\\"nums\\\" nor \\\"kids\\\" objects.\");\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getContentStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getContentStream", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "public PDStream getContentStream() {\n    return new PDStream(charStream);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.addGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.addGroup", "org.apache.pdfbox.cos.COSArray.add", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds an optional content group (OCG).\n *\n * @param ocg\n * \t\tthe optional content group\n */\npublic void addGroup(PDOptionalContentGroup ocg) {\n    COSArray ocgs = getOCGs();\n    ocgs.add(ocg.getCOSObject());\n    // By default, add new group to the \"Order\" entry so it appears in the user interface\n    COSArray order = getD().getCOSArray(COSName.ORDER);\n    if (order == null) {\n        order = new COSArray();\n        getD().setItem(COSName.ORDER, order);\n    }\n    order.add(ocg);\n}", "/**\n * This will add an object to the array.\n *\n * @param object\n * \t\tThe object to add to the array.\n */\npublic void add(COSBase object) {\n    // wrap indirect objects\n    if ((((object instanceof COSDictionary) || (object instanceof COSArray)) && (!object.isDirect())) && (object.getKey() != null)) {\n        COSObject cosObject = new COSObject(object, object.getKey());\n        objects.add(cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        objects.add(object);\n        getUpdateState().update(object);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<init>", "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new TrueType font from a Font dictionary.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @throws IOException\n * \t\tif the font could not be created\n */\npublic PDTrueTypeFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    TrueTypeFont ttfFont = null;\n    boolean fontIsDamaged = false;\n    if (getFontDescriptor() != null) {\n        PDFontDescriptor fd = super.getFontDescriptor();\n        PDStream ff2Stream = fd.getFontFile2();\n        if (ff2Stream != null) {\n            RandomAccessRead view = null;\n            try {\n                view = ff2Stream.getCOSObject().createView();\n                // embedded\n                TTFParser ttfParser = getParser(view, true);\n                ttfFont = ttfParser.parse(view);\n                ttfFont.close();\n            } catch (IOException e) {\n                LOG.warn(\"Could not read embedded TTF for font \" + getBaseFont(), e);\n                fontIsDamaged = true;\n                IOUtils.closeQuietly(view);\n            }\n        }\n    }\n    isEmbedded = ttfFont != null;\n    isDamaged = fontIsDamaged;\n    // substitute\n    if (ttfFont == null) {\n        FontMapping<TrueTypeFont> mapping = FontMappers.instance().getTrueTypeFont(getBaseFont(), getFontDescriptor());\n        ttfFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + ttfFont) + \" for \") + getBaseFont());\n        }\n    }\n    otf = ((ttfFont instanceof OpenTypeFont) && ((OpenTypeFont) (ttfFont)).isSupportedOTF()) ? ((OpenTypeFont) (ttfFont)) : null;\n    ttf = ttfFont;\n    readEncoding();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.COSArrayList.converterToCOSArray",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.COSArrayList.converterToCOSArray", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will convert a list of COSObjectables to an array list of COSBase objects.\n *\n * @param cosObjectableList\n * \t\tA list of COSObjectable.\n * @return A list of COSBase.\n * @throws IllegalArgumentException\n * \t\tif an object type is not supported for conversion to a\n * \t\tCOSBase object.\n */\npublic static COSArray converterToCOSArray(List<?> cosObjectableList) {\n    COSArray array = null;\n    if (cosObjectableList != null) {\n        if (cosObjectableList instanceof COSArrayList) {\n            // if it is already a COSArrayList then we don't want to recreate the array, we want to reuse it.\n            array = ((COSArrayList<?>) (cosObjectableList)).array;\n        } else {\n            array = new COSArray();\n            for (Object next : cosObjectableList) {\n                if (next instanceof String) {\n                    array.add(new COSString(((String) (next))));\n                } else if ((next instanceof Integer) || (next instanceof Long)) {\n                    array.add(COSInteger.get(((Number) (next)).longValue()));\n                } else if ((next instanceof Float) || (next instanceof Double)) {\n                    array.add(new COSFloat(((Number) (next)).floatValue()));\n                } else if (next instanceof COSObjectable) {\n                    COSObjectable object = ((COSObjectable) (next));\n                    array.add(object.getCOSObject());\n                } else if (next == null) {\n                    array.add(COSNull.NULL);\n                } else {\n                    throw new IllegalArgumentException((\"Error: Don't know how to convert type to COSBase '\" + next.getClass().getName()) + \"'\");\n                }\n            }\n        }\n    }\n    return array;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.setEmbeddedFileUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.setEmbeddedFileUnicode", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the embedded Unicode file for this spec. If you call this, then do not forget to also\n * call\n * {@link #setEmbeddedFile(org.apache.pdfbox.pdmodel.common.filespecification.PDEmbeddedFile) setEmbeddedFile(PDEmbeddedFile)}\n * or the attachment will not be visible on some viewers.\n *\n * @param file\n * \t\tThe Unicode file to be embedded.\n */\npublic void setEmbeddedFileUnicode(PDEmbeddedFile file) {\n    COSDictionary ef = getEFDictionary();\n    if ((ef == null) && (file != null)) {\n        ef = new COSDictionary();\n        fs.setItem(COSName.EF, ef);\n    }\n    if (ef != null) {\n        ef.setItem(COSName.UF, file);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderForm",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderForm", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createHolderForm(PDResources holderFormResources, PDStream holderFormStream, PDRectangle bbox) {\n    PDFormXObject holderForm = new PDFormXObject(holderFormStream);\n    holderForm.setResources(holderFormResources);\n    holderForm.setBBox(bbox);\n    holderForm.setFormType(1);\n    pdfStructure.setHolderForm(holderForm);\n    LOG.info(\"Holder form has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * Check for owner password.\n *\n * @param ownerPassword\n * \t\tThe owner password.\n * @param user\n * \t\tThe u entry of the encryption dictionary.\n * @param owner\n * \t\tThe o entry of the encryption dictionary.\n * @param permissions\n * \t\tThe set of permissions on the document.\n * @param id\n * \t\tThe document id.\n * @param encRevision\n * \t\tThe encryption algorithm revision.\n * @param keyLengthInBytes\n * \t\tThe encryption key length in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata\n * @return True If the ownerPassword param is the owner password.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\npublic boolean isOwnerPassword(byte[] ownerPassword, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException {\n    switch (encRevision) {\n        case REVISION_2 :\n        case REVISION_3 :\n        case REVISION_4 :\n            return isOwnerPassword234(ownerPassword, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);\n        case REVISION_5 :\n        case REVISION_6 :\n            return isOwnerPassword56(ownerPassword, user, owner, encRevision);\n        default :\n            throw new IOException(\"Unknown Encryption Revision \" + encRevision);\n    }\n}", "private boolean isOwnerPassword56(byte[] ownerPassword, byte[] user, byte[] owner, int encRevision) throws IOException {\n    if (owner.length < 40) {\n        // PDFBOX-5104\n        throw new IOException(\"Owner password is too short\");\n    }\n    byte[] truncatedOwnerPassword = truncate127(ownerPassword);\n    byte[] oHash = new byte[32];\n    byte[] oValidationSalt = new byte[8];\n    System.arraycopy(owner, 0, oHash, 0, 32);\n    System.arraycopy(owner, 32, oValidationSalt, 0, 8);\n    if (encRevision == REVISION_5) {\n        return MessageDigest.isEqual(computeSHA256(truncatedOwnerPassword, oValidationSalt, user), oHash);\n    } else {\n        return MessageDigest.isEqual(computeHash2A(truncatedOwnerPassword, oValidationSalt, user), oHash);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates an Image XObject in the given document. This constructor is for internal PDFBox use\n * and is not for PDF generation. Users who want to create images should look at {@link #createFromFileByExtension(File, PDDocument)}.\n *\n * @param document\n * \t\tthe current document\n * @throws java.io.IOException\n * \t\tif there is an error creating the XObject.\n */\npublic PDImageXObject(PDDocument document) throws IOException {\n    this(new PDStream(document), null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.TextPosition.mergeDiacritic",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.TextPosition.mergeDiacritic", "org.apache.pdfbox.text.TextPosition.<clinit>" ],
    "fullMethods" : [ "/**\n * Merge a single character TextPosition into the current object. This is to be used only for\n * cases where we have a diacritic that overlaps an existing TextPosition. In a graphical\n * display, we could overlay them, but for text extraction we need to merge them. Use the\n * contains() method to test if two objects overlap.\n *\n * @param diacritic\n * \t\tTextPosition to merge into the current TextPosition.\n */\npublic void mergeDiacritic(TextPosition diacritic) {\n    if (diacritic.getUnicode().length() > 1) {\n        return;\n    }\n    float diacXStart = diacritic.getXDirAdj();\n    float diacXEnd = diacXStart + diacritic.widths[0];\n    float currCharXStart = getXDirAdj();\n    int strLen = unicode.length();\n    boolean wasAdded = false;\n    for (int i = 0; (i < strLen) && (!wasAdded); i++) {\n        if (i >= widths.length) {\n            LOG.info((((\"diacritic \" + diacritic.getUnicode()) + \" on ligature \") + unicode) + \" is not supported yet and is ignored (PDFBOX-2831)\");\n            break;\n        }\n        float currCharXEnd = currCharXStart + widths[i];\n        // this is the case where there is an overlap of the diacritic character with the\n        // current character and the previous character. If no previous character, just append\n        // the diacritic after the current one\n        if ((diacXStart < currCharXStart) && (diacXEnd <= currCharXEnd)) {\n            if (i == 0) {\n                insertDiacritic(i, diacritic);\n            } else {\n                float distanceOverlapping1 = diacXEnd - currCharXStart;\n                float percentage1 = distanceOverlapping1 / widths[i];\n                float distanceOverlapping2 = currCharXStart - diacXStart;\n                float percentage2 = distanceOverlapping2 / widths[i - 1];\n                if (percentage1 >= percentage2) {\n                    insertDiacritic(i, diacritic);\n                } else {\n                    insertDiacritic(i - 1, diacritic);\n                }\n            }\n            wasAdded = true;\n        } else if (diacXStart < currCharXStart) {\n            insertDiacritic(i, diacritic);\n            wasAdded = true;\n        } else if (diacXEnd <= currCharXEnd) {\n            insertDiacritic(i, diacritic);\n            wasAdded = true;\n        } else if (i == (strLen - 1)) {\n            insertDiacritic(i, diacritic);\n            wasAdded = true;\n        }\n        // couldn't find anything useful so we go to the next character in the TextPosition\n        currCharXStart += widths[i];\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolygonAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolygonAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolygonAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationPolygon annotation = ((PDAnnotationPolygon) (getAnnotation()));\n    float lineWidth = getLineWidth();\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    // Adjust rectangle even if not empty\n    // CTAN-example-Annotations.pdf p2\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    float[][] pathArray = getPathArray(annotation);\n    if (pathArray == null) {\n        return;\n    }\n    for (int i = 0; i < pathArray.length; ++i) {\n        for (int j = 0; j < (pathArray[i].length / 2); ++j) {\n            float x = pathArray[i][j * 2];\n            float y = pathArray[i][(j * 2) + 1];\n            minX = Math.min(minX, x);\n            minY = Math.min(minY, y);\n            maxX = Math.max(maxX, x);\n            maxY = Math.max(maxY, y);\n        }\n    }\n    rect.setLowerLeftX(Math.min(minX - lineWidth, rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - lineWidth, rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + lineWidth, rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + lineWidth, rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());\n        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());\n            cloudyBorder.createCloudyPolygon(pathArray);\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            // Acrobat applies a padding to each side of the bbox so the line is\n            // completely within the bbox.\n            for (int i = 0; i < pathArray.length; i++) {\n                float[] pointsArray = pathArray[i];\n                // first array shall be of size 2 and specify the moveto operator\n                if ((i == 0) && (pointsArray.length == 2)) {\n                    contentStream.moveTo(pointsArray[0], pointsArray[1]);\n                } else // entries of length 2 shall be treated as lineto operator\n                if (pointsArray.length == 2) {\n                    contentStream.lineTo(pointsArray[0], pointsArray[1]);\n                } else if (pointsArray.length == 6) {\n                    contentStream.curveTo(pointsArray[0], pointsArray[1], pointsArray[2], pointsArray[3], pointsArray[4], pointsArray[5]);\n                }\n            }\n            contentStream.closePath();\n        }\n        contentStream.drawShape(lineWidth, hasStroke, hasBackground);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getNonStrokingJavaComposite",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getNonStrokingJavaComposite", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.<clinit>" ],
    "fullMethods" : [ "public Composite getNonStrokingJavaComposite() {\n    return BlendComposite.getInstance(blendMode, ((float) (nonStrokingAlphaConstant)));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth", "org.apache.pdfbox.pdmodel.font.PDFont.<clinit>" ],
    "fullMethods" : [ "/**\n * Determines the width of the space character. This is very important for text extraction.\n *\n * @return the width of the space character\n */\npublic float getSpaceWidth() {\n    if (Float.compare(fontWidthOfSpace, -1.0F) == 0) {\n        try {\n            if ((toUnicodeCMap != null) && dict.containsKey(COSName.TO_UNICODE)) {\n                int spaceMapping = toUnicodeCMap.getSpaceMapping();\n                if (spaceMapping > (-1)) {\n                    fontWidthOfSpace = getWidth(spaceMapping);\n                }\n            } else {\n                try {\n                    // PDFBOX-5920: try with encoding, which gets the correct code\n                    fontWidthOfSpace = getStringWidth(\" \");\n                } catch (IllegalArgumentException | UnsupportedOperationException ex) {\n                    // Happens if space is not available in the font\n                    // or if encoding isn't implemented\n                    LOG.debug(ex.getMessage(), ex);\n                }\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getWidth(32);\n                }\n            }\n            // try to get it from the font itself\n            if (fontWidthOfSpace <= 0) {\n                fontWidthOfSpace = getWidthFromFont(32);\n                // use the average font width as fall back\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getAverageFontWidth();\n                }\n            }\n        } catch (Exception e) {\n            LOG.error((\"Can't determine the width of the space character for font \" + getName()) + \", assuming 250\", e);\n            fontWidthOfSpace = 250.0F;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Space width for font \" + getName()) + \" is \") + fontWidthOfSpace);\n        }\n    }\n    return fontWidthOfSpace;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.FlateFilterDecoderStream.read",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.FlateFilterDecoderStream.read", "org.apache.pdfbox.filter.FlateFilterDecoderStream.fetch", "org.apache.pdfbox.filter.FlateFilterDecoderStream.<clinit>" ],
    "fullMethods" : [ "/**\n * This will read a chunk of data.\n *\n * @param data\n * \t\tThe buffer to write data to.\n * @param offset\n * \t\tThe offset into the data stream.\n * @param length\n * \t\tThe number of byte to attempt to read.\n * @return The number of bytes actually read.\n * @throws IOException\n * \t\tIf there is an error reading data from the underlying stream.\n */\n@Override\npublic int read(byte[] data, int offset, int length) throws IOException {\n    if (isEOF) {\n        return -1;\n    }\n    int numberOfBytesRead = 0;\n    while (numberOfBytesRead < length) {\n        int available = bytesDecoded - currentDataIndex;\n        if (available > 0) {\n            int bytes2Copy = Math.min(length - numberOfBytesRead, available);\n            System.arraycopy(decodedData, currentDataIndex, data, numberOfBytesRead + offset, bytes2Copy);\n            currentDataIndex += bytes2Copy;\n            numberOfBytesRead += bytes2Copy;\n        } else if (!fetch()) {\n            break;\n        }\n    } \n    return numberOfBytesRead;\n}", "private boolean fetch() throws IOException {\n    currentDataIndex = 0;\n    if (isEOF || inflater.finished()) {\n        isEOF = true;\n        bytesDecoded = 0;\n        return false;\n    }\n    if (inflater.needsInput()) {\n        int bytesRead = in.read(buffer);\n        if (bytesRead > (-1)) {\n            inflater.setInput(buffer, 0, bytesRead);\n        } else {\n            isEOF = true;\n            return false;\n        }\n    }\n    try {\n        // overwrite formerly read bytes\n        if (bytesDecoded > 0) {\n            Arrays.fill(decodedData, 0, bytesDecoded, ((byte) (0)));\n        }\n        bytesDecoded = inflater.inflate(decodedData);\n    } catch (DataFormatException exception) {\n        isEOF = true;\n        // check if some bytes could be read at all\n        int countZeros = 0;\n        for (int i = 0; i < decodedData.length; i++) {\n            if (decodedData[i] == 0) {\n                countZeros++;\n            } else {\n                countZeros = 0;\n            }\n        }\n        bytesDecoded = decodedData.length - countZeros;\n        // don't throw an exception, use the already read data or an empty stream\n        LOG.warn(\"FlateFilter: premature end of stream due to a DataFormatException = \" + exception.getMessage());\n        return bytesDecoded > 0;\n    }\n    return true;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type7ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType1Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderFormStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderFormStream", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createHolderFormStream(PDDocument template) {\n    PDStream holderForm = new PDStream(template);\n    pdfStructure.setHolderFormStream(holderForm);\n    LOG.info(\"Holder form stream has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.DateConverter.toCalendar",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.DateConverter.toCalendar", "org.apache.pdfbox.util.DateConverter.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the Calendar for a given COS string containing a date,\n * or {@code null} if it cannot be parsed.\n *\n * The returned value will have 0 for DST_OFFSET.\n *\n * @param text\n * \t\tA COS string containing a date.\n * @return The Calendar that the text string represents, or {@code null} if it cannot be parsed.\n */\npublic static Calendar toCalendar(COSString text) {\n    if (text == null) {\n        return null;\n    }\n    return toCalendar(text.getString());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.FlateFilterDecoderStream.read",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.FlateFilterDecoderStream.read", "org.apache.pdfbox.filter.FlateFilterDecoderStream.fetch", "org.apache.pdfbox.filter.FlateFilterDecoderStream.<clinit>" ],
    "fullMethods" : [ "/**\n * This will read the next byte from the stream.\n *\n * @return The next byte read from the stream.\n * @throws IOException\n * \t\tIf there is an error reading from the wrapped stream.\n */\n@Override\npublic int read() throws IOException {\n    if (isEOF) {\n        return -1;\n    }\n    if ((currentDataIndex == bytesDecoded) && (!fetch())) {\n        return -1;\n    }\n    return decodedData[currentDataIndex++] & 0xff;\n}", "private boolean fetch() throws IOException {\n    currentDataIndex = 0;\n    if (isEOF || inflater.finished()) {\n        isEOF = true;\n        bytesDecoded = 0;\n        return false;\n    }\n    if (inflater.needsInput()) {\n        int bytesRead = in.read(buffer);\n        if (bytesRead > (-1)) {\n            inflater.setInput(buffer, 0, bytesRead);\n        } else {\n            isEOF = true;\n            return false;\n        }\n    }\n    try {\n        // overwrite formerly read bytes\n        if (bytesDecoded > 0) {\n            Arrays.fill(decodedData, 0, bytesDecoded, ((byte) (0)));\n        }\n        bytesDecoded = inflater.inflate(decodedData);\n    } catch (DataFormatException exception) {\n        isEOF = true;\n        // check if some bytes could be read at all\n        int countZeros = 0;\n        for (int i = 0; i < decodedData.length; i++) {\n            if (decodedData[i] == 0) {\n                countZeros++;\n            } else {\n                countZeros = 0;\n            }\n        }\n        bytesDecoded = decodedData.length - countZeros;\n        // don't throw an exception, use the already read data or an empty stream\n        LOG.warn(\"FlateFilter: premature end of stream due to a DataFormatException = \" + exception.getMessage());\n        return bytesDecoded > 0;\n    }\n    return true;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.getPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.getPage", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the page on which the object shall be rendered.\n *\n * @return the referenced page or null.\n */\npublic PDPage getPage() {\n    COSDictionary pageDict = this.getCOSObject().getCOSDictionary(COSName.PG);\n    if (pageDict != null) {\n        return new PDPage(pageDict);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.compress.COSWriterCompressionPool.createObjectStreams",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.compress.COSWriterCompressionPool.createObjectStreams", "org.apache.pdfbox.pdfwriter.compress.COSWriterObjectStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates {@link COSWriterObjectStream}s for all currently registered objects of this pool, that have been marked\n * as fit for being compressed in this manner. Such object streams may be added to a PDF document and shall be\n * declared in a document's {@link PDFXRefStream} accordingly. The objects contained in such a stream must not be\n * added to the document separately.\n *\n * @return The created {@link COSWriterObjectStream}s for all currently registered compressible objects.\n */\npublic List<COSWriterObjectStream> createObjectStreams() {\n    List<COSWriterObjectStream> objectStreams = new ArrayList<>();\n    COSWriterObjectStream objectStream = null;\n    for (int i = 0; i < objectStreamObjects.size(); i++) {\n        COSObjectKey key = objectStreamObjects.get(i);\n        if ((objectStream == null) || ((i % parameters.getObjectStreamSize()) == 0)) {\n            objectStream = new COSWriterObjectStream(this);\n            objectStreams.add(objectStream);\n        }\n        objectStream.prepareStreamObject(key, objectPool.getObject(key));\n    }\n    return objectStreams;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getOpaqueImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getOpaqueImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns an RGB buffered image containing the opaque image stream without any masks applied. If this Image XObject\n * is a mask then the buffered image will contain the raw mask.\n *\n * @param region\n * \t\tThe region of the source image to get, or null if the entire image is needed. The actual region\n * \t\twill be clipped to the dimensions of the source image.\n * @param subsampling\n * \t\tThe amount of rows and columns to advance for every output pixel, a value of 1 meaning every\n * \t\tpixel will be read. It must not be larger than the image width or height.\n * @return the image without any masks applied\n * @throws IOException\n * \t\tif the image cannot be read\n */\npublic BufferedImage getOpaqueImage(Rectangle region, int subsampling) throws IOException {\n    return SampledImageReader.getRGBImage(this, region, subsampling, null);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.COSArrayList.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.COSArrayList.add", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic void add(int index, E element) {\n    if (isFiltered) {\n        throw new UnsupportedOperationException(\"Adding an element in a filtered List is not permitted\");\n    }\n    // when adding if there is a parentDict then change the item\n    // in the dictionary from a single item to an array.\n    if (parentDict != null) {\n        parentDict.setItem(dictKey, array);\n        // clear the parent dict so it doesn't happen again, there might be\n        // a usecase for keeping the parentDict around but not now.\n        parentDict = null;\n    }\n    actual.add(index, element);\n    if (element instanceof String) {\n        array.add(index, new COSString(((String) (element))));\n    } else {\n        array.add(index, ((COSObjectable) (element)).getCOSObject());\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.getFieldTree", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Refreshes the appearance streams and appearance dictionaries for the widget annotations of all fields.\n *\n * @throws IOException\n * \t\tif the appearance streams could not be refreshed\n */\npublic void refreshAppearances() throws IOException {\n    for (PDField field : getFieldTree()) {\n        if (field instanceof PDTerminalField) {\n            ((PDTerminalField) (field)).constructAppearances();\n        }\n    }\n}", "/**\n * Return the field tree representing all form fields\n *\n * @return the field tree representing all form fields\n */\npublic PDFieldTree getFieldTree() {\n    return new PDFieldTree(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDPushButton.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDPushButton.<init>", "org.apache.pdfbox.pdmodel.interactive.form.PDButton.<init>", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @see PDField#PDField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroform.\n */\npublic PDPushButton(PDAcroForm acroForm) {\n    super(acroForm);\n    getCOSObject().setFlag(COSName.FF, FLAG_PUSHBUTTON, true);\n}", "/**\n *\n * @see PDField#PDField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroform.\n */\nPDButton(PDAcroForm acroForm) {\n    super(acroForm);\n    getCOSObject().setItem(COSName.FT, COSName.BTN);\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.load", "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a simple font.\n *\n * <p>\n * <b>Note:</b> Simple fonts only support 256 characters. For Unicode support, use\n * {@link PDType0Font#load(PDDocument, File)} instead.\n * </p>\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param randomAccessRead\n * \t\tthe source of the TTF.\n * @param encoding\n * \t\tThe PostScript encoding vector to be used for embedding.\n * @return a PDTrueTypeFont instance.\n * @throws IOException\n * \t\tIf there is an error loading the data.\n */\npublic static PDTrueTypeFont load(PDDocument doc, RandomAccessRead randomAccessRead, Encoding encoding) throws IOException {\n    return new PDTrueTypeFont(doc, new TTFParser().parse(randomAccessRead), encoding, true);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.getTextColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.getTextColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the RGB text color of this node.  Default is black and this method\n * will never return null.\n *\n * @return The structure element of this node.\n */\npublic PDColor getTextColor() {\n    COSArray csValues = getCOSObject().getCOSArray(COSName.C);\n    if (csValues == null) {\n        csValues = new COSArray();\n        csValues.growToSize(3, new COSFloat(0));\n        getCOSObject().setItem(COSName.C, csValues);\n    }\n    return new PDColor(csValues, PDDeviceRGB.INSTANCE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationFileAttachment.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationFileAttachment.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFileAttachmentAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDFileAttachmentAppearanceHandler appearanceHandler = new PDFileAttachmentAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.isGroupEnabled",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.isGroupEnabled", "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.getD", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Indicates whether an optional content group is enabled.\n *\n * @param group\n * \t\tthe group object\n * @return true if the group is enabled\n */\npublic boolean isGroupEnabled(PDOptionalContentGroup group) {\n    // TODO handle Optional Content Configuration Dictionaries,\n    // i.e. OCProperties/Configs\n    PDOptionalContentProperties.BaseState baseState = getBaseState();\n    boolean enabled = baseState != BaseState.OFF;\n    // TODO What to do with BaseState.Unchanged?\n    if (group == null) {\n        return enabled;\n    }\n    COSDictionary d = getD();\n    COSArray on = d.getCOSArray(COSName.ON);\n    if (on != null) {\n        for (COSBase o : on) {\n            COSDictionary dictionary = toDictionary(o);\n            if (dictionary == group.getCOSObject()) {\n                return true;\n            }\n        }\n    }\n    COSArray off = d.getCOSArray(COSName.OFF);\n    if (off != null) {\n        for (COSBase o : off) {\n            COSDictionary dictionary = toDictionary(o);\n            if (dictionary == group.getCOSObject()) {\n                return false;\n            }\n        }\n    }\n    return enabled;\n}", "/**\n * Return the the /D dictionary.\n *\n * @return the /D dictionary, never null.\n */\nprivate COSDictionary getD() {\n    COSDictionary d = dict.getCOSDictionary(COSName.D);\n    if (d == null) {\n        d = new COSDictionary();\n        // Name optional but required for PDF/A-3\n        d.setString(COSName.NAME, \"Top\");\n        // D is required\n        dict.setItem(COSName.D, d);\n    }\n    return d;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.getFieldIterator",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.getFieldIterator", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns an iterator which walks all fields in the field tree, in order.\n *\n * @return an iterator which walks all fields in the field tree\n */\npublic Iterator<PDField> getFieldIterator() {\n    return new PDFieldTree(this).iterator();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.load", "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a simple font.\n *\n * <p><b>Note:</b> Simple fonts only support 256 characters. For Unicode support, use\n * {@link PDType0Font#load(PDDocument, File)} instead.</p>\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param file\n * \t\tA TTF file.\n * @param encoding\n * \t\tThe PostScript encoding vector to be used for embedding.\n * @return a PDTrueTypeFont instance.\n * @throws IOException\n * \t\tIf there is an error loading the data.\n */\npublic static PDTrueTypeFont load(PDDocument doc, File file, Encoding encoding) throws IOException {\n    return load(doc, new RandomAccessReadBufferedFile(file), encoding);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.<init>", "org.apache.pdfbox.pdmodel.graphics.PDXObject.<init>", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a Form XObject for reading.\n *\n * @param stream\n * \t\tThe XObject stream\n */\npublic PDFormXObject(PDStream stream) {\n    super(stream, COSName.FORM);\n    cache = null;\n}", "/**\n * Creates a new XObject from the given stream and subtype.\n *\n * @param stream\n * \t\tThe stream to read.\n * @param subtype\n * \t\tthe subtype to be used for this XObject\n */\nprotected PDXObject(COSStream stream, COSName subtype) {\n    this.stream = new PDStream(stream);\n    // could be used for writing:\n    stream.setName(COSName.TYPE, COSName.XOBJECT.getName());\n    stream.setName(COSName.SUBTYPE, subtype.getName());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerFormResource",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerFormResource", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createInnerFormResource() {\n    PDResources innerFormResources = new PDResources();\n    pdfStructure.setInnerFormResources(innerFormResources);\n    LOG.info(\"Resources of another form (inner form - it will be inside holder form)\" + \"have been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationSquiggly.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationSquiggly.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquigglyAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDSquigglyAppearanceHandler appearanceHandler = new PDSquigglyAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the content of the given image as an AWT buffered image with an RGB color space.\n * If a color key mask is provided then an ARGB image is returned instead.\n * This method never returns null.\n *\n * @param pdImage\n * \t\tthe image to read\n * @param region\n * \t\tThe region of the source image to get, or null if the entire image is needed.\n * \t\tThe actual region will be clipped to the dimensions of the source image.\n * @param subsampling\n * \t\tThe amount of rows and columns to advance for every output pixel, a value\n * \t\tof 1 meaning every pixel will be read. It must not be larger than the image width or height.\n * @param colorKey\n * \t\tan optional color key mask\n * @return content of this image as an (A)RGB buffered image\n * @throws IOException\n * \t\tif the image cannot be read\n */\npublic static BufferedImage getRGBImage(PDImage pdImage, Rectangle region, int subsampling, COSArray colorKey) throws IOException {\n    if (pdImage.isEmpty()) {\n        throw new IOException(\"Image stream is empty\");\n    }\n    Rectangle clipped = clipRegion(pdImage, region);\n    // get parameters, they must be valid or have been repaired\n    final PDColorSpace colorSpace = pdImage.getColorSpace();\n    final int numComponents = colorSpace.getNumberOfComponents();\n    final int width = ((int) (Math.ceil(clipped.getWidth() / subsampling)));\n    final int height = ((int) (Math.ceil(clipped.getHeight() / subsampling)));\n    final int bitsPerComponent = pdImage.getBitsPerComponent();\n    if ((((width <= 0) || (height <= 0)) || (pdImage.getWidth() <= 0)) || (pdImage.getHeight() <= 0)) {\n        throw new IOException(\"image width and height must be positive\");\n    }\n    try {\n        if (((bitsPerComponent == 1) && (colorKey == null)) && (numComponents == 1)) {\n            return from1Bit(pdImage, clipped, subsampling, width, height);\n        }\n        // An AWT raster must use 8/16/32 bits per component. Images with < 8bpc\n        // will be unpacked into a byte-backed raster. Images with 16bpc will be reduced\n        // in depth to 8bpc as they will be drawn to TYPE_INT_RGB images anyway. All code\n        // in PDColorSpace#toRGBImage expects an 8-bit range, i.e. 0-255.\n        // Interleaved raster allows chunk-copying for 8-bit images.\n        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, width, height, numComponents, new Point(0, 0));\n        final float[] defaultDecode = pdImage.getColorSpace().getDefaultDecode(8);\n        final float[] decode = getDecodeArray(pdImage);\n        if (((bitsPerComponent == 8) && (colorKey == null)) && Arrays.equals(decode, defaultDecode)) {\n            // convert image, faster path for non-decoded, non-colormasked 8-bit images\n            return from8bit(pdImage, raster, clipped, subsampling, width, height);\n        }\n        return fromAny(pdImage, raster, colorKey, clipped, subsampling, width, height);\n    } catch (NegativeArraySizeException | IllegalArgumentException ex) {\n        throw new IOException(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDPageAdditionalActions.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDPageAdditionalActions.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDPageAdditionalActions() {\n    actions = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getDocumentOutline",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getDocumentOutline", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the outline associated with this document or null if it does not exist.\n *\n * @return The document's outline.\n */\npublic PDDocumentOutline getDocumentOutline() {\n    COSDictionary outlineDict = root.getCOSDictionary(COSName.OUTLINES);\n    return outlineDict != null ? new PDDocumentOutline(outlineDict) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.createAnnotation",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.createAnnotation", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * Create the correct annotation from the base COS object.\n *\n * @param base\n * \t\tThe COS object that is the annotation.\n * @return The correctly typed annotation object, never null.\n * @throws IOException\n * \t\tIf the annotation type is unknown.\n */\npublic static PDAnnotation createAnnotation(COSBase base) throws IOException {\n    if (base instanceof COSDictionary) {\n        COSDictionary annotDic = ((COSDictionary) (base));\n        String subtype = annotDic.getNameAsString(COSName.SUBTYPE);\n        if (null == subtype) {\n            LOG.debug(\"Unknown annotation subtype\");\n            return new PDAnnotationUnknown(annotDic);\n        }\n        switch (subtype) {\n            case PDAnnotationFileAttachment.SUB_TYPE :\n                return new PDAnnotationFileAttachment(annotDic);\n            case PDAnnotationLine.SUB_TYPE :\n                return new PDAnnotationLine(annotDic);\n            case PDAnnotationLink.SUB_TYPE :\n                return new PDAnnotationLink(annotDic);\n            case PDAnnotationPopup.SUB_TYPE :\n                return new PDAnnotationPopup(annotDic);\n            case PDAnnotationRubberStamp.SUB_TYPE :\n                return new PDAnnotationRubberStamp(annotDic);\n            case PDAnnotationSquare.SUB_TYPE :\n                return new PDAnnotationSquare(annotDic);\n            case PDAnnotationCircle.SUB_TYPE :\n                return new PDAnnotationCircle(annotDic);\n            case PDAnnotationPolygon.SUB_TYPE :\n                return new PDAnnotationPolygon(annotDic);\n            case PDAnnotationPolyline.SUB_TYPE :\n                return new PDAnnotationPolyline(annotDic);\n            case PDAnnotationInk.SUB_TYPE :\n                return new PDAnnotationInk(annotDic);\n            case PDAnnotationText.SUB_TYPE :\n                return new PDAnnotationText(annotDic);\n            case PDAnnotationHighlight.SUB_TYPE :\n                return new PDAnnotationHighlight(annotDic);\n            case PDAnnotationUnderline.SUB_TYPE :\n                return new PDAnnotationUnderline(annotDic);\n            case PDAnnotationStrikeout.SUB_TYPE :\n                return new PDAnnotationStrikeout(annotDic);\n            case PDAnnotationSquiggly.SUB_TYPE :\n                return new PDAnnotationSquiggly(annotDic);\n            case PDAnnotationWidget.SUB_TYPE :\n                return new PDAnnotationWidget(annotDic);\n            case PDAnnotationFreeText.SUB_TYPE :\n                return new PDAnnotationFreeText(annotDic);\n            case PDAnnotationCaret.SUB_TYPE :\n                return new PDAnnotationCaret(annotDic);\n            case PDAnnotationSound.SUB_TYPE :\n                return new PDAnnotationSound(annotDic);\n            default :\n                // TODO not yet implemented:\n                // Movie, Screen, PrinterMark, TrapNet, Watermark, 3D, Redact\n                LOG.debug(\"Unknown or unsupported annotation subtype \" + subtype);\n                return new PDAnnotationUnknown(annotDic);\n        }\n    } else {\n        throw new IOException(\"Error: Unknown annotation type \" + base);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.PDFontSetting.getFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.PDFontSetting.getFont", "org.apache.pdfbox.pdmodel.font.PDFontFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get the font for this font setting.\n *\n * @return The font for this setting of null if one was not found.\n * @throws IOException\n * \t\tIf there is an error getting the font.\n */\npublic PDFont getFont() throws IOException {\n    PDFont retval = null;\n    COSBase font = fontSetting.getObject(0);\n    if (font instanceof COSDictionary) {\n        retval = PDFontFactory.createFont(((COSDictionary) (font)));\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFile",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification.getEmbeddedFile", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the embedded file.\n *\n * @return The embedded file for this file spec.\n */\npublic PDEmbeddedFile getEmbeddedFile() {\n    COSBase base = getObjectFromEFDictionary(COSName.F);\n    if (base instanceof COSStream) {\n        return new PDEmbeddedFile(((COSStream) (base)));\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDocument.createCOSStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDocument.createCOSStream", "org.apache.pdfbox.cos.COSStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new COSStream using the current configuration for scratch files.\n *\n * @return the new COSStream\n */\npublic COSStream createCOSStream() {\n    COSStream stream = new COSStream(streamCache);\n    // collect all COSStreams so that they can be closed when closing the COSDocument.\n    // This is limited to newly created pdfs as all COSStreams of an existing pdf are\n    // collected within the map objectPool\n    streams.add(stream);\n    return stream;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFileByContent",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFileByContent", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image file. The file format is determined by the file\n * content. The following file types are supported: JPG, JPEG, TIF, TIFF, GIF, BMP and PNG. This\n * is a convenience method that calls {@link JPEGFactory#createFromStream},\n * {@link CCITTFactory#createFromFile} or {@link ImageIO#read} combined with\n * {@link LosslessFactory#createFromImage}. (The later can also be used to create a\n * PDImageXObject from a BufferedImage). Starting with 2.0.18, this call will create an image\n * directly from a PNG file without decoding it (when possible), which is faster. However the\n * result size depends on the compression skill of the software that created the PNG file. If\n * file size or bandwidth are important to you or to your clients, then create your PNG files\n * with a tool that has implemented the\n * <a href=\"https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/\">Zopfli\n * algorithm</a>, or use the two-step process mentioned above.\n *\n * @param file\n * \t\tthe image file.\n * @param doc\n * \t\tthe document that shall use this PDImageXObject.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromFileByContent(File file, PDDocument doc) throws IOException {\n    FileType fileType = null;\n    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(file))) {\n        fileType = FileTypeDetector.detectFileType(bufferedInputStream);\n    } catch (IOException e) {\n        throw new IOException(\"Could not determine file type: \" + file.getName(), e);\n    }\n    if (fileType == null) {\n        throw new IllegalArgumentException(\"Image type not supported: \" + file.getName());\n    }\n    if (fileType == FileType.JPEG) {\n        try (FileInputStream fis = new FileInputStream(file)) {\n            return JPEGFactory.createFromStream(doc, fis);\n        }\n    }\n    if (fileType == FileType.TIFF) {\n        try {\n            return CCITTFactory.createFromFile(doc, file);\n        } catch (IOException ex) {\n            LOG.debug(\"Reading as TIFF failed, setting fileType to PNG\", ex);\n            // Plan B: try reading with ImageIO\n            // common exception:\n            // First image in tiff is not CCITT T4 or T6 compressed\n            fileType = FileType.PNG;\n        }\n    }\n    if (((fileType == FileType.BMP) || (fileType == FileType.GIF)) || (fileType == FileType.PNG)) {\n        BufferedImage bim = ImageIO.read(file);\n        return LosslessFactory.createFromImage(doc, bim);\n    }\n    throw new IllegalArgumentException(((\"Image type \" + fileType) + \" not supported: \") + file.getName());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.addSubject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.addSubject", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * (Optional) byte array containing DER-encoded X.509v3 certificate that is acceptable for\n * signing. works like {@link #setSubject(List)} but one byte array\n *\n * @param subject\n * \t\tbyte array containing DER-encoded X.509v3 certificate\n */\npublic void addSubject(byte[] subject) {\n    COSArray array = dictionary.getCOSArray(COSName.SUBJECT);\n    if (array == null) {\n        array = new COSArray();\n    }\n    array.add(new COSString(subject));\n    dictionary.setItem(COSName.SUBJECT, array);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getSoftMask",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getSoftMask", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the Soft Mask Image XObject associated with this image, or null if there is none.\n *\n * @return the SMask Image XObject, or null.\n * @throws java.io.IOException\n * \t\tif the soft mask data could not be read\n */\npublic PDImageXObject getSoftMask() throws IOException {\n    COSStream cosStream = getCOSObject().getCOSStream(COSName.SMASK);\n    if (cosStream != null) {\n        // always DeviceGray\n        return new PDImageXObject(new PDStream(cosStream), null);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDIndexed.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDIndexed.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new Indexed color space.\n * Default DeviceRGB, hival 255.\n */\npublic PDIndexed() {\n    array = new COSArray();\n    array.add(COSName.INDEXED);\n    array.add(COSName.DEVICERGB);\n    array.add(COSInteger.get(255));\n    array.add(COSNull.NULL);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createProcSetArray",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createProcSetArray", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createProcSetArray() {\n    COSArray procSetArr = new COSArray();\n    procSetArr.add(COSName.getPDFName(\"PDF\"));\n    procSetArr.add(COSName.getPDFName(\"Text\"));\n    procSetArr.add(COSName.getPDFName(\"ImageB\"));\n    procSetArr.add(COSName.getPDFName(\"ImageC\"));\n    procSetArr.add(COSName.getPDFName(\"ImageI\"));\n    pdfStructure.setProcSet(procSetArr);\n    LOG.info(\"ProcSet array has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setFont",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setFont", "org.apache.pdfbox.pdmodel.PDAbstractContentStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the font and font size to draw text with.\n *\n * @param font\n * \t\tThe font to use.\n * @param fontSize\n * \t\tThe font size to draw the text.\n * @throws IOException\n * \t\tIf there is an error writing the font information.\n */\npublic void setFont(PDFont font, float fontSize) throws IOException {\n    if (fontStack.isEmpty()) {\n        fontStack.add(font);\n    } else {\n        fontStack.pop();\n        fontStack.push(font);\n    }\n    // keep track of fonts which are configured for subsetting\n    if (font.willBeSubset()) {\n        if (document != null) {\n            document.getFontsToSubset().add(font);\n        } else {\n            LOG.warn((\"Using the subsetted font '\" + font.getName()) + \"' without a PDDocument context; call subset() before saving\");\n        }\n    } else if ((!font.isEmbedded()) && (!font.isStandard14())) {\n        LOG.warn((\"attempting to use font '\" + font.getName()) + \"' that isn't embedded\");\n    }\n    // complex text layout\n    if (font instanceof PDType0Font) {\n        PDType0Font type0Font = ((PDType0Font) (font));\n        GsubData gsubData = type0Font.getGsubData();\n        if (gsubData != GsubData.NO_DATA_FOUND) {\n            GsubWorker gsubWorker = gsubWorkerFactory.getGsubWorker(type0Font.getCmapLookup(), gsubData);\n            gsubWorkers.put(((PDType0Font) (font)), gsubWorker);\n        } else if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No GSUB data found in font\" + font.getName());\n        }\n    }\n    writeOperand(resources.add(font));\n    writeOperand(fontSize);\n    writeOperator(OperatorName.SET_FONT_AND_SIZE);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a PDColor containing the given color value.\n *\n * @param array\n * \t\ta COS array containing the color value\n * @param colorSpace\n * \t\tcolor space in which the color value is defined\n */\npublic PDColor(COSArray array, PDColorSpace colorSpace) {\n    if ((array.size() > 0) && (array.get(array.size() - 1) instanceof COSName)) {\n        // color components (optional), for the color of an uncoloured tiling pattern\n        components = new float[array.size() - 1];\n        initComponents(array);\n        // pattern name (required)\n        COSBase base = array.get(array.size() - 1);\n        if (base instanceof COSName) {\n            patternName = ((COSName) (base));\n        } else {\n            LOG.warn((\"pattern name in \" + array) + \" isn't a name, ignored\");\n            patternName = COSName.getPDFName(\"Unknown\");\n        }\n    } else {\n        // color components only\n        components = new float[array.size()];\n        initComponents(array);\n        patternName = null;\n    }\n    this.colorSpace = colorSpace;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1FontEmbedder.getGlyphList",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1FontEmbedder.getGlyphList", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the font's glyph list.\n */\npublic GlyphList getGlyphList() {\n    return GlyphList.getAdobeGlyphList();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPolyline.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPolyline.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolylineAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDPolylineAppearanceHandler appearanceHandler = new PDPolylineAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCircleAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCircleAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCircleAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    float lineWidth = getLineWidth();\n    PDAnnotationCircle annotation = ((PDAnnotationCircle) (getAnnotation()));\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());\n        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());\n            cloudyBorder.createCloudyEllipse(annotation.getRectDifference());\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            annotation.setRectDifference(cloudyBorder.getRectDifference());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            // Acrobat applies a padding to each side of the bbox so the line is completely within\n            // the bbox.\n            PDRectangle borderBox = handleBorderBox(annotation, lineWidth);\n            // lower left corner\n            float x0 = borderBox.getLowerLeftX();\n            float y0 = borderBox.getLowerLeftY();\n            // upper right corner\n            float x1 = borderBox.getUpperRightX();\n            float y1 = borderBox.getUpperRightY();\n            // mid points\n            float xm = x0 + (borderBox.getWidth() / 2);\n            float ym = y0 + (borderBox.getHeight() / 2);\n            // see http://spencermortensen.com/articles/bezier-circle/\n            // the below number was calculated from sampling content streams\n            // generated using Adobe Reader\n            float magic = 0.55555415F;\n            // control point offsets\n            float vOffset = (borderBox.getHeight() / 2) * magic;\n            float hOffset = (borderBox.getWidth() / 2) * magic;\n            contentStream.moveTo(xm, y1);\n            contentStream.curveTo(xm + hOffset, y1, x1, ym + vOffset, x1, ym);\n            contentStream.curveTo(x1, ym - vOffset, xm + hOffset, y0, xm, y0);\n            contentStream.curveTo(xm - hOffset, y0, x0, ym - vOffset, x0, ym);\n            contentStream.curveTo(x0, ym + vOffset, xm - hOffset, y1, xm, y1);\n            contentStream.closePath();\n        }\n        contentStream.drawShape(lineWidth, hasStroke, hasBackground);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.LZWFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.LZWFilter.decode", "org.apache.pdfbox.filter.LZWFilter.<clinit>" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    COSDictionary decodeParams = getDecodeParams(parameters, index);\n    boolean earlyChange = decodeParams.getInt(COSName.EARLY_CHANGE, 1) != 0;\n    doLZWDecode(encoded, Predictor.wrapPredictor(decoded, decodeParams), earlyChange);\n    return new DecodeResult(parameters);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getPage", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the corresponding page of this annotation. See also\n * <a href=\"https://stackoverflow.com/a/36894982/535646\">this answer</a> about what to do if\n * the page isn't available.\n *\n * @return The corresponding page or null if not available.\n */\npublic PDPage getPage() {\n    COSDictionary page = getCOSObject().getCOSDictionary(COSName.P);\n    return page != null ? new PDPage(page) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param valueClass\n * \t\tThe PD Model type of object that is the value.\n */\npublic PDNumberTreeNode(Class<? extends COSObjectable> valueClass) {\n    node = new COSDictionary();\n    valueType = valueClass;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.processPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.processPage", "org.apache.pdfbox.contentstream.PDFStreamEngine.initPage", "org.apache.pdfbox.pdmodel.PDPage.getCropBox", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * This will initialize and process the contents of the stream.\n *\n * @param page\n * \t\tthe page to process\n * @throws IOException\n * \t\tif there is an error accessing the stream\n */\npublic void processPage(PDPage page) throws IOException {\n    initPage(page);\n    if (page.hasContents()) {\n        isProcessingPage = true;\n        processStream(page);\n        isProcessingPage = false;\n    }\n}", "/**\n * Initializes the stream engine for the given page.\n */\nprivate void initPage(PDPage page) {\n    if (page == null) {\n        throw new IllegalArgumentException(\"Page cannot be null\");\n    }\n    currentPage = page;\n    graphicsStack.clear();\n    graphicsStack.push(new PDGraphicsState(page.getCropBox()));\n    resources = null;\n    initialMatrix = page.getMatrix();\n}", "/**\n * A rectangle, expressed in default user space units, defining the visible region of default user space. When the\n * page is displayed or printed, its contents are to be clipped (cropped) to this rectangle.\n *\n * @return the cropbox of the page\n */\npublic PDRectangle getCropBox() {\n    COSBase base = PDPageTree.getInheritableAttribute(page, COSName.CROP_BOX);\n    if (base instanceof COSArray) {\n        return clipToMediaBox(new PDRectangle(((COSArray) (base))));\n    } else {\n        return getMediaBox();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationFreeText annotation = ((PDAnnotationFreeText) (getAnnotation()));\n    float[] pathsArray;\n    if (PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent())) {\n        pathsArray = annotation.getCallout();\n        if ((pathsArray == null) || ((pathsArray.length != 4) && (pathsArray.length != 6))) {\n            pathsArray = new float[0];\n        }\n    } else {\n        pathsArray = new float[0];\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream(true)) {\n        // The fill color is the /C entry, there is no /IC entry defined\n        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getColor());\n        setOpacity(cs, annotation.getConstantOpacity());\n        // Adobe uses the last non stroking color from /DA as stroking color!\n        // But if there is a color in /DS, then that one is used for text.\n        PDColor strokingColor = extractNonStrokingColor(annotation);\n        boolean hasStroke = cs.setStrokingColorOnDemand(strokingColor);\n        PDColor textColor = strokingColor;\n        String defaultStyleString = annotation.getDefaultStyleString();\n        if (defaultStyleString != null) {\n            Matcher m = COLOR_PATTERN.matcher(defaultStyleString);\n            if (m.find()) {\n                int color = Integer.parseInt(m.group(1), 16);\n                float r = ((color >> 16) & 0xff) / 255.0F;\n                float g = ((color >> 8) & 0xff) / 255.0F;\n                float b = (color & 0xff) / 255.0F;\n                textColor = new PDColor(new float[]{ r, g, b }, PDDeviceRGB.INSTANCE);\n            }\n        }\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        String lineEndingStyle = annotation.getLineEndingStyle();\n        // draw callout line(s)\n        // must be done before retangle paint to avoid a line cutting through cloud\n        // see CTAN-example-Annotations.pdf\n        for (int i = 0; i < (pathsArray.length / 2); ++i) {\n            float x = pathsArray[i * 2];\n            float y = pathsArray[(i * 2) + 1];\n            if (i == 0) {\n                if (SHORT_STYLES.contains(lineEndingStyle)) {\n                    // modify coordinate to shorten the segment\n                    // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n                    float x1 = pathsArray[2];\n                    float y1 = pathsArray[3];\n                    float len = ((float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2))));\n                    if (Float.compare(len, 0) != 0) {\n                        x += ((x1 - x) / len) * ab.width;\n                        y += ((y1 - y) / len) * ab.width;\n                    }\n                }\n                cs.moveTo(x, y);\n            } else {\n                cs.lineTo(x, y);\n            }\n        }\n        if (pathsArray.length > 0) {\n            cs.stroke();\n        }\n        // paint the styles here and after line(s) draw, to avoid line crossing a filled shape\n        if ((PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent()) && // check only needed to avoid q cm Q if LE_NONE\n        (!LE_NONE.equals(lineEndingStyle))) && (pathsArray.length >= 4)) {\n            float x2 = pathsArray[2];\n            float y2 = pathsArray[3];\n            float x1 = pathsArray[0];\n            float y1 = pathsArray[1];\n            cs.saveGraphicsState();\n            if (ANGLED_STYLES.contains(lineEndingStyle)) {\n                // do a transform so that first \"arm\" is imagined flat,\n                // like in line handler.\n                // The alternative would be to apply the transform to the\n                // LE shape coordinates directly, which would be more work\n                // and produce code difficult to understand\n                double angle = Math.atan2(y2 - y1, x2 - x1);\n                cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n            } else {\n                cs.transform(Matrix.getTranslateInstance(x1, y1));\n            }\n            drawStyle(lineEndingStyle, cs, 0, 0, ab.width, hasStroke, hasBackground, false);\n            cs.restoreGraphicsState();\n        }\n        PDRectangle borderBox;\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            // Adobe draws the text with the original rectangle in mind.\n            // but if there is an /RD, then writing area get smaller.\n            // do this here because /RD is overwritten in a few lines\n            borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());\n            // TODO this segment was copied from square handler. Refactor?\n            CloudyBorder cloudyBorder = new CloudyBorder(cs, borderEffect.getIntensity(), ab.width, getRectangle());\n            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            annotation.setRectDifference(cloudyBorder.getRectDifference());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            // handle the border box\n            // \n            // There are two options. The handling is not part of the PDF specification but\n            // implementation specific to Adobe Reader\n            // - if /RD is set the border box is the /Rect entry inset by the respective\n            // border difference.\n            // - if /RD is not set then we don't touch /RD etc because Adobe doesn't either.\n            borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());\n            annotation.getNormalAppearanceStream().setBBox(borderBox);\n            // note that borderBox is not modified\n            PDRectangle paddedRectangle = getPaddedRectangle(borderBox, ab.width / 2);\n            cs.addRect(paddedRectangle.getLowerLeftX(), paddedRectangle.getLowerLeftY(), paddedRectangle.getWidth(), paddedRectangle.getHeight());\n        }\n        cs.drawShape(ab.width, hasStroke, hasBackground);\n        // rotation is an undocumented feature, but Adobe uses it. Examples can be found\n        // in pdf_commenting_new.pdf file, page 3.\n        int rotation = annotation.getCOSObject().getInt(COSName.ROTATE, 0);\n        cs.transform(Matrix.getRotateInstance(Math.toRadians(rotation), 0, 0));\n        float xOffset;\n        float yOffset;\n        float width = ((rotation == 90) || (rotation == 270)) ? borderBox.getHeight() : borderBox.getWidth();\n        // strategy to write formatted text is somewhat inspired by\n        // AppearanceGeneratorHelper.insertGeneratedAppearance()\n        PDFont font = null;\n        float clipY;\n        float clipWidth = width - (ab.width * 4);\n        float clipHeight = ((rotation == 90) || (rotation == 270)) ? borderBox.getWidth() - (ab.width * 4) : borderBox.getHeight() - (ab.width * 4);\n        extractFontDetails(annotation);\n        if (document != null) {\n            PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();\n            if (acroForm != null) {\n                // Try to get font from AcroForm default resources\n                // Sample file: https://gitlab.freedesktop.org/poppler/poppler/issues/6\n                PDResources defaultResources = acroForm.getDefaultResources();\n                if (defaultResources != null) {\n                    PDFont defaultResourcesFont = defaultResources.getFont(fontName);\n                    if (defaultResourcesFont != null) {\n                        font = defaultResourcesFont;\n                    }\n                }\n            }\n        }\n        if (font == null) {\n            font = getDefaultFont();\n        }\n        // value used by Adobe, no idea where it comes from, actual font bbox max y is 0.931\n        // gathered by creating an annotation with width 0.\n        float yDelta = 0.7896F;\n        switch (rotation) {\n            case 180 :\n                xOffset = (-borderBox.getUpperRightX()) + (ab.width * 2);\n                yOffset = ((-borderBox.getLowerLeftY()) - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = (-borderBox.getUpperRightY()) + (ab.width * 2);\n                break;\n            case 90 :\n                xOffset = borderBox.getLowerLeftY() + (ab.width * 2);\n                yOffset = ((-borderBox.getLowerLeftX()) - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = (-borderBox.getUpperRightX()) + (ab.width * 2);\n                break;\n            case 270 :\n                xOffset = (-borderBox.getUpperRightY()) + (ab.width * 2);\n                yOffset = (borderBox.getUpperRightX() - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = borderBox.getLowerLeftX() + (ab.width * 2);\n                break;\n            case 0 :\n            default :\n                xOffset = borderBox.getLowerLeftX() + (ab.width * 2);\n                yOffset = (borderBox.getUpperRightY() - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = borderBox.getLowerLeftY() + (ab.width * 2);\n                break;\n        }\n        // clip writing area\n        cs.addRect(xOffset, clipY, clipWidth, clipHeight);\n        cs.clip();\n        String annotationContents = annotation.getContents();\n        if (annotationContents != null) {\n            cs.beginText();\n            cs.setFont(font, fontSize);\n            cs.setNonStrokingColor(textColor.getComponents());\n            AppearanceStyle appearanceStyle = new AppearanceStyle();\n            appearanceStyle.setFont(font);\n            appearanceStyle.setFontSize(fontSize);\n            PlainTextFormatter formatter = // Adobe ignores the /Q\n            // .textAlign(annotation.getQ())\n            new PlainTextFormatter.Builder(cs).style(appearanceStyle).text(new PlainText(annotationContents)).width(width - (ab.width * 4)).wrapLines(true).initialOffset(xOffset, yOffset).build();\n            try {\n                formatter.format();\n            } catch (IllegalArgumentException ex) {\n                throw new IOException(ex);\n            } finally {\n                cs.endText();\n            }\n        }\n        if (pathsArray.length > 0) {\n            PDRectangle rect = getRectangle();\n            // Adjust rectangle\n            // important to do this after the rectangle has been painted, because the\n            // final rectangle will be bigger due to callout\n            // CTAN-example-Annotations.pdf p1\n            // TODO in a class structure this should be overridable\n            float minX = Float.MAX_VALUE;\n            float minY = Float.MAX_VALUE;\n            float maxX = Float.MIN_VALUE;\n            float maxY = Float.MIN_VALUE;\n            for (int i = 0; i < (pathsArray.length / 2); ++i) {\n                float x = pathsArray[i * 2];\n                float y = pathsArray[(i * 2) + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n            // arrow length is 9 * width at about 30Â° => 10 * width seems to be enough\n            rect.setLowerLeftX(Math.min(minX - (ab.width * 10), rect.getLowerLeftX()));\n            rect.setLowerLeftY(Math.min(minY - (ab.width * 10), rect.getLowerLeftY()));\n            rect.setUpperRightX(Math.max(maxX + (ab.width * 10), rect.getUpperRightX()));\n            rect.setUpperRightY(Math.max(maxY + (ab.width * 10), rect.getUpperRightY()));\n            annotation.setRectangle(rect);\n            // need to set the BBox too, because rectangle modification came later\n            annotation.getNormalAppearanceStream().setBBox(getRectangle());\n            // TODO when callout is used, /RD should be so that the result is the writable part\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.Filter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.Filter.decode", "org.apache.pdfbox.filter.Filter.<clinit>" ],
    "fullMethods" : [ "/**\n * Decodes data, with optional DecodeOptions. Not all filters support all options, and so callers should check the\n * options' <code>honored</code> flag to test if they were applied.\n *\n * @param encoded\n * \t\tthe input stream holding the encoded data\n * @param filterList\n * \t\tlist of filters to be used for decoding\n * @param parameters\n * \t\tthe parameters used for decoding\n * @param options\n * \t\tadditional options for decoding\n * @param results\n * \t\tlist of optional decoding results for each filter\n * @return the decoded stream data\n * @throws IOException\n * \t\tif the stream cannot be decoded\n * @throws IllegalArgumentException\n * \t\tif filterList is empty\n */\npublic static RandomAccessRead decode(InputStream encoded, List<Filter> filterList, COSDictionary parameters, DecodeOptions options, List<DecodeResult> results) throws IOException {\n    long length = parameters.getLong(COSName.LENGTH, RandomAccessReadBuffer.DEFAULT_CHUNK_SIZE_4KB);\n    if (filterList.isEmpty()) {\n        throw new IllegalArgumentException(\"Empty filterList\");\n    }\n    if (filterList.size() > 1) {\n        Set<Filter> filterSet = new HashSet<>(filterList);\n        if (filterSet.size() != filterList.size()) {\n            List<Filter> reducedFilterList = new ArrayList<>();\n            for (Filter filter : filterList) {\n                if (!reducedFilterList.contains(filter)) {\n                    reducedFilterList.add(filter);\n                }\n            }\n            // replace origin list with the reduced one\n            filterList = reducedFilterList;\n            LOG.warn(\"Removed duplicated filter entries\");\n        }\n    }\n    InputStream input = encoded;\n    RandomAccessReadWriteBuffer randomAccessWriteBuffer = null;\n    OutputStream output = null;\n    // apply filters\n    for (int i = 0; i < filterList.size(); i++) {\n        if (i > 0) {\n            randomAccessWriteBuffer.seek(0);\n            input = new RandomAccessInputStream(randomAccessWriteBuffer);\n            length = randomAccessWriteBuffer.length();\n        }\n        // we don't know the size of the decoded stream, just estimate a 4 times bigger size than the encoded stream\n        // use the estimated stream size as chunk size, use the default chunk size as limit to avoid to big values\n        if ((length <= 0) || (length >= (RandomAccessReadBuffer.DEFAULT_CHUNK_SIZE_4KB / 4))) {\n            length = RandomAccessReadBuffer.DEFAULT_CHUNK_SIZE_4KB;\n        } else {\n            length = length * 4;\n        }\n        randomAccessWriteBuffer = new RandomAccessReadWriteBuffer(((int) (length)));\n        output = new RandomAccessOutputStream(randomAccessWriteBuffer);\n        try {\n            DecodeResult result = filterList.get(i).decode(input, output, parameters, i, options);\n            if (results != null) {\n                results.add(result);\n            }\n        } finally {\n            IOUtils.closeQuietly(input);\n        }\n    }\n    randomAccessWriteBuffer.seek(0);\n    return randomAccessWriteBuffer;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.getInheritableAttribute",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.getInheritableAttribute", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the given attribute, inheriting from parent tree nodes if necessary.\n *\n * @param node\n * \t\tpage object\n * @param key\n * \t\tthe key to look up\n * @return COS value for the given key\n */\npublic static COSBase getInheritableAttribute(COSDictionary node, COSName key) {\n    return getInheritableAttribute(node, key, new HashSet<>());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFDocument.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFDocument.<init>", "org.apache.pdfbox.cos.COSDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor, creates a new FDF document.\n */\npublic FDFDocument() {\n    fdfSource = null;\n    document = new COSDocument();\n    document.getDocumentState().setParsing(false);\n    document.setVersion(1.2F);\n    // First we need a trailer\n    document.setTrailer(new COSDictionary());\n    // Next we need the root dictionary.\n    FDFCatalog catalog = new FDFCatalog();\n    setCatalog(catalog);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDFieldFactory.createField",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDFieldFactory.createField", "org.apache.pdfbox.pdmodel.interactive.form.PDNonTerminalField.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a COSField subclass from the given field.\n *\n * @param form\n * \t\tthe form that the field is part of\n * @param field\n * \t\tthe dictionary representing a field element\n * @param parent\n * \t\tthe parent node of the node to be created\n * @return the corresponding PDField instance\n */\npublic static PDField createField(PDAcroForm form, COSDictionary field, PDNonTerminalField parent) {\n    // Test if we have a non terminal field first as it might have\n    // properties which do apply to other fields\n    // A non terminal fields has Kids entries which do have\n    // a field name (other than annotations)\n    if (field.containsKey(COSName.KIDS)) {\n        COSArray kids = field.getCOSArray(COSName.KIDS);\n        if ((kids != null) && (kids.size() > 0)) {\n            for (int i = 0; i < kids.size(); i++) {\n                COSBase kid = kids.getObject(i);\n                if ((kid instanceof COSDictionary) && (((COSDictionary) (kid)).getString(COSName.T) != null)) {\n                    return new PDNonTerminalField(form, field, parent);\n                }\n            }\n        }\n    }\n    String fieldType = findFieldType(field, new HashSet<>());\n    if (FIELD_TYPE_CHOICE.equals(fieldType)) {\n        return createChoiceSubType(form, field, parent);\n    } else if (FIELD_TYPE_TEXT.equals(fieldType)) {\n        return new PDTextField(form, field, parent);\n    } else if (FIELD_TYPE_SIGNATURE.equals(fieldType)) {\n        return new PDSignatureField(form, field, parent);\n    } else if (FIELD_TYPE_BUTTON.equals(fieldType)) {\n        return createButtonSubType(form, field, parent);\n    } else {\n        // an erroneous non-field object, see PDFBOX-2885\n        return null;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationStrikeout.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationStrikeout.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDStrikeoutAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDStrikeoutAppearanceHandler appearanceHandler = new PDStrikeoutAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getMediaBox",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getMediaBox", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * A rectangle, expressed in default user space units, defining the boundaries of the physical medium on which the\n * page is intended to be displayed or printed.\n *\n * @return the media box of the page\n */\npublic PDRectangle getMediaBox() {\n    if (mediaBox == null) {\n        COSBase base = PDPageTree.getInheritableAttribute(page, COSName.MEDIA_BOX);\n        if (base instanceof COSArray) {\n            mediaBox = new PDRectangle(((COSArray) (base)));\n        } else {\n            LOG.debug(\"Can't find MediaBox, will use U.S. Letter\");\n            mediaBox = PDRectangle.LETTER;\n        }\n    }\n    return mediaBox;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.getNextSibling",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.getNextSibling", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getOutlineItem", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @return The next sibling or null if there is no next sibling.\n */\npublic PDOutlineItem getNextSibling() {\n    return getOutlineItem(COSName.NEXT);\n}", "PDOutlineItem getOutlineItem(COSName name) {\n    COSDictionary outline = getCOSObject().getCOSDictionary(name);\n    return outline != null ? new PDOutlineItem(outline) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createTemplate",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createTemplate", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a PDDocument and adds the page parameter to it and keeps this as a template in the PDF template\n * Structure.\n *\n * @param page\n * \t\tthe page to be added\n * @throws IOException\n * \t\tif the document could not be created\n */\n@Override\npublic void createTemplate(PDPage page) throws IOException {\n    PDDocument template = new PDDocument();\n    template.addPage(page);\n    pdfStructure.setTemplate(template);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setOptions",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setOptions", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the display and export values - the 'Opt' key.\n *\n * <p>\n * This will set both, the export value and the display value\n * of the choice field. If either one of the parameters is null or an\n * empty list is supplied the options will\n * be removed.\n * </p>\n * <p>\n * An {@link IllegalArgumentException} will be thrown if the\n * number of items in the list differ.\n * </p>\n *\n * @see #setOptions(List)\n * @param exportValues\n * \t\tList containing all possible export values.\n * @param displayValues\n * \t\tList containing all possible display values.\n */\npublic void setOptions(List<String> exportValues, List<String> displayValues) {\n    if ((((exportValues != null) && (displayValues != null)) && (!exportValues.isEmpty())) && (!displayValues.isEmpty())) {\n        if (exportValues.size() != displayValues.size()) {\n            throw new IllegalArgumentException(\"The number of entries for exportValue and displayValue shall be the same.\");\n        } else {\n            List<KeyValue> keyValuePairs = FieldUtils.toKeyValueList(exportValues, displayValues);\n            if (isSort()) {\n                FieldUtils.sortByValue(keyValuePairs);\n            }\n            COSArray options = new COSArray();\n            for (int i = 0; i < exportValues.size(); i++) {\n                COSArray entry = new COSArray();\n                KeyValue pair = keyValuePairs.get(i);\n                entry.add(new COSString(pair.getKey()));\n                entry.add(new COSString(pair.getValue()));\n                options.add(entry);\n            }\n            getCOSObject().setItem(COSName.OPT, options);\n        }\n    } else {\n        getCOSObject().removeItem(COSName.OPT);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.setGroupEnabled",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.setGroupEnabled", "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.getD", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Enables or disables an optional content group.\n *\n * @param group\n * \t\tthe group object\n * @param enable\n * \t\ttrue to enable, false to disable\n * @return true if the group already had an on or off setting, false otherwise\n */\npublic boolean setGroupEnabled(PDOptionalContentGroup group, boolean enable) {\n    COSDictionary d = getD();\n    COSArray on = d.getCOSArray(COSName.ON);\n    if (on == null) {\n        on = new COSArray();\n        d.setItem(COSName.ON, on);\n    }\n    COSArray off = d.getCOSArray(COSName.OFF);\n    if (off == null) {\n        off = new COSArray();\n        d.setItem(COSName.OFF, off);\n    }\n    boolean found = false;\n    if (enable) {\n        for (COSBase o : off) {\n            COSDictionary groupDictionary = toDictionary(o);\n            if (groupDictionary == group.getCOSObject()) {\n                // enable group\n                off.remove(o);\n                on.add(o);\n                found = true;\n                break;\n            }\n        }\n    } else {\n        for (COSBase o : on) {\n            COSDictionary groupDictionary = toDictionary(o);\n            if (groupDictionary == group.getCOSObject()) {\n                // disable group\n                on.remove(o);\n                off.add(o);\n                found = true;\n                break;\n            }\n        }\n    }\n    if (!found) {\n        if (enable) {\n            on.add(group.getCOSObject());\n        } else {\n            off.add(group.getCOSObject());\n        }\n    }\n    return found;\n}", "/**\n * Return the the /D dictionary.\n *\n * @return the /D dictionary, never null.\n */\nprivate COSDictionary getD() {\n    COSDictionary d = dict.getCOSDictionary(COSName.D);\n    if (d == null) {\n        d = new COSDictionary();\n        // Name optional but required for PDF/A-3\n        d.setString(COSName.NAME, \"Top\");\n        // D is required\n        dict.setItem(COSName.D, d);\n    }\n    return d;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.pattern.PDAbstractPattern.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.pattern.PDAbstractPattern.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new Pattern dictionary.\n */\npublic PDAbstractPattern() {\n    patternDictionary = new COSDictionary();\n    patternDictionary.setName(COSName.TYPE, COSName.PATTERN.getName());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSArray.setString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSArray.setString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the value in the array as a string.\n *\n * @param index\n * \t\tThe index into the array.\n * @param string\n * \t\tThe string to set in the array.\n */\npublic void setString(int index, String string) {\n    if (string != null) {\n        set(index, new COSString(string));\n    } else {\n        set(index, null);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.pattern.PDTilingPattern.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.pattern.PDTilingPattern.<init>", "org.apache.pdfbox.cos.COSStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new tiling pattern.\n */\npublic PDTilingPattern() {\n    super(new COSStream());\n    getCOSObject().setName(COSName.TYPE, COSName.PATTERN.getName());\n    getCOSObject().setInt(COSName.PATTERN_TYPE, PDAbstractPattern.TYPE_TILING_PATTERN);\n    // Resources required per PDF specification; when missing, pattern is not displayed in Adobe Reader\n    setResources(new PDResources());\n    resourceCache = null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFField.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFField.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFField() {\n    field = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.close",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.close", "org.apache.pdfbox.pdmodel.PDAbstractContentStream.<clinit>" ],
    "fullMethods" : [ "/**\n * Close the content stream.  This must be called when you are done with this object.\n *\n * @throws IOException\n * \t\tIf the underlying stream has a problem being written to.\n */\n@Override\npublic void close() throws IOException {\n    if (inTextMode) {\n        LOG.warn(\"You did not call endText(), some viewers won't display your text\");\n    }\n    outputStream.close();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Parse all compressed objects. The stream is closed after parsing.\n *\n * @return a map containing all parsed objects using the object number as key\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic Map<COSObjectKey, COSBase> parseAllObjects() throws IOException {\n    Map<COSObjectKey, COSBase> allObjects = new HashMap<>();\n    try {\n        Map<Integer, Long> objectNumbers = privateReadObjectOffsets();\n        // count the number of object numbers eliminating double entries\n        long numberOfObjNumbers = objectNumbers.values().stream().distinct().count();\n        // the usage of the index should be restricted to cases where more than one\n        // object use the same object number.\n        // there are malformed pdfs in the wild which would lead to false results if\n        // pdfbox always relies on the index if available. In most cases the object number\n        // is sufficient to choose the correct object\n        boolean indexNeeded = objectNumbers.size() > numberOfObjNumbers;\n        long currentPosition = source.getPosition();\n        if ((firstObject > 0) && (currentPosition < firstObject)) {\n            source.skip(firstObject - ((int) (currentPosition)));\n        }\n        int index = 0;\n        for (Entry<Integer, Long> entry : objectNumbers.entrySet()) {\n            COSObjectKey objectKey = getObjectKey(entry.getValue(), 0);\n            // skip object if the index doesn't match\n            if ((indexNeeded && (objectKey.getStreamIndex() > (-1))) && (objectKey.getStreamIndex() != index)) {\n                index++;\n                continue;\n            }\n            int finalPosition = firstObject + entry.getKey();\n            currentPosition = source.getPosition();\n            if ((finalPosition > 0) && (currentPosition < finalPosition)) {\n                // jump to the offset of the object to be parsed\n                source.skip(finalPosition - ((int) (currentPosition)));\n            }\n            COSBase streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n            allObjects.put(objectKey, streamObject);\n            index++;\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return allObjects;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDMarkedContentReference.getPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDMarkedContentReference.getPage", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "/**\n * Gets the page.\n *\n * @return the page\n */\npublic PDPage getPage() {\n    COSDictionary pg = getCOSObject().getCOSDictionary(COSName.PG);\n    return pg != null ? new PDPage(pg) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.filespecification.PDSimpleFileSpecification.setFile",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.filespecification.PDSimpleFileSpecification.setFile", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the file name.\n *\n * @param fileName\n * \t\tThe name of the file.\n */\n@Override\npublic void setFile(String fileName) {\n    file = new COSString(fileName);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.next",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.next", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PDPage next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    COSDictionary next = queue.poll();\n    sanitizeType(next);\n    ResourceCache resourceCache = (document != null) ? document.getResourceCache() : null;\n    return new PDPage(next, resourceCache);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.remove",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.remove", "org.apache.pdfbox.pdmodel.PDPageTree.get", "org.apache.pdfbox.pdmodel.PDPageTree.getKids", "org.apache.pdfbox.pdmodel.PDPageTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Removes the page with the given index from the page tree.\n *\n * @param index\n * \t\tzero-based page index\n */\npublic void remove(int index) {\n    COSDictionary node = get(index + 1, root, 0);\n    remove(node);\n}", "/**\n * Returns the given COS page using a depth-first search.\n *\n * @param pageNum\n * \t\t1-based page number\n * @param node\n * \t\tpage tree node to search\n * @param encountered\n * \t\tnumber of pages encountered so far\n * @return COS dictionary of the Page object\n * @throws IllegalStateException\n * \t\tif the requested page number isn't found\n * @throws IndexOutOfBoundsException\n * \t\tif the requested page number is higher than the page count\n */\nprivate COSDictionary get(int pageNum, COSDictionary node, int encountered) {\n    if (pageNum < 1) {\n        throw new IndexOutOfBoundsException(\"Index out of bounds: \" + pageNum);\n    }\n    if (pageSet.contains(node)) {\n        pageSet.clear();\n        throw new IllegalStateException(\"Possible recursion found when searching for page \" + pageNum);\n    } else {\n        // collect already processed pages to detect possible recursions\n        // to avoid a StackOverflowError\n        pageSet.add(node);\n    }\n    if (isPageTreeNode(node)) {\n        int count = node.getInt(COSName.COUNT, 0);\n        if (pageNum <= (encountered + count)) {\n            // it's a kid of this node\n            for (COSDictionary kid : getKids(node)) {\n                // which kid?\n                if (isPageTreeNode(kid)) {\n                    int kidCount = kid.getInt(COSName.COUNT, 0);\n                    if (pageNum <= (encountered + kidCount)) {\n                        // it's this kid\n                        return get(pageNum, kid, encountered);\n                    } else {\n                        encountered += kidCount;\n                    }\n                } else {\n                    // single page\n                    encountered++;\n                    if (pageNum == encountered) {\n                        // it's this page\n                        return get(pageNum, kid, encountered);\n                    }\n                }\n            }\n            throw new IllegalStateException(\"1-based index not found: \" + pageNum);\n        } else {\n            throw new IndexOutOfBoundsException(\"1-based index out of bounds: \" + pageNum);\n        }\n    } else if (encountered == pageNum) {\n        pageSet.clear();\n        return node;\n    } else {\n        throw new IllegalStateException(\"1-based index not found: \" + pageNum);\n    }\n}", "/**\n * Helper to get kids from malformed PDFs.\n *\n * @param node\n * \t\tpage tree node\n * @return list of kids\n */\nprivate List<COSDictionary> getKids(COSDictionary node) {\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // probably a malformed PDF\n        return Collections.emptyList();\n    }\n    int size = kids.size();\n    List<COSDictionary> result = new ArrayList<>(size);\n    for (int i = 0; i < size; i++) {\n        COSBase base = kids.getObject(i);\n        if (base instanceof COSDictionary) {\n            result.add(((COSDictionary) (base)));\n        } else if (base == null) {\n            LOG.warn(\"replaced null entry with an empty page\");\n            COSDictionary emptyPage = new COSDictionary();\n            emptyPage.setItem(COSName.TYPE, COSName.PAGE);\n            kids.set(i, emptyPage);\n            result.add(emptyPage);\n        } else {\n            LOG.warn(\"COSDictionary expected, but got \" + base.getClass().getSimpleName());\n        }\n    }\n    return result;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAppearanceDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAppearanceDictionary", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createAppearanceDictionary(PDFormXObject holderForm, PDSignatureField signatureField) throws IOException {\n    PDAppearanceDictionary appearance = new PDAppearanceDictionary();\n    appearance.getCOSObject().setDirect(true);\n    PDAppearanceStream appearanceStream = new PDAppearanceStream(holderForm.getCOSObject());\n    appearance.setNormalAppearance(appearanceStream);\n    signatureField.getWidgets().get(0).setAppearance(appearance);\n    pdfStructure.setAppearanceDictionary(appearance);\n    LOG.info(\"PDF appearance dictionary has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace.create",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace.create", "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a color space given a name or array. Abbreviated device color names are not supported\n * here, please replace them first. This method is for PDFBox internal use only, others should\n * use {@link #create(COSBase, PDResources)}.\n *\n * @param colorSpace\n * \t\tthe color space COS object\n * @param resources\n * \t\tthe current resources.\n * @param wasDefault\n * \t\tif current color space was used by a default color space.\n * @return a new color space.\n * @throws MissingResourceException\n * \t\tif the color space is missing in the resources dictionary\n * @throws IOException\n * \t\tif the color space is unknown or cannot be created.\n */\npublic static PDColorSpace create(COSBase colorSpace, PDResources resources, boolean wasDefault) throws IOException {\n    if (colorSpace instanceof COSObject) {\n        return createFromCOSObject(((COSObject) (colorSpace)), resources);\n    } else if (colorSpace instanceof COSName) {\n        COSName name = ((COSName) (colorSpace));\n        // default color spaces\n        if (resources != null) {\n            COSName defaultName = null;\n            if (name.equals(COSName.DEVICECMYK) && resources.hasColorSpace(COSName.DEFAULT_CMYK)) {\n                defaultName = COSName.DEFAULT_CMYK;\n            } else if (name.equals(COSName.DEVICERGB) && resources.hasColorSpace(COSName.DEFAULT_RGB)) {\n                defaultName = COSName.DEFAULT_RGB;\n            } else if (name.equals(COSName.DEVICEGRAY) && resources.hasColorSpace(COSName.DEFAULT_GRAY)) {\n                defaultName = COSName.DEFAULT_GRAY;\n            }\n            if (resources.hasColorSpace(defaultName) && (!wasDefault)) {\n                return resources.getColorSpace(defaultName, true);\n            }\n        }\n        // built-in color spaces\n        if (name == COSName.DEVICECMYK) {\n            return PDDeviceCMYK.INSTANCE;\n        } else if (name == COSName.DEVICERGB) {\n            return PDDeviceRGB.INSTANCE;\n        } else if (name == COSName.DEVICEGRAY) {\n            return PDDeviceGray.INSTANCE;\n        } else if (name == COSName.PATTERN) {\n            return new PDPattern(resources);\n        } else if (resources != null) {\n            if (!resources.hasColorSpace(name)) {\n                throw new MissingResourceException(\"Missing color space: \" + name.getName());\n            }\n            return resources.getColorSpace(name);\n        } else {\n            throw new MissingResourceException(\"Unknown color space: \" + name.getName());\n        }\n    } else if (colorSpace instanceof COSArray) {\n        COSArray array = ((COSArray) (colorSpace));\n        if (array.size() == 0) {\n            throw new IOException(\"Colorspace array is empty\");\n        }\n        COSBase base = array.getObject(0);\n        if (!(base instanceof COSName)) {\n            throw new IOException(\"First element in colorspace array must be a name\");\n        }\n        COSName name = ((COSName) (base));\n        // TODO cache these returned color spaces?\n        if (name == COSName.CALGRAY) {\n            return new PDCalGray(array);\n        } else if (name == COSName.CALRGB) {\n            return new PDCalRGB(array);\n        } else if (name == COSName.DEVICEN) {\n            return new PDDeviceN(array, resources);\n        } else if (name == COSName.INDEXED) {\n            return new PDIndexed(array, resources);\n        } else if (name == COSName.SEPARATION) {\n            return new PDSeparation(array, resources);\n        } else if (name == COSName.ICCBASED) {\n            return PDICCBased.create(array, resources);\n        } else if (name == COSName.LAB) {\n            return new PDLab(array);\n        } else if (name == COSName.PATTERN) {\n            if (array.size() == 1) {\n                return new PDPattern(resources);\n            } else {\n                return new PDPattern(resources, PDColorSpace.create(array.get(1)));\n            }\n        } else if (((name == COSName.DEVICECMYK) || (name == COSName.DEVICERGB)) || (name == COSName.DEVICEGRAY)) {\n            // not allowed in an array, but we sometimes encounter these regardless\n            return create(name, resources, wasDefault);\n        } else {\n            throw new IOException(\"Invalid color space kind: \" + name);\n        }\n    } else if ((colorSpace instanceof COSDictionary) && ((COSDictionary) (colorSpace)).containsKey(COSName.COLORSPACE)) {\n        // PDFBOX-4833: dictionary with /ColorSpace entry\n        COSBase base = ((COSDictionary) (colorSpace)).getDictionaryObject(COSName.COLORSPACE);\n        if (base == colorSpace) {\n            // PDFBOX-5315\n            throw new IOException((\"Recursion in colorspace: \" + ((COSDictionary) (colorSpace)).getItem(COSName.COLORSPACE)) + \" points to itself\");\n        }\n        return create(base, resources, wasDefault);\n    } else {\n        throw new IOException(\"Expected a name or array but got: \" + colorSpace);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDButton.updateByOption", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.getWidgets", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the selected option given its name, and try to update the visual appearance.\n *\n * @param value\n * \t\tName of option to select\n * @throws IOException\n * \t\tif the value could not be set\n * @throws IllegalArgumentException\n * \t\tif the value is not a valid option.\n */\n@Override\npublic void setValue(String value) throws IOException {\n    checkValue(value);\n    // if there are export values/an Opt entry there is a different\n    // approach to setting the value\n    if (!getExportValues().isEmpty()) {\n        updateByOption(value);\n    } else {\n        updateByValue(value);\n    }\n    applyChange();\n}", "private void updateByOption(String value) {\n    List<PDAnnotationWidget> widgets = getWidgets();\n    List<String> options = getExportValues();\n    if (widgets.size() != options.size()) {\n        throw new IllegalArgumentException(\"The number of options doesn't match the number of widgets\");\n    }\n    if (value.equals(COSName.Off.getName())) {\n        updateByValue(value);\n    } else {\n        // the value is the index of the matching option\n        int optionsIndex = options.indexOf(value);\n        // get the values the options are pointing to as\n        // this might not be numerical\n        // see PDFBOX-3682\n        if (optionsIndex != (-1)) {\n            updateByValue(getOnValue(optionsIndex));\n        }\n    }\n}", "/**\n * Returns the widget annotations associated with this field.\n *\n * @return The list of widget annotations. Be aware that this list is <i>not</i> backed by the\nactual widget collection of the field, so adding or deleting has no effect on the PDF\ndocument until you call {@link #setWidgets(java.util.List) setWidgets()} with the modified\nlist.\n */\n@Override\npublic List<PDAnnotationWidget> getWidgets() {\n    List<PDAnnotationWidget> widgets = new ArrayList<>();\n    COSArray kids = getCOSObject().getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // the field itself is a widget\n        widgets.add(new PDAnnotationWidget(getCOSObject()));\n    } else if (kids.size() > 0) {\n        // there are multiple widgets\n        for (int i = 0; i < kids.size(); i++) {\n            COSBase kid = kids.getObject(i);\n            if (kid instanceof COSDictionary) {\n                widgets.add(new PDAnnotationWidget(((COSDictionary) (kid))));\n            }\n        }\n    }\n    return widgets;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPageMode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPageMode", "org.apache.pdfbox.pdmodel.PDDocumentCatalog.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the page display mode.\n *\n * @return the PageMode of the document, if not present PageMode.USE_NONE is returned\n */\npublic PageMode getPageMode() {\n    String mode = root.getNameAsString(COSName.PAGE_MODE);\n    if (mode != null) {\n        try {\n            return PageMode.fromString(mode);\n        } catch (IllegalArgumentException e) {\n            LOG.debug((\"Invalid PageMode used '\" + mode) + \"' - setting to PageMode.USE_NONE\", e);\n            return PageMode.USE_NONE;\n        }\n    } else {\n        return PageMode.USE_NONE;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDFormFieldAdditionalActions.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDFormFieldAdditionalActions.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDFormFieldAdditionalActions() {\n    actions = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.fillPath",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.fillPath", "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getNonStrokingJavaComposite", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void fillPath(int windingRule) throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    graphics.setComposite(graphicsState.getNonStrokingJavaComposite());\n    setClip();\n    linePath.setWindingRule(windingRule);\n    // disable anti-aliasing for rectangular paths, this is a workaround to avoid small stripes\n    // which occur when solid fills are used to simulate piecewise gradients, see PDFBOX-2302\n    // note that we ignore paths with a width/height under 1 as these are fills used as strokes,\n    // see PDFBOX-1658 for an example\n    Rectangle2D bounds = linePath.getBounds2D();\n    boolean noAntiAlias = (isRectangular(linePath) && (bounds.getWidth() > 1)) && (bounds.getHeight() > 1);\n    if (noAntiAlias) {\n        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n    }\n    Shape shape;\n    if (graphicsState.getNonStrokingColorSpace() instanceof PDPattern) {\n        // apply clip to path to avoid oversized device bounds in shading contexts (PDFBOX-2901)\n        Area area = new Area(linePath);\n        Shape clip = graphics.getClip();\n        if (clip != null) {\n            area.intersect(new Area(clip));\n        }\n        intersectShadingBBox(graphicsState.getNonStrokingColor(), area);\n        shape = area;\n    } else {\n        shape = linePath;\n    }\n    if (isContentRendered() && (!shape.getPathIterator(null).isDone())) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        graphics.setPaint(getNonStrokingPaint());\n        graphics.fill(shape);\n    }\n    linePath.reset();\n    if (noAntiAlias) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "public Composite getNonStrokingJavaComposite() {\n    return BlendComposite.getInstance(blendMode, ((float) (nonStrokingAlphaConstant)));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.asUnmodifiableDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.asUnmodifiableDictionary", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns an unmodifiable view of this dictionary.\n *\n * @return an unmodifiable view of this dictionary\n */\npublic COSDictionary asUnmodifiableDictionary() {\n    return new UnmodifiableCOSDictionary(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.iterator",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.iterator", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.FieldIterator.<init>", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.FieldIterator.<init>", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.FieldIterator.enqueueKids", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns an iterator which walks all fields in the tree, in order.\n */\n@Override\npublic Iterator<PDField> iterator() {\n    return new FieldIterator(acroForm);\n}", "private FieldIterator(PDAcroForm form) {\n    List<PDField> fields = form.getFields();\n    for (PDField field : fields) {\n        enqueueKids(field);\n    }\n}", "private FieldIterator(PDAcroForm form) {\n    List<PDField> fields = form.getFields();\n    for (PDField field : fields) {\n        enqueueKids(field);\n    }\n}", "private void enqueueKids(PDField node) {\n    queue.add(node);\n    set.add(node.getCOSObject());\n    if (node instanceof PDNonTerminalField) {\n        List<PDField> kids = ((PDNonTerminalField) (node)).getChildren();\n        for (PDField kid : kids) {\n            if (set.contains(kid.getCOSObject())) {\n                LOG.error((\"Child of field '\" + node.getFullyQualifiedName()) + \"' already exists elsewhere, ignored to avoid recursion\");\n            } else {\n                enqueueKids(kid);\n            }\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentNameDictionary.getJavaScript",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentNameDictionary.getJavaScript", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the document level JavaScript name tree. When the document is opened, all the JavaScript\n * actions in it shall be executed, defining JavaScript functions for use by other scripts in\n * the document.\n *\n * @return The document level JavaScript name tree.\n */\npublic PDJavascriptNameTreeNode getJavaScript() {\n    COSDictionary dic = nameDictionary.getCOSDictionary(COSName.JAVA_SCRIPT);\n    return dic != null ? new PDJavascriptNameTreeNode(dic) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.pagenavigation.PDThreadBead.getPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.pagenavigation.PDThreadBead.getPage", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the page that this bead is part of.\n *\n * @return The page that this bead is part of.\n */\npublic PDPage getPage() {\n    COSDictionary dic = bead.getCOSDictionary(COSName.P);\n    return dic != null ? new PDPage(dic) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getViewports",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getViewports", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the viewports.\n *\n * @return a list of viewports or null if there is no /VP entry.\n */\npublic List<PDViewportDictionary> getViewports() {\n    COSArray array = page.getCOSArray(COSName.VP);\n    if (array == null) {\n        return null;\n    }\n    List<PDViewportDictionary> viewports = new ArrayList<>();\n    for (int i = 0; i < array.size(); ++i) {\n        COSBase base2 = array.getObject(i);\n        if (base2 instanceof COSDictionary) {\n            viewports.add(new PDViewportDictionary(((COSDictionary) (base2))));\n        } else {\n            LOG.warn((\"Array element \" + base2) + \" is skipped, must be a (viewport) dictionary\");\n        }\n    }\n    return viewports;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.getReferencedObject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.getReferencedObject", "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.<clinit>" ],
    "fullMethods" : [ "/**\n * Gets a higher-level object for the referenced object.\n * Currently this method may return a {@link PDAnnotation},\n * a {@link PDXObject} or <code>null</code>.\n *\n * @return a higher-level object for the referenced object\n */\npublic COSObjectable getReferencedObject() {\n    COSDictionary objDictionary = getCOSObject().getCOSDictionary(COSName.OBJ);\n    if (objDictionary == null) {\n        return null;\n    }\n    try {\n        if (objDictionary instanceof COSStream) {\n            PDXObject xobject = PDXObject.createXObject(objDictionary, null);// <-- TODO: valid?\n\n            if (xobject != null) {\n                return xobject;\n            }\n        }\n        PDAnnotation annotation = PDAnnotation.createAnnotation(objDictionary);\n        /* COSName.TYPE is optional, so if annotation is of type unknown and\n        COSName.TYPE is not COSName.ANNOT it still may be an annotation.\n        TODO shall we return the annotation object instead of null?\n        what else can be the target of the object reference?\n         */\n        if ((!(annotation instanceof PDAnnotationUnknown)) || COSName.ANNOT.equals(objDictionary.getCOSName(COSName.TYPE))) {\n            return annotation;\n        }\n    } catch (IOException exception) {\n        LOG.debug(\"Couldn't get the referenced object - returning null instead\", exception);\n        // this can only happen if the target is an XObject.\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.setRoleMap",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.setRoleMap", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the role map.\n *\n * @param roleMap\n * \t\tthe role map\n */\npublic void setRoleMap(Map<String, String> roleMap) {\n    COSDictionary rmDic = new COSDictionary();\n    roleMap.forEach(rmDic::setName);\n    this.getCOSObject().setItem(COSName.ROLE_MAP, rmDic);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.put",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the extended graphics state resource with the given name.\n *\n * @param name\n * \t\tthe name of the resource\n * @param extGState\n * \t\tthe extended graphics state to be added\n */\npublic void put(COSName name, PDExtendedGraphicsState extGState) {\n    put(COSName.EXT_G_STATE, name, extGState);\n}", "/**\n * Sets the value of a given named resource.\n */\nprivate void put(COSName kind, COSName name, COSObjectable object) {\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if (dict == null) {\n        dict = new COSDictionary();\n        resources.setItem(kind, dict);\n    }\n    dict.setItem(name, object);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDCheckBox.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDCheckBox.<init>", "org.apache.pdfbox.pdmodel.interactive.form.PDButton.<init>", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @see PDField#PDField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroform.\n */\npublic PDCheckBox(PDAcroForm acroForm) {\n    super(acroForm);\n}", "/**\n *\n * @see PDField#PDField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroform.\n */\nPDButton(PDAcroForm acroForm) {\n    super(acroForm);\n    getCOSObject().setItem(COSName.FT, COSName.BTN);\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.showTextWithPositioning",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.showTextWithPositioning", "org.apache.pdfbox.pdmodel.PDAbstractContentStream.showTextInternal", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * Shows the given text at the location specified by the current text matrix with the given\n * interspersed positioning. This allows the user to efficiently position each glyph or sequence\n * of glyphs.\n *\n * @param textWithPositioningArray\n * \t\tAn array consisting of String and Float types. Each String is\n * \t\toutput to the page using the current text matrix. Using the default coordinate system, each\n * \t\tinterspersed number adjusts the current text matrix by translating to the left or down for\n * \t\thorizontal and vertical text respectively. The number is expressed in thousands of a text\n * \t\tspace unit, and may be negative.\n * @throws IOException\n * \t\tif an io exception occurs.\n */\npublic void showTextWithPositioning(Object[] textWithPositioningArray) throws IOException {\n    write(\"[\");\n    for (Object obj : textWithPositioningArray) {\n        if (obj instanceof String) {\n            showTextInternal(((String) (obj)));\n        } else if (obj instanceof Float) {\n            writeOperand(((Float) (obj)));\n        } else {\n            throw new IllegalArgumentException(\"Argument must consist of array of Float and String types\");\n        }\n    }\n    write(\"] \");\n    writeOperator(OperatorName.SHOW_TEXT_ADJUSTED);\n}", "/**\n * Outputs a string using the correct encoding and subsetting as required.\n *\n * @param text\n * \t\tThe Unicode text to show.\n * @throws IOException\n * \t\tIf an io exception occurs.\n */\nprotected void showTextInternal(String text) throws IOException {\n    if (!inTextMode) {\n        throw new IllegalStateException(\"Must call beginText() before showText()\");\n    }\n    if (fontStack.isEmpty()) {\n        throw new IllegalStateException(\"Must call setFont() before showText()\");\n    }\n    PDFont font = fontStack.peek();\n    // complex text layout\n    byte[] encodedText = null;\n    if (font instanceof PDType0Font) {\n        GsubWorker gsubWorker = gsubWorkers.get(font);\n        if (gsubWorker != null) {\n            PDType0Font type0Font = ((PDType0Font) (font));\n            Set<Integer> glyphIds = new HashSet<>();\n            encodedText = encodeForGsub(gsubWorker, glyphIds, type0Font, text);\n            if (type0Font.willBeSubset()) {\n                type0Font.addGlyphsToSubset(glyphIds);\n            }\n        }\n    }\n    if (encodedText == null) {\n        encodedText = font.encode(text);\n    }\n    // Unicode code points to keep when subsetting\n    if (font.willBeSubset()) {\n        int offset = 0;\n        while (offset < text.length()) {\n            int codePoint = text.codePointAt(offset);\n            font.addToSubset(codePoint);\n            offset += Character.charCount(codePoint);\n        } \n    }\n    COSWriter.writeString(encodedText, outputStream);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.Overlay.overlayDocuments",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.Overlay.overlayDocuments", "org.apache.pdfbox.multipdf.Overlay.processPages", "org.apache.pdfbox.multipdf.PDFCloneUtility.<clinit>" ],
    "fullMethods" : [ "/**\n * This will add overlays documents to a document. If you created the overlay documents with\n * subsetted fonts, you need to save them first so that the subsetting gets done.\n *\n * @param specificPageOverlayDocumentMap\n * \t\tOptional map of overlay documents for specific pages. The\n * \t\tpage numbers are 1-based. The map must be empty (but not null) if no specific mappings are\n * \t\tused.\n * @return The modified input PDF document, which has to be saved and closed by the caller. If\nthe input document was passed by {@link #setInputPDF(PDDocument) setInputPDF(PDDocument)}\nthen it is that object that is returned.\n * @throws IOException\n * \t\tif something went wrong\n */\npublic PDDocument overlayDocuments(Map<Integer, PDDocument> specificPageOverlayDocumentMap) throws IOException {\n    loadPDFs();\n    for (Map.Entry<Integer, PDDocument> e : specificPageOverlayDocumentMap.entrySet()) {\n        PDDocument doc = e.getValue();\n        if (doc != null) {\n            specificPageOverlayLayoutPageMap.put(e.getKey(), createLayoutPageFromDocument(doc));\n        }\n    }\n    processPages(inputPDFDocument);\n    return inputPDFDocument;\n}", "private void processPages(PDDocument document) throws IOException {\n    int pageCounter = 0;\n    PDFCloneUtility cloner = new PDFCloneUtility(document);\n    PDPageTree pageTree = document.getPages();\n    int numberOfPages = pageTree.getCount();\n    for (PDPage page : pageTree) {\n        pageCounter++;\n        LayoutPage layoutPage = getLayoutPage(pageCounter, numberOfPages);\n        if (layoutPage == null) {\n            continue;\n        }\n        COSDictionary pageDictionary = page.getCOSObject();\n        COSBase originalContent = pageDictionary.getDictionaryObject(COSName.CONTENTS);\n        COSArray newContentArray = new COSArray();\n        switch (position) {\n            case FOREGROUND :\n                // save state\n                newContentArray.add(createStream(\"q\\n\"));\n                addOriginalContent(originalContent, newContentArray);\n                // restore state\n                newContentArray.add(createStream(\"Q\\n\"));\n                // overlay content last\n                overlayPage(page, layoutPage, newContentArray, cloner);\n                break;\n            case BACKGROUND :\n                // overlay content first\n                overlayPage(page, layoutPage, newContentArray, cloner);\n                addOriginalContent(originalContent, newContentArray);\n                break;\n            default :\n                throw new IOException(\"Unknown type of position:\" + position);\n        }\n        pageDictionary.setItem(COSName.CONTENTS, newContentArray);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.getIDTree",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.getIDTree", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the ID tree.\n *\n * @return the ID tree\n */\npublic PDNameTreeNode<PDStructureElement> getIDTree() {\n    COSDictionary idTree = getCOSObject().getCOSDictionary(COSName.ID_TREE);\n    return idTree != null ? new PDStructureElementNameTreeNode(idTree) : null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignature", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createSignature(PDSignatureField pdSignatureField, PDPage page, String signerName) throws IOException {\n    PDSignature pdSignature = new PDSignature();\n    PDAnnotationWidget widget = pdSignatureField.getWidgets().get(0);\n    pdSignatureField.setValue(pdSignature);\n    widget.setPage(page);\n    page.getAnnotations().add(widget);\n    if (!signerName.isEmpty()) {\n        pdSignature.setName(signerName);\n    }\n    pdfStructure.setPdSignature(pdSignature);\n    LOG.info(\"PDSignature has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationFreeText.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationFreeText.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationFreeText.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationFreeText(COSDictionary a) {\n    super(a);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromImage", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new JPEG PDImageXObject from a BufferedImage and a given quality.\n * <p>\n * Do not read a JPEG image from a stream/file and call this method; you'll get more speed and\n * quality by calling {@link #createFromStream(org.apache.pdfbox.pdmodel.PDDocument,\n * java.io.InputStream) createFromStream()} instead.\n *\n * The image will be created with a dpi value of 72 to be stored in metadata.\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param image\n * \t\tthe BufferedImage to embed\n * @param quality\n * \t\tThe desired JPEG compression quality; between 0 (best\n * \t\tcompression) and 1 (best image quality). See\n * \t\t{@link ImageWriteParam#setCompressionQuality(float)} for more details.\n * @return a new Image XObject\n * @throws IOException\n * \t\tif the JPEG data cannot be written\n */\npublic static PDImageXObject createFromImage(PDDocument document, BufferedImage image, float quality) throws IOException {\n    return createFromImage(document, image, quality, 72);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param input\n * \t\tAn input stream of a TrueType font. It will be closed before returning.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding. Set this to false when\n * \t\tcreating a font for AcroForm.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font load(PDDocument doc, InputStream input, boolean embedSubset) throws IOException {\n    return load(doc, RandomAccessReadBuffer.createBufferFromStream(input), embedSubset, false);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFNamedPageReference.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFNamedPageReference.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFNamedPageReference() {\n    ref = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.LineTo.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.LineTo.process", "org.apache.pdfbox.contentstream.operator.graphics.LineTo.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.size() < 2) {\n        throw new MissingOperandException(operator, operands);\n    }\n    COSBase base0 = operands.get(0);\n    if (!(base0 instanceof COSNumber)) {\n        return;\n    }\n    COSBase base1 = operands.get(1);\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    // append straight line segment from the current point to the point\n    COSNumber x = ((COSNumber) (base0));\n    COSNumber y = ((COSNumber) (base1));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    Point2D.Float pos = context.transformedPoint(x.floatValue(), y.floatValue());\n    if (context.getCurrentPoint() == null) {\n        LOG.warn((((\"LineTo (\" + pos.x) + \",\") + pos.y) + \") without initial MoveTo\");\n        context.moveTo(pos.x, pos.y);\n    } else {\n        context.lineTo(pos.x, pos.y);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromImage", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new JPEG PDImageXObject from a BufferedImage.\n * <p>\n * Do not read a JPEG image from a stream/file and call this method; you'll get more speed and\n * quality by calling {@link #createFromStream(org.apache.pdfbox.pdmodel.PDDocument,\n * java.io.InputStream) createFromStream()} instead.\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param image\n * \t\tthe BufferedImage to embed\n * @return a new Image XObject\n * @throws IOException\n * \t\tif the JPEG data cannot be written\n */\npublic static PDImageXObject createFromImage(PDDocument document, BufferedImage image) throws IOException {\n    return createFromImage(document, image, 0.75F);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.getChars",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.getChars", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the characters corresponding to the ASCII hex encoding of the given short.\n *\n * @param num\n * \t\tthe short value to be converted\n * @return the ASCII hex encoding of the given short value\n */\npublic static char[] getChars(short num) {\n    char[] hex = new char[4];\n    hex[0] = HEX_CHARS[(num >> 12) & 0xf];\n    hex[1] = HEX_CHARS[(num >> 8) & 0xf];\n    hex[2] = HEX_CHARS[(num >> 4) & 0xf];\n    hex[3] = HEX_CHARS[num & 0xf];\n    return hex;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationStamp(COSDictionary a) {\n    super(a);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFDocument.save",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFDocument.save", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * This will save the document to an output stream.\n *\n * @param output\n * \t\tThe stream to write to.\n * @throws IOException\n * \t\tIf there is an error writing the document.\n */\npublic void save(OutputStream output) throws IOException {\n    COSWriter writer = new COSWriter(output);\n    writer.write(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadFDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadFDF", "org.apache.pdfbox.pdfparser.COSParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will load a document from an input stream. The stream is loaded to the memory to establish random access to\n * the data.\n *\n * @param input\n * \t\tThe stream that contains the document. To read the stream\n * \t\t{@link org.apache.pdfbox.io.RandomAccessReadBuffer} is used\n * @return The document that was loaded.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\npublic static FDFDocument loadFDF(InputStream input) throws IOException {\n    try (RandomAccessRead readBuffer = new RandomAccessReadBuffer(input)) {\n        FDFParser parser = new FDFParser(readBuffer);\n        return parser.parse();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.flatten",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.flatten", "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.<clinit>" ],
    "fullMethods" : [ "/**\n * This will flatten all form fields.\n *\n * <p>\n * Flattening a form field will take the current appearance and make that part of the pages content stream. All form\n * fields and annotations associated are removed.\n * </p>\n *\n * <p>\n * Invisible and hidden fields will be skipped and will not become part of the page content stream\n * </p>\n *\n * <p>\n * The appearances for the form fields widgets will <strong>not</strong> be generated\n * </p>\n *\n * @throws IOException\n * \t\tif something went wrong flattening the fields\n */\npublic void flatten() throws IOException {\n    // for dynamic XFA forms there is no flatten as this would mean to do a rendering\n    // from the XFA content into a static PDF.\n    if (xfaIsDynamic()) {\n        LOG.warn(\"Flatten for a dynamix XFA form is not supported\");\n        return;\n    }\n    List<PDField> fields = new ArrayList<>();\n    for (PDField field : getFieldTree()) {\n        fields.add(field);\n    }\n    flatten(fields, false);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param randomAccessRead\n * \t\tsource of a TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding. Set this to false when creating a font for\n * \t\tAcroForm.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font load(PDDocument doc, RandomAccessRead randomAccessRead, boolean embedSubset, boolean vertical) throws IOException {\n    return new PDType0Font(doc, new TTFParser().parse(randomAccessRead), embedSubset, true, vertical);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getWidth", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic int getWidth() {\n    initJPXValues();\n    return getCOSObject().getInt(COSName.WIDTH);\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSObject.getObject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.saveIncremental",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.saveIncremental", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * Save the PDF as an incremental update. This is only possible if the PDF was loaded from a file or a stream, not\n * if the document was created in PDFBox itself. This allows to include objects even if there is no path of objects\n * that have {@link COSUpdateInfo#isNeedToBeUpdated()} set so the incremental update gets smaller. Only dictionaries\n * are supported; if you need to update other objects classes, then add their parent dictionary.\n * <p>\n * This method is for experienced users only. You will usually never need it. It is useful only if you are required\n * to keep the current revision and append the changes. A typical use case is changing a signed file without\n * invalidating the signature. To know which objects are getting changed, you need to have some understanding of the\n * PDF specification, and look at the saved file with an editor to verify that you are updating the correct objects.\n * You should also inspect the page and document structures of the file with PDFDebugger.\n * <p>\n * If your modification includes annotations, make sure these link back to their page by calling\n * {@link PDAnnotation#setPage(PDPage)}. Although this is optional,\n * not doing it\n * <a href=\"https://stackoverflow.com/questions/74836898/\">can cause trouble when PDFs get\n * signed</a>. (PDFBox already does this for signature widget annotations)\n * <p>\n * Don't use the input file as target as this will produce a corrupted file.\n *\n * @param output\n * \t\tstream to write to. It will be closed when done. It <i><b>must never</b></i> point to the source\n * \t\tfile or that one will be harmed!\n * @param objectsToWrite\n * \t\tobjects that <b>must</b> be part of the incremental saving.\n * @throws IOException\n * \t\tif the output could not be written\n * @throws IllegalStateException\n * \t\tif the document was not loaded from a file or a stream.\n */\npublic void saveIncremental(OutputStream output, Set<COSDictionary> objectsToWrite) throws IOException {\n    subsetDesignatedFonts();\n    if (pdfSource == null) {\n        throw new IllegalStateException(\"document was not loaded from a file or a stream\");\n    }\n    COSWriter writer = new COSWriter(output, pdfSource, objectsToWrite);\n    writer.write(this, signInterface);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDPageLabelRange.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDPageLabelRange.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new empty page label range object.\n */\npublic PDPageLabelRange() {\n    this(new COSDictionary());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.create",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.create", "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new ICC color space using the PDF array, optionally using a resource cache.\n *\n * @param iccArray\n * \t\tthe ICC stream object.\n * @param resources\n * \t\tresources to use as cache, or null for no caching.\n * @return an ICC color space.\n * @throws IOException\n * \t\tif there is an error reading the ICC profile or if the parameter is\n * \t\tinvalid.\n */\npublic static PDICCBased create(COSArray iccArray, PDResources resources) throws IOException {\n    checkArray(iccArray);\n    COSBase base = iccArray.get(1);\n    if ((base instanceof COSObject) && (resources != null)) {\n        ResourceCache resourceCache = resources.getResourceCache();\n        if (resourceCache != null) {\n            COSObject indirect = ((COSObject) (base));\n            PDColorSpace space = resourceCache.getColorSpace(indirect);\n            if (space instanceof PDICCBased) {\n                return ((PDICCBased) (space));\n            } else {\n                PDICCBased newSpace = new PDICCBased(iccArray);\n                resourceCache.put(indirect, newSpace);\n                return newSpace;\n            }\n        }\n    }\n    return new PDICCBased(iccArray);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getRawRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage.getRawRaster", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "@Override\npublic WritableRaster getRawRaster() throws IOException {\n    return SampledImageReader.getRawRaster(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type6ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.TilingPaintFactory.TilingPaintParameter.equals",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.TilingPaintFactory.TilingPaintParameter.equals", "org.apache.pdfbox.rendering.TilingPaintFactory.<clinit>" ],
    "fullMethods" : [ "// this may not catch all equals, but at least those related to one resource dictionary.\n// it isn't needed to investigate further because matrix or transform would be different anyway.\n@Override\npublic boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (!(obj instanceof TilingPaintParameter)) {\n        return false;\n    }\n    final TilingPaintParameter other = ((TilingPaintParameter) (obj));\n    if (!Objects.equals(this.matrix, other.matrix)) {\n        return false;\n    }\n    if (!Objects.equals(this.patternDict, other.patternDict)) {\n        return false;\n    }\n    if (!Objects.equals(this.colorSpace, other.colorSpace)) {\n        return false;\n    }\n    if ((this.color == null) && (other.color != null)) {\n        return false;\n    }\n    if ((this.color != null) && (other.color == null)) {\n        return false;\n    }\n    if ((this.color != null) && (this.color.getColorSpace() != other.color.getColorSpace())) {\n        return false;\n    }\n    try {\n        if ((((this.color != null) && (other.color != null)) && (this.color != other.color)) && (this.color.toRGB() != other.color.toRGB())) {\n            return false;\n        }\n    } catch (IOException ex) {\n        LOG.debug(\"Couldn't convert color to RGB - treating as not equal\", ex);\n        return false;\n    }\n    return Objects.equals(this.xform, other.xform);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.put",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the XObject resource with the given name.\n *\n * @param name\n * \t\tthe name of the resource\n * @param xobject\n * \t\tthe XObject to be added\n */\npublic void put(COSName name, PDXObject xobject) {\n    put(COSName.XOBJECT, name, xobject);\n}", "/**\n * Sets the value of a given named resource.\n */\nprivate void put(COSName kind, COSName name, COSObjectable object) {\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if (dict == null) {\n        dict = new COSDictionary();\n        resources.setItem(kind, dict);\n    }\n    dict.setItem(name, object);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setNonStrokingColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setNonStrokingColor", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceGray.<clinit>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceGray.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the non-stroking color in the DeviceGray color space. Range is 0..1.\n *\n * @param g\n * \t\tThe gray value.\n * @throws IOException\n * \t\tIf an IO error occurs while writing to the stream.\n * @throws IllegalArgumentException\n * \t\tIf the parameter is invalid.\n */\npublic void setNonStrokingColor(float g) throws IOException {\n    if (isOutsideOneInterval(g)) {\n        throw new IllegalArgumentException(\"Parameter must be within 0..1, but is \" + g);\n    }\n    writeOperand(g);\n    writeOperator(OperatorName.NON_STROKING_GRAY);\n    setNonStrokingColorSpaceStack(PDDeviceGray.INSTANCE);\n}", "", "private PDDeviceGray() {\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getContentsForStreamParsing",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getContentsForStreamParsing", "org.apache.pdfbox.filter.FlateFilterDecoderStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic RandomAccessRead getContentsForStreamParsing() throws IOException {\n    // return a stream based reader if there is just one stream\n    COSStream contentStream = page.getCOSStream(COSName.CONTENTS);\n    if ((contentStream != null) && COSName.FLATE_DECODE.equals(contentStream.getFilters())) {\n        // for now only streams using a flate filter are supported\n        try {\n            FlateFilterDecoderStream decoderStream = new FlateFilterDecoderStream(contentStream.createRawInputStream());\n            return new NonSeekableRandomAccessReadInputStream(decoderStream);\n        } catch (IOException exception) {\n            LOG.warn(\"skipped malformed content stream\");\n            return new RandomAccessReadBuffer(DELIMITER);\n        }\n    }\n    return getContentsForRandomAccess();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.CryptFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.CryptFilter.decode", "org.apache.pdfbox.filter.Filter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    COSName encryptionName = parameters.getCOSName(COSName.NAME);\n    if ((encryptionName == null) || encryptionName.equals(COSName.IDENTITY)) {\n        // currently the only supported implementation is the Identity crypt filter\n        Filter identityFilter = new IdentityFilter();\n        identityFilter.decode(encoded, decoded, parameters, index);\n        return new DecodeResult(parameters);\n    }\n    throw new IOException(\"Unsupported crypt filter \" + encryptionName.getName());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.viewerpreferences.PDViewerPreferences.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.viewerpreferences.PDViewerPreferences.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "NON_FULL_SCREEN_PAGE_MODE() {\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setUserEncryptionKey",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PDEncryption.setUserEncryptionKey", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the UE entry in the standard encryption dictionary.\n *\n * @param ue\n * \t\tA 32 byte array or null if there is no user encryption key.\n * @throws IOException\n * \t\tIf there is an error setting the data.\n */\npublic void setUserEncryptionKey(byte[] ue) throws IOException {\n    dictionary.setItem(COSName.UE, new COSString(ue));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.createFromFile",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.createFromFile", "org.apache.pdfbox.pdmodel.graphics.image.CCITTFactory.createFromRandomAccessImpl", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new CCITT Fax compressed image XObject from a specific image of a TIFF file. Only\n * single-strip CCITT T4 or T6 compressed TIFF files are supported. If you're not sure what TIFF\n * files you have, use\n * {@link LosslessFactory#createFromImage(PDDocument, BufferedImage)}\n * or {@link CCITTFactory#createFromImage(PDDocument, BufferedImage)}\n * instead.\n *\n * @param document\n * \t\tthe document to create the image as part of.\n * @param file\n * \t\tthe TIFF file which contains a suitable CCITT compressed image\n * @param number\n * \t\tTIFF image number, starting from 0\n * @return a new Image XObject\n * @throws IOException\n * \t\tif there is an error reading the TIFF data.\n */\npublic static PDImageXObject createFromFile(PDDocument document, File file, int number) throws IOException {\n    try (RandomAccessRead raf = new RandomAccessReadBufferedFile(file)) {\n        return createFromRandomAccessImpl(document, raf, number);\n    }\n}", "/**\n * Creates a new CCITT Fax compressed image XObject from a TIFF file.\n *\n * @param document\n * \t\tthe document to create the image as part of.\n * @param reader\n * \t\tthe random access TIFF file which contains a suitable CCITT\n * \t\tcompressed image\n * @param number\n * \t\tTIFF image number, starting from 0\n * @return a new Image XObject, or null if no such page\n * @throws IOException\n * \t\tif there is an error reading the TIFF data.\n */\nprivate static PDImageXObject createFromRandomAccessImpl(PDDocument document, RandomAccessRead reader, int number) throws IOException {\n    COSDictionary decodeParms = new COSDictionary();\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    extractFromTiff(reader, bos, decodeParms, number);\n    if (bos.size() == 0) {\n        return null;\n    }\n    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(bos.toByteArray());\n    PDImageXObject pdImage = new PDImageXObject(document, encodedByteStream, COSName.CCITTFAX_DECODE, decodeParms.getInt(COSName.COLUMNS), decodeParms.getInt(COSName.ROWS), 1, PDDeviceGray.INSTANCE);\n    COSDictionary dict = pdImage.getCOSObject();\n    dict.setItem(COSName.DECODE_PARMS, decodeParms);\n    return pdImage;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeToken",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeToken", "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeObject", "org.apache.pdfbox.cos.COSName.writePDF", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Writes a single operator token.\n *\n * @param op\n * \t\tThe operator to write to the stream.\n * @throws IOException\n * \t\tIf there is an error writing to the stream.\n */\npublic void writeToken(Operator op) throws IOException {\n    writeObject(op);\n}", "private void writeObject(Operator op) throws IOException {\n    if (op.getName().equals(OperatorName.BEGIN_INLINE_IMAGE)) {\n        output.write(OperatorName.BEGIN_INLINE_IMAGE.getBytes(StandardCharsets.ISO_8859_1));\n        output.write(EOL);\n        COSDictionary dic = op.getImageParameters();\n        for (COSName key : dic.keySet()) {\n            COSBase value = dic.getDictionaryObject(key);\n            key.writePDF(output);\n            output.write(SPACE);\n            writeObject(value);\n            output.write(EOL);\n        }\n        output.write(OperatorName.BEGIN_INLINE_IMAGE_DATA.getBytes(StandardCharsets.ISO_8859_1));\n        output.write(EOL);\n        output.write(op.getImageData());\n        output.write(EOL);\n        output.write(OperatorName.END_INLINE_IMAGE.getBytes(StandardCharsets.ISO_8859_1));\n        output.write(EOL);\n    } else {\n        output.write(op.getName().getBytes(StandardCharsets.ISO_8859_1));\n        output.write(EOL);\n    }\n}", "/**\n * This will output this string as a PDF object.\n *\n * @param output\n * \t\tThe stream to write to.\n * @throws IOException\n * \t\tIf there is an error writing to the stream.\n */\npublic void writePDF(OutputStream output) throws IOException {\n    output.write('/');\n    byte[] bytes = getName().getBytes(StandardCharsets.UTF_8);\n    for (byte b : bytes) {\n        int current = b & 0xff;\n        // be more restrictive than the PDF spec, \"Name Objects\", see PDFBOX-2073\n        if ((((((((((((current >= 'A') && (current <= 'Z')) || ((current >= 'a') && (current <= 'z'))) || ((current >= '0') && (current <= '9'))) || (current == '+')) || (current == '-')) || (current == '_')) || (current == '@')) || (current == '*')) || (current == '$')) || (current == ';')) || (current == '.')) {\n            output.write(current);\n        } else {\n            output.write('#');\n            Hex.writeHexByte(b, output);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.injectAppearanceStreams",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.injectAppearanceStreams", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void injectAppearanceStreams(PDStream holderFormStream, PDStream innerFormStream, PDStream imageFormStream, COSName imageFormName, COSName imageName, COSName innerFormName, PDVisibleSignDesigner properties) throws IOException {\n    // TODO remove unused parameter from interface??\n    // Use width and height of BBox as values for transformation matrix.\n    int width = ((int) (this.getStructure().getFormatterRectangle().getWidth()));\n    int height = ((int) (this.getStructure().getFormatterRectangle().getHeight()));\n    String imgFormContent = (((((\"q \" + width) + \" 0 0 \") + height) + \" 0 0 cm /\") + imageName.getName()) + \" Do Q\\n\";\n    String holderFormContent = (\"q 1 0 0 1 0 0 cm /\" + innerFormName.getName()) + \" Do Q\\n\";\n    String innerFormContent = (\"q 1 0 0 1 0 0 cm /n0 Do Q q 1 0 0 1 0 0 cm /\" + imageFormName.getName()) + \" Do Q\\n\";\n    appendRawCommands(pdfStructure.getHolderFormStream().createOutputStream(), holderFormContent);\n    appendRawCommands(pdfStructure.getInnerFormStream().createOutputStream(), innerFormContent);\n    appendRawCommands(pdfStructure.getImageFormStream().createOutputStream(), imgFormContent);\n    LOG.info(\"Injected appearance stream to pdf\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.printing.PDFPrintable.print",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.printing.PDFPrintable.print", "org.apache.pdfbox.printing.PDFPrintable.<clinit>" ],
    "fullMethods" : [ "@Override\npublic int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n    if ((pageIndex < 0) || (pageIndex >= pageTree.getCount())) {\n        return NO_SUCH_PAGE;\n    }\n    try {\n        Graphics2D graphics2D = ((Graphics2D) (graphics));\n        // capture the DPI that will be used for rasterizing the image\n        // if rasterizing is specified\n        float rasterDpi = dpi;\n        if (rasterDpi == RASTERIZE_DPI_AUTO) {\n            rasterDpi = ((float) (graphics2D.getTransform().getScaleX())) * 72.0F;\n            LOG.debug(\"auto raster dpi: \" + rasterDpi);\n        }\n        PDPage page = pageTree.get(pageIndex);\n        PDRectangle cropBox = getRotatedCropBox(page);\n        // the imageable area is the area within the page margins\n        final double imageableWidth = pageFormat.getImageableWidth();\n        final double imageableHeight = pageFormat.getImageableHeight();\n        double scale = 1;\n        if (scaling != Scaling.ACTUAL_SIZE) {\n            // scale to fit\n            double scaleX = imageableWidth / cropBox.getWidth();\n            double scaleY = imageableHeight / cropBox.getHeight();\n            scale = Math.min(scaleX, scaleY);\n            // only shrink to fit when enabled\n            if ((scale > 1) && (scaling == Scaling.SHRINK_TO_FIT)) {\n                scale = 1;\n            }\n            // only stretch to fit when enabled\n            if ((scale < 1) && (scaling == Scaling.STRETCH_TO_FIT)) {\n                scale = 1;\n            }\n        }\n        // set the graphics origin to the origin of the imageable area (i.e the margins)\n        graphics2D.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n        // center on page\n        if (center) {\n            double dx = (imageableWidth - (cropBox.getWidth() * scale)) / 2;\n            double dy = (imageableHeight - (cropBox.getHeight() * scale)) / 2;\n            if ((dx >= 0) && (dy >= 0)) {\n                graphics2D.translate(dx, dy);\n            } else {\n                // PDFBOX-3117 and https://lists.apache.org/thread/12s9tc93ofgmjfq1dpqfps9p725l0wwr\n                LOG.warn((((\"Centering disabled because of negative translation value (\" + dx) + \",\") + dy) + \")\");\n            }\n        }\n        // rasterize to bitmap (optional)\n        Graphics2D printerGraphics = null;\n        BufferedImage image = null;\n        if ((dpi > 0) || (dpi == RASTERIZE_DPI_AUTO)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"dpi set to \" + rasterDpi);\n            }\n            float dpiScale = rasterDpi / 72;\n            image = new BufferedImage(((int) ((imageableWidth * dpiScale) / scale)), ((int) ((imageableHeight * dpiScale) / scale)), BufferedImage.TYPE_INT_ARGB);\n            printerGraphics = graphics2D;\n            graphics2D = image.createGraphics();\n            // rescale\n            printerGraphics.scale(scale / dpiScale, scale / dpiScale);\n            scale = dpiScale;\n        }\n        // draw to graphics using PDFRender\n        AffineTransform transform = graphics2D.getTransform();\n        graphics2D.setBackground(Color.WHITE);\n        renderer.setSubsamplingAllowed(subsamplingAllowed);\n        renderer.setRenderingHints(renderingHints);\n        renderer.renderPageToGraphics(pageIndex, graphics2D, ((float) (scale)), ((float) (scale)), RenderDestination.PRINT);\n        // draw crop box\n        if (showPageBorder) {\n            graphics2D.setTransform(transform);\n            graphics2D.setClip(0, 0, ((int) (imageableWidth)), ((int) (imageableHeight)));\n            graphics2D.scale(scale, scale);\n            graphics2D.setColor(Color.GRAY);\n            graphics2D.setStroke(new BasicStroke(0.5F));\n            graphics.drawRect(0, 0, ((int) (cropBox.getWidth())), ((int) (cropBox.getHeight())));\n        }\n        // draw rasterized bitmap (optional)\n        if (printerGraphics != null) {\n            printerGraphics.setBackground(Color.WHITE);\n            printerGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());\n            printerGraphics.drawImage(image, 0, 0, null);\n            graphics2D.dispose();\n        }\n        return PAGE_EXISTS;\n    } catch (IOException e) {\n        throw new PrinterIOException(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getRawRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getRawRaster", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "@Override\npublic WritableRaster getRawRaster() throws IOException {\n    return SampledImageReader.getRawRaster(this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerForm",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerForm", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createInnerForm(PDResources innerFormResources, PDStream innerFormStream, PDRectangle bbox) {\n    PDFormXObject innerForm = new PDFormXObject(innerFormStream);\n    innerForm.setResources(innerFormResources);\n    innerForm.setBBox(bbox);\n    innerForm.setFormType(1);\n    pdfStructure.setInnerForm(innerForm);\n    LOG.info(\"Another form (inner form - it will be inside holder form) has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationLink.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationLink.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationLink.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationLink(COSDictionary a) {\n    super(a);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceCharacteristicsDictionary.getBorderColour",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceCharacteristicsDictionary.getBorderColour", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceCharacteristicsDictionary.getColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the border color.\n *\n * @return the border color.\n */\npublic PDColor getBorderColour() {\n    return getColor(COSName.BC);\n}", "private PDColor getColor(COSName itemName) {\n    COSArray cs = getCOSObject().getCOSArray(itemName);\n    if (cs != null) {\n        PDColorSpace colorSpace;\n        switch (cs.size()) {\n            case 1 :\n                colorSpace = PDDeviceGray.INSTANCE;\n                break;\n            case 3 :\n                colorSpace = PDDeviceRGB.INSTANCE;\n                break;\n            case 4 :\n                colorSpace = PDDeviceCMYK.INSTANCE;\n                break;\n            default :\n                return null;\n        }\n        return new PDColor(cs, colorSpace);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingContext.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type1ShadingContext(shading, cm, xform, matrix);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.state.SetLineDashPattern.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.state.SetLineDashPattern.process", "org.apache.pdfbox.contentstream.operator.state.SetLineDashPattern.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws MissingOperandException {\n    if (arguments.size() < 2) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    if (!(base0 instanceof COSArray)) {\n        return;\n    }\n    COSBase base1 = arguments.get(1);\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    COSArray dashArray = ((COSArray) (base0));\n    int dashPhase = ((COSNumber) (base1)).intValue();\n    for (COSBase base : dashArray) {\n        if (base instanceof COSNumber) {\n            COSNumber num = ((COSNumber) (base));\n            if (Float.compare(num.floatValue(), 0) != 0) {\n                break;\n            }\n        } else {\n            LOG.warn((\"dash array has non number element \" + base) + \", ignored\");\n            dashArray = new COSArray();\n            break;\n        }\n    }\n    getContext().setLineDashPattern(dashArray, dashPhase);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.markedcontent.DrawObject.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.markedcontent.DrawObject.process", "org.apache.pdfbox.contentstream.operator.markedcontent.DrawObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    if (arguments.isEmpty()) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    COSName name = ((COSName) (base0));\n    PDFStreamEngine context = getContext();\n    PDXObject xobject = context.getResources().getXObject(name);\n    ((PDFMarkedContentExtractor) (context)).xobject(xobject);\n    if (xobject instanceof PDFormXObject) {\n        try {\n            context.increaseLevel();\n            if (context.getLevel() > 50) {\n                LOG.error(\"recursion is too deep, skipping form XObject\");\n                return;\n            }\n            if (xobject instanceof PDTransparencyGroup) {\n                context.showTransparencyGroup(((PDTransparencyGroup) (xobject)));\n            } else {\n                context.showForm(((PDFormXObject) (xobject)));\n            }\n        } finally {\n            context.decreaseLevel();\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerFormStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerFormStream", "org.apache.pdfbox.pdmodel.common.PDStream.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createInnerFormStream(PDDocument template) {\n    PDStream innerFormStream = new PDStream(template);\n    pdfStructure.setInnterFormStream(innerFormStream);\n    LOG.info(\"Stream of another form (inner form - it will be inside holder form) \" + \"has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDNamedDestination.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDNamedDestination.<init>", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param dest\n * \t\tThe named destination.\n */\npublic PDNamedDestination(COSString dest) {\n    namedDestination = dest;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationCircle.constructAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationCircle.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCircleAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void constructAppearances(PDDocument document) {\n    if (customAppearanceHandler == null) {\n        PDCircleAppearanceHandler appearanceHandler = new PDCircleAppearanceHandler(this, document);\n        appearanceHandler.generateAppearanceStreams();\n    } else {\n        customAppearanceHandler.generateAppearanceStreams();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showAnnotation",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showAnnotation", "org.apache.pdfbox.contentstream.PDFStreamEngine.processAnnotation", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getRectangle", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<clinit>" ],
    "fullMethods" : [ "/**\n * Shows the given annotation.\n *\n * @param annotation\n * \t\tAn annotation on the current page.\n * @throws IOException\n * \t\tIf an error occurred reading the annotation\n */\npublic void showAnnotation(PDAnnotation annotation) throws IOException {\n    PDAppearanceStream appearanceStream = getAppearance(annotation);\n    if (appearanceStream != null) {\n        processAnnotation(annotation, appearanceStream);\n    }\n}", "/**\n * Process the given annotation with the specified appearance stream.\n *\n * @param annotation\n * \t\tThe annotation containing the appearance stream to process.\n * @param appearance\n * \t\tThe appearance stream to process.\n * @throws IOException\n * \t\tIf there is an error reading or parsing the appearance content stream.\n */\nprotected void processAnnotation(PDAnnotation annotation, PDAppearanceStream appearance) throws IOException {\n    PDRectangle bbox = appearance.getBBox();\n    PDRectangle rect = annotation.getRectangle();\n    // zero-sized rectangles are not valid\n    if ((((((rect != null) && (rect.getWidth() > 0)) && (rect.getHeight() > 0)) && (bbox != null)) && (bbox.getWidth() > 0)) && (bbox.getHeight() > 0)) {\n        PDResources parent = pushResources(appearance);\n        Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n        Matrix matrix = appearance.getMatrix();\n        // transformed appearance box  fixme: may be an arbitrary shape\n        Rectangle2D transformedBox = bbox.transform(matrix).getBounds2D();\n        // compute a matrix which scales and translates the transformed appearance box to align\n        // with the edges of the annotation's rectangle\n        Matrix a = Matrix.getTranslateInstance(rect.getLowerLeftX(), rect.getLowerLeftY());\n        a.scale(((float) (rect.getWidth() / transformedBox.getWidth())), ((float) (rect.getHeight() / transformedBox.getHeight())));\n        a.translate(((float) (-transformedBox.getX())), ((float) (-transformedBox.getY())));\n        // Matrix shall be concatenated with A to form a matrix AA that maps from the appearance's\n        // coordinate system to the annotation's rectangle in default user space\n        // \n        // HOWEVER only the opposite order works for rotated pages with\n        // filled fields / annotations that have a matrix in the appearance stream, see PDFBOX-3083\n        Matrix aa = Matrix.concatenate(a, matrix);\n        // make matrix AA the CTM\n        getGraphicsState().setCurrentTransformationMatrix(aa);\n        // clip to bounding box\n        clipToRect(bbox);\n        // needed for patterns in appearance streams, e.g. PDFBOX-2182\n        initialMatrix = aa.clone();\n        try {\n            processStreamOperators(appearance);\n        } finally {\n            restoreGraphicsStack(savedStack);\n            popResources(parent);\n        }\n    }\n}", "/**\n * The annotation rectangle, defining the location of the annotation on the page in default user space units. This\n * is usually required and should not return null on valid PDF documents. But where this is a parent form field with\n * children, such as radio button collections then the rectangle will be null.\n *\n * @return The Rect value of this annotation.\n */\npublic PDRectangle getRectangle() {\n    COSArray rectArray = dictionary.getCOSArray(COSName.RECT);\n    PDRectangle rectangle = null;\n    if (rectArray != null) {\n        if (((((rectArray.size() == 4) && (rectArray.getObject(0) instanceof COSNumber)) && (rectArray.getObject(1) instanceof COSNumber)) && (rectArray.getObject(2) instanceof COSNumber)) && (rectArray.getObject(3) instanceof COSNumber)) {\n            rectangle = new PDRectangle(rectArray);\n        } else {\n            LOG.warn(rectArray + \" is not a rectangle array, returning null\");\n        }\n    }\n    return rectangle;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPageLayout",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPageLayout", "org.apache.pdfbox.pdmodel.PDDocumentCatalog.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the page layout.\n *\n * @return the PageLayout of the document, if not present PageLayout.SINGLE_PAGE is returned\n */\npublic PageLayout getPageLayout() {\n    String mode = root.getNameAsString(COSName.PAGE_LAYOUT);\n    if ((mode != null) && (!mode.isEmpty())) {\n        try {\n            return PageLayout.fromString(mode);\n        } catch (IllegalArgumentException e) {\n            LOG.warn((\"Invalid PageLayout used '\" + mode) + \"' - returning PageLayout.SINGLE_PAGE\", e);\n        }\n    }\n    return PageLayout.SINGLE_PAGE;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getBitsPerComponent",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getBitsPerComponent", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "@Override\npublic int getBitsPerComponent() {\n    if (isStencil()) {\n        return 1;\n    } else {\n        initJPXValues();\n        return getCOSObject().getInt(COSName.BITS_PER_COMPONENT, COSName.BPC);\n    }\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getResources",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getResources", "org.apache.pdfbox.pdmodel.font.PDType3CharProc.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PDResources getResources() {\n    if (charStream.containsKey(COSName.RESOURCES)) {\n        // PDFBOX-5294\n        LOG.warn(\"Using resources dictionary found in charproc entry\");\n        LOG.warn(\"This should have been in the font or in the page dictionary\");\n        return new PDResources(charStream.getCOSDictionary(COSName.RESOURCES));\n    }\n    return font.getResources();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.taggedpdf.PDTableAttributeObject.setHeaders",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.taggedpdf.PDTableAttributeObject.setHeaders", "org.apache.pdfbox.pdmodel.documentinterchange.taggedpdf.PDStandardAttributeObject.setArrayOfString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the headers (Headers). An array of byte strings, where each string\n * shall be the element identifier (see the\n * {@link org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureElement#getElementIdentifier()}) for a TH structure\n * element that shall be used as a header associated with this cell.\n *\n * @param headers\n * \t\tthe headers\n */\npublic void setHeaders(String[] headers) {\n    this.setArrayOfString(HEADERS, headers);\n}", "/**\n * Sets an array of strings.\n *\n * @param name\n * \t\tthe attribute name\n * @param values\n * \t\tthe array of strings\n */\nprotected void setArrayOfString(String name, String[] values) {\n    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);\n    COSArray array = new COSArray();\n    for (String value : values) {\n        array.add(new COSString(value));\n    }\n    this.getCOSObject().setItem(name, array);\n    COSBase newBase = this.getCOSObject().getDictionaryObject(name);\n    this.potentiallyNotifyChanged(oldBase, newBase);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNProcess.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNProcess.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new DeviceN Process Dictionary.\n */\npublic PDDeviceNProcess() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3Font.getBoundingBox",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3Font.getBoundingBox", "org.apache.pdfbox.pdmodel.font.PDType3Font.generateBoundingBox", "org.apache.pdfbox.pdmodel.font.PDType3Font.<clinit>" ],
    "fullMethods" : [ "@Override\npublic BoundingBox getBoundingBox() {\n    if (fontBBox == null) {\n        fontBBox = generateBoundingBox();\n    }\n    return fontBBox;\n}", "private BoundingBox generateBoundingBox() {\n    PDRectangle rect = getFontBBox();\n    if (rect == null) {\n        LOG.warn(\"FontBBox missing, returning empty rectangle\");\n        return new BoundingBox();\n    }\n    if (!isNonZeroBoundingBox(rect)) {\n        // Plan B: get the max bounding box of the glyphs\n        COSDictionary cp = getCharProcs();\n        if (cp != null) {\n            for (COSName name : cp.keySet()) {\n                COSStream typ3CharProcStream = cp.getCOSStream(name);\n                if (typ3CharProcStream != null) {\n                    PDType3CharProc charProc = new PDType3CharProc(this, typ3CharProcStream);\n                    try {\n                        PDRectangle glyphBBox = charProc.getGlyphBBox();\n                        if (glyphBBox == null) {\n                            continue;\n                        }\n                        rect.setLowerLeftX(Math.min(rect.getLowerLeftX(), glyphBBox.getLowerLeftX()));\n                        rect.setLowerLeftY(Math.min(rect.getLowerLeftY(), glyphBBox.getLowerLeftY()));\n                        rect.setUpperRightX(Math.max(rect.getUpperRightX(), glyphBBox.getUpperRightX()));\n                        rect.setUpperRightY(Math.max(rect.getUpperRightY(), glyphBBox.getUpperRightY()));\n                    } catch (IOException ex) {\n                        // ignore\n                        LOG.debug(\"error getting the glyph bounding box - font bounding box will be used\", ex);\n                    }\n                }\n            }\n        }\n    }\n    return new BoundingBox(rect.getLowerLeftX(), rect.getLowerLeftY(), rect.getUpperRightX(), rect.getUpperRightY());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText", "org.apache.pdfbox.contentstream.PDFStreamEngine.<clinit>" ],
    "fullMethods" : [ "/**\n * Called when a string of text is to be shown.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextString(byte[] string) throws IOException {\n    showText(string);\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingContext.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type5ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.load",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.load", "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<clinit>" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a simple font.\n *\n * <p>\n * <b>Note:</b> Simple fonts only support 256 characters. For Unicode support, use\n * {@link PDType0Font#load(PDDocument, InputStream)} instead.\n * </p>\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param ttf\n * \t\tA true type font\n * @param encoding\n * \t\tThe PostScript encoding vector to be used for embedding.\n * @return a PDTrueTypeFont instance.\n * @throws IOException\n * \t\tIf there is an error loading the data.\n */\npublic static PDTrueTypeFont load(PDDocument doc, TrueTypeFont ttf, Encoding encoding) throws IOException {\n    return new PDTrueTypeFont(doc, ttf, encoding, false);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceCharacteristicsDictionary.getBackground",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceCharacteristicsDictionary.getBackground", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceCharacteristicsDictionary.getColor", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * This will retrieve the background color.\n *\n * @return the background color.\n */\npublic PDColor getBackground() {\n    return getColor(COSName.BG);\n}", "private PDColor getColor(COSName itemName) {\n    COSArray cs = getCOSObject().getCOSArray(itemName);\n    if (cs != null) {\n        PDColorSpace colorSpace;\n        switch (cs.size()) {\n            case 1 :\n                colorSpace = PDDeviceGray.INSTANCE;\n                break;\n            case 3 :\n                colorSpace = PDDeviceRGB.INSTANCE;\n                break;\n            case 4 :\n                colorSpace = PDDeviceCMYK.INSTANCE;\n                break;\n            default :\n                return null;\n        }\n        return new PDColor(cs, colorSpace);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.save",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.save", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Save the document using the given compression.\n * <p>\n * Don't use the input file as target as this will produce a corrupted file.\n * <p>\n * If encryption has been activated (with {@link #protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy)\n * protect(ProtectionPolicy)}), do not use the document after saving because the contents are now encrypted.\n * The same applies if your file was created from parts of another file and that\n * one is to be used after saving.\n *\n * @param file\n * \t\tThe file to save as.\n * @param compressParameters\n * \t\tThe parameters for the document's compression.\n * @throws IOException\n * \t\tif the output could not be written\n */\npublic void save(File file, CompressParameters compressParameters) throws IOException {\n    if (file.exists() && (file.length() > 0)) {\n        LOG.warn((\"You are overwriting the existing file \" + file.getName()) + \", this will produce a corrupted file if you're also reading from it\");\n    }\n    try (BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(file))) {\n        save(bufferedOutputStream, compressParameters);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDNamedDestination.setNamedDestination",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDNamedDestination.setNamedDestination", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the named destination.\n *\n * @param dest\n * \t\tThe new named destination.\n * @throws IOException\n * \t\tIf there is an error setting the named destination.\n */\npublic void setNamedDestination(String dest) throws IOException {\n    if (dest == null) {\n        namedDestination = null;\n    } else {\n        namedDestination = new COSString(dest);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.writeExternalSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.writeExternalSignature", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Write externally created signature of PDF data obtained via {@link #getDataToSign()} method.\n *\n * @param cmsSignature\n * \t\tCMS signature byte array\n * @throws IllegalStateException\n * \t\tif PDF is not prepared for external signing\n * @throws IOException\n * \t\tif source data stream is closed\n */\npublic void writeExternalSignature(byte[] cmsSignature) throws IOException {\n    if ((incrementPart == null) || (incrementalInput == null)) {\n        throw new IllegalStateException(\"PDF not prepared for setting signature\");\n    }\n    byte[] signatureBytes = Hex.getBytes(cmsSignature);\n    // subtract 2 bytes because of the enclosing \"<>\"\n    if (signatureBytes.length > (signatureLength - 2)) {\n        throw new IOException(\"Can't write signature, not enough space; \" + \"adjust it with SignatureOptions.setPreferredSignatureSize\");\n    }\n    // overwrite the signature Contents in the buffer\n    int incPartSigOffset = ((int) (signatureOffset - incrementalInput.length()));\n    System.arraycopy(signatureBytes, 0, incrementPart, incPartSigOffset + 1, signatureBytes.length);\n    // write the data to the incremental output stream\n    IOUtils.copy(new RandomAccessInputStream(incrementalInput), incrementalOutput);\n    incrementalOutput.write(incrementPart);\n    // prevent further use\n    incrementPart = null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFOptionElement.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFOptionElement.<init>", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFOptionElement() {\n    option = new COSArray();\n    option.add(new COSString(\"\"));\n    option.add(new COSString(\"\"));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * Check if a plaintext password is the user password.\n *\n * @param password\n * \t\tThe plaintext password.\n * @param user\n * \t\tThe u entry of the encryption dictionary.\n * @param owner\n * \t\tThe o entry of the encryption dictionary.\n * @param permissions\n * \t\tThe permissions set in the PDF.\n * @param id\n * \t\tThe document id used for encryption.\n * @param encRevision\n * \t\tThe revision of the encryption algorithm.\n * @param keyLengthInBytes\n * \t\tThe length of the encryption key in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata.\n * @return true If the plaintext password is the user password.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\npublic boolean isUserPassword(byte[] password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException {\n    switch (encRevision) {\n        case REVISION_2 :\n        case REVISION_3 :\n        case REVISION_4 :\n            return isUserPassword234(password, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);\n        case REVISION_5 :\n        case REVISION_6 :\n            return isUserPassword56(password, user, encRevision);\n        default :\n            throw new IOException(\"Unknown Encryption Revision \" + encRevision);\n    }\n}", "private boolean isUserPassword56(byte[] password, byte[] user, int encRevision) throws IOException {\n    byte[] truncatedPassword = truncate127(password);\n    byte[] uHash = new byte[32];\n    byte[] uValidationSalt = new byte[8];\n    System.arraycopy(user, 0, uHash, 0, 32);\n    System.arraycopy(user, 32, uValidationSalt, 0, 8);\n    byte[] hash;\n    if (encRevision == REVISION_5) {\n        hash = computeSHA256(truncatedPassword, uValidationSalt, null);\n    } else {\n        hash = computeHash2A(truncatedPassword, uValidationSalt, null);\n    }\n    return MessageDigest.isEqual(hash, uHash);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getStencilImage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getStencilImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns an ARGB image filled with the given paint and using the given image as a mask.\n *\n * @param paint\n * \t\tthe paint to fill the visible portions of the image with\n * @return a masked image filled with the given paint\n * @throws IOException\n * \t\tif the image cannot be read\n * @throws IllegalStateException\n * \t\tif the image is not a stencil.\n */\npublic static BufferedImage getStencilImage(PDImage pdImage, Paint paint) throws IOException {\n    int width = pdImage.getWidth();\n    int height = pdImage.getHeight();\n    // compose to ARGB\n    BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    Graphics2D g = masked.createGraphics();\n    g.setPaint(paint);\n    g.fillRect(0, 0, width, height);\n    g.dispose();\n    // set the alpha\n    WritableRaster raster = masked.getRaster();\n    final int[] transparent = new int[4];\n    // avoid getting a BufferedImage for the mask to lessen memory footprint.\n    // Such masks are always bpc=1 and have no colorspace, but have a decode.\n    // (see 8.9.6.2 Stencil Masking)\n    try (InputStream iis = pdImage.createInputStream()) {\n        final float[] decode = getDecodeArray(pdImage);\n        int value = (decode[0] < decode[1]) ? 1 : 0;\n        int rowLen = width / 8;\n        if ((width % 8) > 0) {\n            rowLen++;\n        }\n        byte[] buff = new byte[rowLen];\n        for (int y = 0; y < height; y++) {\n            int x = 0;\n            int readLen = ((int) (IOUtils.populateBuffer(iis, buff)));\n            for (int r = 0; (r < rowLen) && (r < readLen); r++) {\n                int byteValue = buff[r];\n                int mask = 128;\n                int shift = 7;\n                for (int i = 0; i < 8; i++) {\n                    int bit = (byteValue & mask) >> shift;\n                    mask >>= 1;\n                    --shift;\n                    if (bit == value) {\n                        raster.setPixel(x, y, transparent);\n                    }\n                    x++;\n                    if (x == width) {\n                        break;\n                    }\n                }\n            }\n            if (readLen != rowLen) {\n                LOG.warn(\"premature EOF, image will be incomplete\");\n                break;\n            }\n        }\n    }\n    return masked;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createPage", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void createPage(PDVisibleSignDesigner properties) {\n    PDPage page = new PDPage(new PDRectangle(properties.getPageWidth(), properties.getPageHeight()));\n    pdfStructure.setPage(page);\n    LOG.info(\"PDF page has been created\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingContext.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type4ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor for embedding.\n */\npublic PDAppearanceDictionary() {\n    dictionary = new COSDictionary();\n    // the N entry is required.\n    dictionary.setItem(COSName.N, new COSDictionary());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.text.MoveText.process",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.text.MoveText.process", "org.apache.pdfbox.contentstream.operator.text.MoveText.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws MissingOperandException {\n    if (arguments.size() < 2) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    PDFStreamEngine context = getContext();\n    Matrix textLineMatrix = context.getTextLineMatrix();\n    if (textLineMatrix == null) {\n        LOG.warn((\"TextLineMatrix is null, \" + getName()) + \" operator will be ignored\");\n        return;\n    }\n    COSBase base0 = arguments.get(0);\n    COSBase base1 = arguments.get(1);\n    if (!(base0 instanceof COSNumber)) {\n        return;\n    }\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    COSNumber x = ((COSNumber) (base0));\n    COSNumber y = ((COSNumber) (base1));\n    Matrix matrix = new Matrix(1, 0, 0, 1, x.floatValue(), y.floatValue());\n    textLineMatrix.concatenate(matrix);\n    context.setTextMatrix(textLineMatrix.clone());\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptStream",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptStream", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptData", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptDataAES256", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * This will encrypt a stream, but not the dictionary as the dictionary is\n * encrypted by visitFromString() in COSWriter and we don't want to encrypt\n * it twice.\n *\n * @param stream\n * \t\tThe stream to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void encryptStream(COSStream stream, long objNum, int genNum) throws IOException {\n    // empty streams don't need to be encrypted\n    if (!stream.hasData()) {\n        return;\n    }\n    byte[] rawData;\n    try (InputStream is = stream.createRawInputStream()) {\n        rawData = IOUtils.toByteArray(is);\n    }\n    ByteArrayInputStream encryptedStream = new ByteArrayInputStream(rawData);\n    try (OutputStream output = stream.createRawOutputStream()) {\n        /* encrypt */\n        encryptData(objNum, genNum, encryptedStream, output, false);\n    }\n}", "/**\n * Encrypt or decrypt a set of data.\n *\n * @param objectNumber\n * \t\tThe data object number.\n * @param genNumber\n * \t\tThe data generation number.\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptData(long objectNumber, long genNumber, InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    // Determine whether we're using Algorithm 1 (for RC4 and AES-128), or 1.A (for AES-256)\n    if (useAES && (encryptionKey.length == 32)) {\n        encryptDataAES256(data, output, decrypt);\n    } else {\n        byte[] finalKey = calcFinalKey(objectNumber, genNumber);\n        if (useAES) {\n            encryptDataAESother(finalKey, data, output, decrypt);\n        } else {\n            encryptDataRC4(finalKey, data, output);\n        }\n    }\n    output.flush();\n}", "/**\n * Encrypt or decrypt data with AES256.\n *\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptDataAES256(InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    byte[] iv = new byte[16];\n    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {\n        return;\n    }\n    Cipher cipher;\n    try {\n        cipher = createCipher(this.encryptionKey, iv, decrypt);\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n    try (CipherInputStream cis = new CipherInputStream(data, cipher)) {\n        IOUtils.copy(cis, output);\n    } catch (IOException exception) {\n        // starting with java 8 the JVM wraps an IOException around a GeneralSecurityException\n        // it should be safe to swallow a GeneralSecurityException\n        if (!(exception.getCause() instanceof GeneralSecurityException)) {\n            throw exception;\n        }\n        LOG.debug(\"A GeneralSecurityException occurred when decrypting some stream data\", exception);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.PDXObject.createXObject",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.PDXObject.createXObject", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new XObject instance of the appropriate type for the COS stream.\n *\n * @param base\n * \t\tThe stream which is wrapped by this XObject.\n * @param resources\n * \t\tthe resources of this XObject\n * @return A new XObject instance.\n * @throws java.io.IOException\n * \t\tif there is an error creating the XObject.\n */\npublic static PDXObject createXObject(COSBase base, PDResources resources) throws IOException {\n    if (base == null) {\n        // TODO throw an exception?\n        return null;\n    }\n    if (!(base instanceof COSStream)) {\n        throw new IOException(\"Unexpected object type: \" + base.getClass().getName());\n    }\n    COSStream stream = ((COSStream) (base));\n    String subtype = stream.getNameAsString(COSName.SUBTYPE);\n    if (COSName.IMAGE.getName().equals(subtype)) {\n        return new PDImageXObject(new PDStream(stream), resources);\n    } else if (COSName.FORM.getName().equals(subtype)) {\n        ResourceCache cache = (resources != null) ? resources.getResourceCache() : null;\n        COSDictionary group = stream.getCOSDictionary(COSName.GROUP);\n        if ((group != null) && COSName.TRANSPARENCY.equals(group.getCOSName(COSName.S))) {\n            return new PDTransparencyGroup(stream, cache);\n        }\n        return new PDFormXObject(stream, cache);\n    } else if (COSName.PS.getName().equals(subtype)) {\n        return new PDPostScriptXObject(stream);\n    } else {\n        throw new IOException(\"Invalid XObject Subtype: \" + subtype);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFIconFit.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFIconFit.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic FDFIconFit() {\n    fit = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.action.PDAdditionalActions.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.action.PDAdditionalActions.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDAdditionalActions() {\n    actions = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKey",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKey", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKeyRev56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.<clinit>" ],
    "fullMethods" : [ "/**\n * Compute the encryption key.\n *\n * @param password\n * \t\tThe password to compute the encrypted key.\n * @param o\n * \t\tThe O entry of the encryption dictionary.\n * @param u\n * \t\tThe U entry of the encryption dictionary.\n * @param oe\n * \t\tThe OE entry of the encryption dictionary.\n * @param ue\n * \t\tThe UE entry of the encryption dictionary.\n * @param permissions\n * \t\tThe permissions for the document.\n * @param id\n * \t\tThe document id.\n * @param encRevision\n * \t\tThe revision of the encryption algorithm.\n * @param keyLengthInBytes\n * \t\tThe length of the encryption key in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata\n * @param isOwnerPassword\n * \t\twhether the password given is the owner password (for revision 6)\n * @return The encrypted key bytes.\n * @throws IOException\n * \t\tIf there is an error with encryption.\n */\npublic byte[] computeEncryptedKey(byte[] password, byte[] o, byte[] u, byte[] oe, byte[] ue, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata, boolean isOwnerPassword) throws IOException {\n    if ((encRevision == REVISION_5) || (encRevision == REVISION_6)) {\n        return computeEncryptedKeyRev56(password, isOwnerPassword, o, u, oe, ue, encRevision);\n    } else {\n        return computeEncryptedKeyRev234(password, o, permissions, id, encryptMetadata, keyLengthInBytes, encRevision);\n    }\n}", "private byte[] computeEncryptedKeyRev56(byte[] password, boolean isOwnerPassword, byte[] o, byte[] u, byte[] oe, byte[] ue, int encRevision) throws IOException {\n    byte[] hash;\n    byte[] fileKeyEnc;\n    if (isOwnerPassword) {\n        if (oe == null) {\n            throw new IOException(\"/Encrypt/OE entry is missing\");\n        }\n        byte[] oKeySalt = new byte[8];\n        System.arraycopy(o, 40, oKeySalt, 0, 8);\n        if (encRevision == REVISION_5) {\n            hash = computeSHA256(password, oKeySalt, u);\n        } else {\n            hash = computeHash2A(password, oKeySalt, u);\n        }\n        fileKeyEnc = oe;\n    } else {\n        if (ue == null) {\n            throw new IOException(\"/Encrypt/UE entry is missing\");\n        }\n        byte[] uKeySalt = new byte[8];\n        System.arraycopy(u, 40, uKeySalt, 0, 8);\n        if (encRevision == REVISION_5) {\n            hash = computeSHA256(password, uKeySalt, null);\n        } else {\n            hash = computeHash2A(password, uKeySalt, null);\n        }\n        fileKeyEnc = ue;\n    }\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(hash, \"AES\"), new IvParameterSpec(new byte[16]));\n        return cipher.doFinal(fileKeyEnc);\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.setValue", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the value of this field to be the given signature.\n *\n * @param value\n * \t\tis the PDSignatureField\n * @throws IOException\n * \t\tif the new value could not be applied\n */\npublic void setValue(PDSignature value) throws IOException {\n    getCOSObject().setItem(COSName.V, value);\n    applyChange();\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSObjectable value) {\n    COSBase base = null;\n    if (value != null) {\n        base = value.getCOSObject();\n    }\n    setItem(key, base);\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.<init>", "org.apache.pdfbox.cos.COSDictionary.setItem", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n *\n * @see PDTerminalField#PDTerminalField(PDAcroForm)\n * @param acroForm\n * \t\tThe acroForm for this field.\n */\npublic PDSignatureField(PDAcroForm acroForm) {\n    super(acroForm);\n    getCOSObject().setItem(COSName.FT, COSName.SIG);\n    PDAnnotationWidget firstWidget = getWidgets().get(0);\n    firstWidget.setLocked(true);\n    firstWidget.setPrinted(true);\n    setPartialName(generatePartialName());\n}", "/**\n * This will set an item in the dictionary. If value is null then the result will be the same as removeItem( key ).\n *\n * @param key\n * \t\tThe key to the dictionary object.\n * @param value\n * \t\tThe value to the dictionary object.\n */\npublic void setItem(COSName key, COSBase value) {\n    if (value == null) {\n        removeItem(key);\n    } else // wrap indirect objects\n    if ((((value instanceof COSDictionary) || (value instanceof COSArray)) && (!value.isDirect())) && (value.getKey() != null)) {\n        COSObject cosObject = new COSObject(value, value.getKey());\n        items.put(key, cosObject);\n        getUpdateState().update(cosObject);\n    } else {\n        items.put(key, value);\n        getUpdateState().update(value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadFDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadFDF", "org.apache.pdfbox.pdfparser.COSParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will load a document from a file.\n *\n * @param file\n * \t\tThe name of the file to load. {@link org.apache.pdfbox.io.RandomAccessReadBufferedFile} is used to\n * \t\tread the file.\n * @return The document that was loaded.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\npublic static FDFDocument loadFDF(File file) throws IOException {\n    RandomAccessRead raFile = null;\n    try {\n        // PDFBOX-5894: RandomAccessRead is not closed here\n        raFile = new RandomAccessReadBufferedFile(file);\n        FDFParser parser = new FDFParser(raFile);\n        return parser.parse();\n    } catch (IOException ioe) {\n        IOUtils.closeQuietly(raFile);\n        throw ioe;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.setValue", "org.apache.pdfbox.cos.COSDictionary.setString", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the plain text value of this field, and try to update the visual appearance.\n *\n * @param value\n * \t\tPlain text\n * @throws IOException\n * \t\tif the value could not be set\n */\n@Override\npublic void setValue(String value) throws IOException {\n    getCOSObject().setString(COSName.V, value);\n    applyChange();\n}", "/**\n * This is a convenience method that will convert the value to a COSString object. If it is null then the object\n * will be removed.\n *\n * @param key\n * \t\tThe key to the object,\n * @param value\n * \t\tThe string value for the name.\n */\npublic void setString(COSName key, String value) {\n    COSString name = null;\n    if (value != null) {\n        name = new COSString(value);\n    }\n    setItem(key, name);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDPropBuild.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDPropBuild.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Default constructor.\n */\npublic PDPropBuild() {\n    dictionary = new COSDictionary();\n    dictionary.setDirect(true);// the specification claim to use direct objects\n\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.removeOID",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSeedValueCertificate.removeOID", "org.apache.pdfbox.cos.COSString.<clinit>" ],
    "fullMethods" : [ "/**\n * removes an OID from the list\n *\n * @param oid\n * \t\tObject Identifier of the certificate policy to be removed\n */\npublic void removeOID(byte[] oid) {\n    COSArray array = dictionary.getCOSArray(COSName.OID);\n    if (array != null) {\n        array.remove(new COSString(oid));\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDPageDestination.getPage",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDPageDestination.getPage", "org.apache.pdfbox.pdmodel.PDPage.<clinit>" ],
    "fullMethods" : [ "/**\n * This will get the page for this destination. A page destination can either reference a page\n * (for a local destination) or a page number (when doing a remote destination to another PDF).\n * If this object is referencing by page number then this method will return null and\n * {@link #getPageNumber()} should be used.\n *\n * @return The page for this destination.\n */\npublic PDPage getPage() {\n    PDPage retval = null;\n    if (array.size() > 0) {\n        COSBase page = array.getObject(0);\n        if (page instanceof COSDictionary) {\n            retval = new PDPage(((COSDictionary) (page)));\n        }\n    }\n    return retval;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.optionalcontent.PDOptionalContentProperties.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a new optional content properties dictionary.\n */\npublic PDOptionalContentProperties() {\n    this.dict = new COSDictionary();\n    this.dict.setItem(COSName.OCGS, new COSArray());\n    COSDictionary d = new COSDictionary();\n    // Name optional but required for PDF/A-3\n    d.setString(COSName.NAME, \"Top\");\n    this.dict.setItem(COSName.D, d);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.toUnicode", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the Unicode character sequence for the given glyph name, or null if there isn't any.\n *\n * @param name\n * \t\tPostScript glyph name\n * @return Unicode character(s), or null.\n */\npublic String toUnicode(String name) {\n    if (name == null) {\n        return null;\n    }\n    String unicode = nameToUnicode.get(name);\n    if (unicode != null) {\n        return unicode;\n    }\n    // separate read/write cache for thread safety\n    unicode = uniNameToUnicodeCache.get(name);\n    if (unicode == null) {\n        // test if we have a suffix and if so remove it\n        if (name.indexOf('.') > 0) {\n            unicode = toUnicode(name.substring(0, name.indexOf('.')));\n        } else if (((name.length() == 7) && name.startsWith(\"uni\")) || ((name.length() == 5) && name.startsWith(\"u\"))) {\n            // test for Unicode name in the format uniXXXX where X is hex\n            int start = (name.length() == 7) ? 3 : 1;\n            try {\n                int codePoint = Integer.parseInt(name.substring(start), 16);\n                if ((codePoint > 0xd7ff) && (codePoint < 0xe000)) {\n                    LOG.warn(\"Unicode character name with disallowed code area: \" + name);\n                } else {\n                    unicode = String.valueOf(((char) (codePoint)));\n                }\n            } catch (NumberFormatException nfe) {\n                LOG.warn(\"Not a number in Unicode character name: \" + name);\n            }\n        }\n        if (unicode != null) {\n            // null value not allowed in ConcurrentHashMap\n            uniNameToUnicodeCache.put(name, unicode);\n        }\n    }\n    return unicode;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.getString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.getString", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns a hex string of the given byte array.\n *\n * @param bytes\n * \t\tthe bytes to be converted\n * @return the hex string representing the given bytes\n */\npublic static String getString(byte[] bytes) {\n    StringBuilder string = new StringBuilder(bytes.length * 2);\n    for (byte b : bytes) {\n        string.append(HEX_CHARS[getHighNibble(b)]).append(HEX_CHARS[getLowNibble(b)]);\n    }\n    return string.toString();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSName.writePDF",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSName.writePDF", "org.apache.pdfbox.util.Hex.<clinit>" ],
    "fullMethods" : [ "/**\n * This will output this string as a PDF object.\n *\n * @param output\n * \t\tThe stream to write to.\n * @throws IOException\n * \t\tIf there is an error writing to the stream.\n */\npublic void writePDF(OutputStream output) throws IOException {\n    output.write('/');\n    byte[] bytes = getName().getBytes(StandardCharsets.UTF_8);\n    for (byte b : bytes) {\n        int current = b & 0xff;\n        // be more restrictive than the PDF spec, \"Name Objects\", see PDFBOX-2073\n        if ((((((((((((current >= 'A') && (current <= 'Z')) || ((current >= 'a') && (current <= 'z'))) || ((current >= '0') && (current <= '9'))) || (current == '+')) || (current == '-')) || (current == '_')) || (current == '@')) || (current == '*')) || (current == '$')) || (current == ';')) || (current == '.')) {\n            output.write(current);\n        } else {\n            output.write('#');\n            Hex.writeHexByte(b, output);\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDBorderEffectDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDBorderEffectDictionary.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor.\n */\npublic PDBorderEffectDictionary() {\n    dictionary = new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given XObject to the resources of the current page and returns the name for the\n * new resources. Returns the existing resource name if the given item already exists.\n *\n * @param xobject\n * \t\tthe XObject to add\n * @param prefix\n * \t\tthe prefix to be used when creating the resource name\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDXObject xobject, String prefix) {\n    return add(COSName.XOBJECT, prefix, xobject);\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.insertSiblingAfter",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.insertSiblingAfter", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.getParent", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.<clinit>" ],
    "fullMethods" : [ "/**\n * Insert a single sibling after this node.\n *\n * @param newSibling\n * \t\tThe item to insert.\n * @throws IllegalArgumentException\n * \t\tif the given sibling node is part of a list\n * \t\t(i.e. if it has a previous or a next sibling)\n */\npublic void insertSiblingAfter(PDOutlineItem newSibling) {\n    requireSingleNode(newSibling);\n    PDOutlineNode parent = getParent();\n    newSibling.setParent(parent);\n    PDOutlineItem next = getNextSibling();\n    setNextSibling(newSibling);\n    newSibling.setPreviousSibling(this);\n    if (next != null) {\n        newSibling.setNextSibling(next);\n        next.setPreviousSibling(newSibling);\n    } else if (parent != null) {\n        getParent().setLastChild(newSibling);\n    }\n    updateParentOpenCountForAddedChild(newSibling);\n}", "/**\n *\n * @return The parent of this node or null if there is no parent.\n */\nPDOutlineNode getParent() {\n    COSDictionary parent = getCOSObject().getCOSDictionary(COSName.PARENT);\n    if (parent != null) {\n        if (COSName.OUTLINES.equals(parent.getCOSName(COSName.TYPE))) {\n            return new PDDocumentOutline(parent);\n        }\n        return new PDOutlineItem(parent);\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeToken",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeToken", "org.apache.pdfbox.pdfwriter.ContentStreamWriter.writeObject", "org.apache.pdfbox.pdfwriter.COSWriter.<clinit>" ],
    "fullMethods" : [ "/**\n * Writes a single operand token.\n *\n * @param base\n * \t\tThe operand to write to the stream.\n * @throws IOException\n * \t\tIf there is an error writing to the stream.\n */\npublic void writeToken(COSBase base) throws IOException {\n    writeObject(base);\n}", "private void writeObject(COSBase o) throws IOException {\n    if (o instanceof COSString) {\n        COSWriter.writeString(((COSString) (o)), output);\n        output.write(SPACE);\n    } else if (o instanceof COSFloat) {\n        ((COSFloat) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSInteger) {\n        ((COSInteger) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSBoolean) {\n        ((COSBoolean) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSName) {\n        ((COSName) (o)).writePDF(output);\n        output.write(SPACE);\n    } else if (o instanceof COSArray) {\n        COSArray array = ((COSArray) (o));\n        output.write(COSWriter.ARRAY_OPEN);\n        for (int i = 0; i < array.size(); i++) {\n            writeObject(array.get(i));\n        }\n        output.write(COSWriter.ARRAY_CLOSE);\n        output.write(SPACE);\n    } else if (o instanceof COSDictionary) {\n        COSDictionary obj = ((COSDictionary) (o));\n        output.write(COSWriter.DICT_OPEN);\n        for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {\n            if (entry.getValue() != null) {\n                writeObject(entry.getKey());\n                writeObject(entry.getValue());\n            }\n        }\n        output.write(COSWriter.DICT_CLOSE);\n        output.write(SPACE);\n    } else if (o instanceof COSNull) {\n        output.write(\"null\".getBytes(StandardCharsets.US_ASCII));\n        output.write(SPACE);\n    } else {\n        throw new IOException(\"Error:Unknown type in content stream:\" + o);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setStrokingColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setStrokingColor", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceCMYK.<clinit>", "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceCMYK.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the stroking color in the DeviceCMYK color space. Range is 0..1\n *\n * @param c\n * \t\tThe cyan value.\n * @param m\n * \t\tThe magenta value.\n * @param y\n * \t\tThe yellow value.\n * @param k\n * \t\tThe black value.\n * @throws IOException\n * \t\tIf an IO error occurs while writing to the stream.\n * @throws IllegalArgumentException\n * \t\tIf the parameters are invalid.\n */\npublic void setStrokingColor(float c, float m, float y, float k) throws IOException {\n    if (((isOutsideOneInterval(c) || isOutsideOneInterval(m)) || isOutsideOneInterval(y)) || isOutsideOneInterval(k)) {\n        throw new IllegalArgumentException(\"Parameters must be within 0..1, but are \" + String.format(\"(%.2f,%.2f,%.2f,%.2f)\", c, m, y, k));\n    }\n    writeOperand(c);\n    writeOperand(m);\n    writeOperand(y);\n    writeOperand(k);\n    writeOperator(OperatorName.STROKING_COLOR_CMYK);\n    setStrokingColorSpaceStack(PDDeviceCMYK.INSTANCE);\n}", "", "protected PDDeviceCMYK() {\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.function.PDFunction.create",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.function.PDFunction.create", "org.apache.pdfbox.pdmodel.common.function.PDFunctionType0.<clinit>" ],
    "fullMethods" : [ "/**\n * Create the correct PD Model function based on the COS base function.\n *\n * @param function\n * \t\tThe COS function dictionary.\n * @return The PDModel Function object, never null.\n * @throws IOException\n * \t\tIf we are unable to create the PDFunction object.\n */\npublic static PDFunction create(COSBase function) throws IOException {\n    if (function == COSName.IDENTITY) {\n        return new PDFunctionTypeIdentity(null);\n    }\n    COSBase base = function;\n    if (function instanceof COSObject) {\n        base = ((COSObject) (function)).getObject();\n    }\n    if (!(base instanceof COSDictionary)) {\n        throw new IOException(\"Error: Function must be a Dictionary, but is \" + (base == null ? \"(null)\" : base.getClass().getSimpleName()));\n    }\n    COSDictionary functionDictionary = ((COSDictionary) (base));\n    int functionType = functionDictionary.getInt(COSName.FUNCTION_TYPE);\n    switch (functionType) {\n        case 0 :\n            return new PDFunctionType0(functionDictionary);\n        case 2 :\n            return new PDFunctionType2(functionDictionary);\n        case 3 :\n            return new PDFunctionType3(functionDictionary);\n        case 4 :\n            return new PDFunctionType4(functionDictionary);\n        default :\n            throw new IOException(\"Error: Unknown function type \" + functionType);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.<init>", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor for embedding.\n */\npublic PDResources() {\n    resources = new COSDictionary();\n    cache = null;\n    directFontCache = new HashMap<>();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given property list to the resources of the current page and returns the name for\n * the new resources. Returns the existing resource name if the given item already exists.\n *\n * @param properties\n * \t\tthe property list to add\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDPropertyList properties) {\n    if (properties instanceof PDOptionalContentGroup) {\n        return add(COSName.PROPERTIES, \"oc\", properties);\n    } else {\n        return add(COSName.PROPERTIES, \"Prop\", properties);\n    }\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.setEmbeddedString",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.setEmbeddedString", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * This is a convenience method that will convert the value to a COSString object. If it is null then the object\n * will be removed.\n *\n * @param embedded\n * \t\tThe embedded dictionary to set the item in.\n * @param key\n * \t\tThe key to the object,\n * @param value\n * \t\tThe string value for the name.\n */\npublic void setEmbeddedString(COSName embedded, COSName key, String value) {\n    COSDictionary dic = getCOSDictionary(embedded);\n    if ((dic == null) && (value != null)) {\n        dic = new COSDictionary();\n        setItem(embedded, dic);\n    }\n    if (dic != null) {\n        dic.setString(key, value);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.add",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.pdmodel.PDResources.add", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.cos.COSObject.<clinit>" ],
    "fullMethods" : [ "/**\n * Adds the given font to the resources of the current page and returns the name for the\n * new resources. Returns the existing resource name if the given item already exists.\n *\n * @param font\n * \t\tthe font to add\n * @return the name of the resource in the resources dictionary\n */\npublic COSName add(PDFont font) {\n    return add(COSName.FONT, \"F\", font);\n}", "/**\n * Adds the given resource if it does not already exist.\n */\nprivate COSName add(COSName kind, String prefix, COSObjectable object) {\n    // return the existing key if the item exists already\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if ((dict != null) && dict.containsValue(object.getCOSObject())) {\n        return dict.getKeyForValue(object.getCOSObject());\n    }\n    // PDFBOX-4509: It could exist as an indirect object, happens when a font is taken from the\n    // AcroForm default resources of a loaded PDF.\n    if ((dict != null) && COSName.FONT.equals(kind)) {\n        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {\n            if ((entry.getValue() instanceof COSObject) && (object.getCOSObject() == ((COSObject) (entry.getValue())).getObject())) {\n                return entry.getKey();\n            }\n        }\n    }\n    // add the item with a new key\n    COSName name = createKey(kind, prefix);\n    put(kind, name, object);\n    return name;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.ASCIIHexFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.ASCIIHexFilter.decode", "org.apache.pdfbox.filter.ASCIIHexFilter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    int value;\n    int firstByte;\n    int secondByte;\n    while ((firstByte = encoded.read()) != (-1)) {\n        // always after first char\n        while (isWhitespace(firstByte)) {\n            firstByte = encoded.read();\n        } \n        if ((firstByte == (-1)) || isEOD(firstByte)) {\n            break;\n        }\n        if (REVERSE_HEX[firstByte] == (-1)) {\n            LOG.error(((\"Invalid hex, int: \" + firstByte) + \" char: \") + ((char) (firstByte)));\n        }\n        value = REVERSE_HEX[firstByte] * 16;\n        secondByte = encoded.read();\n        if ((secondByte == (-1)) || isEOD(secondByte)) {\n            // second value behaves like 0 in case of EOD\n            decoded.write(value);\n            break;\n        }\n        if (REVERSE_HEX[secondByte] == (-1)) {\n            LOG.error(((\"Invalid hex, int: \" + secondByte) + \" char: \") + ((char) (secondByte)));\n        }\n        value += REVERSE_HEX[secondByte];\n        decoded.write(value);\n    } \n    decoded.flush();\n    return new DecodeResult(parameters);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFMergerUtility.mergeDocuments",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFMergerUtility.mergeDocuments", "org.apache.pdfbox.multipdf.PDFMergerUtility.legacyMergeDocuments", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Merge the list of source documents, saving the result in the destination file. The source\n * list is not reset after merge. If you want to merge one document at a time, then it's better\n * to use\n * {@link #appendDocument(org.apache.pdfbox.pdmodel.PDDocument, org.apache.pdfbox.pdmodel.PDDocument)}.\n *\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache; in case of <code>null</code>\n * \t\tunrestricted main memory is used\n * @param compressParameters\n * \t\tdefines if compressed object streams are enabled\n * @throws IOException\n * \t\tIf there is an error saving the document.\n */\npublic void mergeDocuments(StreamCacheCreateFunction streamCacheCreateFunction, CompressParameters compressParameters) throws IOException {\n    if (documentMergeMode == DocumentMergeMode.PDFBOX_LEGACY_MODE) {\n        legacyMergeDocuments(streamCacheCreateFunction, compressParameters);\n    } else if (documentMergeMode == DocumentMergeMode.OPTIMIZE_RESOURCES_MODE) {\n        optimizedMergeDocuments(streamCacheCreateFunction, compressParameters);\n    }\n}", "/**\n * Merge the list of source documents, saving the result in the destination file.\n *\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache; in case of <code>null</code>\n * \t\tunrestricted main memory is used\n * @throws IOException\n * \t\tIf there is an error saving the document.\n */\nprivate void legacyMergeDocuments(StreamCacheCreateFunction streamCacheCreateFunction, CompressParameters compressParameters) throws IOException {\n    if (!sources.isEmpty()) {\n        // Make sure that:\n        // - first Exception is kept\n        // - all PDDocuments are closed\n        // - all FileInputStreams are closed\n        // - there's a way to see which errors occurred\n        StreamCacheCreateFunction strmCacheFunc = (streamCacheCreateFunction != null) ? streamCacheCreateFunction : IOUtils.createMemoryOnlyStreamCache();\n        try (PDDocument destination = new PDDocument(strmCacheFunc)) {\n            for (Object sourceObject : sources) {\n                PDDocument sourceDoc;\n                if (sourceObject instanceof File) {\n                    sourceDoc = Loader.loadPDF(((File) (sourceObject)));\n                } else {\n                    sourceDoc = Loader.loadPDF(((RandomAccessRead) (sourceObject)));\n                }\n                try {\n                    appendDocument(destination, sourceDoc);\n                } finally {\n                    IOUtils.closeAndLogException(sourceDoc, LOG, \"PDDocument\", null);\n                }\n            }\n            // optionally set meta data\n            if (destinationDocumentInformation != null) {\n                destination.setDocumentInformation(destinationDocumentInformation);\n            }\n            if (destinationMetadata != null) {\n                destination.getDocumentCatalog().setMetadata(destinationMetadata);\n            }\n            if (destinationStream == null) {\n                destination.save(destinationFileName, compressParameters);\n            } else {\n                destination.save(destinationStream, compressParameters);\n            }\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.CCITTFaxFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.CCITTFaxFilter.decode", "org.apache.pdfbox.filter.Filter.getDecodeParams", "org.apache.pdfbox.filter.Filter.<clinit>" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    // get decode parameters\n    COSDictionary decodeParms = getDecodeParams(parameters, index);\n    // parse dimensions\n    int cols = decodeParms.getInt(COSName.COLUMNS, 1728);\n    int rows = decodeParms.getInt(COSName.ROWS, 0);\n    int height = parameters.getInt(COSName.HEIGHT, COSName.H, 0);\n    if ((rows > 0) && (height > 0)) {\n        // PDFBOX-771, PDFBOX-3727: rows in DecodeParms sometimes contains an incorrect value\n        rows = height;\n    } else {\n        // at least one of the values has to have a valid value\n        rows = Math.max(rows, height);\n    }\n    // decompress data\n    int k = decodeParms.getInt(COSName.K, 0);\n    boolean encodedByteAlign = decodeParms.getBoolean(COSName.ENCODED_BYTE_ALIGN, false);\n    int arraySize = ((cols + 7) / 8) * rows;\n    // TODO possible options??\n    byte[] decompressed = new byte[arraySize];\n    CCITTFaxDecoderStream s;\n    int type;\n    long tiffOptions = 0;\n    if (k == 0) {\n        if (decodeParms.containsKey(COSName.END_OF_LINE)) {\n            // PDFBOX-6080: respect the parameter if it exists\n            boolean hasEndOfLine = decodeParms.getBoolean(COSName.END_OF_LINE, false);\n            type = (hasEndOfLine) ? TIFFExtension.COMPRESSION_CCITT_T4 : TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE;\n        } else {\n            // In twelvemonkeys, this part is found in CCITTFaxDecoderStream.findCompressionType()\n            // needed for 015315-p8-ccitt.pdf, PDFBOX-2123-1bit.pdf, PDFBOX-2778.pdf\n            type = TIFFExtension.COMPRESSION_CCITT_T4;// Group 3 1D\n\n            byte[] streamData = new byte[20];\n            int bytesRead = encoded.read(streamData);\n            if (bytesRead == (-1)) {\n                throw new IOException(\"EOF while reading CCITT header\");\n            }\n            PushbackInputStream pushbackInputStream = new PushbackInputStream(encoded, streamData.length);\n            pushbackInputStream.unread(streamData, 0, bytesRead);\n            encoded = pushbackInputStream;\n            if ((streamData[0] != 0) || (((streamData[1] >> 4) != 1) && (streamData[1] != 1))) {\n                // leading EOL (0b000000000001) not found, search further and try RLE if not found\n                type = TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE;\n                short b = ((short) (((streamData[0] << 8) + (streamData[1] & 0xff)) >> 4));\n                for (int i = 12; i < (bytesRead * 8); i++) {\n                    b = ((short) ((b << 1) + ((streamData[i / 8] >> (7 - (i % 8))) & 0x1)));\n                    if ((b & 0xfff) == 1) {\n                        type = TIFFExtension.COMPRESSION_CCITT_T4;\n                        break;\n                    }\n                }\n            }\n        }\n    } else if (k > 0) {\n        // Group 3 2D\n        type = TIFFExtension.COMPRESSION_CCITT_T4;\n        tiffOptions = TIFFExtension.GROUP3OPT_2DENCODING;\n    } else {\n        // Group 4\n        type = TIFFExtension.COMPRESSION_CCITT_T6;\n    }\n    s = new CCITTFaxDecoderStream(encoded, cols, type, tiffOptions, encodedByteAlign);\n    readFromDecoderStream(s, decompressed);\n    // invert bitmap\n    boolean blackIsOne = decodeParms.getBoolean(COSName.BLACK_IS_1, false);\n    if (!blackIsOne) {\n        // Inverting the bitmap\n        // Note the previous approach with starting from an IndexColorModel didn't work\n        // reliably. In some cases the image wouldn't be painted for some reason.\n        // So a safe but slower approach was taken.\n        invertBitmap(decompressed);\n    }\n    decoded.write(decompressed);\n    return new DecodeResult(parameters);\n}", "// gets the decode params for a specific filter index, this is used to\n// normalise the DecodeParams entry so that it is always a dictionary\nprotected COSDictionary getDecodeParams(COSDictionary dictionary, int index) {\n    COSBase filter = dictionary.getDictionaryObject(COSName.F, COSName.FILTER);\n    COSBase obj = dictionary.getDictionaryObject(COSName.DP, COSName.DECODE_PARMS);\n    if ((filter instanceof COSName) && (obj instanceof COSDictionary)) {\n        // PDFBOX-3932: The PDF specification requires \"If there is only one filter and that\n        // filter has parameters, DecodeParms shall be set to the filterâs parameter dictionary\"\n        // but tests show that Adobe means \"one filter name object\".\n        return ((COSDictionary) (obj));\n    } else if ((filter instanceof COSArray) && (obj instanceof COSArray)) {\n        COSArray array = ((COSArray) (obj));\n        if (index < array.size()) {\n            COSBase objAtIndex = array.getObject(index);\n            if (objAtIndex instanceof COSDictionary) {\n                return ((COSDictionary) (objAtIndex));\n            }\n        }\n    } else if ((obj != null) && (!((filter instanceof COSArray) || (obj instanceof COSArray)))) {\n        LOG.error(\"Expected DecodeParams to be an Array or Dictionary but found \" + obj.getClass().getName());\n    }\n    return new COSDictionary();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDResources.put",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.pdmodel.PDResources.put", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the color space resource with the given name.\n *\n * @param name\n * \t\tthe name of the resource\n * @param colorSpace\n * \t\tthe color space to be added\n */\npublic void put(COSName name, PDColorSpace colorSpace) {\n    put(COSName.COLORSPACE, name, colorSpace);\n}", "/**\n * Sets the value of a given named resource.\n */\nprivate void put(COSName kind, COSName name, COSObjectable object) {\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    if (dict == null) {\n        dict = new COSDictionary();\n        resources.setItem(kind, dict);\n    }\n    dict.setItem(name, object);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFileAttachmentAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFileAttachmentAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFileAttachmentAppearanceHandler.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationFileAttachment annotation = ((PDAnnotationFileAttachment) (getAnnotation()));\n    PDRectangle rect = getRectangle();\n    if (rect == null) {\n        return;\n    }\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        // minimum code of PDTextAppearanceHandler.adjustRectAndBBox()\n        int size = 18;\n        rect.setUpperRightX(rect.getLowerLeftX() + size);\n        rect.setLowerLeftY(rect.getUpperRightY() - size);\n        annotation.setRectangle(rect);\n        annotation.getNormalAppearanceStream().setBBox(new PDRectangle(size, size));\n        // test case: pdf_commenting_new.pdf page 7\n        String attachmentName = annotation.getAttachmentName();\n        switch (attachmentName) {\n            case \"Paperclip\" :\n                drawPaperclip(contentStream);\n                break;\n            case \"Graph\" :\n                drawGraph(contentStream);\n                break;\n            case \"Tag\" :\n                drawTag(contentStream);\n                break;\n            default :\n                drawPushPin(contentStream);\n                break;\n        }\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.setEmbeddedDate",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.setEmbeddedDate", "org.apache.pdfbox.cos.COSDictionary.<clinit>" ],
    "fullMethods" : [ "/**\n * Set the date object.\n *\n * @param embedded\n * \t\tThe embedded dictionary.\n * @param key\n * \t\tThe key to the date.\n * @param date\n * \t\tThe date to set.\n */\npublic void setEmbeddedDate(COSName embedded, COSName key, Calendar date) {\n    COSDictionary dic = getCOSDictionary(embedded);\n    if ((dic == null) && (date != null)) {\n        dic = new COSDictionary();\n        setItem(embedded, dic);\n    }\n    if (dic != null) {\n        dic.setDate(key, date);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDPattern.getInitialColor",
    "thirdPartyMethod" : "org.apache.commons.logging.LogFactory.getLog",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDPattern.getInitialColor", "org.apache.pdfbox.pdmodel.graphics.color.PDPattern.<clinit>", "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<clinit>" ],
    "fullMethods" : [ "@Override\npublic PDColor getInitialColor() {\n    return EMPTY_PATTERN;\n}", "", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isTraceEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<init>" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "/**\n * Constructor.\n */\nFileSystemFontProvider(FontCache cache) {\n    this.cache = cache;\n    try {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Will search the local system for fonts\");\n        }\n        // scan the local system for font files\n        FontFileFinder fontFileFinder = new FontFileFinder();\n        List<URI> fonts = fontFileFinder.find();\n        List<File> files = new ArrayList<>(fonts.size());\n        for (URI font : fonts) {\n            files.add(new File(font));\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace((\"Found \" + files.size()) + \" fonts on the local system\");\n        }\n        if (!files.isEmpty()) {\n            // load cached FontInfo objects\n            List<FSFontInfo> cachedInfos = loadDiskCache(files);\n            if ((cachedInfos != null) && (!cachedInfos.isEmpty())) {\n                fontInfoList.addAll(cachedInfos);\n            } else {\n                LOG.info(\"Building on-disk font cache, this may take a while\");\n                scanFonts(files);\n                saveDiskCache();\n                LOG.info((\"Finished building on-disk font cache, found \" + fontInfoList.size()) + \" fonts\");\n            }\n        }\n    } catch (AccessControlException e) {\n        LOG.error(\"Error accessing the file system\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerFormStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerFormStream" ],
    "fullMethods" : [ "@Override\npublic void createInnerFormStream(PDDocument template) {\n    PDStream innerFormStream = new PDStream(template);\n    pdfStructure.setInnterFormStream(innerFormStream);\n    LOG.info(\"Stream of another form (inner form - it will be inside holder form) \" + \"has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAcroForm",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAcroForm" ],
    "fullMethods" : [ "@Override\npublic void createAcroForm(PDDocument template) {\n    PDAcroForm theAcroForm = new PDAcroForm(template);\n    template.getDocumentCatalog().setAcroForm(theAcroForm);\n    pdfStructure.setAcroForm(theAcroForm);\n    LOG.info(\"AcroForm has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAffineTransform",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAffineTransform" ],
    "fullMethods" : [ "@Override\npublic void createAffineTransform(AffineTransform affineTransform) {\n    pdfStructure.setAffineTransform(affineTransform);\n    LOG.info(\"Matrix has been added\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderForm",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderForm" ],
    "fullMethods" : [ "@Override\npublic void createHolderForm(PDResources holderFormResources, PDStream holderFormStream, PDRectangle bbox) {\n    PDFormXObject holderForm = new PDFormXObject(holderFormStream);\n    holderForm.setResources(holderFormResources);\n    holderForm.setBBox(bbox);\n    holderForm.setFormType(1);\n    pdfStructure.setHolderForm(holderForm);\n    LOG.info(\"Holder form has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.TextPosition.mergeDiacritic",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.TextPosition.mergeDiacritic" ],
    "fullMethods" : [ "/**\n * Merge a single character TextPosition into the current object. This is to be used only for\n * cases where we have a diacritic that overlaps an existing TextPosition. In a graphical\n * display, we could overlay them, but for text extraction we need to merge them. Use the\n * contains() method to test if two objects overlap.\n *\n * @param diacritic\n * \t\tTextPosition to merge into the current TextPosition.\n */\npublic void mergeDiacritic(TextPosition diacritic) {\n    if (diacritic.getUnicode().length() > 1) {\n        return;\n    }\n    float diacXStart = diacritic.getXDirAdj();\n    float diacXEnd = diacXStart + diacritic.widths[0];\n    float currCharXStart = getXDirAdj();\n    int strLen = unicode.length();\n    boolean wasAdded = false;\n    for (int i = 0; (i < strLen) && (!wasAdded); i++) {\n        if (i >= widths.length) {\n            LOG.info((((\"diacritic \" + diacritic.getUnicode()) + \" on ligature \") + unicode) + \" is not supported yet and is ignored (PDFBOX-2831)\");\n            break;\n        }\n        float currCharXEnd = currCharXStart + widths[i];\n        // this is the case where there is an overlap of the diacritic character with the\n        // current character and the previous character. If no previous character, just append\n        // the diacritic after the current one\n        if ((diacXStart < currCharXStart) && (diacXEnd <= currCharXEnd)) {\n            if (i == 0) {\n                insertDiacritic(i, diacritic);\n            } else {\n                float distanceOverlapping1 = diacXEnd - currCharXStart;\n                float percentage1 = distanceOverlapping1 / widths[i];\n                float distanceOverlapping2 = currCharXStart - diacXStart;\n                float percentage2 = distanceOverlapping2 / widths[i - 1];\n                if (percentage1 >= percentage2) {\n                    insertDiacritic(i, diacritic);\n                } else {\n                    insertDiacritic(i - 1, diacritic);\n                }\n            }\n            wasAdded = true;\n        } else if (diacXStart < currCharXStart) {\n            insertDiacritic(i, diacritic);\n            wasAdded = true;\n        } else if (diacXEnd <= currCharXEnd) {\n            insertDiacritic(i, diacritic);\n            wasAdded = true;\n        } else if (i == (strLen - 1)) {\n            insertDiacritic(i, diacritic);\n            wasAdded = true;\n        }\n        // couldn't find anything useful so we go to the next character in the TextPosition\n        currCharXStart += widths[i];\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<init>" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "/**\n * Constructor.\n */\nFileSystemFontProvider(FontCache cache) {\n    this.cache = cache;\n    try {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Will search the local system for fonts\");\n        }\n        // scan the local system for font files\n        FontFileFinder fontFileFinder = new FontFileFinder();\n        List<URI> fonts = fontFileFinder.find();\n        List<File> files = new ArrayList<>(fonts.size());\n        for (URI font : fonts) {\n            files.add(new File(font));\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace((\"Found \" + files.size()) + \" fonts on the local system\");\n        }\n        if (!files.isEmpty()) {\n            // load cached FontInfo objects\n            List<FSFontInfo> cachedInfos = loadDiskCache(files);\n            if ((cachedInfos != null) && (!cachedInfos.isEmpty())) {\n                fontInfoList.addAll(cachedInfos);\n            } else {\n                LOG.info(\"Building on-disk font cache, this may take a while\");\n                scanFonts(files);\n                saveDiskCache();\n                LOG.info((\"Finished building on-disk font cache, found \" + fontInfoList.size()) + \" fonts\");\n            }\n        }\n    } catch (AccessControlException e) {\n        LOG.error(\"Error accessing the file system\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderFormStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderFormStream" ],
    "fullMethods" : [ "@Override\npublic void createHolderFormStream(PDDocument template) {\n    PDStream holderForm = new PDStream(template);\n    pdfStructure.setHolderFormStream(holderForm);\n    LOG.info(\"Holder form stream has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAcroFormDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAcroFormDictionary" ],
    "fullMethods" : [ "@Override\npublic void createAcroFormDictionary(PDAcroForm acroForm, PDSignatureField signatureField) throws IOException {\n    @SuppressWarnings(\"unchecked\")\n    List<PDField> acroFormFields = acroForm.getFields();\n    COSDictionary acroFormDict = acroForm.getCOSObject();\n    acroForm.setSignaturesExist(true);\n    acroForm.setAppendOnly(true);\n    acroFormDict.setDirect(true);\n    acroFormFields.add(signatureField);\n    // WTF sylfaen?\n    acroForm.setDefaultAppearance(\"/sylfaen 0 Tf 0 g\");\n    pdfStructure.setAcroFormFields(acroFormFields);\n    pdfStructure.setAcroFormDictionary(acroFormDict);\n    LOG.info(\"AcroForm dictionary has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.<init>" ],
    "fullMethods" : [ "/**\n * Constructor, creates PDF template structure.\n */\npublic PDVisibleSigBuilder() {\n    pdfStructure = new PDFTemplateStructure();\n    LOG.info(\"PDF Structure has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createPage" ],
    "fullMethods" : [ "@Override\npublic void createPage(PDVisibleSignDesigner properties) {\n    PDPage page = new PDPage(new PDRectangle(properties.getPageWidth(), properties.getPageHeight()));\n    pdfStructure.setPage(page);\n    LOG.info(\"PDF page has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.injectProcSetArray",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.injectProcSetArray" ],
    "fullMethods" : [ "@Override\npublic void injectProcSetArray(PDFormXObject innerForm, PDPage page, PDResources innerFormResources, PDResources imageFormResources, PDResources holderFormResources, COSArray procSet) {\n    innerForm.getResources().getCOSObject().setItem(COSName.PROC_SET, procSet);\n    page.getCOSObject().setItem(COSName.PROC_SET, procSet);\n    innerFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);\n    imageFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);\n    holderFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);\n    LOG.info(\"Inserted ProcSet to PDF\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerFormResource",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerFormResource" ],
    "fullMethods" : [ "@Override\npublic void createInnerFormResource() {\n    PDResources innerFormResources = new PDResources();\n    pdfStructure.setInnerFormResources(innerFormResources);\n    LOG.info(\"Resources of another form (inner form - it will be inside holder form)\" + \"have been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureImage" ],
    "fullMethods" : [ "@Override\npublic void createSignatureImage(PDDocument template, BufferedImage image) throws IOException {\n    pdfStructure.setImage(LosslessFactory.createFromImage(template, image));\n    LOG.info(\"Visible Signature Image has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureRectangle",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureRectangle" ],
    "fullMethods" : [ "@Override\npublic void createSignatureRectangle(PDSignatureField signatureField, PDVisibleSignDesigner properties) throws IOException {\n    PDRectangle rect = new PDRectangle();\n    rect.setUpperRightX(properties.getxAxis() + properties.getWidth());\n    rect.setUpperRightY(properties.getTemplateHeight() - properties.getyAxis());\n    rect.setLowerLeftY((properties.getTemplateHeight() - properties.getyAxis()) - properties.getHeight());\n    rect.setLowerLeftX(properties.getxAxis());\n    signatureField.getWidgets().get(0).setRectangle(rect);\n    pdfStructure.setSignatureRectangle(rect);\n    LOG.info(\"Signature rectangle has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageFormResources",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageFormResources" ],
    "fullMethods" : [ "@Override\npublic void createImageFormResources() {\n    PDResources imageFormResources = new PDResources();\n    pdfStructure.setImageFormResources(imageFormResources);\n    LOG.info(\"Created image form resources\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createFormatterRectangle",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createFormatterRectangle" ],
    "fullMethods" : [ "@Override\npublic void createFormatterRectangle(int[] params) {\n    PDRectangle formatterRectangle = new PDRectangle();\n    formatterRectangle.setLowerLeftX(Math.min(params[0], params[2]));\n    formatterRectangle.setLowerLeftY(Math.min(params[1], params[3]));\n    formatterRectangle.setUpperRightX(Math.max(params[0], params[2]));\n    formatterRectangle.setUpperRightY(Math.max(params[1], params[3]));\n    pdfStructure.setFormatterRectangle(formatterRectangle);\n    LOG.info(\"Formatter rectangle has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureField",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignatureField" ],
    "fullMethods" : [ "@Override\npublic void createSignatureField(PDAcroForm acroForm) throws IOException {\n    PDSignatureField sf = new PDSignatureField(acroForm);\n    pdfStructure.setSignatureField(sf);\n    LOG.info(\"Signature field has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAppearanceDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createAppearanceDictionary" ],
    "fullMethods" : [ "@Override\npublic void createAppearanceDictionary(PDFormXObject holderForm, PDSignatureField signatureField) throws IOException {\n    PDAppearanceDictionary appearance = new PDAppearanceDictionary();\n    appearance.getCOSObject().setDirect(true);\n    PDAppearanceStream appearanceStream = new PDAppearanceStream(holderForm.getCOSObject());\n    appearance.setNormalAppearance(appearanceStream);\n    signatureField.getWidgets().get(0).setAppearance(appearance);\n    pdfStructure.setAppearanceDictionary(appearance);\n    LOG.info(\"PDF appearance dictionary has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createWidgetDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createWidgetDictionary" ],
    "fullMethods" : [ "@Override\npublic void createWidgetDictionary(PDSignatureField signatureField, PDResources holderFormResources) throws IOException {\n    COSDictionary widgetDict = signatureField.getWidgets().get(0).getCOSObject();\n    widgetDict.setNeedToBeUpdated(true);\n    widgetDict.setItem(COSName.DR, holderFormResources.getCOSObject());\n    pdfStructure.setWidgetDictionary(widgetDict);\n    LOG.info(\"WidgetDictionary has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDFTemplateCreator.buildPDF",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDFTemplateCreator.buildPDF" ],
    "fullMethods" : [ "/**\n * Build a PDF with a visible signature step by step, and return it as a stream.\n *\n * @param properties\n * \t\tproperties to be used for the creation\n * @return InputStream stream containing the pdf holding the visible signature\n * @throws IOException\n * \t\tif the PDF could not be created\n */\npublic InputStream buildPDF(PDVisibleSignDesigner properties) throws IOException {\n    LOG.info(\"pdf building has been started\");\n    PDFTemplateStructure pdfStructure = pdfBuilder.getStructure();\n    // we create array of [Text, ImageB, ImageC, ImageI]\n    pdfBuilder.createProcSetArray();\n    // create page\n    pdfBuilder.createPage(properties);\n    PDPage page = pdfStructure.getPage();\n    // create template\n    pdfBuilder.createTemplate(page);\n    try (PDDocument template = pdfStructure.getTemplate()) {\n        // create /AcroForm\n        pdfBuilder.createAcroForm(template);\n        PDAcroForm acroForm = pdfStructure.getAcroForm();\n        // AcroForm contains signature fields\n        pdfBuilder.createSignatureField(acroForm);\n        PDSignatureField pdSignatureField = pdfStructure.getSignatureField();\n        // create signature\n        // TODO\n        // The line below has no effect with the CreateVisibleSignature example.\n        // The signature field is needed as a \"holder\" for the /AP tree,\n        // but the /P and /V PDSignatureField entries are ignored by PDDocument.addSignature\n        pdfBuilder.createSignature(pdSignatureField, page, \"\");\n        // that is /AcroForm/DR entry\n        pdfBuilder.createAcroFormDictionary(acroForm, pdSignatureField);\n        // create AffineTransform\n        pdfBuilder.createAffineTransform(properties.getTransform());\n        AffineTransform transform = pdfStructure.getAffineTransform();\n        // rectangle, formatter, image. /AcroForm/DR/XObject contains that form\n        pdfBuilder.createSignatureRectangle(pdSignatureField, properties);\n        pdfBuilder.createFormatterRectangle(properties.getFormatterRectangleParameters());\n        PDRectangle bbox = pdfStructure.getFormatterRectangle();\n        pdfBuilder.createSignatureImage(template, properties.getImage());\n        // create form stream, form and  resource.\n        pdfBuilder.createHolderFormStream(template);\n        PDStream holderFormStream = pdfStructure.getHolderFormStream();\n        pdfBuilder.createHolderFormResources();\n        PDResources holderFormResources = pdfStructure.getHolderFormResources();\n        pdfBuilder.createHolderForm(holderFormResources, holderFormStream, bbox);\n        // that is /AP entry the appearance dictionary.\n        pdfBuilder.createAppearanceDictionary(pdfStructure.getHolderForm(), pdSignatureField);\n        // inner form stream, form and resource (holder form contains inner form)\n        pdfBuilder.createInnerFormStream(template);\n        pdfBuilder.createInnerFormResource();\n        PDResources innerFormResource = pdfStructure.getInnerFormResources();\n        pdfBuilder.createInnerForm(innerFormResource, pdfStructure.getInnerFormStream(), bbox);\n        PDFormXObject innerForm = pdfStructure.getInnerForm();\n        // inner form must be in the holder form as we wrote\n        pdfBuilder.insertInnerFormToHolderResources(innerForm, holderFormResources);\n        // Image form is in this structure: /AcroForm/DR/FRM/Resources/XObject/n2\n        pdfBuilder.createImageFormStream(template);\n        PDStream imageFormStream = pdfStructure.getImageFormStream();\n        pdfBuilder.createImageFormResources();\n        PDResources imageFormResources = pdfStructure.getImageFormResources();\n        pdfBuilder.createImageForm(imageFormResources, innerFormResource, imageFormStream, bbox, transform, pdfStructure.getImage());\n        pdfBuilder.createBackgroundLayerForm(innerFormResource, bbox);\n        // now inject procSetArray\n        pdfBuilder.injectProcSetArray(innerForm, page, innerFormResource, imageFormResources, holderFormResources, pdfStructure.getProcSet());\n        COSName imageFormName = pdfStructure.getImageFormName();\n        COSName imageName = pdfStructure.getImageName();\n        COSName innerFormName = pdfStructure.getInnerFormName();\n        // now create Streams of AP\n        pdfBuilder.injectAppearanceStreams(holderFormStream, imageFormStream, imageFormStream, imageFormName, imageName, innerFormName, properties);\n        pdfBuilder.createVisualSignature(template);\n        pdfBuilder.createWidgetDictionary(pdSignatureField, holderFormResources);\n        InputStream in = getVisualSignatureAsStream(pdfStructure.getVisualSignature());\n        LOG.info(\"stream returning started, size= \" + in.available());\n        // return result of the stream\n        return in;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareForDecryption",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareForDecryption" ],
    "fullMethods" : [ "/**\n * Prepares everything to decrypt the document.\n *\n * Only if decryption of single objects is needed this should be called.\n *\n * @param encryption\n * \t\tencryption dictionary\n * @param documentIDArray\n * \t\tdocument id\n * @param decryptionMaterial\n * \t\tInformation used to decrypt the document.\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\n@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException {\n    if (!(decryptionMaterial instanceof StandardDecryptionMaterial)) {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    // This is only used with security version 4 and 5.\n    if (encryption.getVersion() >= REVISION_4) {\n        setStreamFilterName(encryption.getStreamFilterName());\n        setStringFilterName(encryption.getStringFilterName());\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = ((StandardDecryptionMaterial) (decryptionMaterial));\n    String password = material.getPassword();\n    if (password == null) {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = (encryption.getVersion() == 1) ? 5 : encryption.getLength() / 8;\n    if ((encryption.getVersion() == REVISION_4) || (encryption.getVersion() == REVISION_5)) {\n        // detect whether AES encryption is used. This assumes that the encryption algo is\n        // stored in the PDCryptFilterDictionary\n        // However, crypt filters are used only when V is 4 or 5.\n        PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n        if (stdCryptFilterDictionary != null) {\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            if (COSName.AESV2.equals(cryptFilterMethod)) {\n                dicLength = 128 / 8;\n                setAES(true);\n                if (encryption.getCOSObject().containsKey(COSName.LENGTH)) {\n                    // PDFBOX-5345\n                    int newLength = encryption.getLength() / 8;\n                    if (newLength < dicLength) {\n                        LOG.warn((((\"Using \" + newLength) + \" bytes key length instead of \") + dicLength) + \" in AESV2 encryption?!\");\n                        dicLength = newLength;\n                    }\n                }\n            }\n            if (COSName.AESV3.equals(cryptFilterMethod)) {\n                dicLength = 256 / 8;\n                setAES(true);\n                if (encryption.getCOSObject().containsKey(COSName.LENGTH)) {\n                    // PDFBOX-5345\n                    int newLength = encryption.getLength() / 8;\n                    if (newLength < dicLength) {\n                        LOG.warn((((\"Using \" + newLength) + \" bytes key length instead of \") + dicLength) + \" in AESV3 encryption?!\");\n                        dicLength = newLength;\n                    }\n                }\n            }\n        }\n    }\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    // we need to know whether the meta data was encrypted for password calculation\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null;\n    byte[] oe = null;\n    Charset passwordCharset = StandardCharsets.ISO_8859_1;\n    if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n        passwordCharset = StandardCharsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    if (dicRevision == REVISION_6) {\n        password = SaslPrep.saslPrepQuery(password);// PDFBOX-4155\n\n    }\n    AccessPermission currentAccessPermission;\n    byte[] encryptedKey;\n    byte[] passwordBytes;\n    boolean isOwnerPassword;\n    if (isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n            passwordBytes = password.getBytes(passwordCharset);\n        } else {\n            passwordBytes = getUserPassword234(password.getBytes(passwordCharset), ownerKey, dicRevision, dicLength);\n        }\n        isOwnerPassword = true;\n    } else if (isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {\n        currentAccessPermission = new AccessPermission(dicPermissions);\n        currentAccessPermission.setReadOnly();\n        setCurrentAccessPermission(currentAccessPermission);\n        passwordBytes = password.getBytes(passwordCharset);\n        isOwnerPassword = false;\n    } else {\n        throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n    }\n    encryptedKey = computeEncryptedKey(passwordBytes, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, isOwnerPassword);\n    if ((dicRevision == REVISION_4) && (encryptedKey.length < 16)) {\n        LOG.info(\"PDFBOX-5955: padding RC4 key to length 16\");\n        encryptedKey = Arrays.copyOf(encryptedKey, 16);\n    }\n    setEncryptionKey(encryptedKey);\n    if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n        validatePerms(encryption, dicPermissions, encryptMetadata);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createProcSetArray",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createProcSetArray" ],
    "fullMethods" : [ "@Override\npublic void createProcSetArray() {\n    COSArray procSetArr = new COSArray();\n    procSetArr.add(COSName.getPDFName(\"PDF\"));\n    procSetArr.add(COSName.getPDFName(\"Text\"));\n    procSetArr.add(COSName.getPDFName(\"ImageB\"));\n    procSetArr.add(COSName.getPDFName(\"ImageC\"));\n    procSetArr.add(COSName.getPDFName(\"ImageI\"));\n    pdfStructure.setProcSet(procSetArr);\n    LOG.info(\"ProcSet array has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageFormStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageFormStream" ],
    "fullMethods" : [ "@Override\npublic void createImageFormStream(PDDocument template) {\n    PDStream imageFormStream = new PDStream(template);\n    pdfStructure.setImageFormStream(imageFormStream);\n    LOG.info(\"Created image form stream\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.JBIG2Filter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.JBIG2Filter.decode", "org.apache.pdfbox.filter.JBIG2Filter.logLevigoDonated" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException {\n    ImageReader reader = findImageReader(\"JBIG2\", \"jbig2-imageio is not installed\");\n    if (reader.getClass().getName().contains(\"levigo\")) {\n        logLevigoDonated();\n    }\n    int bits = parameters.getInt(COSName.BITS_PER_COMPONENT, 1);\n    COSDictionary params = getDecodeParams(parameters, index);\n    ImageReadParam irp = reader.getDefaultReadParam();\n    irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());\n    irp.setSourceRegion(options.getSourceRegion());\n    options.setFilterSubsampled(true);\n    InputStream source = encoded;\n    if (params != null) {\n        COSStream globals = params.getCOSStream(COSName.JBIG2_GLOBALS);\n        if (globals != null) {\n            source = new SequenceInputStream(globals.createInputStream(), encoded);\n        }\n    }\n    try (ImageInputStream iis = ImageIO.createImageInputStream(source)) {\n        reader.setInput(iis);\n        BufferedImage image;\n        try {\n            image = reader.read(0, irp);\n        } catch (Exception e) {\n            // wrap and rethrow any exceptions\n            throw new IOException(\"Could not read JBIG2 image\", e);\n        }\n        // I am assuming since JBIG2 is always black and white\n        // depending on your renderer this might or might be needed\n        if (image.getColorModel().getPixelSize() != bits) {\n            if (bits != 1) {\n                LOG.warn(\"Attempting to handle a JBIG2 with more than 1-bit depth\");\n            }\n            BufferedImage packedImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);\n            Graphics graphics = packedImage.getGraphics();\n            graphics.drawImage(image, 0, 0, null);\n            graphics.dispose();\n            image = packedImage;\n        }\n        DataBuffer dBuf = image.getData().getDataBuffer();\n        if (dBuf.getDataType() == DataBuffer.TYPE_BYTE) {\n            decoded.write(((DataBufferByte) (dBuf)).getData());\n        } else {\n            throw new IOException(\"Unexpected image buffer type\");\n        }\n    } finally {\n        reader.dispose();\n    }\n    return new DecodeResult(parameters);\n}", "private static synchronized void logLevigoDonated() {\n    if (!levigoLogged) {\n        LOG.info(\"The Levigo JBIG2 plugin has been donated to the Apache Foundation\");\n        LOG.info(\"and an improved version is available for download at \" + \"https://pdfbox.apache.org/download.cgi\");\n        levigoLogged = true;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createBackgroundLayerForm",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createBackgroundLayerForm" ],
    "fullMethods" : [ "@Override\npublic void createBackgroundLayerForm(PDResources innerFormResource, PDRectangle bbox) throws IOException {\n    // create blank n0 background layer form\n    PDFormXObject n0Form = new PDFormXObject(pdfStructure.getTemplate().getDocument().createCOSStream());\n    n0Form.setBBox(bbox);\n    n0Form.setResources(new PDResources());\n    n0Form.setFormType(1);\n    innerFormResource.put(COSName.getPDFName(\"n0\"), n0Form);\n    LOG.info(\"Created background layer form\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createVisualSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createVisualSignature" ],
    "fullMethods" : [ "@Override\npublic void createVisualSignature(PDDocument template) {\n    pdfStructure.setVisualSignature(template.getDocument());\n    LOG.info(\"Visible signature has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.Splitter.split",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.Splitter.split", "org.apache.pdfbox.multipdf.Splitter.processPages", "org.apache.pdfbox.multipdf.Splitter.processPage" ],
    "fullMethods" : [ "/**\n * This will take a document and split into several other documents.\n *\n * @param document\n * \t\tThe document to split.\n * @return A list of all the split documents. These should all be saved before closing any\ndocuments, including the source document. Any further operations should be made after\nreloading them, to avoid problems due to resource sharing. For the same reason, they should\nnot be saved with encryption.\n * @throws IOException\n * \t\tIf there is an IOError\n */\npublic List<PDDocument> split(PDDocument document) throws IOException {\n    // reset the currentPageNumber for a case if the split method will be used several times\n    currentPageNumber = 0;\n    destinationDocuments = new ArrayList<>();\n    sourceDocument = document;\n    pageDictMaps = new ArrayList<>();\n    annotDictMaps = new ArrayList<>();\n    destToFixMap = new HashMap<>();\n    idSet = new HashSet<>();\n    roleSet = new HashSet<>();\n    processPages();\n    for (int i = 0; i < destinationDocuments.size(); ++i) {\n        PDDocument destinationDocument = destinationDocuments.get(i);\n        pageDictMap = pageDictMaps.get(i);\n        annotDictMap = annotDictMaps.get(i);\n        cloneStructureTree(destinationDocument);\n        fixDestinations(destinationDocument);\n    }\n    return destinationDocuments;\n}", "/**\n * Interface method to handle the start of the page processing.\n *\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprivate void processPages() throws IOException {\n    for (PDPage page : sourceDocument.getPages()) {\n        if (((currentPageNumber + 1) >= startPage) && ((currentPageNumber + 1) <= endPage)) {\n            processPage(page);\n            currentPageNumber++;\n        } else if (currentPageNumber > endPage) {\n            break;\n        } else {\n            currentPageNumber++;\n        }\n    }\n}", "/**\n * Interface to start processing a new page.\n *\n * @param page\n * \t\tThe page that is about to get processed.\n * @throws IOException\n * \t\tIf there is an error creating the new document.\n */\nprotected void processPage(PDPage page) throws IOException {\n    createNewDocumentIfNecessary();\n    PDPage imported = getDestinationDocument().importPage(page);\n    if ((page.getResources() != null) && (!page.getCOSObject().containsKey(COSName.RESOURCES))) {\n        imported.setResources(page.getResources());\n        LOG.info(\"Resources imported in Splitter\");// follow-up to warning in importPage\n\n    }\n    if (imported.getCOSObject().containsKey(COSName.B)) {\n        imported.getCOSObject().removeItem(COSName.B);\n        LOG.warn(\"/B entry (beads) removed by splitter\");\n    }\n    // remove page links to avoid copying not needed resources\n    processAnnotations(imported);\n    pageDictMap.put(page.getCOSObject(), imported.getCOSObject());\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.injectAppearanceStreams",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.injectAppearanceStreams" ],
    "fullMethods" : [ "@Override\npublic void injectAppearanceStreams(PDStream holderFormStream, PDStream innerFormStream, PDStream imageFormStream, COSName imageFormName, COSName imageName, COSName innerFormName, PDVisibleSignDesigner properties) throws IOException {\n    // TODO remove unused parameter from interface??\n    // Use width and height of BBox as values for transformation matrix.\n    int width = ((int) (this.getStructure().getFormatterRectangle().getWidth()));\n    int height = ((int) (this.getStructure().getFormatterRectangle().getHeight()));\n    String imgFormContent = (((((\"q \" + width) + \" 0 0 \") + height) + \" 0 0 cm /\") + imageName.getName()) + \" Do Q\\n\";\n    String holderFormContent = (\"q 1 0 0 1 0 0 cm /\" + innerFormName.getName()) + \" Do Q\\n\";\n    String innerFormContent = (\"q 1 0 0 1 0 0 cm /n0 Do Q q 1 0 0 1 0 0 cm /\" + imageFormName.getName()) + \" Do Q\\n\";\n    appendRawCommands(pdfStructure.getHolderFormStream().createOutputStream(), holderFormContent);\n    appendRawCommands(pdfStructure.getInnerFormStream().createOutputStream(), innerFormContent);\n    appendRawCommands(pdfStructure.getImageFormStream().createOutputStream(), imgFormContent);\n    LOG.info(\"Injected appearance stream to pdf\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageForm",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createImageForm" ],
    "fullMethods" : [ "@Override\npublic void createImageForm(PDResources imageFormResources, PDResources innerFormResource, PDStream imageFormStream, PDRectangle bbox, AffineTransform at, PDImageXObject img) throws IOException {\n    PDFormXObject imageForm = new PDFormXObject(imageFormStream);\n    imageForm.setBBox(bbox);\n    imageForm.setMatrix(at);\n    imageForm.setResources(imageFormResources);\n    imageForm.setFormType(1);\n    imageFormResources.getCOSObject().setDirect(true);\n    COSName imageFormName = COSName.getPDFName(\"n2\");\n    innerFormResource.put(imageFormName, imageForm);\n    COSName imageName = imageFormResources.add(img, \"img\");\n    pdfStructure.setImageForm(imageForm);\n    pdfStructure.setImageFormName(imageFormName);\n    pdfStructure.setImageName(imageName);\n    LOG.info(\"Created image form\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerForm",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createInnerForm" ],
    "fullMethods" : [ "@Override\npublic void createInnerForm(PDResources innerFormResources, PDStream innerFormStream, PDRectangle bbox) {\n    PDFormXObject innerForm = new PDFormXObject(innerFormStream);\n    innerForm.setResources(innerFormResources);\n    innerForm.setBBox(bbox);\n    innerForm.setFormType(1);\n    pdfStructure.setInnerForm(innerForm);\n    LOG.info(\"Another form (inner form - it will be inside holder form) has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.insertInnerFormToHolderResources",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.insertInnerFormToHolderResources" ],
    "fullMethods" : [ "@Override\npublic void insertInnerFormToHolderResources(PDFormXObject innerForm, PDResources holderFormResources) {\n    holderFormResources.put(COSName.FRM, innerForm);\n    pdfStructure.setInnerFormName(COSName.FRM);\n    LOG.info(\"Now inserted inner form inside holder form\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createSignature" ],
    "fullMethods" : [ "@Override\npublic void createSignature(PDSignatureField pdSignatureField, PDPage page, String signerName) throws IOException {\n    PDSignature pdSignature = new PDSignature();\n    PDAnnotationWidget widget = pdSignatureField.getWidgets().get(0);\n    pdSignatureField.setValue(pdSignature);\n    widget.setPage(page);\n    page.getAnnotations().add(widget);\n    if (!signerName.isEmpty()) {\n        pdSignature.setName(signerName);\n    }\n    pdfStructure.setPdSignature(pdSignature);\n    LOG.info(\"PDSignature has been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.getFormattedValue" ],
    "fullMethods" : [ "/**\n * This is the public method for setting the appearance stream.\n *\n * @param apValue\n * \t\tthe String value which the appearance should represent\n * @throws IOException\n * \t\tIf there is an error creating the stream.\n */\npublic void setAppearanceValue(String apValue) throws IOException {\n    value = getFormattedValue(apValue);\n    // Treat multiline field values in single lines as single lime values.\n    // This is in line with how Adobe Reader behaves when entering text\n    // interactively but NOT how it behaves when the field value has been\n    // set programmatically and Reader is forced to generate the appearance\n    // using PDAcroForm.setNeedAppearances\n    // see PDFBOX-3911\n    if ((field instanceof PDTextField) && (!((PDTextField) (field)).isMultiline())) {\n        value = value.replaceAll(\"\\\\u000D\\\\u000A|[\\\\u000A\\\\u000B\\\\u000C\\\\u000D\\\\u0085\\\\u2028\\\\u2029]\", \" \");\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        if (widget.getCOSObject().containsKey(\"PMD\")) {\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" is a PaperMetaData widget, no appearance stream created\");\n            continue;\n        }\n        // some fields have the /Da at the widget level if the\n        // widgets differ in layout.\n        PDDefaultAppearanceString acroFormAppearance = defaultAppearance;\n        if (widget.getCOSObject().getDictionaryObject(COSName.DA) != null) {\n            defaultAppearance = getWidgetDefaultAppearanceString(widget);\n        }\n        PDRectangle rect = widget.getRectangle();\n        if (rect == null) {\n            widget.getCOSObject().removeItem(COSName.AP);\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" has no rectangle, no appearance stream created\");\n            continue;\n        }\n        PDAppearanceDictionary appearanceDict = widget.getAppearance();\n        if (appearanceDict == null) {\n            appearanceDict = new PDAppearanceDictionary();\n            widget.setAppearance(appearanceDict);\n        }\n        PDAppearanceEntry appearance = appearanceDict.getNormalAppearance();\n        // TODO support appearances other than \"normal\"\n        PDAppearanceStream appearanceStream;\n        if (isValidAppearanceStream(appearance)) {\n            appearanceStream = appearance.getAppearanceStream();\n        } else {\n            appearanceStream = prepareNormalAppearanceStream(widget);\n            appearanceDict.setNormalAppearance(appearanceStream);\n            // TODO support appearances other than \"normal\"\n        }\n        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();\n        /* Adobe Acrobat always recreates the complete appearance stream if there is an appearance characteristics\n        entry (the widget dictionaries MK entry). In addition if there is no content yet also create the appearance\n        stream from the entries.\n         */\n        if ((appearanceCharacteristics != null) || (appearanceStream.getContentStream().getLength() == 0)) {\n            initializeAppearanceContent(widget, appearanceCharacteristics, appearanceStream);\n        }\n        setAppearanceContent(widget, appearanceStream);\n        // restore the field level appearance\n        defaultAppearance = acroFormAppearance;\n    }\n}", "private String getFormattedValue(String apValue) {\n    // format the field value for the appearance if there is scripting support and the field\n    // has a format event\n    PDFormFieldAdditionalActions actions = field.getActions();\n    if (actions == null) {\n        return apValue;\n    }\n    PDAction actionF = actions.getF();\n    if (actionF != null) {\n        if (field.getAcroForm().getScriptingHandler() != null) {\n            ScriptingHandler scriptingHandler = field.getAcroForm().getScriptingHandler();\n            return scriptingHandler.format(((PDActionJavaScript) (actionF)), apValue);\n        }\n        LOG.info(\"Field contains a formatting action but no ScriptingHandler \" + \"has been supplied - formatted value might be incorrect\");\n    }\n    return apValue;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderFormResources",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createHolderFormResources" ],
    "fullMethods" : [ "@Override\npublic void createHolderFormResources() {\n    PDResources holderFormResources = new PDResources();\n    pdfStructure.setHolderFormResources(holderFormResources);\n    LOG.info(\"Holder form resources have been created\");\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.info",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.retrieveDimensions" ],
    "fullMethods" : [ "/**\n * Creates a new JPEG Image XObject from a byte array containing JPEG data.\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param byteArray\n * \t\tbytes of JPEG image\n * @return a new Image XObject\n * @throws IOException\n * \t\tif the input stream cannot be read\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray) throws IOException {\n    // copy stream\n    ByteArrayInputStream byteStream = new ByteArrayInputStream(byteArray);\n    Dimensions meta = retrieveDimensions(byteStream);\n    PDColorSpace colorSpace;\n    switch (meta.numComponents) {\n        case 1 :\n            colorSpace = PDDeviceGray.INSTANCE;\n            break;\n        case 3 :\n            colorSpace = PDDeviceRGB.INSTANCE;\n            break;\n        case 4 :\n            colorSpace = PDDeviceCMYK.INSTANCE;\n            break;\n        default :\n            throw new UnsupportedOperationException(\"number of data elements not supported: \" + meta.numComponents);\n    }\n    // create PDImageXObject from stream\n    PDImageXObject pdImage = new PDImageXObject(document, byteStream, COSName.DCT_DECODE, meta.width, meta.height, 8, colorSpace);\n    if (colorSpace instanceof PDDeviceCMYK) {\n        COSArray decode = new COSArray();\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        pdImage.setDecode(decode);\n    }\n    return pdImage;\n}", "private static Dimensions retrieveDimensions(ByteArrayInputStream stream) throws IOException {\n    ImageReader reader = Filter.findRasterReader(\"JPEG\", \"a suitable JAI I/O image filter is not installed\");\n    try (ImageInputStream iis = ImageIO.createImageInputStream(stream)) {\n        reader.setInput(iis);\n        Dimensions meta = new Dimensions();\n        meta.width = reader.getWidth(0);\n        meta.height = reader.getHeight(0);\n        // PDFBOX-4691: get from image metadata (faster because no decoding)\n        try {\n            meta.numComponents = getNumComponentsFromImageMetadata(reader);\n            if (meta.numComponents != 0) {\n                return meta;\n            }\n            LOG.info(\"No image metadata, will decode image and use raster size\");\n        } catch (IOException ex) {\n            LOG.warn(\"Error reading image metadata, will decode image and use raster size\");\n        }\n        // Old method: get from raster (slower)\n        ImageIO.setUseCache(false);\n        Raster raster = reader.readRaster(0, null);\n        meta.numComponents = raster.getNumDataElements();\n        return meta;\n    } finally {\n        stream.reset();\n        reader.dispose();\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param parent\n * \t\tThe parent font.\n * @param trueTypeFont\n * \t\tThe true type font used to create the parent font\n * @throws IOException\n * \t\tif the font could not be read\n */\npublic PDCIDFontType2(COSDictionary fontDictionary, PDType0Font parent, TrueTypeFont trueTypeFont) throws IOException {\n    super(fontDictionary, parent);\n    PDFontDescriptor fd = getFontDescriptor();\n    if (trueTypeFont != null) {\n        ttf = trueTypeFont;\n        otf = ((trueTypeFont instanceof OpenTypeFont) && ((OpenTypeFont) (trueTypeFont)).isSupportedOTF()) ? ((OpenTypeFont) (trueTypeFont)) : null;\n        isEmbedded = true;\n        isDamaged = false;\n    } else {\n        boolean fontIsDamaged = false;\n        TrueTypeFont ttfFont = null;\n        PDStream stream = null;\n        if (fd != null) {\n            stream = fd.getFontFile2();\n            if (stream == null) {\n                stream = fd.getFontFile3();\n            }\n            if (stream == null) {\n                // Acrobat looks in FontFile too, even though it is not in the spec, see PDFBOX-2599\n                stream = fd.getFontFile();\n            }\n        }\n        if (stream != null) {\n            try {\n                // embedded OTF or TTF\n                RandomAccessRead view = stream.getCOSObject().createView();\n                TTFParser ttfParser = getParser(view, true);\n                ttfFont = ttfParser.parse(view);\n                ttfFont.close();\n            } catch (IOException e) {\n                fontIsDamaged = true;\n                LOG.warn(\"Could not read embedded OTF for font \" + getBaseFont(), e);\n            }\n            if ((ttfFont instanceof OpenTypeFont) && (!((OpenTypeFont) (ttfFont)).isSupportedOTF())) {\n                // the OpenType font contains CFF2 outlines which are not supported yet\n                ttfFont = null;\n                fontIsDamaged = true;\n                LOG.warn(\"Found an OpenType font using CFF2 outlines which are not supported \" + fd.getFontName());\n            }\n        }\n        isEmbedded = ttfFont != null;\n        isDamaged = fontIsDamaged;\n        if (ttfFont == null) {\n            ttfFont = findFontOrSubstitute();\n        }\n        otf = ((ttfFont instanceof OpenTypeFont) && ((OpenTypeFont) (ttfFont)).isSupportedOTF()) ? ((OpenTypeFont) (ttfFont)) : null;\n        ttf = ttfFont;\n    }\n    cmap = ttf.getUnicodeCmapLookup(false);\n    cid2gid = readCIDToGIDMap();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getGlyphBBox",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getGlyphBBox", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Calculate the bounding box of this glyph. This will work only if the first operator in the\n * stream is d1.\n *\n * @return the bounding box of this glyph, or null if the first operator is not d1.\n * @throws IOException\n * \t\tIf an io error occurs while parsing the stream.\n */\npublic PDRectangle getGlyphBBox() throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(this);\n    Object token = parser.parseNextToken();\n    while (token != null) {\n        if (token instanceof Operator) {\n            if (((Operator) (token)).getName().equals(\"d1\") && (arguments.size() == 6)) {\n                for (int i = 0; i < 6; ++i) {\n                    if (!(arguments.get(i) instanceof COSNumber)) {\n                        return null;\n                    }\n                }\n                float x = ((COSNumber) (arguments.get(2))).floatValue();\n                float y = ((COSNumber) (arguments.get(3))).floatValue();\n                return new PDRectangle(x, y, ((COSNumber) (arguments.get(4))).floatValue() - x, ((COSNumber) (arguments.get(5))).floatValue() - y);\n            } else {\n                return null;\n            }\n        } else {\n            arguments.add(((COSBase) (token)));\n        }\n        token = parser.parseNextToken();\n    } \n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>" ],
    "fullMethods" : [ "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getType1Font" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n * <p>\n * The method returns null if there was an error opening the font.\n */\n@Override\npublic synchronized FontBoxFont getFont() {\n    // synchronized to avoid race condition on cache access,\n    // which could result in an unreferenced but open font\n    FontBoxFont cached = parent.cache.getFont(this);\n    if (cached != null) {\n        return cached;\n    } else {\n        FontBoxFont font;\n        switch (format) {\n            case PFB :\n                font = getType1Font(postScriptName, file);\n                break;\n            case TTF :\n                font = getTrueTypeFont(postScriptName, file);\n                break;\n            case OTF :\n                font = getOTFFont(postScriptName, file);\n                break;\n            default :\n                throw new RuntimeException(\"can't happen\");\n        }\n        if (font != null) {\n            parent.cache.addFont(this, font);\n        }\n        return font;\n    }\n}", "private Type1Font getType1Font(String postScriptName, File file) {\n    try (InputStream input = new FileInputStream(file)) {\n        Type1Font type1 = Type1Font.createWithPFB(input);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Loaded \" + postScriptName) + \" from \") + file);\n        }\n        return type1;\n    } catch (IOException e) {\n        LOG.warn(\"Could not load font file: \" + file, e);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showForm",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showForm", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStream", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Shows a form from the content stream.\n *\n * @param form\n * \t\tform XObject\n * @throws IOException\n * \t\tif the form cannot be processed\n */\npublic void showForm(PDFormXObject form) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    if (form.getCOSObject().getLength() > 0) {\n        processStream(form);\n    }\n}", "/**\n * Process a content stream.\n *\n * @param contentStream\n * \t\tthe content stream\n * @throws IOException\n * \t\tif there is an exception while processing the stream\n */\nprivate void processStream(PDContentStream contentStream) throws IOException {\n    PDResources parent = pushResources(contentStream);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(contentStream.getMatrix());\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // clip to bounding box\n    PDRectangle bbox = contentStream.getBBox();\n    clipToRect(bbox);\n    try {\n        processStreamOperators(contentStream);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.FDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.FDFParser.parse", "org.apache.pdfbox.pdfparser.COSParser.parseFDFHeader", "org.apache.pdfbox.pdfparser.COSParser.parseHeader", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the FDFDocument object.\n *\n * @return the parsed FDFDocument\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic FDFDocument parse() throws IOException {\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        if (!parseFDFHeader()) {\n            throw new IOException(\"Error: Header doesn't contain versioninfo\");\n        }\n        initialParse();\n        exceptionOccurred = false;\n        return new FDFDocument(document, source);\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * Parse the header of a fdf.\n *\n * @return true if a FDF header was found\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected boolean parseFDFHeader() throws IOException {\n    return parseHeader(FDF_HEADER, FDF_DEFAULT_VERSION);\n}", "private boolean parseHeader(String headerMarker, String defaultVersion) throws IOException {\n    // read first line\n    String header = readLine();\n    // some pdf-documents are broken and the pdf-version is in one of the following lines\n    if (!header.contains(headerMarker)) {\n        header = readLine();\n        while (!header.contains(headerMarker)) {\n            // if a line starts with a digit, it has to be the first one with data in it\n            if ((header.length() > 0) && Character.isDigit(header.charAt(0))) {\n                break;\n            }\n            header = readLine();\n        } \n    }\n    // nothing found\n    if (!header.contains(headerMarker)) {\n        source.seek(0);\n        return false;\n    }\n    // sometimes there is some garbage in the header before the header\n    // actually starts, so lets try to find the header first.\n    int headerStart = header.indexOf(headerMarker);\n    // greater than zero because if it is zero then there is no point of trimming\n    if (headerStart > 0) {\n        // trim off any leading characters\n        header = header.substring(headerStart);\n    }\n    // This is used if there is garbage after the header on the same line\n    if (header.startsWith(headerMarker) && (!header.matches(headerMarker + \"\\\\d.\\\\d\"))) {\n        if (header.length() < (headerMarker.length() + 3)) {\n            // No version number at all, set to 1.4 as default\n            header = headerMarker + defaultVersion;\n            LOG.debug((\"No version found, set to \" + defaultVersion) + \" as default.\");\n        } else {\n            String headerGarbage = header.substring(headerMarker.length() + 3) + \"\\n\";\n            header = header.substring(0, headerMarker.length() + 3);\n            source.rewind(headerGarbage.getBytes(StandardCharsets.ISO_8859_1).length);\n        }\n    }\n    float headerVersion = -1;\n    try {\n        String[] headerParts = header.split(\"-\");\n        if (headerParts.length == 2) {\n            headerVersion = Float.parseFloat(headerParts[1]);\n        }\n    } catch (NumberFormatException exception) {\n        LOG.debug(\"Can't parse the header version.\", exception);\n    }\n    if (headerVersion < 0) {\n        if (isLenient) {\n            headerVersion = 1.7F;\n        } else {\n            throw new IOException(\"Error getting header version: \" + header);\n        }\n    }\n    document.setVersion(headerVersion);\n    // rewind\n    source.seek(0);\n    return true;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Set the selected value of this field, and try to update the visual appearance.\n *\n * @param value\n * \t\tThe name of the selected item.\n * @throws IOException\n * \t\tif the value could not be set\n */\n@Override\npublic void setValue(String value) throws IOException {\n    getCOSObject().setString(COSName.V, value);\n    // remove I key for single valued choice field\n    setSelectedOptionsIndex(null);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.readObjectNumbers",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.readObjectNumbers", "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.privateReadObjectNumbers", "org.apache.pdfbox.pdfparser.BaseParser.readLong", "org.apache.pdfbox.pdfparser.BaseParser.skipSpaces", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Read all object numbers from the compressed object stream. The stream is closed after reading the object numbers.\n *\n * @return a map off all object numbers and the corresponding offset within the object stream.\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic Map<Long, Integer> readObjectNumbers() throws IOException {\n    Map<Long, Integer> objectNumbers = null;\n    try {\n        objectNumbers = privateReadObjectNumbers();\n    } finally {\n        source.close();\n        document = null;\n    }\n    return objectNumbers;\n}", "private Map<Long, Integer> privateReadObjectNumbers() throws IOException {\n    // don't initialize map using numberOfObjects as there might by less object numbers than expected\n    Map<Long, Integer> objectNumbers = new HashMap<>();\n    long firstObjectPosition = (source.getPosition() + firstObject) - 1;\n    for (int i = 0; i < numberOfObjects; i++) {\n        // don't read beyond the part of the stream reserved for the object numbers\n        if (source.getPosition() >= firstObjectPosition) {\n            break;\n        }\n        long objectNumber = readObjectNumber();\n        int offset = ((int) (readLong()));\n        objectNumbers.put(objectNumber, offset);\n    }\n    return objectNumbers;\n}", "/**\n * This will read an long from the stream.\n *\n * @return The long that was read from the stream.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected long readLong() throws IOException {\n    skipSpaces();\n    long retval = 0;\n    StringBuilder longBuffer = readStringNumber();\n    try {\n        retval = Long.parseLong(longBuffer.toString());\n    } catch (NumberFormatException e) {\n        source.rewind(longBuffer.toString().getBytes(StandardCharsets.ISO_8859_1).length);\n        throw new IOException((((\"Error: Expected a long type at offset \" + source.getPosition()) + \", instead got '\") + longBuffer) + \"'\", e);\n    }\n    return retval;\n}", "/**\n * This will skip all spaces and comments that are present.\n *\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected void skipSpaces() throws IOException {\n    int c = source.read();\n    // 37 is the % character, a comment\n    while (isWhitespace(c) || (c == 37)) {\n        if (c == 37) {\n            // skip past the comment section\n            c = source.read();\n            while ((!isEOL(c)) && (c != (-1))) {\n                c = source.read();\n            } \n        } else {\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.Filter.getCompressionLevel",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.Filter.getCompressionLevel" ],
    "fullMethods" : [ "/**\n *\n * @return the ZIP compression level configured for PDFBox\n */\npublic static int getCompressionLevel() {\n    int compressionLevel = Deflater.DEFAULT_COMPRESSION;\n    try {\n        compressionLevel = Integer.parseInt(System.getProperty(Filter.SYSPROP_DEFLATELEVEL, \"-1\"));\n    } catch (NumberFormatException ex) {\n        LOG.warn(ex.getMessage(), ex);\n    }\n    return Math.max(-1, Math.min(Deflater.BEST_COMPRESSION, compressionLevel));\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.setEndPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.setEndPage", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the last page to be extracted by this class.\n *\n * @param endPageValue\n * \t\tNew value of 1-based endPage property.\n */\npublic void setEndPage(int endPageValue) {\n    if (endPageValue <= 0) {\n        LOG.warn(\"Parameter must be 1-based, but is \" + endPageValue);\n    }\n    endPage = endPageValue;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadFDF",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadFDF", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will load a document from an input stream. The stream is loaded to the memory to establish random access to\n * the data.\n *\n * @param input\n * \t\tThe stream that contains the document. To read the stream\n * \t\t{@link org.apache.pdfbox.io.RandomAccessReadBuffer} is used\n * @return The document that was loaded.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\npublic static FDFDocument loadFDF(InputStream input) throws IOException {\n    try (RandomAccessRead readBuffer = new RandomAccessReadBuffer(input)) {\n        FDFParser parser = new FDFParser(readBuffer);\n        return parser.parse();\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Refreshes the appearance streams and appearance dictionaries for the widget annotations of the specified fields.\n *\n * @param fields\n * \t\ta list of fields to be refreshed\n * @throws IOException\n * \t\tif the appearance streams could not be refreshed\n */\npublic void refreshAppearances(List<PDField> fields) throws IOException {\n    for (PDField field : fields) {\n        if (field instanceof PDTerminalField) {\n            ((PDTerminalField) (field)).constructAppearances();\n        }\n    }\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Refreshes the appearance streams and appearance dictionaries for the widget annotations of all fields.\n *\n * @throws IOException\n * \t\tif the appearance streams could not be refreshed\n */\npublic void refreshAppearances() throws IOException {\n    for (PDField field : getFieldTree()) {\n        if (field instanceof PDTerminalField) {\n            ((PDTerminalField) (field)).constructAppearances();\n        }\n    }\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType0Font.fetchCMapUCS2" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param randomAccessRead\n * \t\tsource of a TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding. Set this to false when creating a font for\n * \t\tAcroForm.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font load(PDDocument doc, RandomAccessRead randomAccessRead, boolean embedSubset, boolean vertical) throws IOException {\n    return new PDType0Font(doc, new TTFParser().parse(randomAccessRead), embedSubset, true, vertical);\n}", "/**\n * Private. Creates a new PDType0Font font for embedding.\n *\n * @param document\n * @param ttf\n * @param embedSubset\n * @param closeTTF\n * \t\twhether to close the ttf parameter after embedding. Must be true when the ttf\n * \t\tparameter was created in the load() method, false when the ttf parameter was passed to the\n * \t\tload() method.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @throws IOException\n */\nprivate PDType0Font(PDDocument document, TrueTypeFont ttf, boolean embedSubset, boolean closeTTF, boolean vertical) throws IOException {\n    if (vertical) {\n        ttf.enableVerticalSubstitutions();\n    }\n    gsubData = ttf.getGsubData();\n    cmapLookup = ttf.getUnicodeCmapLookup();\n    embedder = new PDCIDFontType2Embedder(document, dict, ttf, embedSubset, this, vertical);\n    descendantFont = embedder.getCIDFont();\n    readEncoding();\n    fetchCMapUCS2();\n    if (closeTTF) {\n        if (embedSubset) {\n            this.ttf = ttf;\n            document.registerTrueTypeFontForClosing(ttf);\n        } else {\n            // the TTF is fully loaded and it is safe to close the underlying data source\n            ttf.close();\n        }\n    }\n}", "/**\n * Fetches the corresponding UCS2 CMap if the font's CMap is predefined.\n */\nprivate void fetchCMapUCS2() throws IOException {\n    // if the font is composite and uses a predefined cmap (excluding Identity-H/V)\n    // or whose descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or\n    // Adobe-Korea1 character collection:\n    COSName name = dict.getCOSName(COSName.ENCODING);\n    if ((isCMapPredefined && (!((name == COSName.IDENTITY_H) || (name == COSName.IDENTITY_V)))) || isDescendantCJK) {\n        // a) Map the character code to a CID using the font's CMap\n        // b) Obtain the ROS from the font's CIDSystemInfo\n        // c) Construct a second CMap name by concatenating the ROS in the format \"R-O-UCS2\"\n        // d) Obtain the CMap with the constructed name\n        // e) Map the CID according to the CMap from step d), producing a Unicode value\n        // todo: not sure how to interpret the PDF spec here, do we always override? or only when Identity-H/V?\n        String strName = null;\n        if (isDescendantCJK) {\n            PDCIDSystemInfo cidSystemInfo = descendantFont.getCIDSystemInfo();\n            if (cidSystemInfo != null) {\n                strName = (((cidSystemInfo.getRegistry() + \"-\") + cidSystemInfo.getOrdering()) + \"-\") + cidSystemInfo.getSupplement();\n            }\n        } else if (name != null) {\n            strName = name.getName();\n        }\n        // try to find the corresponding Unicode (UC2) CMap\n        if (strName != null) {\n            try {\n                CMap prdCMap = CMapManager.getPredefinedCMap(strName);\n                String ucs2Name = ((prdCMap.getRegistry() + \"-\") + prdCMap.getOrdering()) + \"-UCS2\";\n                cMapUCS2 = CMapManager.getPredefinedCMap(ucs2Name);\n            } catch (IOException ex) {\n                LOG.warn(((\"Could not get \" + strName) + \" UC2 map for font \") + getName(), ex);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDocument.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDocument.<init>", "org.apache.pdfbox.cos.COSDocument.getStreamCache" ],
    "fullMethods" : [ "/**\n * Constructor that will use the provided function to create a stream cache for the storage of the PDF streams.\n *\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache\n * @param parser\n * \t\tParser to be used to parse the document on demand\n */\npublic COSDocument(StreamCacheCreateFunction streamCacheCreateFunction, ICOSParser parser) {\n    streamCache = getStreamCache(streamCacheCreateFunction);\n    this.parser = parser;\n}", "private RandomAccessStreamCache getStreamCache(StreamCacheCreateFunction streamCacheCreateFunction) {\n    if (streamCacheCreateFunction == null) {\n        return null;\n    }\n    try {\n        return streamCacheCreateFunction.create();\n    } catch (IOException exception1) {\n        LOG.warn(\"An error occurred when creating stream cache. Using memory only cache as fallback.\", exception1);\n    }\n    try {\n        return IOUtils.createMemoryOnlyStreamCache().create();\n    } catch (IOException exception2) {\n        LOG.warn(\"An error occurred when creating stream cache for fallback.\", exception2);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType0Font.fetchCMapUCS2" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param ttf\n * \t\tA TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding. Set this to false when creating a font for\n * \t\tAcroForm.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font load(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException {\n    return new PDType0Font(doc, ttf, embedSubset, false, false);\n}", "/**\n * Private. Creates a new PDType0Font font for embedding.\n *\n * @param document\n * @param ttf\n * @param embedSubset\n * @param closeTTF\n * \t\twhether to close the ttf parameter after embedding. Must be true when the ttf\n * \t\tparameter was created in the load() method, false when the ttf parameter was passed to the\n * \t\tload() method.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @throws IOException\n */\nprivate PDType0Font(PDDocument document, TrueTypeFont ttf, boolean embedSubset, boolean closeTTF, boolean vertical) throws IOException {\n    if (vertical) {\n        ttf.enableVerticalSubstitutions();\n    }\n    gsubData = ttf.getGsubData();\n    cmapLookup = ttf.getUnicodeCmapLookup();\n    embedder = new PDCIDFontType2Embedder(document, dict, ttf, embedSubset, this, vertical);\n    descendantFont = embedder.getCIDFont();\n    readEncoding();\n    fetchCMapUCS2();\n    if (closeTTF) {\n        if (embedSubset) {\n            this.ttf = ttf;\n            document.registerTrueTypeFontForClosing(ttf);\n        } else {\n            // the TTF is fully loaded and it is safe to close the underlying data source\n            ttf.close();\n        }\n    }\n}", "/**\n * Fetches the corresponding UCS2 CMap if the font's CMap is predefined.\n */\nprivate void fetchCMapUCS2() throws IOException {\n    // if the font is composite and uses a predefined cmap (excluding Identity-H/V)\n    // or whose descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or\n    // Adobe-Korea1 character collection:\n    COSName name = dict.getCOSName(COSName.ENCODING);\n    if ((isCMapPredefined && (!((name == COSName.IDENTITY_H) || (name == COSName.IDENTITY_V)))) || isDescendantCJK) {\n        // a) Map the character code to a CID using the font's CMap\n        // b) Obtain the ROS from the font's CIDSystemInfo\n        // c) Construct a second CMap name by concatenating the ROS in the format \"R-O-UCS2\"\n        // d) Obtain the CMap with the constructed name\n        // e) Map the CID according to the CMap from step d), producing a Unicode value\n        // todo: not sure how to interpret the PDF spec here, do we always override? or only when Identity-H/V?\n        String strName = null;\n        if (isDescendantCJK) {\n            PDCIDSystemInfo cidSystemInfo = descendantFont.getCIDSystemInfo();\n            if (cidSystemInfo != null) {\n                strName = (((cidSystemInfo.getRegistry() + \"-\") + cidSystemInfo.getOrdering()) + \"-\") + cidSystemInfo.getSupplement();\n            }\n        } else if (name != null) {\n            strName = name.getName();\n        }\n        // try to find the corresponding Unicode (UC2) CMap\n        if (strName != null) {\n            try {\n                CMap prdCMap = CMapManager.getPredefinedCMap(strName);\n                String ucs2Name = ((prdCMap.getRegistry() + \"-\") + prdCMap.getOrdering()) + \"-UCS2\";\n                cMapUCS2 = CMapManager.getPredefinedCMap(ucs2Name);\n            } catch (IOException ex) {\n                LOG.warn(((\"Could not get \" + strName) + \" UC2 map for font \") + getName(), ex);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.shadingFill",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.shadingFill", "org.apache.pdfbox.rendering.PageDrawer.applySoftMaskToPaint", "org.apache.pdfbox.rendering.PageDrawer.TransparencyGroup.<init>", "org.apache.pdfbox.rendering.PageDrawer.TransparencyGroup.<init>", "org.apache.pdfbox.rendering.PageDrawer.access", "org.apache.pdfbox.contentstream.PDFStreamEngine.processTransparencyGroup", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void shadingFill(COSName shadingName) throws IOException {\n    if (!isContentRendered()) {\n        return;\n    }\n    PDShading shading = getResources().getShading(shadingName);\n    if (shading == null) {\n        LOG.error((\"shading \" + shadingName) + \" does not exist in resources dictionary\");\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    Shape savedClip = graphics.getClip();\n    graphics.setClip(null);\n    lastClips = null;\n    // get the transformed BBox and intersect with current clipping path\n    // need to do it here and not in shading getRaster() because it may have been rotated\n    PDRectangle bbox = shading.getBBox();\n    Area area;\n    if (bbox != null) {\n        area = new Area(bbox.transform(ctm));\n        area.intersect(getGraphicsState().getCurrentClippingPath());\n    } else {\n        Rectangle2D bounds = shading.getBounds(new AffineTransform(), ctm);\n        if (bounds != null) {\n            bounds.add(new Point2D.Double(Math.floor(bounds.getMinX() - 1), Math.floor(bounds.getMinY() - 1)));\n            bounds.add(new Point2D.Double(Math.ceil(bounds.getMaxX() + 1), Math.ceil(bounds.getMaxY() + 1)));\n            area = new Area(bounds);\n            area.intersect(getGraphicsState().getCurrentClippingPath());\n        } else {\n            area = getGraphicsState().getCurrentClippingPath();\n        }\n    }\n    if (!area.isEmpty()) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        Paint paint = shading.toPaint(ctm);\n        paint = applySoftMaskToPaint(paint, getGraphicsState().getSoftMask());\n        graphics.setPaint(paint);\n        graphics.fill(area);\n    }\n    graphics.setClip(savedClip);\n}", "private Paint applySoftMaskToPaint(Paint parentPaint, PDSoftMask softMask) throws IOException {\n    if ((softMask == null) || (softMask.getGroup() == null)) {\n        return parentPaint;\n    }\n    PDColor backdropColor = null;\n    if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        COSArray backdropColorArray = softMask.getBackdropColor();\n        if (backdropColorArray != null) {\n            PDTransparencyGroup form = softMask.getGroup();\n            PDColorSpace colorSpace = form.getGroup().getColorSpace(form.getResources());\n            // PDFBOX-5795\n            if ((colorSpace != null) && (colorSpace.getNumberOfComponents() == backdropColorArray.size())) {\n                backdropColor = new PDColor(backdropColorArray, colorSpace);\n            }\n        }\n    }\n    TransparencyGroup transparencyGroup = new TransparencyGroup(softMask.getGroup(), true, softMask.getInitialTransformationMatrix(), backdropColor);\n    BufferedImage image = transparencyGroup.getImage();\n    if (image == null) {\n        // Adobe Reader ignores empty softmasks instead of using bc color\n        // sample file: PDFJS-6967_reduced_outside_softmask.pdf\n        return parentPaint;\n    }\n    BufferedImage gray = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);\n    if (COSName.ALPHA.equals(softMask.getSubType())) {\n        gray.setData(image.getAlphaRaster());\n    } else if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        Graphics g = gray.getGraphics();\n        g.drawImage(image, 0, 0, null);\n        g.dispose();\n    } else {\n        throw new IOException(\"Invalid soft mask subtype.\");\n    }\n    gray = adjustImage(gray);\n    Rectangle2D tpgBounds = transparencyGroup.getBounds();\n    return new SoftMask(parentPaint, gray, tpgBounds, backdropColor, softMask.getTransferFunction());\n}", "/**\n * Creates a buffered image for a transparency group result.\n *\n * @param form\n * \t\tthe transparency group of the form or soft mask.\n * @param isSoftMask\n * \t\ttrue if this is a soft mask.\n * @param ctm\n * \t\tthe relevant current transformation matrix. For soft masks, this is the CTM at\n * \t\tthe time the soft mask is set (not at the time the soft mask is used for fill/stroke!),\n * \t\tfor forms, this is the CTM at the time the form is invoked.\n * @param backdropColor\n * \t\tthe color according to the /bc entry to be used for luminosity soft\n * \t\tmasks.\n * @throws IOException\n */\nprivate TransparencyGroup(PDTransparencyGroup form, boolean isSoftMask, Matrix ctm, PDColor backdropColor) throws IOException {\n    Graphics2D savedGraphics = graphics;\n    List<Path2D> savedLastClips = lastClips;\n    Shape savedInitialClip = initialClip;\n    // get the CTM x Form Matrix transform\n    Matrix transform = Matrix.concatenate(ctm, form.getMatrix());\n    // transform the bbox\n    PDRectangle formBBox = form.getBBox();\n    if (formBBox == null) {\n        // PDFBOX-5471\n        // check done here and not in caller to avoid getBBox() creating rectangle twice\n        LOG.warn(\"transparency group ignored because BBox is null\");\n        formBBox = new PDRectangle();\n    }\n    GeneralPath transformedBox = formBBox.transform(transform);\n    // clip the bbox to prevent giant bboxes from consuming all memory\n    Area transformed = new Area(transformedBox);\n    transformed.intersect(getGraphicsState().getCurrentClippingPath());\n    Rectangle2D clipRect = transformed.getBounds2D();\n    if (clipRect.isEmpty()) {\n        image = null;\n        bbox = null;\n        minX = 0;\n        minY = 0;\n        maxX = 0;\n        maxY = 0;\n        width = 0;\n        height = 0;\n        return;\n    }\n    this.bbox = new PDRectangle(((float) (clipRect.getX())), ((float) (clipRect.getY())), ((float) (clipRect.getWidth())), ((float) (clipRect.getHeight())));\n    // apply the underlying Graphics2D device's DPI transform\n    AffineTransform xformOriginal = xform;\n    xform = AffineTransform.getScaleInstance(xformScalingFactorX, xformScalingFactorY);\n    Rectangle2D bounds = xform.createTransformedShape(clipRect).getBounds2D();\n    minX = ((int) (Math.floor(bounds.getMinX())));\n    minY = ((int) (Math.floor(bounds.getMinY())));\n    maxX = ((int) (Math.floor(bounds.getMaxX()))) + 1;\n    maxY = ((int) (Math.floor(bounds.getMaxY()))) + 1;\n    width = maxX - minX;\n    height = maxY - minY;\n    // FIXME - color space\n    if (isGray(form.getGroup().getColorSpace(form.getResources()))) {\n        image = create2ByteGrayAlphaImage(width, height);\n    } else {\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n    boolean needsBackdrop = ((!isSoftMask) && (!form.getGroup().isIsolated())) && hasBlendMode(form, new HashSet<>());\n    BufferedImage backdropImage = null;\n    // Position of this group in parent group's coordinates\n    int backdropX = 0;\n    int backdropY = 0;\n    if (needsBackdrop) {\n        if (transparencyGroupStack.isEmpty()) {\n            // Use the current page as the parent group.\n            backdropImage = renderer.getPageImage();\n            if (backdropImage == null) {\n                needsBackdrop = false;\n            } else {\n                backdropX = minX;\n                backdropY = backdropImage.getHeight() - maxY;\n            }\n        } else {\n            TransparencyGroup parentGroup = transparencyGroupStack.peek();\n            backdropImage = parentGroup.image;\n            backdropX = minX - parentGroup.minX;\n            backdropY = parentGroup.maxY - maxY;\n        }\n    }\n    Graphics2D g = image.createGraphics();\n    if (needsBackdrop) {\n        // backdropImage must be included in group image but not in group alpha.\n        g.drawImage(backdropImage, 0, 0, width, height, backdropX, backdropY, backdropX + width, backdropY + height, null);\n        g = new GroupGraphics(image, g);\n    }\n    if (isSoftMask && (backdropColor != null)) {\n        // \"If the subtype is Luminosity, the transparency group XObject G shall be\n        // composited with a fully opaque backdrop whose colour is everywhere defined\n        // by the soft-mask dictionary's BC entry.\"\n        g.setBackground(new Color(backdropColor.toRGB()));\n        g.clearRect(0, 0, width, height);\n    }\n    // flip y-axis\n    g.translate(0, image.getHeight());\n    g.scale(1, -1);\n    boolean savedFlipTG = flipTG;\n    flipTG = false;\n    // apply device transform (DPI)\n    // the initial translation is ignored, because we're not writing into the initial graphics device\n    g.transform(xform);\n    PDRectangle pageSizeOriginal = pageSize;\n    pageSize = new PDRectangle(minX / xformScalingFactorX, minY / xformScalingFactorY, ((float) (bounds.getWidth() / xformScalingFactorX)), ((float) (bounds.getHeight() / xformScalingFactorY)));\n    int clipWindingRuleOriginal = clipWindingRule;\n    clipWindingRule = -1;\n    GeneralPath linePathOriginal = linePath;\n    linePath = new GeneralPath();\n    // adjust the origin\n    g.translate(-clipRect.getX(), -clipRect.getY());\n    graphics = g;\n    setRenderingHints();\n    try {\n        if (isSoftMask) {\n            processSoftMask(form);\n        } else {\n            transparencyGroupStack.push(this);\n            processTransparencyGroup(form);\n            if (!transparencyGroupStack.isEmpty()) {\n                transparencyGroupStack.pop();\n            }\n        }\n        if (needsBackdrop) {\n            ((GroupGraphics) (graphics)).removeBackdrop(backdropImage, backdropX, backdropY);\n        }\n    } finally {\n        flipTG = savedFlipTG;\n        lastClips = savedLastClips;\n        graphics.dispose();\n        graphics = savedGraphics;\n        initialClip = savedInitialClip;\n        clipWindingRule = clipWindingRuleOriginal;\n        linePath = linePathOriginal;\n        pageSize = pageSizeOriginal;\n        xform = xformOriginal;\n    }\n}", "/**\n * Creates a buffered image for a transparency group result.\n *\n * @param form\n * \t\tthe transparency group of the form or soft mask.\n * @param isSoftMask\n * \t\ttrue if this is a soft mask.\n * @param ctm\n * \t\tthe relevant current transformation matrix. For soft masks, this is the CTM at\n * \t\tthe time the soft mask is set (not at the time the soft mask is used for fill/stroke!),\n * \t\tfor forms, this is the CTM at the time the form is invoked.\n * @param backdropColor\n * \t\tthe color according to the /bc entry to be used for luminosity soft\n * \t\tmasks.\n * @throws IOException\n */\nprivate TransparencyGroup(PDTransparencyGroup form, boolean isSoftMask, Matrix ctm, PDColor backdropColor) throws IOException {\n    Graphics2D savedGraphics = graphics;\n    List<Path2D> savedLastClips = lastClips;\n    Shape savedInitialClip = initialClip;\n    // get the CTM x Form Matrix transform\n    Matrix transform = Matrix.concatenate(ctm, form.getMatrix());\n    // transform the bbox\n    PDRectangle formBBox = form.getBBox();\n    if (formBBox == null) {\n        // PDFBOX-5471\n        // check done here and not in caller to avoid getBBox() creating rectangle twice\n        LOG.warn(\"transparency group ignored because BBox is null\");\n        formBBox = new PDRectangle();\n    }\n    GeneralPath transformedBox = formBBox.transform(transform);\n    // clip the bbox to prevent giant bboxes from consuming all memory\n    Area transformed = new Area(transformedBox);\n    transformed.intersect(getGraphicsState().getCurrentClippingPath());\n    Rectangle2D clipRect = transformed.getBounds2D();\n    if (clipRect.isEmpty()) {\n        image = null;\n        bbox = null;\n        minX = 0;\n        minY = 0;\n        maxX = 0;\n        maxY = 0;\n        width = 0;\n        height = 0;\n        return;\n    }\n    this.bbox = new PDRectangle(((float) (clipRect.getX())), ((float) (clipRect.getY())), ((float) (clipRect.getWidth())), ((float) (clipRect.getHeight())));\n    // apply the underlying Graphics2D device's DPI transform\n    AffineTransform xformOriginal = xform;\n    xform = AffineTransform.getScaleInstance(xformScalingFactorX, xformScalingFactorY);\n    Rectangle2D bounds = xform.createTransformedShape(clipRect).getBounds2D();\n    minX = ((int) (Math.floor(bounds.getMinX())));\n    minY = ((int) (Math.floor(bounds.getMinY())));\n    maxX = ((int) (Math.floor(bounds.getMaxX()))) + 1;\n    maxY = ((int) (Math.floor(bounds.getMaxY()))) + 1;\n    width = maxX - minX;\n    height = maxY - minY;\n    // FIXME - color space\n    if (isGray(form.getGroup().getColorSpace(form.getResources()))) {\n        image = create2ByteGrayAlphaImage(width, height);\n    } else {\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n    boolean needsBackdrop = ((!isSoftMask) && (!form.getGroup().isIsolated())) && hasBlendMode(form, new HashSet<>());\n    BufferedImage backdropImage = null;\n    // Position of this group in parent group's coordinates\n    int backdropX = 0;\n    int backdropY = 0;\n    if (needsBackdrop) {\n        if (transparencyGroupStack.isEmpty()) {\n            // Use the current page as the parent group.\n            backdropImage = renderer.getPageImage();\n            if (backdropImage == null) {\n                needsBackdrop = false;\n            } else {\n                backdropX = minX;\n                backdropY = backdropImage.getHeight() - maxY;\n            }\n        } else {\n            TransparencyGroup parentGroup = transparencyGroupStack.peek();\n            backdropImage = parentGroup.image;\n            backdropX = minX - parentGroup.minX;\n            backdropY = parentGroup.maxY - maxY;\n        }\n    }\n    Graphics2D g = image.createGraphics();\n    if (needsBackdrop) {\n        // backdropImage must be included in group image but not in group alpha.\n        g.drawImage(backdropImage, 0, 0, width, height, backdropX, backdropY, backdropX + width, backdropY + height, null);\n        g = new GroupGraphics(image, g);\n    }\n    if (isSoftMask && (backdropColor != null)) {\n        // \"If the subtype is Luminosity, the transparency group XObject G shall be\n        // composited with a fully opaque backdrop whose colour is everywhere defined\n        // by the soft-mask dictionary's BC entry.\"\n        g.setBackground(new Color(backdropColor.toRGB()));\n        g.clearRect(0, 0, width, height);\n    }\n    // flip y-axis\n    g.translate(0, image.getHeight());\n    g.scale(1, -1);\n    boolean savedFlipTG = flipTG;\n    flipTG = false;\n    // apply device transform (DPI)\n    // the initial translation is ignored, because we're not writing into the initial graphics device\n    g.transform(xform);\n    PDRectangle pageSizeOriginal = pageSize;\n    pageSize = new PDRectangle(minX / xformScalingFactorX, minY / xformScalingFactorY, ((float) (bounds.getWidth() / xformScalingFactorX)), ((float) (bounds.getHeight() / xformScalingFactorY)));\n    int clipWindingRuleOriginal = clipWindingRule;\n    clipWindingRule = -1;\n    GeneralPath linePathOriginal = linePath;\n    linePath = new GeneralPath();\n    // adjust the origin\n    g.translate(-clipRect.getX(), -clipRect.getY());\n    graphics = g;\n    setRenderingHints();\n    try {\n        if (isSoftMask) {\n            processSoftMask(form);\n        } else {\n            transparencyGroupStack.push(this);\n            processTransparencyGroup(form);\n            if (!transparencyGroupStack.isEmpty()) {\n                transparencyGroupStack.pop();\n            }\n        }\n        if (needsBackdrop) {\n            ((GroupGraphics) (graphics)).removeBackdrop(backdropImage, backdropX, backdropY);\n        }\n    } finally {\n        flipTG = savedFlipTG;\n        lastClips = savedLastClips;\n        graphics.dispose();\n        graphics = savedGraphics;\n        initialClip = savedInitialClip;\n        clipWindingRule = clipWindingRuleOriginal;\n        linePath = linePathOriginal;\n        pageSize = pageSizeOriginal;\n        xform = xformOriginal;\n    }\n}", "{\n    org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup x1;\n    org.apache.pdfbox.rendering.PageDrawer x0;\n\n\n    x0 := @parameter0: org.apache.pdfbox.rendering.PageDrawer;\n    x1 := @parameter1: org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup;\n    virtualinvoke x0.<org.apache.pdfbox.rendering.PageDrawer: void processTransparencyGroup(org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup)>(x1);\n\n    return;\n}\n", "/**\n * Processes a transparency group stream.\n *\n * @param group\n * \t\ttransparency group to be processed\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\nprotected void processTransparencyGroup(PDTransparencyGroup group) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    PDResources parent = pushResources(group);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(group.getMatrix());\n    // Before execution of the transparency group XObjectâs content stream,\n    // the current blend mode in the graphics state shall be initialized to Normal,\n    // the current stroking and nonstroking alpha constants to 1.0, and the current soft mask to None.\n    graphicsState.setBlendMode(BlendMode.NORMAL);\n    graphicsState.setAlphaConstant(1);\n    graphicsState.setNonStrokeAlphaConstant(1);\n    graphicsState.setSoftMask(null);\n    // clip to bounding box\n    clipToRect(group.getBBox());\n    try {\n        processStreamOperators(group);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getWidth", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Get the width from a type3 charproc stream.\n *\n * @return the glyph width.\n * @throws IOException\n * \t\tif the stream could not be read, or did not have d0 or d1 as first\n * \t\toperator, or if their first argument was not a number.\n */\npublic float getWidth() throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(this);\n    Object token = parser.parseNextToken();\n    while (token != null) {\n        if (token instanceof Operator) {\n            return parseWidth(((Operator) (token)), arguments);\n        } else {\n            arguments.add(((COSBase) (token)));\n        }\n        token = parser.parseNextToken();\n    } \n    throw new IOException(\"Unexpected end of stream\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.setStartPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.setStartPage", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the first page to be extracted by this class.\n *\n * @param startPageValue\n * \t\tNew value of 1-based startPage property.\n */\npublic void setStartPage(int startPageValue) {\n    if (startPageValue <= 0) {\n        LOG.warn(\"Parameter must be 1-based, but is \" + startPageValue);\n    }\n    startPage = startPageValue;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadPDF",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadPDF", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Parses a PDF.\n *\n * @param input\n * \t\tbyte array that contains the document. {@link org.apache.pdfbox.io.RandomAccessReadBuffer} is used\n * \t\tto read the data.\n * @param password\n * \t\tpassword to be used for decryption\n * @param keyStore\n * \t\tkey store to be used for decryption when using public key security\n * @param alias\n * \t\talias to be used for decryption when using public key security\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache to be used for buffering\n * \t\tnew/altered PDF streams\n * @return loaded document\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIn case of a reading or parsing error.\n */\npublic static PDDocument loadPDF(byte[] input, String password, InputStream keyStore, String alias, StreamCacheCreateFunction streamCacheCreateFunction) throws IOException {\n    RandomAccessRead source = null;\n    try {\n        // RandomAccessRead is not closed here, may be needed for signing\n        source = new RandomAccessReadBuffer(input);\n        PDFParser parser = new PDFParser(source, password, keyStore, alias, streamCacheCreateFunction);\n        return parser.parse();\n    } catch (IOException ioe) {\n        IOUtils.closeQuietly(source);\n        throw ioe;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.applyMask", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.scaleImage" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    if (((region == null) && (subsampling == cachedImageSubsampling)) && (cachedImage != null)) {\n        BufferedImage cached = cachedImage.get();\n        if (cached != null) {\n            return cached;\n        }\n    }\n    initJPXValues();\n    // get RGB image w/o reference because applyMask might modify it, take long time and a lot of memory.\n    final BufferedImage image;\n    final PDImageXObject softMask = getSoftMask();\n    final PDImageXObject mask = getMask();\n    if (jpxSMask != null) {\n        // PDFBOX-5657: handle JPEG2000 SMaskInData\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), jpxSMask, false, true, null);\n    } else if (softMask != null) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), softMask.getOpaqueImage(region, subsampling), softMask.getInterpolate(), true, extractMatte(softMask));\n    } else if ((mask != null) && mask.isStencil()) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), mask.getOpaqueImage(region, subsampling), mask.getInterpolate(), false, null);\n    } else {\n        image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());\n    }\n    if ((region == null) && (subsampling <= cachedImageSubsampling)) {\n        // only cache full-image renders, and prefer lower subsampling frequency, as lower\n        // subsampling means higher quality and longer render times.\n        cachedImageSubsampling = subsampling;\n        cachedImage = new SoftReference<>(image);\n    }\n    return image;\n}", "/**\n *\n * @param image\n * \t\tThe image to apply the mask to as alpha channel.\n * @param mask\n * \t\tA mask image in 8 bit Gray. Even for a stencil mask image due to\n * \t\t{@link #getOpaqueImage()} and {@link SampledImageReader}'s {@code from1Bit()} special\n * \t\thandling of DeviceGray.\n * @param interpolateMask\n * \t\tinterpolation flag of the mask image.\n * @param isSoft\n * \t\t{@code true} if a soft mask. If not stencil mask, then alpha will be inverted\n * \t\tby this method.\n * @param matte\n * \t\tan optional RGB matte if a soft mask.\n * @return an ARGB image (can be the altered original image)\n */\nprivate BufferedImage applyMask(BufferedImage image, BufferedImage mask, boolean interpolateMask, boolean isSoft, float[] matte) {\n    if (mask == null) {\n        return image;\n    }\n    final int width = Math.max(image.getWidth(), mask.getWidth());\n    final int height = Math.max(image.getHeight(), mask.getHeight());\n    // scale mask to fit image, or image to fit mask, whichever is larger.\n    // also make sure that mask is 8 bit gray and image is ARGB as this\n    // is what needs to be returned.\n    if ((mask.getWidth() < width) || (mask.getHeight() < height)) {\n        mask = scaleImage(mask, width, height, BufferedImage.TYPE_BYTE_GRAY, interpolateMask);\n    } else if (mask.getType() != BufferedImage.TYPE_BYTE_GRAY) {\n        mask = scaleImage(mask, width, height, BufferedImage.TYPE_BYTE_GRAY, false);\n    }\n    if ((image.getWidth() < width) || (image.getHeight() < height)) {\n        image = scaleImage(image, width, height, BufferedImage.TYPE_INT_ARGB, getInterpolate());\n    } else if (image.getType() != BufferedImage.TYPE_INT_ARGB) {\n        image = scaleImage(image, width, height, BufferedImage.TYPE_INT_ARGB, false);\n    }\n    // compose alpha into ARGB image, either:\n    // - very fast by direct bit combination if not a soft mask and a 8 bit alpha source.\n    // - fast by letting the sample model do a bulk band operation if no matte is set.\n    // - slow and complex by matte calculations on individual pixel components.\n    final WritableRaster raster = image.getRaster();\n    final WritableRaster alpha = mask.getRaster();\n    if ((!isSoft) && (raster.getDataBuffer().getSize() == alpha.getDataBuffer().getSize())) {\n        final DataBuffer dst = raster.getDataBuffer();\n        final DataBuffer src = alpha.getDataBuffer();\n        for (int i = 0, c = dst.getSize(); c > 0; i++ , c--) {\n            dst.setElem(i, (dst.getElem(i) & 0xffffff) | ((~src.getElem(i)) << 24));\n        }\n    } else if (matte == null) {\n        final int[] samples = new int[width];\n        for (int y = 0; y < height; y++) {\n            alpha.getSamples(0, y, width, 1, 0, samples);\n            if (!isSoft) {\n                for (int x = 0; x < width; x++) {\n                    samples[x] ^= -1;\n                }\n            }\n            raster.setSamples(0, y, width, 1, 3, samples);\n        }\n    } else {\n        final int[] alphas = new int[width];\n        final int[] pixels = new int[4 * width];\n        // Original code is to clamp component and alpha to [0f, 1f] as matte is,\n        // and later expand to [0; 255] again (with rounding).\n        // component = 255f * ((component / 255f - matte) / (alpha / 255f) + matte)\n        // = (255 * component - 255 * 255f * matte) / alpha + 255f * matte\n        // There is a clearly visible factor 255 for most components in above formula,\n        // i.e. max value is 255 * 255: 16 bits + sign.\n        // Let's use faster fixed point integer arithmetics with Q16.15,\n        // introducing neglible errors (0.001%).\n        // Note: For \"correct\" rounding we increase the final matte value (m0h, m1h, m2h) by\n        // a half an integer.\n        final int fraction = 15;\n        final int factor = 255 << fraction;\n        final int m0 = Math.round(factor * matte[0]) * 255;\n        final int m1 = Math.round(factor * matte[1]) * 255;\n        final int m2 = Math.round(factor * matte[2]) * 255;\n        final int m0h = (m0 / 255) + (1 << (fraction - 1));\n        final int m1h = (m1 / 255) + (1 << (fraction - 1));\n        final int m2h = (m2 / 255) + (1 << (fraction - 1));\n        for (int y = 0; y < height; y++) {\n            raster.getPixels(0, y, width, 1, pixels);\n            alpha.getSamples(0, y, width, 1, 0, alphas);\n            int offset = 0;\n            for (int x = 0; x < width; x++) {\n                int a = alphas[x];\n                if (a == 0) {\n                    offset += 3;\n                } else {\n                    pixels[offset] = clampColor(((((pixels[offset++] * factor) - m0) / a) + m0h) >> fraction);\n                    pixels[offset] = clampColor(((((pixels[offset++] * factor) - m1) / a) + m1h) >> fraction);\n                    pixels[offset] = clampColor(((((pixels[offset++] * factor) - m2) / a) + m2h) >> fraction);\n                }\n                pixels[offset++] = a;\n            }\n            raster.setPixels(0, y, width, 1, pixels);\n        }\n    }\n    return image;\n}", "/**\n * High-quality image scaling.\n */\nprivate static BufferedImage scaleImage(BufferedImage image, int width, int height, int type, boolean interpolate) {\n    final int imgWidth = image.getWidth();\n    final int imgHeight = image.getHeight();\n    // largeScale switch is arbitrarily chosen as to where bicubic becomes very slow\n    boolean largeScale = (width * height) > ((3000 * 3000) * (type == BufferedImage.TYPE_BYTE_GRAY ? 3 : 1));\n    interpolate &= (imgWidth != width) || (imgHeight != height);\n    BufferedImage image2 = new BufferedImage(width, height, type);\n    if (interpolate) {\n        AffineTransform af = AffineTransform.getScaleInstance(((double) (width)) / imgWidth, ((double) (height)) / imgHeight);\n        AffineTransformOp afo = new AffineTransformOp(af, largeScale ? AffineTransformOp.TYPE_BILINEAR : AffineTransformOp.TYPE_BICUBIC);\n        try {\n            afo.filter(image, image2);\n            return image2;\n        } catch (ImagingOpException e) {\n            LOG.warn(e.getMessage(), e);\n        }\n    }\n    Graphics2D g = image2.createGraphics();\n    if (interpolate) {\n        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, largeScale ? RenderingHints.VALUE_INTERPOLATION_BILINEAR : RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n        g.setRenderingHint(RenderingHints.KEY_RENDERING, largeScale ? RenderingHints.VALUE_RENDER_DEFAULT : RenderingHints.VALUE_RENDER_QUALITY);\n    }\n    g.drawImage(image, 0, 0, width, height, 0, 0, imgWidth, imgHeight, null);\n    g.dispose();\n    return image2;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType0Font.fetchCMapUCS2" ],
    "fullMethods" : [ "/**\n * Constructor for reading a Type0 font from a PDF file.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @throws IOException\n * \t\tif the descendant font is missing.\n */\npublic PDType0Font(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    gsubData = GsubData.NO_DATA_FOUND;\n    cmapLookup = null;\n    COSArray descendantFonts = dict.getCOSArray(COSName.DESCENDANT_FONTS);\n    if (descendantFonts == null) {\n        throw new IOException(\"Missing descendant font array\");\n    }\n    if (descendantFonts.size() == 0) {\n        throw new IOException(\"Descendant font array is empty\");\n    }\n    COSBase descendantFontDictBase = descendantFonts.getObject(0);\n    if (!(descendantFontDictBase instanceof COSDictionary)) {\n        throw new IOException(\"Missing descendant font dictionary\");\n    }\n    if (!COSName.FONT.equals(((COSDictionary) (descendantFontDictBase)).getCOSName(COSName.TYPE, COSName.FONT))) {\n        throw new IOException(\"Missing or wrong type in descendant font dictionary\");\n    }\n    descendantFont = PDFontFactory.createDescendantFont(((COSDictionary) (descendantFontDictBase)), this);\n    readEncoding();\n    fetchCMapUCS2();\n}", "/**\n * Fetches the corresponding UCS2 CMap if the font's CMap is predefined.\n */\nprivate void fetchCMapUCS2() throws IOException {\n    // if the font is composite and uses a predefined cmap (excluding Identity-H/V)\n    // or whose descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or\n    // Adobe-Korea1 character collection:\n    COSName name = dict.getCOSName(COSName.ENCODING);\n    if ((isCMapPredefined && (!((name == COSName.IDENTITY_H) || (name == COSName.IDENTITY_V)))) || isDescendantCJK) {\n        // a) Map the character code to a CID using the font's CMap\n        // b) Obtain the ROS from the font's CIDSystemInfo\n        // c) Construct a second CMap name by concatenating the ROS in the format \"R-O-UCS2\"\n        // d) Obtain the CMap with the constructed name\n        // e) Map the CID according to the CMap from step d), producing a Unicode value\n        // todo: not sure how to interpret the PDF spec here, do we always override? or only when Identity-H/V?\n        String strName = null;\n        if (isDescendantCJK) {\n            PDCIDSystemInfo cidSystemInfo = descendantFont.getCIDSystemInfo();\n            if (cidSystemInfo != null) {\n                strName = (((cidSystemInfo.getRegistry() + \"-\") + cidSystemInfo.getOrdering()) + \"-\") + cidSystemInfo.getSupplement();\n            }\n        } else if (name != null) {\n            strName = name.getName();\n        }\n        // try to find the corresponding Unicode (UC2) CMap\n        if (strName != null) {\n            try {\n                CMap prdCMap = CMapManager.getPredefinedCMap(strName);\n                String ucs2Name = ((prdCMap.getRegistry() + \"-\") + prdCMap.getOrdering()) + \"-UCS2\";\n                cMapUCS2 = CMapManager.getPredefinedCMap(ucs2Name);\n            } catch (IOException ex) {\n                LOG.warn(((\"Could not get \" + strName) + \" UC2 map for font \") + getName(), ex);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.Splitter.split",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.Splitter.split", "org.apache.pdfbox.multipdf.Splitter.processPages", "org.apache.pdfbox.multipdf.Splitter.processPage", "org.apache.pdfbox.multipdf.Splitter.processAnnotations" ],
    "fullMethods" : [ "/**\n * This will take a document and split into several other documents.\n *\n * @param document\n * \t\tThe document to split.\n * @return A list of all the split documents. These should all be saved before closing any\ndocuments, including the source document. Any further operations should be made after\nreloading them, to avoid problems due to resource sharing. For the same reason, they should\nnot be saved with encryption.\n * @throws IOException\n * \t\tIf there is an IOError\n */\npublic List<PDDocument> split(PDDocument document) throws IOException {\n    // reset the currentPageNumber for a case if the split method will be used several times\n    currentPageNumber = 0;\n    destinationDocuments = new ArrayList<>();\n    sourceDocument = document;\n    pageDictMaps = new ArrayList<>();\n    annotDictMaps = new ArrayList<>();\n    destToFixMap = new HashMap<>();\n    idSet = new HashSet<>();\n    roleSet = new HashSet<>();\n    processPages();\n    for (int i = 0; i < destinationDocuments.size(); ++i) {\n        PDDocument destinationDocument = destinationDocuments.get(i);\n        pageDictMap = pageDictMaps.get(i);\n        annotDictMap = annotDictMaps.get(i);\n        cloneStructureTree(destinationDocument);\n        fixDestinations(destinationDocument);\n    }\n    return destinationDocuments;\n}", "/**\n * Interface method to handle the start of the page processing.\n *\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprivate void processPages() throws IOException {\n    for (PDPage page : sourceDocument.getPages()) {\n        if (((currentPageNumber + 1) >= startPage) && ((currentPageNumber + 1) <= endPage)) {\n            processPage(page);\n            currentPageNumber++;\n        } else if (currentPageNumber > endPage) {\n            break;\n        } else {\n            currentPageNumber++;\n        }\n    }\n}", "/**\n * Interface to start processing a new page.\n *\n * @param page\n * \t\tThe page that is about to get processed.\n * @throws IOException\n * \t\tIf there is an error creating the new document.\n */\nprotected void processPage(PDPage page) throws IOException {\n    createNewDocumentIfNecessary();\n    PDPage imported = getDestinationDocument().importPage(page);\n    if ((page.getResources() != null) && (!page.getCOSObject().containsKey(COSName.RESOURCES))) {\n        imported.setResources(page.getResources());\n        LOG.info(\"Resources imported in Splitter\");// follow-up to warning in importPage\n\n    }\n    if (imported.getCOSObject().containsKey(COSName.B)) {\n        imported.getCOSObject().removeItem(COSName.B);\n        LOG.warn(\"/B entry (beads) removed by splitter\");\n    }\n    // remove page links to avoid copying not needed resources\n    processAnnotations(imported);\n    pageDictMap.put(page.getCOSObject(), imported.getCOSObject());\n}", "/**\n * Clone all annotations because of changes possibly made, and because the structure tree is\n * cloned.\n *\n * @param imported\n * @throws IOException\n */\nprivate void processAnnotations(PDPage imported) throws IOException {\n    List<PDAnnotation> annotations = imported.getAnnotations();\n    if (annotations.isEmpty()) {\n        return;\n    }\n    List<PDAnnotation> clonedAnnotations = new ArrayList<>(annotations.size());\n    for (PDAnnotation annotation : annotations) {\n        // create a shallow clone\n        COSDictionary clonedDict = new COSDictionary(annotation.getCOSObject());\n        PDAnnotation annotationClone = PDAnnotation.createAnnotation(clonedDict);\n        annotDictMap.put(annotation.getCOSObject(), clonedDict);\n        clonedAnnotations.add(annotationClone);\n        if (annotationClone instanceof PDAnnotationLink) {\n            PDAnnotationLink link = ((PDAnnotationLink) (annotationClone));\n            PDDestination srcDestination = null;\n            try {\n                srcDestination = link.getDestination();\n            } catch (IOException ex) {\n                LOG.warn((\"Incorrect destination in link annotation on page \" + (currentPageNumber + 1)) + \" is removed\", ex);\n                link.setDestination(null);\n            }\n            PDAction action = null;\n            if (srcDestination == null) {\n                action = link.getAction();\n                if (action instanceof PDActionGoTo) {\n                    PDActionGoTo goToAction = ((PDActionGoTo) (action));\n                    try {\n                        srcDestination = goToAction.getDestination();\n                    } catch (IOException ex) {\n                        LOG.warn((\"GoToAction with incorrect destination in link annotation on page \" + (currentPageNumber + 1)) + \" is removed\", ex);\n                        link.setAction(null);\n                    }\n                }\n            }\n            if (srcDestination instanceof PDNamedDestination) {\n                srcDestination = sourceDocument.getDocumentCatalog().findNamedDestinationPage(((PDNamedDestination) (srcDestination)));\n                // we do not use the named destination anymore because names get modified, e.g.\n                // 0xAD becomes 0, see file 410609.pdf where the name no longer matches with the\n                // entry in the new name tree; plus the original solution was 40 additional loc\n            }\n            if (srcDestination instanceof PDPageDestination) {\n                // preserve links to pages within the split result:\n                // not fully possible here because we don't have the full target document yet.\n                // However we're cloning as needed and remember what to do later.\n                PDPage destinationPage = ((PDPageDestination) (srcDestination)).getPage();\n                if (destinationPage != null) {\n                    // clone destination\n                    COSArray clonedDestinationArray = new COSArray(((PDPageDestination) (srcDestination)).getCOSObject().toList());\n                    PDPageDestination dstDestination = ((PDPageDestination) (PDDestination.create(clonedDestinationArray)));\n                    // remember the destination to adjust / remove page later\n                    destToFixMap.put(dstDestination, imported);\n                    if (action != null) {\n                        // if action is not null, then the destination came from an action,\n                        // thus clone action as well, then assign destination clone, then action\n                        COSDictionary clonedActionDict = new COSDictionary(action.getCOSObject());\n                        PDActionGoTo dstAction = ((PDActionGoTo) (PDActionFactory.createAction(clonedActionDict)));\n                        dstAction.setDestination(dstDestination);\n                        link.setAction(dstAction);\n                    } else {\n                        // just assign destination clone\n                        link.setDestination(dstDestination);\n                    }\n                }\n            }\n        }\n        if ((annotationClone instanceof PDAnnotationWidget) && annotationClone.getCOSObject().containsKey(COSName.PARENT)) {\n            // remove non-terminal field /Parent reference, because this may lead to orphan pages\n            annotationClone.getCOSObject().removeItem(COSName.PARENT);\n        }\n        if (annotation.getPage() != null) {\n            annotationClone.setPage(imported);\n        }\n    }\n    // Second loop for markup and popup annotations, which reference annotations themselves\n    for (PDAnnotation annotation : clonedAnnotations) {\n        if (annotation instanceof PDAnnotationMarkup) {\n            PDAnnotationPopup annotationPopup = ((PDAnnotationMarkup) (annotation)).getPopup();\n            if (annotationPopup == null) {\n                continue;\n            }\n            COSDictionary clonedPopupDict = annotDictMap.get(annotationPopup.getCOSObject());\n            if (clonedPopupDict != null) {\n                annotation.getCOSObject().setItem(COSName.POPUP, clonedPopupDict);\n            } else {\n                // orphan popup (not in annotation list); clone it and fix references\n                clonedPopupDict = new COSDictionary(annotationPopup.getCOSObject());\n                annotDictMap.put(annotationPopup.getCOSObject(), clonedPopupDict);\n                PDAnnotationPopup annotationPopupClone = ((PDAnnotationPopup) (PDAnnotation.createAnnotation(clonedPopupDict)));\n                annotationPopupClone.setParent(((PDAnnotationMarkup) (annotation)));\n                ((PDAnnotationMarkup) (annotation)).setPopup(annotationPopupClone);\n                if (annotationPopupClone.getPage() != null) {\n                    annotationPopupClone.setPage(imported);\n                }\n            }\n        }\n        if (annotation instanceof PDAnnotationPopup) {\n            PDAnnotationMarkup annotationMarkup = ((PDAnnotationPopup) (annotation)).getParent();\n            if (annotationMarkup == null) {\n                continue;\n            }\n            COSDictionary clonedMarkupDict = annotDictMap.get(annotationMarkup.getCOSObject());\n            // clonedMarkupDict will be null if markup annotation is an orphan (not in annotation list)\n            annotation.getCOSObject().setItem(COSName.PARENT, clonedMarkupDict);\n        }\n    }\n    imported.setAnnotations(clonedAnnotations);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical", "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType0Font.fetchCMapUCS2" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a vertical Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param ttf\n * \t\tA TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font loadVertical(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException {\n    return new PDType0Font(doc, ttf, embedSubset, false, true);\n}", "/**\n * Private. Creates a new PDType0Font font for embedding.\n *\n * @param document\n * @param ttf\n * @param embedSubset\n * @param closeTTF\n * \t\twhether to close the ttf parameter after embedding. Must be true when the ttf\n * \t\tparameter was created in the load() method, false when the ttf parameter was passed to the\n * \t\tload() method.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @throws IOException\n */\nprivate PDType0Font(PDDocument document, TrueTypeFont ttf, boolean embedSubset, boolean closeTTF, boolean vertical) throws IOException {\n    if (vertical) {\n        ttf.enableVerticalSubstitutions();\n    }\n    gsubData = ttf.getGsubData();\n    cmapLookup = ttf.getUnicodeCmapLookup();\n    embedder = new PDCIDFontType2Embedder(document, dict, ttf, embedSubset, this, vertical);\n    descendantFont = embedder.getCIDFont();\n    readEncoding();\n    fetchCMapUCS2();\n    if (closeTTF) {\n        if (embedSubset) {\n            this.ttf = ttf;\n            document.registerTrueTypeFontForClosing(ttf);\n        } else {\n            // the TTF is fully loaded and it is safe to close the underlying data source\n            ttf.close();\n        }\n    }\n}", "/**\n * Fetches the corresponding UCS2 CMap if the font's CMap is predefined.\n */\nprivate void fetchCMapUCS2() throws IOException {\n    // if the font is composite and uses a predefined cmap (excluding Identity-H/V)\n    // or whose descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or\n    // Adobe-Korea1 character collection:\n    COSName name = dict.getCOSName(COSName.ENCODING);\n    if ((isCMapPredefined && (!((name == COSName.IDENTITY_H) || (name == COSName.IDENTITY_V)))) || isDescendantCJK) {\n        // a) Map the character code to a CID using the font's CMap\n        // b) Obtain the ROS from the font's CIDSystemInfo\n        // c) Construct a second CMap name by concatenating the ROS in the format \"R-O-UCS2\"\n        // d) Obtain the CMap with the constructed name\n        // e) Map the CID according to the CMap from step d), producing a Unicode value\n        // todo: not sure how to interpret the PDF spec here, do we always override? or only when Identity-H/V?\n        String strName = null;\n        if (isDescendantCJK) {\n            PDCIDSystemInfo cidSystemInfo = descendantFont.getCIDSystemInfo();\n            if (cidSystemInfo != null) {\n                strName = (((cidSystemInfo.getRegistry() + \"-\") + cidSystemInfo.getOrdering()) + \"-\") + cidSystemInfo.getSupplement();\n            }\n        } else if (name != null) {\n            strName = name.getName();\n        }\n        // try to find the corresponding Unicode (UC2) CMap\n        if (strName != null) {\n            try {\n                CMap prdCMap = CMapManager.getPredefinedCMap(strName);\n                String ucs2Name = ((prdCMap.getRegistry() + \"-\") + prdCMap.getOrdering()) + \"-UCS2\";\n                cMapUCS2 = CMapManager.getPredefinedCMap(ucs2Name);\n            } catch (IOException ex) {\n                LOG.warn(((\"Could not get \" + strName) + \" UC2 map for font \") + getName(), ex);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.setVisualSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.setVisualSignature", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.initFromRandomAccessRead", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Reads the visual signature from the given input stream.\n *\n * @param is\n * \t\tthe input stream containing the visual signature\n * @throws IOException\n * \t\twhen something went wrong during parsing\n */\npublic void setVisualSignature(InputStream is) throws IOException {\n    initFromRandomAccessRead(new RandomAccessReadBuffer(is));\n}", "private void initFromRandomAccessRead(RandomAccessRead rar) throws IOException {\n    pdfSource = rar;\n    PDFParser parser = new PDFParser(pdfSource);\n    visualSignature = parser.parse().getDocument();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.LZWFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.LZWFilter.decode", "org.apache.pdfbox.filter.LZWFilter.doLZWDecode" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    COSDictionary decodeParams = getDecodeParams(parameters, index);\n    boolean earlyChange = decodeParams.getInt(COSName.EARLY_CHANGE, 1) != 0;\n    doLZWDecode(encoded, Predictor.wrapPredictor(decoded, decodeParams), earlyChange);\n    return new DecodeResult(parameters);\n}", "private static void doLZWDecode(InputStream encoded, OutputStream decoded, boolean earlyChange) throws IOException {\n    List<byte[]> codeTable = createCodeTable();// includes CLEAR/EOD handling as needed\n\n    int chunk = 9;\n    final MemoryCacheImageInputStream in = new MemoryCacheImageInputStream(encoded);\n    byte[] prev = null;// no previous string yet\n\n    long nextCommand;\n    try {\n        while ((nextCommand = in.readBits(chunk)) != EOD) {\n            if (nextCommand == CLEAR_TABLE) {\n                chunk = 9;\n                codeTable = createCodeTable();\n                prev = null;\n                continue;\n            }\n            byte[] curr;\n            if (nextCommand < codeTable.size()) {\n                // Normal case: code exists\n                curr = codeTable.get(((int) (nextCommand)));\n                decoded.write(curr);\n                if (prev != null) {\n                    // Add prev + first(curr)\n                    byte[] entry = Arrays.copyOf(prev, prev.length + 1);\n                    entry[prev.length] = curr[0];\n                    codeTable.add(entry);\n                }\n            } else if ((nextCommand == codeTable.size()) && (prev != null)) {\n                // KwKwK case: code equals next available index\n                curr = Arrays.copyOf(prev, prev.length + 1);\n                curr[prev.length] = prev[0];\n                decoded.write(curr);\n                codeTable.add(curr);\n            } else {\n                // Corrupt stream (code out of range, or KwKwK without prev)\n                throw new EOFException(\"Invalid LZW code: \" + nextCommand);\n            }\n            prev = curr;// move forward\n\n            chunk = calculateChunk(codeTable.size(), earlyChange);\n        } \n    } catch (EOFException ex) {\n        LOG.warn(\"Premature EOF in LZW stream, EOD code missing\", ex);\n    }\n    decoded.flush();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.<init>", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * Instantiate a new PDFTextStripper object.\n */\npublic PDFTextStripper() {\n    addOperator(new BeginMarkedContentSequenceWithProperties(this));\n    addOperator(new BeginMarkedContentSequence(this));\n    addOperator(new EndMarkedContentSequence(this));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.retrieveDimensions", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.getNumComponentsFromImageMetadata" ],
    "fullMethods" : [ "/**\n * Creates a new JPEG Image XObject from a byte array containing JPEG data.\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param byteArray\n * \t\tbytes of JPEG image\n * @return a new Image XObject\n * @throws IOException\n * \t\tif the input stream cannot be read\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray) throws IOException {\n    // copy stream\n    ByteArrayInputStream byteStream = new ByteArrayInputStream(byteArray);\n    Dimensions meta = retrieveDimensions(byteStream);\n    PDColorSpace colorSpace;\n    switch (meta.numComponents) {\n        case 1 :\n            colorSpace = PDDeviceGray.INSTANCE;\n            break;\n        case 3 :\n            colorSpace = PDDeviceRGB.INSTANCE;\n            break;\n        case 4 :\n            colorSpace = PDDeviceCMYK.INSTANCE;\n            break;\n        default :\n            throw new UnsupportedOperationException(\"number of data elements not supported: \" + meta.numComponents);\n    }\n    // create PDImageXObject from stream\n    PDImageXObject pdImage = new PDImageXObject(document, byteStream, COSName.DCT_DECODE, meta.width, meta.height, 8, colorSpace);\n    if (colorSpace instanceof PDDeviceCMYK) {\n        COSArray decode = new COSArray();\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        pdImage.setDecode(decode);\n    }\n    return pdImage;\n}", "private static Dimensions retrieveDimensions(ByteArrayInputStream stream) throws IOException {\n    ImageReader reader = Filter.findRasterReader(\"JPEG\", \"a suitable JAI I/O image filter is not installed\");\n    try (ImageInputStream iis = ImageIO.createImageInputStream(stream)) {\n        reader.setInput(iis);\n        Dimensions meta = new Dimensions();\n        meta.width = reader.getWidth(0);\n        meta.height = reader.getHeight(0);\n        // PDFBOX-4691: get from image metadata (faster because no decoding)\n        try {\n            meta.numComponents = getNumComponentsFromImageMetadata(reader);\n            if (meta.numComponents != 0) {\n                return meta;\n            }\n            LOG.info(\"No image metadata, will decode image and use raster size\");\n        } catch (IOException ex) {\n            LOG.warn(\"Error reading image metadata, will decode image and use raster size\");\n        }\n        // Old method: get from raster (slower)\n        ImageIO.setUseCache(false);\n        Raster raster = reader.readRaster(0, null);\n        meta.numComponents = raster.getNumDataElements();\n        return meta;\n    } finally {\n        stream.reset();\n        reader.dispose();\n    }\n}", "private static int getNumComponentsFromImageMetadata(ImageReader reader) throws IOException {\n    IIOMetadata imageMetadata = reader.getImageMetadata(0);\n    if (imageMetadata == null) {\n        return 0;\n    }\n    Element root = ((Element) (imageMetadata.getAsTree(\"javax_imageio_jpeg_image_1.0\")));\n    if (root == null) {\n        return 0;\n    }\n    try {\n        XPath xpath = XPathFactory.newInstance().newXPath();\n        String numFrameComponents = xpath.evaluate(\"markerSequence/sof/@numFrameComponents\", root);\n        if (numFrameComponents.isEmpty()) {\n            return 0;\n        }\n        return Integer.parseInt(numFrameComponents);\n    } catch (NumberFormatException | XPathExpressionException ex) {\n        LOG.warn(ex.getMessage(), ex);\n        return 0;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.processPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.processPage", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStream", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will initialize and process the contents of the stream.\n *\n * @param page\n * \t\tthe page to process\n * @throws IOException\n * \t\tif there is an error accessing the stream\n */\npublic void processPage(PDPage page) throws IOException {\n    initPage(page);\n    if (page.hasContents()) {\n        isProcessingPage = true;\n        processStream(page);\n        isProcessingPage = false;\n    }\n}", "/**\n * Process a content stream.\n *\n * @param contentStream\n * \t\tthe content stream\n * @throws IOException\n * \t\tif there is an exception while processing the stream\n */\nprivate void processStream(PDContentStream contentStream) throws IOException {\n    PDResources parent = pushResources(contentStream);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(contentStream.getMatrix());\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // clip to bounding box\n    PDRectangle bbox = contentStream.getBBox();\n    clipToRect(bbox);\n    try {\n        processStreamOperators(contentStream);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.generateNormalAppearance", "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.extractNonStrokingColor" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationFreeText annotation = ((PDAnnotationFreeText) (getAnnotation()));\n    float[] pathsArray;\n    if (PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent())) {\n        pathsArray = annotation.getCallout();\n        if ((pathsArray == null) || ((pathsArray.length != 4) && (pathsArray.length != 6))) {\n            pathsArray = new float[0];\n        }\n    } else {\n        pathsArray = new float[0];\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream(true)) {\n        // The fill color is the /C entry, there is no /IC entry defined\n        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getColor());\n        setOpacity(cs, annotation.getConstantOpacity());\n        // Adobe uses the last non stroking color from /DA as stroking color!\n        // But if there is a color in /DS, then that one is used for text.\n        PDColor strokingColor = extractNonStrokingColor(annotation);\n        boolean hasStroke = cs.setStrokingColorOnDemand(strokingColor);\n        PDColor textColor = strokingColor;\n        String defaultStyleString = annotation.getDefaultStyleString();\n        if (defaultStyleString != null) {\n            Matcher m = COLOR_PATTERN.matcher(defaultStyleString);\n            if (m.find()) {\n                int color = Integer.parseInt(m.group(1), 16);\n                float r = ((color >> 16) & 0xff) / 255.0F;\n                float g = ((color >> 8) & 0xff) / 255.0F;\n                float b = (color & 0xff) / 255.0F;\n                textColor = new PDColor(new float[]{ r, g, b }, PDDeviceRGB.INSTANCE);\n            }\n        }\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        String lineEndingStyle = annotation.getLineEndingStyle();\n        // draw callout line(s)\n        // must be done before retangle paint to avoid a line cutting through cloud\n        // see CTAN-example-Annotations.pdf\n        for (int i = 0; i < (pathsArray.length / 2); ++i) {\n            float x = pathsArray[i * 2];\n            float y = pathsArray[(i * 2) + 1];\n            if (i == 0) {\n                if (SHORT_STYLES.contains(lineEndingStyle)) {\n                    // modify coordinate to shorten the segment\n                    // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n                    float x1 = pathsArray[2];\n                    float y1 = pathsArray[3];\n                    float len = ((float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2))));\n                    if (Float.compare(len, 0) != 0) {\n                        x += ((x1 - x) / len) * ab.width;\n                        y += ((y1 - y) / len) * ab.width;\n                    }\n                }\n                cs.moveTo(x, y);\n            } else {\n                cs.lineTo(x, y);\n            }\n        }\n        if (pathsArray.length > 0) {\n            cs.stroke();\n        }\n        // paint the styles here and after line(s) draw, to avoid line crossing a filled shape\n        if ((PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent()) && // check only needed to avoid q cm Q if LE_NONE\n        (!LE_NONE.equals(lineEndingStyle))) && (pathsArray.length >= 4)) {\n            float x2 = pathsArray[2];\n            float y2 = pathsArray[3];\n            float x1 = pathsArray[0];\n            float y1 = pathsArray[1];\n            cs.saveGraphicsState();\n            if (ANGLED_STYLES.contains(lineEndingStyle)) {\n                // do a transform so that first \"arm\" is imagined flat,\n                // like in line handler.\n                // The alternative would be to apply the transform to the\n                // LE shape coordinates directly, which would be more work\n                // and produce code difficult to understand\n                double angle = Math.atan2(y2 - y1, x2 - x1);\n                cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n            } else {\n                cs.transform(Matrix.getTranslateInstance(x1, y1));\n            }\n            drawStyle(lineEndingStyle, cs, 0, 0, ab.width, hasStroke, hasBackground, false);\n            cs.restoreGraphicsState();\n        }\n        PDRectangle borderBox;\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            // Adobe draws the text with the original rectangle in mind.\n            // but if there is an /RD, then writing area get smaller.\n            // do this here because /RD is overwritten in a few lines\n            borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());\n            // TODO this segment was copied from square handler. Refactor?\n            CloudyBorder cloudyBorder = new CloudyBorder(cs, borderEffect.getIntensity(), ab.width, getRectangle());\n            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            annotation.setRectDifference(cloudyBorder.getRectDifference());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            // handle the border box\n            // \n            // There are two options. The handling is not part of the PDF specification but\n            // implementation specific to Adobe Reader\n            // - if /RD is set the border box is the /Rect entry inset by the respective\n            // border difference.\n            // - if /RD is not set then we don't touch /RD etc because Adobe doesn't either.\n            borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());\n            annotation.getNormalAppearanceStream().setBBox(borderBox);\n            // note that borderBox is not modified\n            PDRectangle paddedRectangle = getPaddedRectangle(borderBox, ab.width / 2);\n            cs.addRect(paddedRectangle.getLowerLeftX(), paddedRectangle.getLowerLeftY(), paddedRectangle.getWidth(), paddedRectangle.getHeight());\n        }\n        cs.drawShape(ab.width, hasStroke, hasBackground);\n        // rotation is an undocumented feature, but Adobe uses it. Examples can be found\n        // in pdf_commenting_new.pdf file, page 3.\n        int rotation = annotation.getCOSObject().getInt(COSName.ROTATE, 0);\n        cs.transform(Matrix.getRotateInstance(Math.toRadians(rotation), 0, 0));\n        float xOffset;\n        float yOffset;\n        float width = ((rotation == 90) || (rotation == 270)) ? borderBox.getHeight() : borderBox.getWidth();\n        // strategy to write formatted text is somewhat inspired by\n        // AppearanceGeneratorHelper.insertGeneratedAppearance()\n        PDFont font = null;\n        float clipY;\n        float clipWidth = width - (ab.width * 4);\n        float clipHeight = ((rotation == 90) || (rotation == 270)) ? borderBox.getWidth() - (ab.width * 4) : borderBox.getHeight() - (ab.width * 4);\n        extractFontDetails(annotation);\n        if (document != null) {\n            PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();\n            if (acroForm != null) {\n                // Try to get font from AcroForm default resources\n                // Sample file: https://gitlab.freedesktop.org/poppler/poppler/issues/6\n                PDResources defaultResources = acroForm.getDefaultResources();\n                if (defaultResources != null) {\n                    PDFont defaultResourcesFont = defaultResources.getFont(fontName);\n                    if (defaultResourcesFont != null) {\n                        font = defaultResourcesFont;\n                    }\n                }\n            }\n        }\n        if (font == null) {\n            font = getDefaultFont();\n        }\n        // value used by Adobe, no idea where it comes from, actual font bbox max y is 0.931\n        // gathered by creating an annotation with width 0.\n        float yDelta = 0.7896F;\n        switch (rotation) {\n            case 180 :\n                xOffset = (-borderBox.getUpperRightX()) + (ab.width * 2);\n                yOffset = ((-borderBox.getLowerLeftY()) - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = (-borderBox.getUpperRightY()) + (ab.width * 2);\n                break;\n            case 90 :\n                xOffset = borderBox.getLowerLeftY() + (ab.width * 2);\n                yOffset = ((-borderBox.getLowerLeftX()) - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = (-borderBox.getUpperRightX()) + (ab.width * 2);\n                break;\n            case 270 :\n                xOffset = (-borderBox.getUpperRightY()) + (ab.width * 2);\n                yOffset = (borderBox.getUpperRightX() - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = borderBox.getLowerLeftX() + (ab.width * 2);\n                break;\n            case 0 :\n            default :\n                xOffset = borderBox.getLowerLeftX() + (ab.width * 2);\n                yOffset = (borderBox.getUpperRightY() - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = borderBox.getLowerLeftY() + (ab.width * 2);\n                break;\n        }\n        // clip writing area\n        cs.addRect(xOffset, clipY, clipWidth, clipHeight);\n        cs.clip();\n        String annotationContents = annotation.getContents();\n        if (annotationContents != null) {\n            cs.beginText();\n            cs.setFont(font, fontSize);\n            cs.setNonStrokingColor(textColor.getComponents());\n            AppearanceStyle appearanceStyle = new AppearanceStyle();\n            appearanceStyle.setFont(font);\n            appearanceStyle.setFontSize(fontSize);\n            PlainTextFormatter formatter = // Adobe ignores the /Q\n            // .textAlign(annotation.getQ())\n            new PlainTextFormatter.Builder(cs).style(appearanceStyle).text(new PlainText(annotationContents)).width(width - (ab.width * 4)).wrapLines(true).initialOffset(xOffset, yOffset).build();\n            try {\n                formatter.format();\n            } catch (IllegalArgumentException ex) {\n                throw new IOException(ex);\n            } finally {\n                cs.endText();\n            }\n        }\n        if (pathsArray.length > 0) {\n            PDRectangle rect = getRectangle();\n            // Adjust rectangle\n            // important to do this after the rectangle has been painted, because the\n            // final rectangle will be bigger due to callout\n            // CTAN-example-Annotations.pdf p1\n            // TODO in a class structure this should be overridable\n            float minX = Float.MAX_VALUE;\n            float minY = Float.MAX_VALUE;\n            float maxX = Float.MIN_VALUE;\n            float maxY = Float.MIN_VALUE;\n            for (int i = 0; i < (pathsArray.length / 2); ++i) {\n                float x = pathsArray[i * 2];\n                float y = pathsArray[(i * 2) + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n            // arrow length is 9 * width at about 30Â° => 10 * width seems to be enough\n            rect.setLowerLeftX(Math.min(minX - (ab.width * 10), rect.getLowerLeftX()));\n            rect.setLowerLeftY(Math.min(minY - (ab.width * 10), rect.getLowerLeftY()));\n            rect.setUpperRightX(Math.max(maxX + (ab.width * 10), rect.getUpperRightX()));\n            rect.setUpperRightY(Math.max(maxY + (ab.width * 10), rect.getUpperRightY()));\n            annotation.setRectangle(rect);\n            // need to set the BBox too, because rectangle modification came later\n            annotation.getNormalAppearanceStream().setBBox(getRectangle());\n            // TODO when callout is used, /RD should be so that the result is the writable part\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}", "// get the last non stroking color from the /DA entry\nprivate PDColor extractNonStrokingColor(PDAnnotationFreeText annotation) {\n    // It could also work with a regular expression, but that should be written so that\n    // \"/LucidaConsole 13.94766 Tf .392 .585 .93 rg\" does not produce \"2 .585 .93 rg\" as result\n    // Another alternative might be to create a PDDocument and a PDPage with /DA content as /Content,\n    // process the whole thing and then get the non stroking color.\n    PDColor strokingColor = new PDColor(new float[]{ 0 }, PDDeviceGray.INSTANCE);\n    String defaultAppearance = annotation.getDefaultAppearance();\n    if (defaultAppearance == null) {\n        return strokingColor;\n    }\n    try {\n        // not sure if charset is correct, but we only need numbers and simple characters\n        PDFStreamParser parser = new PDFStreamParser(defaultAppearance.getBytes(StandardCharsets.US_ASCII));\n        COSArray arguments = new COSArray();\n        COSArray colors = null;\n        Operator graphicOp = null;\n        for (Object token = parser.parseNextToken(); token != null; token = parser.parseNextToken()) {\n            if (token instanceof Operator) {\n                Operator op = ((Operator) (token));\n                String name = op.getName();\n                if ((OperatorName.NON_STROKING_GRAY.equals(name) || OperatorName.NON_STROKING_RGB.equals(name)) || OperatorName.NON_STROKING_CMYK.equals(name)) {\n                    graphicOp = op;\n                    colors = arguments;\n                }\n                arguments = new COSArray();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n        }\n        if (graphicOp != null) {\n            switch (graphicOp.getName()) {\n                case OperatorName.NON_STROKING_GRAY :\n                    strokingColor = new PDColor(colors, PDDeviceGray.INSTANCE);\n                    break;\n                case OperatorName.NON_STROKING_RGB :\n                    strokingColor = new PDColor(colors, PDDeviceRGB.INSTANCE);\n                    break;\n                case OperatorName.NON_STROKING_CMYK :\n                    strokingColor = new PDColor(colors, PDDeviceCMYK.INSTANCE);\n                    break;\n                default :\n                    break;\n            }\n        }\n    } catch (IOException ex) {\n        LOG.warn(\"Problem parsing /DA, will use default black\", ex);\n    }\n    return strokingColor;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.<init>", "org.apache.pdfbox.pdfparser.COSParser.init", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Constructor for encrypted pdfs.\n *\n * @param source\n * \t\tinput representing the pdf.\n * @param password\n * \t\tpassword to be used for decryption.\n * @param keyStore\n * \t\tkey store to be used for decryption when using public key security\n * @param keyAlias\n * \t\talias to be used for decryption when using public key security\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of the stream cache\n * @throws IOException\n * \t\tif the source data could not be read\n */\npublic COSParser(RandomAccessRead source, String password, InputStream keyStore, String keyAlias, StreamCacheCreateFunction streamCacheCreateFunction) throws IOException {\n    super(source);\n    this.password = password;\n    this.keyAlias = keyAlias;\n    fileLen = source.length();\n    keyStoreInputStream = keyStore;\n    init(streamCacheCreateFunction);\n}", "private void init(StreamCacheCreateFunction streamCacheCreateFunction) {\n    String eofLookupRangeStr = System.getProperty(SYSPROP_EOFLOOKUPRANGE);\n    if (eofLookupRangeStr != null) {\n        try {\n            setEOFLookupRange(Integer.parseInt(eofLookupRangeStr));\n        } catch (NumberFormatException nfe) {\n            LOG.warn((((\"System property \" + SYSPROP_EOFLOOKUPRANGE) + \" does not contain an integer value, but: '\") + eofLookupRangeStr) + \"'\");\n        }\n    }\n    document = new COSDocument(streamCacheCreateFunction, this);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showAnnotation",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showAnnotation", "org.apache.pdfbox.contentstream.PDFStreamEngine.processAnnotation", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Shows the given annotation.\n *\n * @param annotation\n * \t\tAn annotation on the current page.\n * @throws IOException\n * \t\tIf an error occurred reading the annotation\n */\npublic void showAnnotation(PDAnnotation annotation) throws IOException {\n    PDAppearanceStream appearanceStream = getAppearance(annotation);\n    if (appearanceStream != null) {\n        processAnnotation(annotation, appearanceStream);\n    }\n}", "/**\n * Process the given annotation with the specified appearance stream.\n *\n * @param annotation\n * \t\tThe annotation containing the appearance stream to process.\n * @param appearance\n * \t\tThe appearance stream to process.\n * @throws IOException\n * \t\tIf there is an error reading or parsing the appearance content stream.\n */\nprotected void processAnnotation(PDAnnotation annotation, PDAppearanceStream appearance) throws IOException {\n    PDRectangle bbox = appearance.getBBox();\n    PDRectangle rect = annotation.getRectangle();\n    // zero-sized rectangles are not valid\n    if ((((((rect != null) && (rect.getWidth() > 0)) && (rect.getHeight() > 0)) && (bbox != null)) && (bbox.getWidth() > 0)) && (bbox.getHeight() > 0)) {\n        PDResources parent = pushResources(appearance);\n        Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n        Matrix matrix = appearance.getMatrix();\n        // transformed appearance box  fixme: may be an arbitrary shape\n        Rectangle2D transformedBox = bbox.transform(matrix).getBounds2D();\n        // compute a matrix which scales and translates the transformed appearance box to align\n        // with the edges of the annotation's rectangle\n        Matrix a = Matrix.getTranslateInstance(rect.getLowerLeftX(), rect.getLowerLeftY());\n        a.scale(((float) (rect.getWidth() / transformedBox.getWidth())), ((float) (rect.getHeight() / transformedBox.getHeight())));\n        a.translate(((float) (-transformedBox.getX())), ((float) (-transformedBox.getY())));\n        // Matrix shall be concatenated with A to form a matrix AA that maps from the appearance's\n        // coordinate system to the annotation's rectangle in default user space\n        // \n        // HOWEVER only the opposite order works for rotated pages with\n        // filled fields / annotations that have a matrix in the appearance stream, see PDFBOX-3083\n        Matrix aa = Matrix.concatenate(a, matrix);\n        // make matrix AA the CTM\n        getGraphicsState().setCurrentTransformationMatrix(aa);\n        // clip to bounding box\n        clipToRect(bbox);\n        // needed for patterns in appearance streams, e.g. PDFBOX-2182\n        initialMatrix = aa.clone();\n        try {\n            processStreamOperators(appearance);\n        } finally {\n            restoreGraphicsStack(savedStack);\n            popResources(parent);\n        }\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTransparencyGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTransparencyGroup", "org.apache.pdfbox.contentstream.PDFStreamEngine.processTransparencyGroup", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Shows a transparency group from the content stream.\n *\n * @param form\n * \t\ttransparency group (form) XObject\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\npublic void showTransparencyGroup(PDTransparencyGroup form) throws IOException {\n    processTransparencyGroup(form);\n}", "/**\n * Processes a transparency group stream.\n *\n * @param group\n * \t\ttransparency group to be processed\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\nprotected void processTransparencyGroup(PDTransparencyGroup group) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    PDResources parent = pushResources(group);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(group.getMatrix());\n    // Before execution of the transparency group XObjectâs content stream,\n    // the current blend mode in the graphics state shall be initialized to Normal,\n    // the current stroking and nonstroking alpha constants to 1.0, and the current soft mask to None.\n    graphicsState.setBlendMode(BlendMode.NORMAL);\n    graphicsState.setAlphaConstant(1);\n    graphicsState.setNonStrokeAlphaConstant(1);\n    graphicsState.setSoftMask(null);\n    // clip to bounding box\n    clipToRect(group.getBBox());\n    try {\n        processStreamOperators(group);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Set the selected option given its index, and try to update the visual appearance.\n *\n * NOTE: this method is only usable if there are export values and used for\n * radio buttons with FLAG_RADIOS_IN_UNISON not set.\n *\n * @param index\n * \t\tindex of option to be selected\n * @throws IOException\n * \t\tif the value could not be set\n * @throws IllegalArgumentException\n * \t\tif the index provided is not a valid index.\n */\npublic void setValue(int index) throws IOException {\n    List<String> exportValues = getExportValues();\n    if ((exportValues.isEmpty() || (index < 0)) || (index >= exportValues.size())) {\n        throw new IllegalArgumentException(((((\"index '\" + index) + \"' is not a valid index for the field \") + getFullyQualifiedName()) + \", valid indices are from 0 to \") + (exportValues.size() - 1));\n    }\n    updateByValue(String.valueOf(index));\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPageLayout",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPageLayout" ],
    "fullMethods" : [ "/**\n * Returns the page layout.\n *\n * @return the PageLayout of the document, if not present PageLayout.SINGLE_PAGE is returned\n */\npublic PageLayout getPageLayout() {\n    String mode = root.getNameAsString(COSName.PAGE_LAYOUT);\n    if ((mode != null) && (!mode.isEmpty())) {\n        try {\n            return PageLayout.fromString(mode);\n        } catch (IllegalArgumentException e) {\n            LOG.warn((\"Invalid PageLayout used '\" + mode) + \"' - returning PageLayout.SINGLE_PAGE\", e);\n        }\n    }\n    return PageLayout.SINGLE_PAGE;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<init>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.loadDiskCache" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "/**\n * Constructor.\n */\nFileSystemFontProvider(FontCache cache) {\n    this.cache = cache;\n    try {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Will search the local system for fonts\");\n        }\n        // scan the local system for font files\n        FontFileFinder fontFileFinder = new FontFileFinder();\n        List<URI> fonts = fontFileFinder.find();\n        List<File> files = new ArrayList<>(fonts.size());\n        for (URI font : fonts) {\n            files.add(new File(font));\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace((\"Found \" + files.size()) + \" fonts on the local system\");\n        }\n        if (!files.isEmpty()) {\n            // load cached FontInfo objects\n            List<FSFontInfo> cachedInfos = loadDiskCache(files);\n            if ((cachedInfos != null) && (!cachedInfos.isEmpty())) {\n                fontInfoList.addAll(cachedInfos);\n            } else {\n                LOG.info(\"Building on-disk font cache, this may take a while\");\n                scanFonts(files);\n                saveDiskCache();\n                LOG.info((\"Finished building on-disk font cache, found \" + fontInfoList.size()) + \" fonts\");\n            }\n        }\n    } catch (AccessControlException e) {\n        LOG.error(\"Error accessing the file system\", e);\n    }\n}", "/**\n * Loads the font metadata cache from disk.\n */\nprivate List<FSFontInfo> loadDiskCache(List<File> files) {\n    Set<String> pending = new HashSet<>(files.size());\n    for (File file : files) {\n        pending.add(file.getAbsolutePath());\n    }\n    List<FSFontInfo> results = new ArrayList<>();\n    // Get the disk cache\n    File diskCacheFile = null;\n    boolean fileExists = false;\n    try {\n        diskCacheFile = getDiskCacheFile();\n        fileExists = diskCacheFile.exists();\n    } catch (SecurityException e) {\n        LOG.debug(\"Error checking for file existence\", e);\n    }\n    if (fileExists) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(diskCacheFile), StandardCharsets.UTF_8))) {\n            // consequent lines usually share the same font file (e.g. \"Courier\", \"Courier-Bold\", \"Courier-Oblique\").\n            // unused if SKIP_CHECKSUMS\n            File lastFile = null;\n            String lastHash = null;\n            // \n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\"\\\\|\", 12);\n                if (parts.length < 10) {\n                    LOG.warn((\"Incorrect line '\" + line) + \"' in font disk cache is skipped\");\n                    continue;\n                }\n                String postScriptName;\n                FontFormat format;\n                CIDSystemInfo cidSystemInfo = null;\n                int usWeightClass = -1;\n                int sFamilyClass = -1;\n                int ulCodePageRange1;\n                int ulCodePageRange2;\n                int macStyle = -1;\n                byte[] panose = null;\n                File fontFile;\n                String hash = \"\";\n                long lastModified = 0;\n                postScriptName = parts[0];\n                format = FontFormat.valueOf(parts[1]);\n                if (parts[2].length() > 0) {\n                    String[] ros = parts[2].split(\"-\");\n                    cidSystemInfo = new CIDSystemInfo(ros[0], ros[1], Integer.parseInt(ros[2]));\n                }\n                if (parts[3].length() > 0) {\n                    usWeightClass = ((int) (Long.parseLong(parts[3], 16)));\n                }\n                if (parts[4].length() > 0) {\n                    sFamilyClass = ((int) (Long.parseLong(parts[4], 16)));\n                }\n                ulCodePageRange1 = ((int) (Long.parseLong(parts[5], 16)));\n                ulCodePageRange2 = ((int) (Long.parseLong(parts[6], 16)));\n                if (parts[7].length() > 0) {\n                    macStyle = ((int) (Long.parseLong(parts[7], 16)));\n                }\n                if (parts[8].length() > 0) {\n                    panose = new byte[10];\n                    for (int i = 0; i < 10; i++) {\n                        String str = parts[8].substring(i * 2, (i * 2) + 2);\n                        int b = Integer.parseInt(str, 16);\n                        panose[i] = ((byte) (b & 0xff));\n                    }\n                }\n                fontFile = new File(parts[9]);\n                if (((parts.length >= 12) && (!parts[10].isEmpty())) && (!parts[11].isEmpty())) {\n                    hash = parts[10];\n                    lastModified = Long.parseLong(parts[11]);\n                }\n                if (fontFile.exists()) {\n                    // if the file exists, find out whether it's the same file.\n                    // first check whether time is different and if yes, whether hash is different\n                    boolean keep = fontFile.lastModified() == lastModified;\n                    if ((!keep) && (!SKIP_CHECKSUMS)) {\n                        String newHash;\n                        if (hash.equals(lastHash) && fontFile.equals(lastFile)) {\n                            newHash = lastHash;// already computed\n\n                        } else {\n                            try {\n                                newHash = computeHash(Files.newInputStream(fontFile.toPath()));\n                                lastFile = fontFile;\n                                lastHash = newHash;\n                            } catch (IOException ex) {\n                                LOG.debug(\"Error reading font file \" + fontFile.getAbsolutePath(), ex);\n                                newHash = \"<err>\";\n                            }\n                        }\n                        if (hash.equals(newHash)) {\n                            keep = true;\n                            lastModified = fontFile.lastModified();\n                        }\n                    }\n                    if (keep) {\n                        FSFontInfo info = new FSFontInfo(fontFile, format, postScriptName, cidSystemInfo, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this, hash, lastModified);\n                        results.add(info);\n                    } else {\n                        LOG.debug((\"Font file \" + fontFile.getAbsolutePath()) + \" is different\");\n                        continue;// don't remove from \"pending\"\n\n                    }\n                } else {\n                    LOG.debug((\"Font file \" + fontFile.getAbsolutePath()) + \" not found, skipped\");\n                }\n                pending.remove(fontFile.getAbsolutePath());\n            } \n        } catch (IOException e) {\n            LOG.warn(\"Error loading font cache, will be re-built\", e);\n            return null;\n        }\n    }\n    if (!pending.isEmpty()) {\n        // re-build the entire cache if we encounter un-cached fonts (could be optimised)\n        LOG.info(pending.size() + \" new font files found, font cache will be re-built\");\n        return null;\n    }\n    return results;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.setVisualSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.setVisualSignature", "org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions.initFromRandomAccessRead", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Reads the visual signature from the given file.\n *\n * @param file\n * \t\tthe file containing the visual signature\n * @throws IOException\n * \t\twhen something went wrong during parsing\n */\npublic void setVisualSignature(File file) throws IOException {\n    initFromRandomAccessRead(new RandomAccessReadBufferedFile(file));\n}", "private void initFromRandomAccessRead(RandomAccessRead rar) throws IOException {\n    pdfSource = rar;\n    PDFParser parser = new PDFParser(pdfSource);\n    visualSignature = parser.parse().getDocument();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText", "org.apache.pdfbox.pdmodel.font.PDFont.getDisplacement", "org.apache.pdfbox.pdmodel.font.PDFont.getWidth", "org.apache.pdfbox.pdmodel.font.PDType3Font.getWidthFromFont", "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getWidth", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Called when a string of text is to be shown.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextString(byte[] string) throws IOException {\n    showText(string);\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}", "/**\n * Returns the displacement vector (w0, w1) in text space, for the given character. For horizontal text only the x\n * component is used, for vertical text only the y component.\n *\n * @param code\n * \t\tcharacter code\n * @return displacement vector\n * @throws IOException\n * \t\tif the data could not be read\n */\npublic Vector getDisplacement(int code) throws IOException {\n    return new Vector(getWidth(code) / 1000, 0);\n}", "@Override\npublic float getWidth(int code) throws IOException {\n    Float width = codeToWidthMap.get(code);\n    if (width != null) {\n        return width;\n    }\n    // Acrobat overrides the widths in the font program on the conforming reader's system with\n    // the widths specified in the font dictionary.\" (Adobe Supplement to the ISO 32000)\n    // \n    // Note: The Adobe Supplement says that the override happens \"If the font program is not\n    // embedded\", however PDFBOX-427 shows that it also applies to embedded fonts.\n    // Type1, Type1C, Type3\n    if ((dict.getDictionaryObject(COSName.WIDTHS) != null) || dict.containsKey(COSName.MISSING_WIDTH)) {\n        int firstChar = dict.getInt(COSName.FIRST_CHAR, -1);\n        int lastChar = dict.getInt(COSName.LAST_CHAR, -1);\n        int siz = getWidths().size();\n        int idx = code - firstChar;\n        if ((((siz > 0) && (code >= firstChar)) && (code <= lastChar)) && (idx < siz)) {\n            width = getWidths().get(idx);\n            if (width == null) {\n                width = 0.0F;\n            }\n            codeToWidthMap.put(code, width);\n            return width;\n        }\n        PDFontDescriptor fd = getFontDescriptor();\n        if (fd != null) {\n            // get entry from /MissingWidth entry\n            width = fd.getMissingWidth();\n            codeToWidthMap.put(code, width);\n            return width;\n        }\n    }\n    // standard 14 font widths are specified by an AFM\n    if (isStandard14()) {\n        width = getStandard14Width(code);\n        codeToWidthMap.put(code, width);\n        return width;\n    }\n    // if there's nothing to override with, then obviously we fall back to the font\n    width = getWidthFromFont(code);\n    codeToWidthMap.put(code, width);\n    return width;\n}", "@Override\npublic float getWidthFromFont(int code) throws IOException {\n    PDType3CharProc charProc = getCharProc(code);\n    if ((charProc == null) || (charProc.getCOSObject().getLength() == 0)) {\n        return 0;\n    }\n    return charProc.getWidth();\n}", "/**\n * Get the width from a type3 charproc stream.\n *\n * @return the glyph width.\n * @throws IOException\n * \t\tif the stream could not be read, or did not have d0 or d1 as first\n * \t\toperator, or if their first argument was not a number.\n */\npublic float getWidth() throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(this);\n    Object token = parser.parseNextToken();\n    while (token != null) {\n        if (token instanceof Operator) {\n            return parseWidth(((Operator) (token)), arguments);\n        } else {\n            arguments.add(((COSBase) (token)));\n        }\n        token = parser.parseNextToken();\n    } \n    throw new IOException(\"Unexpected end of stream\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Search for/parse the object with the given object number. The stream is closed after parsing the object with the\n * given number.\n *\n * @param objectNumber\n * \t\tthe number of the object to b e parsed\n * @return the parsed object or null if the object with the given number can't be found\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic COSBase parseObject(long objectNumber) throws IOException {\n    COSBase streamObject = null;\n    try {\n        Integer objectOffset = privateReadObjectNumbers().get(objectNumber);\n        if (objectOffset != null) {\n            // jump to the offset of the first object\n            long currentPosition = source.getPosition();\n            if ((firstObject > 0) && (currentPosition < firstObject)) {\n                source.skip(firstObject - ((int) (currentPosition)));\n            }\n            // jump to the offset of the object to be parsed\n            source.skip(objectOffset);\n            streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return streamObject;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator", "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator", "org.apache.pdfbox.contentstream.PDFStreamEngine.operatorException" ],
    "fullMethods" : [ "/**\n * This is used to handle an operation.\n *\n * @param operation\n * \t\tThe operation to perform.\n * @param arguments\n * \t\tThe list of arguments.\n * @throws IOException\n * \t\tIf there is an error processing the operation.\n */\npublic void processOperator(String operation, List<COSBase> arguments) throws IOException {\n    Operator operator = Operator.getOperator(operation);\n    processOperator(operator, arguments);\n}", "/**\n * This is used to handle an operation.\n *\n * @param operator\n * \t\tThe operation to perform.\n * @param operands\n * \t\tThe list of arguments.\n * @throws IOException\n * \t\tIf there is an error processing the operation.\n */\nprotected void processOperator(Operator operator, List<COSBase> operands) throws IOException {\n    String name = operator.getName();\n    OperatorProcessor processor = operators.get(name);\n    if (processor != null) {\n        try {\n            processor.process(operator, operands);\n        } catch (IOException e) {\n            operatorException(operator, operands, e);\n        }\n    } else {\n        unsupportedOperator(operator, operands);\n    }\n}", "/**\n * Called when an exception is thrown by an operator.\n *\n * @param operator\n * \t\tThe unknown operator.\n * @param operands\n * \t\tThe list of operands.\n * @param exception\n * \t\tthe exception which occurred when processing the operator\n * @throws IOException\n * \t\tif there is an error processing the operator exception\n */\nprotected void operatorException(Operator operator, List<COSBase> operands, IOException exception) throws IOException {\n    if (((exception instanceof MissingOperandException) || (exception instanceof MissingResourceException)) || (exception instanceof MissingImageReaderException)) {\n        LOG.error(exception.getMessage(), exception);\n    } else if (exception instanceof EmptyGraphicsStackException) {\n        LOG.warn(exception.getMessage(), exception);\n    } else if (operator.getName().equals(\"Do\")) {\n        // todo: this too forgiving, but PDFBox has always worked this way for DrawObject\n        // some careful refactoring is needed\n        LOG.warn(exception.getMessage(), exception);\n    } else if (exception.getCause() instanceof DataFormatException) {\n        LOG.warn(exception.getMessage(), exception);\n    } else {\n        throw exception;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Sets the entry \"V\" to the given values. Requires {@link #isMultiSelect()} to be true.\n *\n * @param values\n * \t\tthe list of values\n * @throws IOException\n * \t\tif the appearance couldn't be generated.\n */\npublic void setValue(List<String> values) throws IOException {\n    if ((values != null) && (!values.isEmpty())) {\n        if (!isMultiSelect()) {\n            throw new IllegalArgumentException(\"The list box does not allow multiple selections.\");\n        }\n        List<String> options = getOptions();\n        if (!options.containsAll(values)) {\n            throw new IllegalArgumentException(\"The values are not contained in the selectable options.\");\n        }\n        getCOSObject().setItem(COSName.V, COSArray.ofCOSStrings(values));\n        updateSelectedOptionsIndex(values, options);\n    } else {\n        getCOSObject().removeItem(COSName.V);\n        getCOSObject().removeItem(COSName.I);\n    }\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Parse all compressed objects. The stream is closed after parsing.\n *\n * @return a map containing all parsed objects using the object number as key\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic Map<COSObjectKey, COSBase> parseAllObjects() throws IOException {\n    Map<COSObjectKey, COSBase> allObjects = new HashMap<>();\n    try {\n        Map<Integer, Long> objectNumbers = privateReadObjectOffsets();\n        // count the number of object numbers eliminating double entries\n        long numberOfObjNumbers = objectNumbers.values().stream().distinct().count();\n        // the usage of the index should be restricted to cases where more than one\n        // object use the same object number.\n        // there are malformed pdfs in the wild which would lead to false results if\n        // pdfbox always relies on the index if available. In most cases the object number\n        // is sufficient to choose the correct object\n        boolean indexNeeded = objectNumbers.size() > numberOfObjNumbers;\n        long currentPosition = source.getPosition();\n        if ((firstObject > 0) && (currentPosition < firstObject)) {\n            source.skip(firstObject - ((int) (currentPosition)));\n        }\n        int index = 0;\n        for (Entry<Integer, Long> entry : objectNumbers.entrySet()) {\n            COSObjectKey objectKey = getObjectKey(entry.getValue(), 0);\n            // skip object if the index doesn't match\n            if ((indexNeeded && (objectKey.getStreamIndex() > (-1))) && (objectKey.getStreamIndex() != index)) {\n                index++;\n                continue;\n            }\n            int finalPosition = firstObject + entry.getKey();\n            currentPosition = source.getPosition();\n            if ((finalPosition > 0) && (currentPosition < finalPosition)) {\n                // jump to the offset of the object to be parsed\n                source.skip(finalPosition - ((int) (currentPosition)));\n            }\n            COSBase streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n            allObjects.put(objectKey, streamObject);\n            index++;\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return allObjects;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.toUnicode" ],
    "fullMethods" : [ "@Override\npublic String toUnicode(int code) {\n    // try to use a ToUnicode CMap\n    String unicode = super.toUnicode(code);\n    if (unicode != null) {\n        return unicode;\n    }\n    // Use identity mapping if the given ToUnicode CMap doesn't provide any valid mapping\n    // a predefined map shall only be used if there isn't any ToUnicode CMap\n    // PDFBOX-6022: not when there's a predefined cmap\n    if ((getToUnicodeCMap() != null) && (!isCMapPredefined)) {\n        return Character.toString(((char) (code)));\n    }\n    if ((isCMapPredefined || isDescendantCJK) && (cMapUCS2 != null)) {\n        // if the font is composite and uses a predefined cmap (excluding Identity-H/V) then\n        // or if its descendant font uses Adobe-GB1/CNS1/Japan1/Korea1\n        // a) Map the character code to a character identifier (CID) according to the font?s CMap\n        int cid = codeToCID(code);\n        // e) Map the CID according to the CMap from step d), producing a Unicode value\n        return cMapUCS2.toUnicode(cid);\n    }\n    // PDFBOX-5324: try to get unicode from font cmap\n    if (descendantFont instanceof PDCIDFontType2) {\n        TrueTypeFont font = ((PDCIDFontType2) (descendantFont)).getTrueTypeFont();\n        if (font != null) {\n            try {\n                CmapLookup cmap = font.getUnicodeCmapLookup(false);\n                if (cmap != null) {\n                    int gid;\n                    if (descendantFont.isEmbedded()) {\n                        // original PDFBOX-5324 supported only embedded fonts\n                        gid = descendantFont.codeToGID(code);\n                    } else {\n                        // PDFBOX-5331: this bypasses the fallback attempt in\n                        // PDCIDFontType2.codeToGID() which would bring a stackoverflow\n                        gid = descendantFont.codeToCID(code);\n                    }\n                    List<Integer> codes = cmap.getCharCodes(gid);\n                    if ((codes != null) && (!codes.isEmpty())) {\n                        return Character.toString(((char) (int) (codes.get(0))));\n                    }\n                }\n            } catch (IOException e) {\n                LOG.warn(\"get unicode from font cmap fail\", e);\n            }\n        }\n    }\n    if (LOG.isWarnEnabled() && (!noUnicode.contains(code))) {\n        // if no value has been produced, there is no way to obtain Unicode for the character.\n        String cid = \"CID+\" + codeToCID(code);\n        LOG.warn(((((\"No Unicode mapping for \" + cid) + \" (\") + code) + \") in font \") + getName());\n        // we keep track of which warnings have been issued, so we don't log multiple times\n        noUnicode.add(code);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Sets the value of this field to be the given signature.\n *\n * @param value\n * \t\tis the PDSignatureField\n * @throws IOException\n * \t\tif the new value could not be applied\n */\npublic void setValue(PDSignature value) throws IOException {\n    getCOSObject().setItem(COSName.V, value);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadFDF",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadFDF", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will load a document from a file.\n *\n * @param file\n * \t\tThe name of the file to load. {@link org.apache.pdfbox.io.RandomAccessReadBufferedFile} is used to\n * \t\tread the file.\n * @return The document that was loaded.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\npublic static FDFDocument loadFDF(File file) throws IOException {\n    RandomAccessRead raFile = null;\n    try {\n        // PDFBOX-5894: RandomAccessRead is not closed here\n        raFile = new RandomAccessReadBufferedFile(file);\n        FDFParser parser = new FDFParser(raFile);\n        return parser.parse();\n    } catch (IOException ioe) {\n        IOUtils.closeQuietly(raFile);\n        throw ioe;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Set the plain text value of this field, and try to update the visual appearance.\n *\n * @param value\n * \t\tPlain text\n * @throws IOException\n * \t\tif the value could not be set\n */\n@Override\npublic void setValue(String value) throws IOException {\n    getCOSObject().setString(COSName.V, value);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup", "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroupOnGraphics", "org.apache.pdfbox.rendering.PageDrawer.TransparencyGroup.<init>", "org.apache.pdfbox.rendering.PageDrawer.TransparencyGroup.<init>", "org.apache.pdfbox.rendering.PageDrawer.access", "org.apache.pdfbox.contentstream.PDFStreamEngine.processTransparencyGroup", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void showTransparencyGroup(PDTransparencyGroup form) throws IOException {\n    showTransparencyGroupOnGraphics(form, graphics);\n}", "/**\n * For advanced users, to extract the transparency group into a separate graphics device.\n *\n * @param form\n * \t\tthe transparency group to be extracted\n * @param graphics\n * \t\tthe target graphics device\n * @throws IOException\n * \t\tif the transparency group could not be extracted\n */\nprotected void showTransparencyGroupOnGraphics(PDTransparencyGroup form, Graphics2D graphics) throws IOException {\n    if (isHiddenOCG(form.getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    TransparencyGroup group = new TransparencyGroup(form, false, getGraphicsState().getCurrentTransformationMatrix(), null);\n    BufferedImage image = group.getImage();\n    if (image == null) {\n        // image is empty, don't bother\n        return;\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    // both the DPI xform and the CTM were already applied to the group, so all we do\n    // here is draw it directly onto the Graphics2D device at the appropriate position\n    AffineTransform savedTransform = graphics.getTransform();\n    AffineTransform transform = new AffineTransform(xform);\n    transform.scale(1.0 / xformScalingFactorX, 1.0 / xformScalingFactorY);\n    graphics.setTransform(transform);\n    // adjust bbox (x,y) position at the initial scale + cropbox\n    PDRectangle bbox = group.getBBox();\n    float x = bbox.getLowerLeftX() - pageSize.getLowerLeftX();\n    float y = pageSize.getUpperRightY() - bbox.getUpperRightY();\n    if (flipTG) {\n        graphics.translate(0, image.getHeight());\n        graphics.scale(1, -1);\n    } else {\n        graphics.translate(x * xformScalingFactorX, y * xformScalingFactorY);\n    }\n    PDSoftMask softMask = getGraphicsState().getSoftMask();\n    if (softMask != null) {\n        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Float(0, 0, image.getWidth(), image.getHeight()));\n        awtPaint = applySoftMaskToPaint(awtPaint, softMask);\n        graphics.setPaint(awtPaint);\n        graphics.fill(new Rectangle2D.Float(0, 0, bbox.getWidth() * xformScalingFactorX, bbox.getHeight() * xformScalingFactorY));\n    } else {\n        try {\n            graphics.drawImage(image, null, null);\n        } catch (InternalError ie) {\n            LOG.error(\"Exception drawing image, see JDK-6689349, \" + \"try rendering into a BufferedImage instead\", ie);\n        }\n    }\n    graphics.setTransform(savedTransform);\n}", "/**\n * Creates a buffered image for a transparency group result.\n *\n * @param form\n * \t\tthe transparency group of the form or soft mask.\n * @param isSoftMask\n * \t\ttrue if this is a soft mask.\n * @param ctm\n * \t\tthe relevant current transformation matrix. For soft masks, this is the CTM at\n * \t\tthe time the soft mask is set (not at the time the soft mask is used for fill/stroke!),\n * \t\tfor forms, this is the CTM at the time the form is invoked.\n * @param backdropColor\n * \t\tthe color according to the /bc entry to be used for luminosity soft\n * \t\tmasks.\n * @throws IOException\n */\nprivate TransparencyGroup(PDTransparencyGroup form, boolean isSoftMask, Matrix ctm, PDColor backdropColor) throws IOException {\n    Graphics2D savedGraphics = graphics;\n    List<Path2D> savedLastClips = lastClips;\n    Shape savedInitialClip = initialClip;\n    // get the CTM x Form Matrix transform\n    Matrix transform = Matrix.concatenate(ctm, form.getMatrix());\n    // transform the bbox\n    PDRectangle formBBox = form.getBBox();\n    if (formBBox == null) {\n        // PDFBOX-5471\n        // check done here and not in caller to avoid getBBox() creating rectangle twice\n        LOG.warn(\"transparency group ignored because BBox is null\");\n        formBBox = new PDRectangle();\n    }\n    GeneralPath transformedBox = formBBox.transform(transform);\n    // clip the bbox to prevent giant bboxes from consuming all memory\n    Area transformed = new Area(transformedBox);\n    transformed.intersect(getGraphicsState().getCurrentClippingPath());\n    Rectangle2D clipRect = transformed.getBounds2D();\n    if (clipRect.isEmpty()) {\n        image = null;\n        bbox = null;\n        minX = 0;\n        minY = 0;\n        maxX = 0;\n        maxY = 0;\n        width = 0;\n        height = 0;\n        return;\n    }\n    this.bbox = new PDRectangle(((float) (clipRect.getX())), ((float) (clipRect.getY())), ((float) (clipRect.getWidth())), ((float) (clipRect.getHeight())));\n    // apply the underlying Graphics2D device's DPI transform\n    AffineTransform xformOriginal = xform;\n    xform = AffineTransform.getScaleInstance(xformScalingFactorX, xformScalingFactorY);\n    Rectangle2D bounds = xform.createTransformedShape(clipRect).getBounds2D();\n    minX = ((int) (Math.floor(bounds.getMinX())));\n    minY = ((int) (Math.floor(bounds.getMinY())));\n    maxX = ((int) (Math.floor(bounds.getMaxX()))) + 1;\n    maxY = ((int) (Math.floor(bounds.getMaxY()))) + 1;\n    width = maxX - minX;\n    height = maxY - minY;\n    // FIXME - color space\n    if (isGray(form.getGroup().getColorSpace(form.getResources()))) {\n        image = create2ByteGrayAlphaImage(width, height);\n    } else {\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n    boolean needsBackdrop = ((!isSoftMask) && (!form.getGroup().isIsolated())) && hasBlendMode(form, new HashSet<>());\n    BufferedImage backdropImage = null;\n    // Position of this group in parent group's coordinates\n    int backdropX = 0;\n    int backdropY = 0;\n    if (needsBackdrop) {\n        if (transparencyGroupStack.isEmpty()) {\n            // Use the current page as the parent group.\n            backdropImage = renderer.getPageImage();\n            if (backdropImage == null) {\n                needsBackdrop = false;\n            } else {\n                backdropX = minX;\n                backdropY = backdropImage.getHeight() - maxY;\n            }\n        } else {\n            TransparencyGroup parentGroup = transparencyGroupStack.peek();\n            backdropImage = parentGroup.image;\n            backdropX = minX - parentGroup.minX;\n            backdropY = parentGroup.maxY - maxY;\n        }\n    }\n    Graphics2D g = image.createGraphics();\n    if (needsBackdrop) {\n        // backdropImage must be included in group image but not in group alpha.\n        g.drawImage(backdropImage, 0, 0, width, height, backdropX, backdropY, backdropX + width, backdropY + height, null);\n        g = new GroupGraphics(image, g);\n    }\n    if (isSoftMask && (backdropColor != null)) {\n        // \"If the subtype is Luminosity, the transparency group XObject G shall be\n        // composited with a fully opaque backdrop whose colour is everywhere defined\n        // by the soft-mask dictionary's BC entry.\"\n        g.setBackground(new Color(backdropColor.toRGB()));\n        g.clearRect(0, 0, width, height);\n    }\n    // flip y-axis\n    g.translate(0, image.getHeight());\n    g.scale(1, -1);\n    boolean savedFlipTG = flipTG;\n    flipTG = false;\n    // apply device transform (DPI)\n    // the initial translation is ignored, because we're not writing into the initial graphics device\n    g.transform(xform);\n    PDRectangle pageSizeOriginal = pageSize;\n    pageSize = new PDRectangle(minX / xformScalingFactorX, minY / xformScalingFactorY, ((float) (bounds.getWidth() / xformScalingFactorX)), ((float) (bounds.getHeight() / xformScalingFactorY)));\n    int clipWindingRuleOriginal = clipWindingRule;\n    clipWindingRule = -1;\n    GeneralPath linePathOriginal = linePath;\n    linePath = new GeneralPath();\n    // adjust the origin\n    g.translate(-clipRect.getX(), -clipRect.getY());\n    graphics = g;\n    setRenderingHints();\n    try {\n        if (isSoftMask) {\n            processSoftMask(form);\n        } else {\n            transparencyGroupStack.push(this);\n            processTransparencyGroup(form);\n            if (!transparencyGroupStack.isEmpty()) {\n                transparencyGroupStack.pop();\n            }\n        }\n        if (needsBackdrop) {\n            ((GroupGraphics) (graphics)).removeBackdrop(backdropImage, backdropX, backdropY);\n        }\n    } finally {\n        flipTG = savedFlipTG;\n        lastClips = savedLastClips;\n        graphics.dispose();\n        graphics = savedGraphics;\n        initialClip = savedInitialClip;\n        clipWindingRule = clipWindingRuleOriginal;\n        linePath = linePathOriginal;\n        pageSize = pageSizeOriginal;\n        xform = xformOriginal;\n    }\n}", "/**\n * Creates a buffered image for a transparency group result.\n *\n * @param form\n * \t\tthe transparency group of the form or soft mask.\n * @param isSoftMask\n * \t\ttrue if this is a soft mask.\n * @param ctm\n * \t\tthe relevant current transformation matrix. For soft masks, this is the CTM at\n * \t\tthe time the soft mask is set (not at the time the soft mask is used for fill/stroke!),\n * \t\tfor forms, this is the CTM at the time the form is invoked.\n * @param backdropColor\n * \t\tthe color according to the /bc entry to be used for luminosity soft\n * \t\tmasks.\n * @throws IOException\n */\nprivate TransparencyGroup(PDTransparencyGroup form, boolean isSoftMask, Matrix ctm, PDColor backdropColor) throws IOException {\n    Graphics2D savedGraphics = graphics;\n    List<Path2D> savedLastClips = lastClips;\n    Shape savedInitialClip = initialClip;\n    // get the CTM x Form Matrix transform\n    Matrix transform = Matrix.concatenate(ctm, form.getMatrix());\n    // transform the bbox\n    PDRectangle formBBox = form.getBBox();\n    if (formBBox == null) {\n        // PDFBOX-5471\n        // check done here and not in caller to avoid getBBox() creating rectangle twice\n        LOG.warn(\"transparency group ignored because BBox is null\");\n        formBBox = new PDRectangle();\n    }\n    GeneralPath transformedBox = formBBox.transform(transform);\n    // clip the bbox to prevent giant bboxes from consuming all memory\n    Area transformed = new Area(transformedBox);\n    transformed.intersect(getGraphicsState().getCurrentClippingPath());\n    Rectangle2D clipRect = transformed.getBounds2D();\n    if (clipRect.isEmpty()) {\n        image = null;\n        bbox = null;\n        minX = 0;\n        minY = 0;\n        maxX = 0;\n        maxY = 0;\n        width = 0;\n        height = 0;\n        return;\n    }\n    this.bbox = new PDRectangle(((float) (clipRect.getX())), ((float) (clipRect.getY())), ((float) (clipRect.getWidth())), ((float) (clipRect.getHeight())));\n    // apply the underlying Graphics2D device's DPI transform\n    AffineTransform xformOriginal = xform;\n    xform = AffineTransform.getScaleInstance(xformScalingFactorX, xformScalingFactorY);\n    Rectangle2D bounds = xform.createTransformedShape(clipRect).getBounds2D();\n    minX = ((int) (Math.floor(bounds.getMinX())));\n    minY = ((int) (Math.floor(bounds.getMinY())));\n    maxX = ((int) (Math.floor(bounds.getMaxX()))) + 1;\n    maxY = ((int) (Math.floor(bounds.getMaxY()))) + 1;\n    width = maxX - minX;\n    height = maxY - minY;\n    // FIXME - color space\n    if (isGray(form.getGroup().getColorSpace(form.getResources()))) {\n        image = create2ByteGrayAlphaImage(width, height);\n    } else {\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n    boolean needsBackdrop = ((!isSoftMask) && (!form.getGroup().isIsolated())) && hasBlendMode(form, new HashSet<>());\n    BufferedImage backdropImage = null;\n    // Position of this group in parent group's coordinates\n    int backdropX = 0;\n    int backdropY = 0;\n    if (needsBackdrop) {\n        if (transparencyGroupStack.isEmpty()) {\n            // Use the current page as the parent group.\n            backdropImage = renderer.getPageImage();\n            if (backdropImage == null) {\n                needsBackdrop = false;\n            } else {\n                backdropX = minX;\n                backdropY = backdropImage.getHeight() - maxY;\n            }\n        } else {\n            TransparencyGroup parentGroup = transparencyGroupStack.peek();\n            backdropImage = parentGroup.image;\n            backdropX = minX - parentGroup.minX;\n            backdropY = parentGroup.maxY - maxY;\n        }\n    }\n    Graphics2D g = image.createGraphics();\n    if (needsBackdrop) {\n        // backdropImage must be included in group image but not in group alpha.\n        g.drawImage(backdropImage, 0, 0, width, height, backdropX, backdropY, backdropX + width, backdropY + height, null);\n        g = new GroupGraphics(image, g);\n    }\n    if (isSoftMask && (backdropColor != null)) {\n        // \"If the subtype is Luminosity, the transparency group XObject G shall be\n        // composited with a fully opaque backdrop whose colour is everywhere defined\n        // by the soft-mask dictionary's BC entry.\"\n        g.setBackground(new Color(backdropColor.toRGB()));\n        g.clearRect(0, 0, width, height);\n    }\n    // flip y-axis\n    g.translate(0, image.getHeight());\n    g.scale(1, -1);\n    boolean savedFlipTG = flipTG;\n    flipTG = false;\n    // apply device transform (DPI)\n    // the initial translation is ignored, because we're not writing into the initial graphics device\n    g.transform(xform);\n    PDRectangle pageSizeOriginal = pageSize;\n    pageSize = new PDRectangle(minX / xformScalingFactorX, minY / xformScalingFactorY, ((float) (bounds.getWidth() / xformScalingFactorX)), ((float) (bounds.getHeight() / xformScalingFactorY)));\n    int clipWindingRuleOriginal = clipWindingRule;\n    clipWindingRule = -1;\n    GeneralPath linePathOriginal = linePath;\n    linePath = new GeneralPath();\n    // adjust the origin\n    g.translate(-clipRect.getX(), -clipRect.getY());\n    graphics = g;\n    setRenderingHints();\n    try {\n        if (isSoftMask) {\n            processSoftMask(form);\n        } else {\n            transparencyGroupStack.push(this);\n            processTransparencyGroup(form);\n            if (!transparencyGroupStack.isEmpty()) {\n                transparencyGroupStack.pop();\n            }\n        }\n        if (needsBackdrop) {\n            ((GroupGraphics) (graphics)).removeBackdrop(backdropImage, backdropX, backdropY);\n        }\n    } finally {\n        flipTG = savedFlipTG;\n        lastClips = savedLastClips;\n        graphics.dispose();\n        graphics = savedGraphics;\n        initialClip = savedInitialClip;\n        clipWindingRule = clipWindingRuleOriginal;\n        linePath = linePathOriginal;\n        pageSize = pageSizeOriginal;\n        xform = xformOriginal;\n    }\n}", "{\n    org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup x1;\n    org.apache.pdfbox.rendering.PageDrawer x0;\n\n\n    x0 := @parameter0: org.apache.pdfbox.rendering.PageDrawer;\n    x1 := @parameter1: org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup;\n    virtualinvoke x0.<org.apache.pdfbox.rendering.PageDrawer: void processTransparencyGroup(org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup)>(x1);\n\n    return;\n}\n", "/**\n * Processes a transparency group stream.\n *\n * @param group\n * \t\ttransparency group to be processed\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\nprotected void processTransparencyGroup(PDTransparencyGroup group) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    PDResources parent = pushResources(group);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(group.getMatrix());\n    // Before execution of the transparency group XObjectâs content stream,\n    // the current blend mode in the graphics state shall be initialized to Normal,\n    // the current stroking and nonstroking alpha constants to 1.0, and the current soft mask to None.\n    graphicsState.setBlendMode(BlendMode.NORMAL);\n    graphicsState.setAlphaConstant(1);\n    graphicsState.setNonStrokeAlphaConstant(1);\n    graphicsState.setSoftMask(null);\n    // clip to bounding box\n    clipToRect(group.getBBox());\n    try {\n        processStreamOperators(group);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fdfDictionary\n * \t\tThe FDF documents catalog.\n */\npublic FDFDictionary(COSDictionary fdfDictionary) {\n    fdf = fdfDictionary;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Set the selected option given its name, and try to update the visual appearance.\n *\n * @param value\n * \t\tName of option to select\n * @throws IOException\n * \t\tif the value could not be set\n * @throws IllegalArgumentException\n * \t\tif the value is not a valid option.\n */\n@Override\npublic void setValue(String value) throws IOException {\n    checkValue(value);\n    // if there are export values/an Opt entry there is a different\n    // approach to setting the value\n    if (!getExportValues().isEmpty()) {\n        updateByOption(value);\n    } else {\n        updateByValue(value);\n    }\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.fillPath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.fillPath", "org.apache.pdfbox.rendering.PageDrawer.intersectShadingBBox", "org.apache.pdfbox.pdmodel.graphics.pattern.PDAbstractPattern.getMatrix", "org.apache.pdfbox.cos.COSDictionary.getDictionaryObject", "org.apache.pdfbox.cos.COSObject.getObject", "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject", "org.apache.pdfbox.pdfparser.COSParser.parseObjectDynamically", "org.apache.pdfbox.pdfparser.COSParser.getObjectOffset", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void fillPath(int windingRule) throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    graphics.setComposite(graphicsState.getNonStrokingJavaComposite());\n    setClip();\n    linePath.setWindingRule(windingRule);\n    // disable anti-aliasing for rectangular paths, this is a workaround to avoid small stripes\n    // which occur when solid fills are used to simulate piecewise gradients, see PDFBOX-2302\n    // note that we ignore paths with a width/height under 1 as these are fills used as strokes,\n    // see PDFBOX-1658 for an example\n    Rectangle2D bounds = linePath.getBounds2D();\n    boolean noAntiAlias = (isRectangular(linePath) && (bounds.getWidth() > 1)) && (bounds.getHeight() > 1);\n    if (noAntiAlias) {\n        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n    }\n    Shape shape;\n    if (graphicsState.getNonStrokingColorSpace() instanceof PDPattern) {\n        // apply clip to path to avoid oversized device bounds in shading contexts (PDFBOX-2901)\n        Area area = new Area(linePath);\n        Shape clip = graphics.getClip();\n        if (clip != null) {\n            area.intersect(new Area(clip));\n        }\n        intersectShadingBBox(graphicsState.getNonStrokingColor(), area);\n        shape = area;\n    } else {\n        shape = linePath;\n    }\n    if (isContentRendered() && (!shape.getPathIterator(null).isDone())) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        graphics.setPaint(getNonStrokingPaint());\n        graphics.fill(shape);\n    }\n    linePath.reset();\n    if (noAntiAlias) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "// checks whether this is a shading pattern and if yes,\n// get the transformed BBox and intersect with current paint area\n// need to do it here and not in shading getRaster() because it may have been rotated\nprivate void intersectShadingBBox(PDColor color, Area area) throws IOException {\n    if (color.getColorSpace() instanceof PDPattern) {\n        PDColorSpace colorSpace = color.getColorSpace();\n        PDAbstractPattern pat = ((PDPattern) (colorSpace)).getPattern(color);\n        if (pat instanceof PDShadingPattern) {\n            PDShading shading = ((PDShadingPattern) (pat)).getShading();\n            PDRectangle bbox = shading.getBBox();\n            if (bbox != null) {\n                Matrix m = Matrix.concatenate(getInitialMatrix(), pat.getMatrix());\n                Area bboxArea = new Area(bbox.transform(m));\n                area.intersect(bboxArea);\n            }\n        }\n    }\n}", "/**\n * Returns the pattern matrix, or the identity matrix is none is available.\n *\n * @return the pattern matrix\n */\npublic Matrix getMatrix() {\n    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));\n}", "/**\n * This will get an object from this dictionary. If the object is a reference then it will dereference it and get it\n * from the document. If the object is COSNull then null will be returned.\n *\n * @param key\n * \t\tThe key to the object that we are getting.\n * @return The object that matches the key.\n */\npublic COSBase getDictionaryObject(COSName key) {\n    COSBase retval = items.get(key);\n    if (retval instanceof COSObject) {\n        retval = ((COSObject) (retval)).getObject();\n    }\n    if (retval instanceof COSNull) {\n        retval = null;\n    }\n    return retval;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}", "@Override\npublic COSBase dereferenceCOSObject(COSObject obj) throws IOException {\n    long currentPos = source.getPosition();\n    COSObjectKey key = obj.getKey();\n    COSBase parsedObj = parseObjectDynamically(key, false);\n    if (parsedObj != null) {\n        parsedObj.setDirect(false);\n        parsedObj.setKey(key);\n    }\n    if (currentPos > 0) {\n        source.seek(currentPos);\n    }\n    return parsedObj;\n}", "/**\n * Parse the object for the given object key.\n *\n * @param objKey\n * \t\tkey of object to be parsed\n * @param requireExistingNotCompressedObj\n * \t\tif <code>true</code> the object to be parsed must be defined in xref\n * \t\t(comment: null objects may be missing from xref) and it must not be a compressed object within object stream\n * \t\t(this is used to circumvent being stuck in a loop in a malicious PDF)\n * @return the parsed object (which is also added to document object)\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprotected synchronized COSBase parseObjectDynamically(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    COSObject pdfObject = document.getObjectFromPool(objKey);\n    if (!pdfObject.isObjectNull()) {\n        return pdfObject.getObject();\n    }\n    Long offsetOrObjstmObNr = getObjectOffset(objKey, requireExistingNotCompressedObj);\n    COSBase referencedObject = null;\n    if (offsetOrObjstmObNr != null) {\n        if (offsetOrObjstmObNr > 0) {\n            referencedObject = parseFileObject(offsetOrObjstmObNr, objKey);\n        } else {\n            // xref value is object nr of object stream containing object to be parsed\n            // since our object was not found it means object stream was not parsed so far\n            referencedObject = parseObjectStreamObject(-offsetOrObjstmObNr, objKey);\n        }\n    }\n    if ((referencedObject == null) || (referencedObject instanceof COSNull)) {\n        // not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)\n        // or some other issue with dereferencing\n        // remove parser to avoid endless recursion\n        pdfObject.setToNull();\n    }\n    return referencedObject;\n}", "private Long getObjectOffset(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    // read offset or object stream object number from xref table\n    Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);\n    // maybe something is wrong with the xref table -> perform brute force search for all objects\n    if ((offsetOrObjstmObNr == null) && isLenient) {\n        offsetOrObjstmObNr = getBruteForceParser().getBFCOSObjectOffsets().get(objKey);\n        if (offsetOrObjstmObNr != null) {\n            LOG.debug(((\"Set missing offset \" + offsetOrObjstmObNr) + \" for object \") + objKey);\n            document.getXrefTable().put(objKey, offsetOrObjstmObNr);\n        }\n    }\n    // test to circumvent loops with broken documents\n    if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null) || (offsetOrObjstmObNr <= 0))) {\n        throw new IOException(((\"Object must be defined and must not be compressed object: \" + objKey.getNumber()) + \":\") + objKey.getGeneration());\n    }\n    return offsetOrObjstmObNr;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.strokePath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.strokePath", "org.apache.pdfbox.rendering.PageDrawer.getStrokingPaint", "org.apache.pdfbox.rendering.PageDrawer.applySoftMaskToPaint", "org.apache.pdfbox.rendering.PageDrawer.TransparencyGroup.<init>", "org.apache.pdfbox.rendering.PageDrawer.TransparencyGroup.<init>", "org.apache.pdfbox.rendering.PageDrawer.access", "org.apache.pdfbox.contentstream.PDFStreamEngine.processTransparencyGroup", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void strokePath() throws IOException {\n    if (isContentRendered()) {\n        graphics.setComposite(getGraphicsState().getStrokingJavaComposite());\n        graphics.setPaint(getStrokingPaint());\n        graphics.setStroke(getStroke());\n        setClip();\n        graphics.draw(linePath);\n    }\n    linePath.reset();\n}", "// returns the stroking AWT Paint\nprivate Paint getStrokingPaint() throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    return applySoftMaskToPaint(getPaint(graphicsState.getStrokingColor()), graphicsState.getSoftMask());\n}", "private Paint applySoftMaskToPaint(Paint parentPaint, PDSoftMask softMask) throws IOException {\n    if ((softMask == null) || (softMask.getGroup() == null)) {\n        return parentPaint;\n    }\n    PDColor backdropColor = null;\n    if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        COSArray backdropColorArray = softMask.getBackdropColor();\n        if (backdropColorArray != null) {\n            PDTransparencyGroup form = softMask.getGroup();\n            PDColorSpace colorSpace = form.getGroup().getColorSpace(form.getResources());\n            // PDFBOX-5795\n            if ((colorSpace != null) && (colorSpace.getNumberOfComponents() == backdropColorArray.size())) {\n                backdropColor = new PDColor(backdropColorArray, colorSpace);\n            }\n        }\n    }\n    TransparencyGroup transparencyGroup = new TransparencyGroup(softMask.getGroup(), true, softMask.getInitialTransformationMatrix(), backdropColor);\n    BufferedImage image = transparencyGroup.getImage();\n    if (image == null) {\n        // Adobe Reader ignores empty softmasks instead of using bc color\n        // sample file: PDFJS-6967_reduced_outside_softmask.pdf\n        return parentPaint;\n    }\n    BufferedImage gray = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);\n    if (COSName.ALPHA.equals(softMask.getSubType())) {\n        gray.setData(image.getAlphaRaster());\n    } else if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        Graphics g = gray.getGraphics();\n        g.drawImage(image, 0, 0, null);\n        g.dispose();\n    } else {\n        throw new IOException(\"Invalid soft mask subtype.\");\n    }\n    gray = adjustImage(gray);\n    Rectangle2D tpgBounds = transparencyGroup.getBounds();\n    return new SoftMask(parentPaint, gray, tpgBounds, backdropColor, softMask.getTransferFunction());\n}", "/**\n * Creates a buffered image for a transparency group result.\n *\n * @param form\n * \t\tthe transparency group of the form or soft mask.\n * @param isSoftMask\n * \t\ttrue if this is a soft mask.\n * @param ctm\n * \t\tthe relevant current transformation matrix. For soft masks, this is the CTM at\n * \t\tthe time the soft mask is set (not at the time the soft mask is used for fill/stroke!),\n * \t\tfor forms, this is the CTM at the time the form is invoked.\n * @param backdropColor\n * \t\tthe color according to the /bc entry to be used for luminosity soft\n * \t\tmasks.\n * @throws IOException\n */\nprivate TransparencyGroup(PDTransparencyGroup form, boolean isSoftMask, Matrix ctm, PDColor backdropColor) throws IOException {\n    Graphics2D savedGraphics = graphics;\n    List<Path2D> savedLastClips = lastClips;\n    Shape savedInitialClip = initialClip;\n    // get the CTM x Form Matrix transform\n    Matrix transform = Matrix.concatenate(ctm, form.getMatrix());\n    // transform the bbox\n    PDRectangle formBBox = form.getBBox();\n    if (formBBox == null) {\n        // PDFBOX-5471\n        // check done here and not in caller to avoid getBBox() creating rectangle twice\n        LOG.warn(\"transparency group ignored because BBox is null\");\n        formBBox = new PDRectangle();\n    }\n    GeneralPath transformedBox = formBBox.transform(transform);\n    // clip the bbox to prevent giant bboxes from consuming all memory\n    Area transformed = new Area(transformedBox);\n    transformed.intersect(getGraphicsState().getCurrentClippingPath());\n    Rectangle2D clipRect = transformed.getBounds2D();\n    if (clipRect.isEmpty()) {\n        image = null;\n        bbox = null;\n        minX = 0;\n        minY = 0;\n        maxX = 0;\n        maxY = 0;\n        width = 0;\n        height = 0;\n        return;\n    }\n    this.bbox = new PDRectangle(((float) (clipRect.getX())), ((float) (clipRect.getY())), ((float) (clipRect.getWidth())), ((float) (clipRect.getHeight())));\n    // apply the underlying Graphics2D device's DPI transform\n    AffineTransform xformOriginal = xform;\n    xform = AffineTransform.getScaleInstance(xformScalingFactorX, xformScalingFactorY);\n    Rectangle2D bounds = xform.createTransformedShape(clipRect).getBounds2D();\n    minX = ((int) (Math.floor(bounds.getMinX())));\n    minY = ((int) (Math.floor(bounds.getMinY())));\n    maxX = ((int) (Math.floor(bounds.getMaxX()))) + 1;\n    maxY = ((int) (Math.floor(bounds.getMaxY()))) + 1;\n    width = maxX - minX;\n    height = maxY - minY;\n    // FIXME - color space\n    if (isGray(form.getGroup().getColorSpace(form.getResources()))) {\n        image = create2ByteGrayAlphaImage(width, height);\n    } else {\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n    boolean needsBackdrop = ((!isSoftMask) && (!form.getGroup().isIsolated())) && hasBlendMode(form, new HashSet<>());\n    BufferedImage backdropImage = null;\n    // Position of this group in parent group's coordinates\n    int backdropX = 0;\n    int backdropY = 0;\n    if (needsBackdrop) {\n        if (transparencyGroupStack.isEmpty()) {\n            // Use the current page as the parent group.\n            backdropImage = renderer.getPageImage();\n            if (backdropImage == null) {\n                needsBackdrop = false;\n            } else {\n                backdropX = minX;\n                backdropY = backdropImage.getHeight() - maxY;\n            }\n        } else {\n            TransparencyGroup parentGroup = transparencyGroupStack.peek();\n            backdropImage = parentGroup.image;\n            backdropX = minX - parentGroup.minX;\n            backdropY = parentGroup.maxY - maxY;\n        }\n    }\n    Graphics2D g = image.createGraphics();\n    if (needsBackdrop) {\n        // backdropImage must be included in group image but not in group alpha.\n        g.drawImage(backdropImage, 0, 0, width, height, backdropX, backdropY, backdropX + width, backdropY + height, null);\n        g = new GroupGraphics(image, g);\n    }\n    if (isSoftMask && (backdropColor != null)) {\n        // \"If the subtype is Luminosity, the transparency group XObject G shall be\n        // composited with a fully opaque backdrop whose colour is everywhere defined\n        // by the soft-mask dictionary's BC entry.\"\n        g.setBackground(new Color(backdropColor.toRGB()));\n        g.clearRect(0, 0, width, height);\n    }\n    // flip y-axis\n    g.translate(0, image.getHeight());\n    g.scale(1, -1);\n    boolean savedFlipTG = flipTG;\n    flipTG = false;\n    // apply device transform (DPI)\n    // the initial translation is ignored, because we're not writing into the initial graphics device\n    g.transform(xform);\n    PDRectangle pageSizeOriginal = pageSize;\n    pageSize = new PDRectangle(minX / xformScalingFactorX, minY / xformScalingFactorY, ((float) (bounds.getWidth() / xformScalingFactorX)), ((float) (bounds.getHeight() / xformScalingFactorY)));\n    int clipWindingRuleOriginal = clipWindingRule;\n    clipWindingRule = -1;\n    GeneralPath linePathOriginal = linePath;\n    linePath = new GeneralPath();\n    // adjust the origin\n    g.translate(-clipRect.getX(), -clipRect.getY());\n    graphics = g;\n    setRenderingHints();\n    try {\n        if (isSoftMask) {\n            processSoftMask(form);\n        } else {\n            transparencyGroupStack.push(this);\n            processTransparencyGroup(form);\n            if (!transparencyGroupStack.isEmpty()) {\n                transparencyGroupStack.pop();\n            }\n        }\n        if (needsBackdrop) {\n            ((GroupGraphics) (graphics)).removeBackdrop(backdropImage, backdropX, backdropY);\n        }\n    } finally {\n        flipTG = savedFlipTG;\n        lastClips = savedLastClips;\n        graphics.dispose();\n        graphics = savedGraphics;\n        initialClip = savedInitialClip;\n        clipWindingRule = clipWindingRuleOriginal;\n        linePath = linePathOriginal;\n        pageSize = pageSizeOriginal;\n        xform = xformOriginal;\n    }\n}", "/**\n * Creates a buffered image for a transparency group result.\n *\n * @param form\n * \t\tthe transparency group of the form or soft mask.\n * @param isSoftMask\n * \t\ttrue if this is a soft mask.\n * @param ctm\n * \t\tthe relevant current transformation matrix. For soft masks, this is the CTM at\n * \t\tthe time the soft mask is set (not at the time the soft mask is used for fill/stroke!),\n * \t\tfor forms, this is the CTM at the time the form is invoked.\n * @param backdropColor\n * \t\tthe color according to the /bc entry to be used for luminosity soft\n * \t\tmasks.\n * @throws IOException\n */\nprivate TransparencyGroup(PDTransparencyGroup form, boolean isSoftMask, Matrix ctm, PDColor backdropColor) throws IOException {\n    Graphics2D savedGraphics = graphics;\n    List<Path2D> savedLastClips = lastClips;\n    Shape savedInitialClip = initialClip;\n    // get the CTM x Form Matrix transform\n    Matrix transform = Matrix.concatenate(ctm, form.getMatrix());\n    // transform the bbox\n    PDRectangle formBBox = form.getBBox();\n    if (formBBox == null) {\n        // PDFBOX-5471\n        // check done here and not in caller to avoid getBBox() creating rectangle twice\n        LOG.warn(\"transparency group ignored because BBox is null\");\n        formBBox = new PDRectangle();\n    }\n    GeneralPath transformedBox = formBBox.transform(transform);\n    // clip the bbox to prevent giant bboxes from consuming all memory\n    Area transformed = new Area(transformedBox);\n    transformed.intersect(getGraphicsState().getCurrentClippingPath());\n    Rectangle2D clipRect = transformed.getBounds2D();\n    if (clipRect.isEmpty()) {\n        image = null;\n        bbox = null;\n        minX = 0;\n        minY = 0;\n        maxX = 0;\n        maxY = 0;\n        width = 0;\n        height = 0;\n        return;\n    }\n    this.bbox = new PDRectangle(((float) (clipRect.getX())), ((float) (clipRect.getY())), ((float) (clipRect.getWidth())), ((float) (clipRect.getHeight())));\n    // apply the underlying Graphics2D device's DPI transform\n    AffineTransform xformOriginal = xform;\n    xform = AffineTransform.getScaleInstance(xformScalingFactorX, xformScalingFactorY);\n    Rectangle2D bounds = xform.createTransformedShape(clipRect).getBounds2D();\n    minX = ((int) (Math.floor(bounds.getMinX())));\n    minY = ((int) (Math.floor(bounds.getMinY())));\n    maxX = ((int) (Math.floor(bounds.getMaxX()))) + 1;\n    maxY = ((int) (Math.floor(bounds.getMaxY()))) + 1;\n    width = maxX - minX;\n    height = maxY - minY;\n    // FIXME - color space\n    if (isGray(form.getGroup().getColorSpace(form.getResources()))) {\n        image = create2ByteGrayAlphaImage(width, height);\n    } else {\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n    boolean needsBackdrop = ((!isSoftMask) && (!form.getGroup().isIsolated())) && hasBlendMode(form, new HashSet<>());\n    BufferedImage backdropImage = null;\n    // Position of this group in parent group's coordinates\n    int backdropX = 0;\n    int backdropY = 0;\n    if (needsBackdrop) {\n        if (transparencyGroupStack.isEmpty()) {\n            // Use the current page as the parent group.\n            backdropImage = renderer.getPageImage();\n            if (backdropImage == null) {\n                needsBackdrop = false;\n            } else {\n                backdropX = minX;\n                backdropY = backdropImage.getHeight() - maxY;\n            }\n        } else {\n            TransparencyGroup parentGroup = transparencyGroupStack.peek();\n            backdropImage = parentGroup.image;\n            backdropX = minX - parentGroup.minX;\n            backdropY = parentGroup.maxY - maxY;\n        }\n    }\n    Graphics2D g = image.createGraphics();\n    if (needsBackdrop) {\n        // backdropImage must be included in group image but not in group alpha.\n        g.drawImage(backdropImage, 0, 0, width, height, backdropX, backdropY, backdropX + width, backdropY + height, null);\n        g = new GroupGraphics(image, g);\n    }\n    if (isSoftMask && (backdropColor != null)) {\n        // \"If the subtype is Luminosity, the transparency group XObject G shall be\n        // composited with a fully opaque backdrop whose colour is everywhere defined\n        // by the soft-mask dictionary's BC entry.\"\n        g.setBackground(new Color(backdropColor.toRGB()));\n        g.clearRect(0, 0, width, height);\n    }\n    // flip y-axis\n    g.translate(0, image.getHeight());\n    g.scale(1, -1);\n    boolean savedFlipTG = flipTG;\n    flipTG = false;\n    // apply device transform (DPI)\n    // the initial translation is ignored, because we're not writing into the initial graphics device\n    g.transform(xform);\n    PDRectangle pageSizeOriginal = pageSize;\n    pageSize = new PDRectangle(minX / xformScalingFactorX, minY / xformScalingFactorY, ((float) (bounds.getWidth() / xformScalingFactorX)), ((float) (bounds.getHeight() / xformScalingFactorY)));\n    int clipWindingRuleOriginal = clipWindingRule;\n    clipWindingRule = -1;\n    GeneralPath linePathOriginal = linePath;\n    linePath = new GeneralPath();\n    // adjust the origin\n    g.translate(-clipRect.getX(), -clipRect.getY());\n    graphics = g;\n    setRenderingHints();\n    try {\n        if (isSoftMask) {\n            processSoftMask(form);\n        } else {\n            transparencyGroupStack.push(this);\n            processTransparencyGroup(form);\n            if (!transparencyGroupStack.isEmpty()) {\n                transparencyGroupStack.pop();\n            }\n        }\n        if (needsBackdrop) {\n            ((GroupGraphics) (graphics)).removeBackdrop(backdropImage, backdropX, backdropY);\n        }\n    } finally {\n        flipTG = savedFlipTG;\n        lastClips = savedLastClips;\n        graphics.dispose();\n        graphics = savedGraphics;\n        initialClip = savedInitialClip;\n        clipWindingRule = clipWindingRuleOriginal;\n        linePath = linePathOriginal;\n        pageSize = pageSizeOriginal;\n        xform = xformOriginal;\n    }\n}", "{\n    org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup x1;\n    org.apache.pdfbox.rendering.PageDrawer x0;\n\n\n    x0 := @parameter0: org.apache.pdfbox.rendering.PageDrawer;\n    x1 := @parameter1: org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup;\n    virtualinvoke x0.<org.apache.pdfbox.rendering.PageDrawer: void processTransparencyGroup(org.apache.pdfbox.pdmodel.graphics.form.PDTransparencyGroup)>(x1);\n\n    return;\n}\n", "/**\n * Processes a transparency group stream.\n *\n * @param group\n * \t\ttransparency group to be processed\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\nprotected void processTransparencyGroup(PDTransparencyGroup group) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    PDResources parent = pushResources(group);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(group.getMatrix());\n    // Before execution of the transparency group XObjectâs content stream,\n    // the current blend mode in the graphics state shall be initialized to Normal,\n    // the current stroking and nonstroking alpha constants to 1.0, and the current soft mask to None.\n    graphicsState.setBlendMode(BlendMode.NORMAL);\n    graphicsState.setAlphaConstant(1);\n    graphicsState.setNonStrokeAlphaConstant(1);\n    graphicsState.setSoftMask(null);\n    // clip to bounding box\n    clipToRect(group.getBBox());\n    try {\n        processStreamOperators(group);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * Processes the operators of the given content stream.\n *\n * @param contentStream\n * \t\tto content stream to parse.\n * @throws IOException\n * \t\tif there is an error reading or parsing the content stream.\n */\nprivate void processStreamOperators(PDContentStream contentStream) throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(contentStream);\n    Object token = parser.parseNextToken();\n    boolean isFirstOperator = true;\n    boolean oldShouldProcessColorOperators = shouldProcessColorOperators;\n    shouldProcessColorOperators = true;\n    if ((contentStream instanceof PDTilingPattern) && (((PDTilingPattern) (contentStream)).getPaintType() == PDTilingPattern.PAINT_UNCOLORED)) {\n        shouldProcessColorOperators = false;\n    }\n    try {\n        while (token != null) {\n            if (token instanceof Operator) {\n                if ((isFirstOperator && (contentStream instanceof PDType3CharProc)) && OperatorName.TYPE3_D1.equals(((Operator) (token)).getName())) {\n                    shouldProcessColorOperators = false;\n                }\n                isFirstOperator = false;\n                processOperator(((Operator) (token)), arguments);\n                arguments.clear();\n            } else {\n                arguments.add(((COSBase) (token)));\n            }\n            token = parser.parseNextToken();\n        } \n    } finally {\n        shouldProcessColorOperators = oldShouldProcessColorOperators;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject", "org.apache.pdfbox.pdfparser.COSParser.parseObjectDynamically", "org.apache.pdfbox.pdfparser.COSParser.getObjectOffset", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "@Override\npublic COSBase dereferenceCOSObject(COSObject obj) throws IOException {\n    long currentPos = source.getPosition();\n    COSObjectKey key = obj.getKey();\n    COSBase parsedObj = parseObjectDynamically(key, false);\n    if (parsedObj != null) {\n        parsedObj.setDirect(false);\n        parsedObj.setKey(key);\n    }\n    if (currentPos > 0) {\n        source.seek(currentPos);\n    }\n    return parsedObj;\n}", "/**\n * Parse the object for the given object key.\n *\n * @param objKey\n * \t\tkey of object to be parsed\n * @param requireExistingNotCompressedObj\n * \t\tif <code>true</code> the object to be parsed must be defined in xref\n * \t\t(comment: null objects may be missing from xref) and it must not be a compressed object within object stream\n * \t\t(this is used to circumvent being stuck in a loop in a malicious PDF)\n * @return the parsed object (which is also added to document object)\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprotected synchronized COSBase parseObjectDynamically(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    COSObject pdfObject = document.getObjectFromPool(objKey);\n    if (!pdfObject.isObjectNull()) {\n        return pdfObject.getObject();\n    }\n    Long offsetOrObjstmObNr = getObjectOffset(objKey, requireExistingNotCompressedObj);\n    COSBase referencedObject = null;\n    if (offsetOrObjstmObNr != null) {\n        if (offsetOrObjstmObNr > 0) {\n            referencedObject = parseFileObject(offsetOrObjstmObNr, objKey);\n        } else {\n            // xref value is object nr of object stream containing object to be parsed\n            // since our object was not found it means object stream was not parsed so far\n            referencedObject = parseObjectStreamObject(-offsetOrObjstmObNr, objKey);\n        }\n    }\n    if ((referencedObject == null) || (referencedObject instanceof COSNull)) {\n        // not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)\n        // or some other issue with dereferencing\n        // remove parser to avoid endless recursion\n        pdfObject.setToNull();\n    }\n    return referencedObject;\n}", "private Long getObjectOffset(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    // read offset or object stream object number from xref table\n    Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);\n    // maybe something is wrong with the xref table -> perform brute force search for all objects\n    if ((offsetOrObjstmObNr == null) && isLenient) {\n        offsetOrObjstmObNr = getBruteForceParser().getBFCOSObjectOffsets().get(objKey);\n        if (offsetOrObjstmObNr != null) {\n            LOG.debug(((\"Set missing offset \" + offsetOrObjstmObNr) + \" for object \") + objKey);\n            document.getXrefTable().put(objKey, offsetOrObjstmObNr);\n        }\n    }\n    // test to circumvent loops with broken documents\n    if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null) || (offsetOrObjstmObNr <= 0))) {\n        throw new IOException(((\"Object must be defined and must not be compressed object: \" + objKey.getNumber()) + \":\") + objKey.getGeneration());\n    }\n    return offsetOrObjstmObNr;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.Loader.loadPDF",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.Loader.loadPDF", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Parses a PDF.\n *\n * @param randomAccessRead\n * \t\trandom access read representing the pdf to be loaded. To pass an\n * \t\tInputStream, wrap it into a {@link RandomAccessReadBuffer}.\n * @param password\n * \t\tpassword to be used for decryption\n * @param keyStore\n * \t\tkey store to be used for decryption when using public key security\n * @param alias\n * \t\talias to be used for decryption when using public key security\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache to be used for buffering\n * \t\tnew/altered PDF streams\n * @return loaded document\n * @throws IOException\n * \t\tin case of a file reading or parsing error\n */\npublic static PDDocument loadPDF(RandomAccessRead randomAccessRead, String password, InputStream keyStore, String alias, StreamCacheCreateFunction streamCacheCreateFunction) throws IOException {\n    PDFParser parser = new PDFParser(randomAccessRead, password, keyStore, alias, streamCacheCreateFunction);\n    return parser.parse();\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText", "org.apache.pdfbox.pdmodel.font.PDFont.getDisplacement", "org.apache.pdfbox.pdmodel.font.PDFont.getWidth", "org.apache.pdfbox.pdmodel.font.PDType3Font.getWidthFromFont", "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getWidth", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * Called when a string of text with spacing adjustments is to be shown.\n *\n * @param array\n * \t\tarray of encoded text strings and adjustments\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextStrings(COSArray array) throws IOException {\n    PDTextState textState = getGraphicsState().getTextState();\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    PDFont font = textState.getFont();\n    boolean isVertical = false;\n    if (font != null) {\n        isVertical = font.isVertical();\n    }\n    for (COSBase obj : array) {\n        if (obj instanceof COSNumber) {\n            float tj = ((COSNumber) (obj)).floatValue();\n            // calculate the combined displacements\n            float tx;\n            float ty;\n            if (isVertical) {\n                tx = 0;\n                ty = ((-tj) / 1000) * fontSize;\n            } else {\n                tx = (((-tj) / 1000) * fontSize) * horizontalScaling;\n                ty = 0;\n            }\n            applyTextAdjustment(tx, ty);\n        } else if (obj instanceof COSString) {\n            byte[] string = ((COSString) (obj)).getBytes();\n            showText(string);\n        } else if (obj instanceof COSArray) {\n            LOG.error(\"Nested arrays are not allowed in an array for TJ operation: \" + obj);\n        } else {\n            LOG.error(((\"Unknown type \" + obj.getClass().getSimpleName()) + \" in array for TJ operation: \") + obj);\n        }\n    }\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}", "/**\n * Returns the displacement vector (w0, w1) in text space, for the given character. For horizontal text only the x\n * component is used, for vertical text only the y component.\n *\n * @param code\n * \t\tcharacter code\n * @return displacement vector\n * @throws IOException\n * \t\tif the data could not be read\n */\npublic Vector getDisplacement(int code) throws IOException {\n    return new Vector(getWidth(code) / 1000, 0);\n}", "@Override\npublic float getWidth(int code) throws IOException {\n    Float width = codeToWidthMap.get(code);\n    if (width != null) {\n        return width;\n    }\n    // Acrobat overrides the widths in the font program on the conforming reader's system with\n    // the widths specified in the font dictionary.\" (Adobe Supplement to the ISO 32000)\n    // \n    // Note: The Adobe Supplement says that the override happens \"If the font program is not\n    // embedded\", however PDFBOX-427 shows that it also applies to embedded fonts.\n    // Type1, Type1C, Type3\n    if ((dict.getDictionaryObject(COSName.WIDTHS) != null) || dict.containsKey(COSName.MISSING_WIDTH)) {\n        int firstChar = dict.getInt(COSName.FIRST_CHAR, -1);\n        int lastChar = dict.getInt(COSName.LAST_CHAR, -1);\n        int siz = getWidths().size();\n        int idx = code - firstChar;\n        if ((((siz > 0) && (code >= firstChar)) && (code <= lastChar)) && (idx < siz)) {\n            width = getWidths().get(idx);\n            if (width == null) {\n                width = 0.0F;\n            }\n            codeToWidthMap.put(code, width);\n            return width;\n        }\n        PDFontDescriptor fd = getFontDescriptor();\n        if (fd != null) {\n            // get entry from /MissingWidth entry\n            width = fd.getMissingWidth();\n            codeToWidthMap.put(code, width);\n            return width;\n        }\n    }\n    // standard 14 font widths are specified by an AFM\n    if (isStandard14()) {\n        width = getStandard14Width(code);\n        codeToWidthMap.put(code, width);\n        return width;\n    }\n    // if there's nothing to override with, then obviously we fall back to the font\n    width = getWidthFromFont(code);\n    codeToWidthMap.put(code, width);\n    return width;\n}", "@Override\npublic float getWidthFromFont(int code) throws IOException {\n    PDType3CharProc charProc = getCharProc(code);\n    if ((charProc == null) || (charProc.getCOSObject().getLength() == 0)) {\n        return 0;\n    }\n    return charProc.getWidth();\n}", "/**\n * Get the width from a type3 charproc stream.\n *\n * @return the glyph width.\n * @throws IOException\n * \t\tif the stream could not be read, or did not have d0 or d1 as first\n * \t\toperator, or if their first argument was not a number.\n */\npublic float getWidth() throws IOException {\n    List<COSBase> arguments = new ArrayList<>();\n    PDFStreamParser parser = new PDFStreamParser(this);\n    Object token = parser.parseNextToken();\n    while (token != null) {\n        if (token instanceof Operator) {\n            return parseWidth(((Operator) (token)), arguments);\n        } else {\n            arguments.add(((COSBase) (token)));\n        }\n        token = parser.parseNextToken();\n    } \n    throw new IOException(\"Unexpected end of stream\");\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.drawImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.drawImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.applyMask", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.scaleImage" ],
    "fullMethods" : [ "@Override\npublic void drawImage(PDImage pdImage) throws IOException {\n    if ((pdImage instanceof PDImageXObject) && isHiddenOCG(((PDImageXObject) (pdImage)).getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    AffineTransform at = ctm.createAffineTransform();\n    if (!pdImage.getInterpolate()) {\n        // if the image is scaled down, we use smooth interpolation, eg PDFBOX-2364\n        // only when scaled up do we use nearest neighbour, eg PDFBOX-2302 / mori-cvpr01.pdf\n        // PDFBOX-4930: we use the sizes of the ARGB image. These can be different\n        // than the original sizes of the base image, when the mask is bigger.\n        // PDFBOX-5091: also consider subsampling, the sizes are different too.\n        BufferedImage bim;\n        if (subsamplingAllowed) {\n            bim = pdImage.getImage(null, getSubsampling(pdImage, at));\n        } else {\n            bim = pdImage.getImage();\n        }\n        boolean isScaledUp = (bim.getWidth() <= Math.abs(Math.round(ctm.getScalingFactorX() * xformScalingFactorX))) || (bim.getHeight() <= Math.abs(Math.round(ctm.getScalingFactorY() * xformScalingFactorY)));\n        if (isScaledUp) {\n            graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        }\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    if (pdImage.isStencil()) {\n        if (getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDPattern) {\n            // The earlier code for stencils (see \"else\") doesn't work with patterns because the\n            // CTM is not taken into consideration.\n            // this code is based on the fact that it is easily possible to draw the mask and\n            // the paint at the correct place with the existing code, but not in one step.\n            // Thus what we do is to draw both in separate images, then combine the two and draw\n            // the result.\n            // Note that the device scale is not used. In theory, some patterns can get better\n            // at higher resolutions but the stencil would become more and more \"blocky\".\n            // If anybody wants to do this, have a look at the code in showTransparencyGroup().\n            // draw the paint\n            Paint paint = getNonStrokingPaint();\n            Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);\n            Rectangle2D bounds = at.createTransformedShape(unitRect).getBounds2D();\n            int w = ((int) (Math.ceil(bounds.getWidth())));\n            int h = ((int) (Math.ceil(bounds.getHeight())));\n            BufferedImage renderedPaint = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n            Graphics2D g = ((Graphics2D) (renderedPaint.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setPaint(paint);\n            g.setRenderingHints(graphics.getRenderingHints());\n            g.fill(bounds);\n            g.dispose();\n            // draw the mask\n            BufferedImage mask = pdImage.getImage();\n            AffineTransform imageTransform = new AffineTransform(at);\n            imageTransform.scale(1.0 / mask.getWidth(), (-1.0) / mask.getHeight());\n            imageTransform.translate(0, -mask.getHeight());\n            AffineTransform full = new AffineTransform(g.getTransform());\n            full.concatenate(imageTransform);\n            Matrix m = new Matrix(full);\n            double scaleX = Math.abs(m.getScalingFactorX());\n            double scaleY = Math.abs(m.getScalingFactorY());\n            boolean smallMask = (mask.getWidth() <= 8) && (mask.getHeight() <= 8);\n            if ((mask.getWidth() == 1) && (mask.getHeight() == 1)) {\n                // PDFBOX-5802: force usage of the lookup table if it is only 1 pixel\n                // (See the comment for PDFBOX-5403 that it isn't done for some\n                // cases based purely on the rendering result of one file!)\n                smallMask = false;\n            }\n            if (!smallMask) {\n                // PDFBOX-5403:\n                // The mask is copied to RGB because this supports a smooth scaling, so we\n                // get a mask with 255 values instead of just 0 and 255.\n                // Inverting is done because when we don't do it, the getScaledInstance() call\n                // produces a black line in many masks. With the inversion we have a white line\n                // which is neutral. Because of the inversion we don't have to substract from 255\n                // in the \"apply the mask\" segment when rasterPixel[3] is assigned.\n                // The inversion is not done for very small ones, because of\n                // PDFBOX-2171-002-002710-p14.pdf where the \"New Harmony Consolidated\" and\n                // \"Sailor Springs\" patterns became almost invisible.\n                // (We may have to decide this differently in the future, e.g. on b/w relationship)\n                BufferedImage tmp = new BufferedImage(mask.getWidth(), mask.getHeight(), BufferedImage.TYPE_INT_RGB);\n                mask = new LookupOp(getInvLookupTable(), graphics.getRenderingHints()).filter(mask, tmp);\n            }\n            BufferedImage renderedMask = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n            g = ((Graphics2D) (renderedMask.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setRenderingHints(graphics.getRenderingHints());\n            if (smallMask) {\n                g.drawImage(mask, imageTransform, null);\n            } else if ((scaleX != 0) && (scaleY != 0)) {\n                while ((scaleX < 0.25) || (Math.round(mask.getWidth() * scaleX) < 1)) {\n                    scaleX *= 2.0;\n                } \n                while ((scaleY < 0.25) || (Math.round(mask.getHeight() * scaleY) < 1)) {\n                    scaleY *= 2.0;\n                } \n                int w2 = ((int) (Math.round(mask.getWidth() * scaleX)));\n                int h2 = ((int) (Math.round(mask.getHeight() * scaleY)));\n                Image scaledMask = mask.getScaledInstance(w2, h2, Image.SCALE_SMOOTH);\n                imageTransform.scale(1.0F / Math.abs(scaleX), 1.0F / Math.abs(scaleY));\n                g.drawImage(scaledMask, imageTransform, null);\n            }\n            g.dispose();\n            // apply the mask\n            int[] alphaPixel = null;\n            int[] rasterPixel = null;\n            WritableRaster raster = renderedPaint.getRaster();\n            WritableRaster alpha = renderedMask.getRaster();\n            for (int y = 0; y < h; y++) {\n                for (int x = 0; x < w; x++) {\n                    alphaPixel = alpha.getPixel(x, y, alphaPixel);\n                    rasterPixel = raster.getPixel(x, y, rasterPixel);\n                    rasterPixel[3] = alphaPixel[0];\n                    raster.setPixel(x, y, rasterPixel);\n                }\n            }\n            // draw the image\n            graphics.drawImage(renderedPaint, AffineTransform.getTranslateInstance(bounds.getMinX(), bounds.getMinY()), null);\n        } else {\n            // fill the image with stenciled paint\n            BufferedImage image = pdImage.getStencilImage(getNonStrokingPaint());\n            // draw the image\n            drawBufferedImage(pdImage, image, at);\n        }\n    } else if (subsamplingAllowed) {\n        int subsampling = getSubsampling(pdImage, at);\n        // draw the subsampled image\n        drawBufferedImage(pdImage, pdImage.getImage(null, subsampling), at);\n    } else {\n        // subsampling not allowed, draw the image\n        drawBufferedImage(pdImage, pdImage.getImage(), at);\n    }\n    if (!pdImage.getInterpolate()) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "/**\n * {@inheritDoc }\n */\n@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    if (((region == null) && (subsampling == cachedImageSubsampling)) && (cachedImage != null)) {\n        BufferedImage cached = cachedImage.get();\n        if (cached != null) {\n            return cached;\n        }\n    }\n    initJPXValues();\n    // get RGB image w/o reference because applyMask might modify it, take long time and a lot of memory.\n    final BufferedImage image;\n    final PDImageXObject softMask = getSoftMask();\n    final PDImageXObject mask = getMask();\n    if (jpxSMask != null) {\n        // PDFBOX-5657: handle JPEG2000 SMaskInData\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), jpxSMask, false, true, null);\n    } else if (softMask != null) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), softMask.getOpaqueImage(region, subsampling), softMask.getInterpolate(), true, extractMatte(softMask));\n    } else if ((mask != null) && mask.isStencil()) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), mask.getOpaqueImage(region, subsampling), mask.getInterpolate(), false, null);\n    } else {\n        image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());\n    }\n    if ((region == null) && (subsampling <= cachedImageSubsampling)) {\n        // only cache full-image renders, and prefer lower subsampling frequency, as lower\n        // subsampling means higher quality and longer render times.\n        cachedImageSubsampling = subsampling;\n        cachedImage = new SoftReference<>(image);\n    }\n    return image;\n}", "/**\n *\n * @param image\n * \t\tThe image to apply the mask to as alpha channel.\n * @param mask\n * \t\tA mask image in 8 bit Gray. Even for a stencil mask image due to\n * \t\t{@link #getOpaqueImage()} and {@link SampledImageReader}'s {@code from1Bit()} special\n * \t\thandling of DeviceGray.\n * @param interpolateMask\n * \t\tinterpolation flag of the mask image.\n * @param isSoft\n * \t\t{@code true} if a soft mask. If not stencil mask, then alpha will be inverted\n * \t\tby this method.\n * @param matte\n * \t\tan optional RGB matte if a soft mask.\n * @return an ARGB image (can be the altered original image)\n */\nprivate BufferedImage applyMask(BufferedImage image, BufferedImage mask, boolean interpolateMask, boolean isSoft, float[] matte) {\n    if (mask == null) {\n        return image;\n    }\n    final int width = Math.max(image.getWidth(), mask.getWidth());\n    final int height = Math.max(image.getHeight(), mask.getHeight());\n    // scale mask to fit image, or image to fit mask, whichever is larger.\n    // also make sure that mask is 8 bit gray and image is ARGB as this\n    // is what needs to be returned.\n    if ((mask.getWidth() < width) || (mask.getHeight() < height)) {\n        mask = scaleImage(mask, width, height, BufferedImage.TYPE_BYTE_GRAY, interpolateMask);\n    } else if (mask.getType() != BufferedImage.TYPE_BYTE_GRAY) {\n        mask = scaleImage(mask, width, height, BufferedImage.TYPE_BYTE_GRAY, false);\n    }\n    if ((image.getWidth() < width) || (image.getHeight() < height)) {\n        image = scaleImage(image, width, height, BufferedImage.TYPE_INT_ARGB, getInterpolate());\n    } else if (image.getType() != BufferedImage.TYPE_INT_ARGB) {\n        image = scaleImage(image, width, height, BufferedImage.TYPE_INT_ARGB, false);\n    }\n    // compose alpha into ARGB image, either:\n    // - very fast by direct bit combination if not a soft mask and a 8 bit alpha source.\n    // - fast by letting the sample model do a bulk band operation if no matte is set.\n    // - slow and complex by matte calculations on individual pixel components.\n    final WritableRaster raster = image.getRaster();\n    final WritableRaster alpha = mask.getRaster();\n    if ((!isSoft) && (raster.getDataBuffer().getSize() == alpha.getDataBuffer().getSize())) {\n        final DataBuffer dst = raster.getDataBuffer();\n        final DataBuffer src = alpha.getDataBuffer();\n        for (int i = 0, c = dst.getSize(); c > 0; i++ , c--) {\n            dst.setElem(i, (dst.getElem(i) & 0xffffff) | ((~src.getElem(i)) << 24));\n        }\n    } else if (matte == null) {\n        final int[] samples = new int[width];\n        for (int y = 0; y < height; y++) {\n            alpha.getSamples(0, y, width, 1, 0, samples);\n            if (!isSoft) {\n                for (int x = 0; x < width; x++) {\n                    samples[x] ^= -1;\n                }\n            }\n            raster.setSamples(0, y, width, 1, 3, samples);\n        }\n    } else {\n        final int[] alphas = new int[width];\n        final int[] pixels = new int[4 * width];\n        // Original code is to clamp component and alpha to [0f, 1f] as matte is,\n        // and later expand to [0; 255] again (with rounding).\n        // component = 255f * ((component / 255f - matte) / (alpha / 255f) + matte)\n        // = (255 * component - 255 * 255f * matte) / alpha + 255f * matte\n        // There is a clearly visible factor 255 for most components in above formula,\n        // i.e. max value is 255 * 255: 16 bits + sign.\n        // Let's use faster fixed point integer arithmetics with Q16.15,\n        // introducing neglible errors (0.001%).\n        // Note: For \"correct\" rounding we increase the final matte value (m0h, m1h, m2h) by\n        // a half an integer.\n        final int fraction = 15;\n        final int factor = 255 << fraction;\n        final int m0 = Math.round(factor * matte[0]) * 255;\n        final int m1 = Math.round(factor * matte[1]) * 255;\n        final int m2 = Math.round(factor * matte[2]) * 255;\n        final int m0h = (m0 / 255) + (1 << (fraction - 1));\n        final int m1h = (m1 / 255) + (1 << (fraction - 1));\n        final int m2h = (m2 / 255) + (1 << (fraction - 1));\n        for (int y = 0; y < height; y++) {\n            raster.getPixels(0, y, width, 1, pixels);\n            alpha.getSamples(0, y, width, 1, 0, alphas);\n            int offset = 0;\n            for (int x = 0; x < width; x++) {\n                int a = alphas[x];\n                if (a == 0) {\n                    offset += 3;\n                } else {\n                    pixels[offset] = clampColor(((((pixels[offset++] * factor) - m0) / a) + m0h) >> fraction);\n                    pixels[offset] = clampColor(((((pixels[offset++] * factor) - m1) / a) + m1h) >> fraction);\n                    pixels[offset] = clampColor(((((pixels[offset++] * factor) - m2) / a) + m2h) >> fraction);\n                }\n                pixels[offset++] = a;\n            }\n            raster.setPixels(0, y, width, 1, pixels);\n        }\n    }\n    return image;\n}", "/**\n * High-quality image scaling.\n */\nprivate static BufferedImage scaleImage(BufferedImage image, int width, int height, int type, boolean interpolate) {\n    final int imgWidth = image.getWidth();\n    final int imgHeight = image.getHeight();\n    // largeScale switch is arbitrarily chosen as to where bicubic becomes very slow\n    boolean largeScale = (width * height) > ((3000 * 3000) * (type == BufferedImage.TYPE_BYTE_GRAY ? 3 : 1));\n    interpolate &= (imgWidth != width) || (imgHeight != height);\n    BufferedImage image2 = new BufferedImage(width, height, type);\n    if (interpolate) {\n        AffineTransform af = AffineTransform.getScaleInstance(((double) (width)) / imgWidth, ((double) (height)) / imgHeight);\n        AffineTransformOp afo = new AffineTransformOp(af, largeScale ? AffineTransformOp.TYPE_BILINEAR : AffineTransformOp.TYPE_BICUBIC);\n        try {\n            afo.filter(image, image2);\n            return image2;\n        } catch (ImagingOpException e) {\n            LOG.warn(e.getMessage(), e);\n        }\n    }\n    Graphics2D g = image2.createGraphics();\n    if (interpolate) {\n        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, largeScale ? RenderingHints.VALUE_INTERPOLATION_BILINEAR : RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n        g.setRenderingHint(RenderingHints.KEY_RENDERING, largeScale ? RenderingHints.VALUE_RENDER_DEFAULT : RenderingHints.VALUE_RENDER_QUALITY);\n    }\n    g.drawImage(image, 0, 0, width, height, 0, 0, imgWidth, imgHeight, null);\n    g.dispose();\n    return image2;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<init>" ],
    "fullMethods" : [ "/**\n * Creates a new TrueType font from a Font dictionary.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @throws IOException\n * \t\tif the font could not be created\n */\npublic PDTrueTypeFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    TrueTypeFont ttfFont = null;\n    boolean fontIsDamaged = false;\n    if (getFontDescriptor() != null) {\n        PDFontDescriptor fd = super.getFontDescriptor();\n        PDStream ff2Stream = fd.getFontFile2();\n        if (ff2Stream != null) {\n            RandomAccessRead view = null;\n            try {\n                view = ff2Stream.getCOSObject().createView();\n                // embedded\n                TTFParser ttfParser = getParser(view, true);\n                ttfFont = ttfParser.parse(view);\n                ttfFont.close();\n            } catch (IOException e) {\n                LOG.warn(\"Could not read embedded TTF for font \" + getBaseFont(), e);\n                fontIsDamaged = true;\n                IOUtils.closeQuietly(view);\n            }\n        }\n    }\n    isEmbedded = ttfFont != null;\n    isDamaged = fontIsDamaged;\n    // substitute\n    if (ttfFont == null) {\n        FontMapping<TrueTypeFont> mapping = FontMappers.instance().getTrueTypeFont(getBaseFont(), getFontDescriptor());\n        ttfFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + ttfFont) + \" for \") + getBaseFont());\n        }\n    }\n    otf = ((ttfFont instanceof OpenTypeFont) && ((OpenTypeFont) (ttfFont)).isSupportedOTF()) ? ((OpenTypeFont) (ttfFont)) : null;\n    ttf = ttfFont;\n    readEncoding();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceContent", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This is the public method for setting the appearance stream.\n *\n * @param apValue\n * \t\tthe String value which the appearance should represent\n * @throws IOException\n * \t\tIf there is an error creating the stream.\n */\npublic void setAppearanceValue(String apValue) throws IOException {\n    value = getFormattedValue(apValue);\n    // Treat multiline field values in single lines as single lime values.\n    // This is in line with how Adobe Reader behaves when entering text\n    // interactively but NOT how it behaves when the field value has been\n    // set programmatically and Reader is forced to generate the appearance\n    // using PDAcroForm.setNeedAppearances\n    // see PDFBOX-3911\n    if ((field instanceof PDTextField) && (!((PDTextField) (field)).isMultiline())) {\n        value = value.replaceAll(\"\\\\u000D\\\\u000A|[\\\\u000A\\\\u000B\\\\u000C\\\\u000D\\\\u0085\\\\u2028\\\\u2029]\", \" \");\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        if (widget.getCOSObject().containsKey(\"PMD\")) {\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" is a PaperMetaData widget, no appearance stream created\");\n            continue;\n        }\n        // some fields have the /Da at the widget level if the\n        // widgets differ in layout.\n        PDDefaultAppearanceString acroFormAppearance = defaultAppearance;\n        if (widget.getCOSObject().getDictionaryObject(COSName.DA) != null) {\n            defaultAppearance = getWidgetDefaultAppearanceString(widget);\n        }\n        PDRectangle rect = widget.getRectangle();\n        if (rect == null) {\n            widget.getCOSObject().removeItem(COSName.AP);\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" has no rectangle, no appearance stream created\");\n            continue;\n        }\n        PDAppearanceDictionary appearanceDict = widget.getAppearance();\n        if (appearanceDict == null) {\n            appearanceDict = new PDAppearanceDictionary();\n            widget.setAppearance(appearanceDict);\n        }\n        PDAppearanceEntry appearance = appearanceDict.getNormalAppearance();\n        // TODO support appearances other than \"normal\"\n        PDAppearanceStream appearanceStream;\n        if (isValidAppearanceStream(appearance)) {\n            appearanceStream = appearance.getAppearanceStream();\n        } else {\n            appearanceStream = prepareNormalAppearanceStream(widget);\n            appearanceDict.setNormalAppearance(appearanceStream);\n            // TODO support appearances other than \"normal\"\n        }\n        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();\n        /* Adobe Acrobat always recreates the complete appearance stream if there is an appearance characteristics\n        entry (the widget dictionaries MK entry). In addition if there is no content yet also create the appearance\n        stream from the entries.\n         */\n        if ((appearanceCharacteristics != null) || (appearanceStream.getContentStream().getLength() == 0)) {\n            initializeAppearanceContent(widget, appearanceCharacteristics, appearanceStream);\n        }\n        setAppearanceContent(widget, appearanceStream);\n        // restore the field level appearance\n        defaultAppearance = acroFormAppearance;\n    }\n}", "/**\n * Constructs and sets new contents for given appearance stream.\n */\nprivate void setAppearanceContent(PDAnnotationWidget widget, PDAppearanceStream appearanceStream) throws IOException {\n    // first copy any needed resources from the documentâs DR dictionary into\n    // the streamâs Resources dictionary\n    defaultAppearance.copyNeededResourcesTo(appearanceStream);\n    // then replace the existing contents of the appearance stream from /Tx BMC\n    // to the matching EMC\n    try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n        ContentStreamWriter writer = new ContentStreamWriter(output);\n        List<Object> tokens = new PDFStreamParser(appearanceStream).parse();\n        int bmcIndex = tokens.indexOf(BMC);\n        if (bmcIndex == (-1)) {\n            // append to existing stream\n            writer.writeTokens(tokens);\n            writer.writeTokens(COSName.TX, BMC);\n        } else {\n            // prepend content before BMC\n            writer.writeTokens(tokens.subList(0, bmcIndex + 1));\n        }\n        // insert field contents\n        insertGeneratedAppearance(widget, appearanceStream, output);\n        int emcIndex = tokens.indexOf(EMC);\n        if (emcIndex == (-1)) {\n            // append EMC\n            writer.writeTokens(EMC);\n        } else {\n            // append contents after EMC\n            writer.writeTokens(tokens.subList(emcIndex, tokens.size()));\n        }\n        writeToStream(output.toByteArray(), appearanceStream);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFParser.parse", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the PDDocument object. This will close the keystore stream when it is\n * done parsing.\n *\n * @param lenient\n * \t\tactivate leniency if set to true\n * @return the populated PDDocument\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic PDDocument parse(boolean lenient) throws IOException {\n    setLenient(lenient);\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        // PDFBOX-1922 read the version header and rewind\n        if ((!parsePDFHeader()) && (!parseFDFHeader())) {\n            if (lenient) {\n                LOG.warn(\"Error: Header doesn't contain versioninfo\");\n            } else {\n                throw new IOException(\"Error: Header doesn't contain versioninfo\");\n            }\n        }\n        if (!initialParseDone) {\n            initialParse();\n        }\n        exceptionOccurred = false;\n        PDDocument pdDocument = createDocument();\n        pdDocument.setEncryptionDictionary(getEncryption());\n        return pdDocument;\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken", "org.apache.pdfbox.pdfparser.BaseParser.<clinit>" ],
    "fullMethods" : [ "/**\n * This will parse the next token in the stream.\n *\n * @return The next token in the stream or null if there are no more tokens in the stream.\n * @throws IOException\n * \t\tIf an io error occurs while parsing the stream.\n */\npublic Object parseNextToken() throws IOException {\n    if (source.isClosed()) {\n        return null;\n    }\n    skipSpaces();\n    if (source.isEOF()) {\n        close();\n        return null;\n    }\n    char c = ((char) (source.peek()));\n    switch (c) {\n        case '<' :\n            // pull off first left bracket\n            source.read();\n            // check for second left bracket\n            c = ((char) (source.peek()));\n            // put back first bracket\n            source.rewind(1);\n            if (c == '<') {\n                try {\n                    return parseCOSDictionary(true);\n                } catch (IOException exception) {\n                    LOG.warn(\"Stop reading invalid dictionary from content stream at offset \" + source.getPosition());\n                    close();\n                    return null;\n                }\n            } else {\n                return parseCOSString();\n            }\n        case '[' :\n            // array\n            try {\n                return parseCOSArray();\n            } catch (IOException exception) {\n                LOG.warn(\"Stop reading invalid array from content stream at offset \" + source.getPosition());\n                close();\n                return null;\n            }\n        case '(' :\n            // string\n            return parseCOSString();\n        case '/' :\n            // name\n            return parseCOSName();\n        case 'n' :\n            // null\n            String nullString = readString();\n            if (nullString.equals(\"null\")) {\n                return COSNull.NULL;\n            } else {\n                return Operator.getOperator(nullString);\n            }\n        case 't' :\n        case 'f' :\n            String next = readString();\n            if (next.equals(\"true\")) {\n                return COSBoolean.TRUE;\n            } else if (next.equals(\"false\")) {\n                return COSBoolean.FALSE;\n            } else {\n                return Operator.getOperator(next);\n            }\n        case '0' :\n        case '1' :\n        case '2' :\n        case '3' :\n        case '4' :\n        case '5' :\n        case '6' :\n        case '7' :\n        case '8' :\n        case '9' :\n        case '-' :\n        case '+' :\n        case '.' :\n            /* We will be filling buf with the rest of the number.  Only\n            allow 1 \".\" and \"-\" and \"+\" at start of number.\n             */\n            StringBuilder buf = new StringBuilder();\n            buf.append(c);\n            source.read();\n            // Ignore double negative (this is consistent with Adobe Reader)\n            if ((c == '-') && (source.peek() == c)) {\n                source.read();\n            }\n            boolean dotNotRead = c != '.';\n            while ((Character.isDigit(c = ((char) (source.peek()))) || (dotNotRead && (c == '.'))) || (c == '-')) {\n                if (c != '-') {\n                    // PDFBOX-4064: ignore \"-\" in the middle of a number\n                    buf.append(c);\n                }\n                source.read();\n                if (dotNotRead && (c == '.')) {\n                    dotNotRead = false;\n                }\n            } \n            String s = buf.toString();\n            if (\"+\".equals(s)) {\n                // PDFBOX-5906\n                LOG.warn(\"isolated '+' is ignored\");\n                return COSNull.NULL;\n            }\n            return COSNumber.get(s);\n        case 'B' :\n            String nextOperator = readString();\n            Operator beginImageOP = Operator.getOperator(nextOperator);\n            if (nextOperator.equals(OperatorName.BEGIN_INLINE_IMAGE)) {\n                inlineImageDepth++;\n                if (inlineImageDepth > 1) {\n                    // PDFBOX-6038\n                    throw new IOException(((((\"Nested '\" + OperatorName.BEGIN_INLINE_IMAGE) + \"' operator not allowed at offset \") + source.getPosition()) + \", first: \") + inlineOffset);\n                } else {\n                    inlineOffset = source.getPosition();\n                }\n                COSDictionary imageParams = new COSDictionary();\n                beginImageOP.setImageParameters(imageParams);\n                Object nextToken = null;\n                while ((nextToken = parseNextToken()) instanceof COSName) {\n                    Object value = parseNextToken();\n                    if (!(value instanceof COSBase)) {\n                        LOG.warn(\"Unexpected token in inline image dictionary at offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                        break;\n                    }\n                    imageParams.setItem(((COSName) (nextToken)), ((COSBase) (value)));\n                } \n                // final token will be the image data, maybe??\n                if (nextToken instanceof Operator) {\n                    Operator imageData = ((Operator) (nextToken));\n                    if ((imageData.getImageData() == null) || (imageData.getImageData().length == 0)) {\n                        LOG.warn(\"empty inline image at stream offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                    }\n                    beginImageOP.setImageData(imageData.getImageData());\n                    inlineImageDepth--;\n                } else {\n                    LOG.warn((((((\"nextToken \" + nextToken) + \" at position \") + (source.isClosed() ? \"EOF\" : source.getPosition())) + \", expected \") + OperatorName.BEGIN_INLINE_IMAGE_DATA) + \"?!\");\n                }\n            }\n            return beginImageOP;\n        case 'I' :\n            // Special case for ID operator\n            String id = Character.toString(((char) (source.read()))) + ((char) (source.read()));\n            if (!id.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA)) {\n                long currentPosition = source.getPosition();\n                close();\n                throw new IOException(((\"Error: Expected operator 'ID' actual='\" + id) + \"' at stream offset \") + currentPosition);\n            }\n            ByteArrayOutputStream imageData = new ByteArrayOutputStream();\n            // skip one line break (CR, LF or CRLF) or any one-byte whitespace\n            if ((!skipLinebreak()) && isWhitespace()) {\n                // pull off the whitespace character\n                source.read();\n            }\n            int lastByte = source.read();\n            int currentByte = source.read();\n            // PDF spec is kinda unclear about this. Should a whitespace\n            // always appear before EI? Not sure, so that we just read\n            // until EI<whitespace>.\n            // Be aware not all kind of whitespaces are allowed here. see PDFBOX-1561\n            while ((!((((lastByte == 'E') && (currentByte == 'I')) && hasNextSpaceOrReturn()) && hasNoFollowingBinData())) && (!isEOF())) {\n                imageData.write(lastByte);\n                lastByte = currentByte;\n                currentByte = source.read();\n            } \n            // the EI operator isn't unread, as it won't be processed anyway\n            Operator beginImageDataOP = Operator.getOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);\n            // save the image data to the operator, so that it can be accessed later\n            beginImageDataOP.setImageData(imageData.toByteArray());\n            return beginImageDataOP;\n        case ']' :\n            // some ']' around without its previous '['\n            // this means a PDF is somewhat corrupt but we will continue to parse.\n            source.read();\n            // must be a better solution than null...\n            return COSNull.NULL;\n        default :\n            // we must be an operator\n            String operator = readOperator().trim();\n            if (operator.length() > 0) {\n                return Operator.getOperator(operator);\n            }\n    }\n    return null;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.process", "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.resolveFieldsFromWidgets", "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.ensureFontResources" ],
    "fullMethods" : [ "@Override\npublic void process() {\n    /* Get the AcroForm in it's current state.\n\n    Also note: getAcroForm() applies a default fixup which this processor\n    is part of. So keep the null parameter otherwise this will end\n    in an endless recursive call\n     */\n    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm(null);\n    if (acroForm != null) {\n        resolveFieldsFromWidgets(acroForm);\n    }\n}", "private void resolveFieldsFromWidgets(PDAcroForm acroForm) {\n    LOG.debug(\"rebuilding fields from widgets\");\n    PDResources resources = acroForm.getDefaultResources();\n    if (resources == null) {\n        // failsafe. Currently resources is never null because defaultfixup is called first.\n        LOG.debug(\"AcroForm default resources is null\");\n        return;\n    }\n    List<PDField> fields = new ArrayList<>();\n    Map<String, PDField> nonTerminalFieldsMap = new HashMap<>();\n    for (PDPage page : document.getPages()) {\n        try {\n            handleAnnotations(acroForm, resources, fields, page.getAnnotations(), nonTerminalFieldsMap);\n        } catch (IOException ioe) {\n            LOG.debug(\"couldn't read annotations for page \" + ioe.getMessage());\n        }\n    }\n    acroForm.setFields(fields);\n    for (PDField field : acroForm.getFieldTree()) {\n        if (field instanceof PDVariableText) {\n            ensureFontResources(resources, ((PDVariableText) (field)));\n        }\n    }\n}", "/* Lookup the font used in the default appearance and if this is \n not available try to find a suitable font and use that.\n This may not be the original font but a similar font replacement\n\n TODO: implement a font lookup similar as discussed in PDFBOX-2661 so that already existing\n       font resources might be accepatble.\n       In such case this must be implemented in PDDefaultAppearanceString too!\n */\nprivate void ensureFontResources(PDResources defaultResources, PDVariableText field) {\n    String daString = field.getDefaultAppearance();\n    if (daString.startsWith(\"/\") && (daString.length() > 1)) {\n        COSName fontName = COSName.getPDFName(daString.substring(1, daString.indexOf(\" \")));\n        try {\n            if (defaultResources.getFont(fontName) == null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"trying to add missing font resource for field \" + field.getFullyQualifiedName());\n                }\n                FontMapper mapper = FontMappers.instance();\n                FontMapping<TrueTypeFont> fontMapping = mapper.getTrueTypeFont(fontName.getName(), null);\n                if (fontMapping != null) {\n                    PDType0Font pdFont = PDType0Font.load(document, fontMapping.getFont(), false);\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(((\"looked up font for \" + fontName.getName()) + \" - found \") + fontMapping.getFont().getName());\n                    }\n                    defaultResources.put(fontName, pdFont);\n                } else if (LOG.isDebugEnabled()) {\n                    LOG.debug(((\"no suitable font found for field \" + field.getFullyQualifiedName()) + \" for font name \") + fontName.getName());\n                }\n            }\n        } catch (IOException ioe) {\n            LOG.debug(((\"unable to handle font resources for field \" + field.getFullyQualifiedName()) + \": \") + ioe.getMessage());\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getCIDFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getCIDFont" ],
    "fullMethods" : [ "/**\n * Finds a CFF CID-Keyed font with the given PostScript name, or a suitable substitute, or null.\n * This method can also map CJK fonts via their CIDSystemInfo (ROS).\n *\n * @param fontDescriptor\n * \t\tFontDescriptor\n * @param cidSystemInfo\n * \t\tthe CID system info, e.g. \"Adobe-Japan1\", if any.\n */\n@Override\npublic CIDFontMapping getCIDFont(String baseFont, PDFontDescriptor fontDescriptor, PDCIDSystemInfo cidSystemInfo) {\n    // try name match or substitute with OTF\n    OpenTypeFont otf1 = ((OpenTypeFont) (findFont(FontFormat.OTF, baseFont)));\n    if (otf1 != null) {\n        return new CIDFontMapping(otf1, null, false);\n    }\n    // try name match or substitute with TTF\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, baseFont)));\n    if (ttf != null) {\n        return new CIDFontMapping(null, ttf, false);\n    }\n    if (cidSystemInfo != null) {\n        // \"In Acrobat 3.0.1 and later, Type 0 fonts that use a CMap whose CIDSystemInfo\n        // dictionary defines the Adobe-GB1, Adobe-CNS1 Adobe-Japan1, or Adobe-Korea1 character\n        // collection can also be substituted.\" - Adobe Supplement to the ISO 32000\n        String collection = (cidSystemInfo.getRegistry() + \"-\") + cidSystemInfo.getOrdering();\n        if (((collection.equals(\"Adobe-GB1\") || collection.equals(\"Adobe-CNS1\")) || collection.equals(\"Adobe-Japan1\")) || collection.equals(\"Adobe-Korea1\")) {\n            // try automatic substitutes via character collection\n            PriorityQueue<FontMatch> queue = getFontMatches(fontDescriptor, cidSystemInfo);\n            FontMatch bestMatch = queue.poll();\n            if (bestMatch != null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(((\"Best match for '\" + baseFont) + \"': \") + bestMatch.info);\n                }\n                FontBoxFont font = bestMatch.info.getFont();\n                if (font instanceof OpenTypeFont) {\n                    return new CIDFontMapping(((OpenTypeFont) (font)), null, true);\n                } else if (font != null) {\n                    return new CIDFontMapping(null, font, true);\n                }\n            }\n        }\n    }\n    // last-resort fallback\n    return new CIDFontMapping(null, lastResortFont, true);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerCoordinate",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerCoordinate" ],
    "fullMethods" : [ "/**\n * The bits per coordinate of this shading. This will return -1 if one has\n * not been set.\n *\n * @return the number of bits per coordinate\n */\npublic int getBitsPerCoordinate() {\n    if (bitsPerCoordinate == (-1)) {\n        bitsPerCoordinate = getCOSObject().getInt(COSName.BITS_PER_COORDINATE, -1);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"bitsPerCoordinate: \" + (Math.pow(2, bitsPerCoordinate) - 1));\n        }\n    }\n    return bitsPerCoordinate;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.printing.PDFPrintable.print",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.printing.PDFPrintable.print" ],
    "fullMethods" : [ "@Override\npublic int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n    if ((pageIndex < 0) || (pageIndex >= pageTree.getCount())) {\n        return NO_SUCH_PAGE;\n    }\n    try {\n        Graphics2D graphics2D = ((Graphics2D) (graphics));\n        // capture the DPI that will be used for rasterizing the image\n        // if rasterizing is specified\n        float rasterDpi = dpi;\n        if (rasterDpi == RASTERIZE_DPI_AUTO) {\n            rasterDpi = ((float) (graphics2D.getTransform().getScaleX())) * 72.0F;\n            LOG.debug(\"auto raster dpi: \" + rasterDpi);\n        }\n        PDPage page = pageTree.get(pageIndex);\n        PDRectangle cropBox = getRotatedCropBox(page);\n        // the imageable area is the area within the page margins\n        final double imageableWidth = pageFormat.getImageableWidth();\n        final double imageableHeight = pageFormat.getImageableHeight();\n        double scale = 1;\n        if (scaling != Scaling.ACTUAL_SIZE) {\n            // scale to fit\n            double scaleX = imageableWidth / cropBox.getWidth();\n            double scaleY = imageableHeight / cropBox.getHeight();\n            scale = Math.min(scaleX, scaleY);\n            // only shrink to fit when enabled\n            if ((scale > 1) && (scaling == Scaling.SHRINK_TO_FIT)) {\n                scale = 1;\n            }\n            // only stretch to fit when enabled\n            if ((scale < 1) && (scaling == Scaling.STRETCH_TO_FIT)) {\n                scale = 1;\n            }\n        }\n        // set the graphics origin to the origin of the imageable area (i.e the margins)\n        graphics2D.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n        // center on page\n        if (center) {\n            double dx = (imageableWidth - (cropBox.getWidth() * scale)) / 2;\n            double dy = (imageableHeight - (cropBox.getHeight() * scale)) / 2;\n            if ((dx >= 0) && (dy >= 0)) {\n                graphics2D.translate(dx, dy);\n            } else {\n                // PDFBOX-3117 and https://lists.apache.org/thread/12s9tc93ofgmjfq1dpqfps9p725l0wwr\n                LOG.warn((((\"Centering disabled because of negative translation value (\" + dx) + \",\") + dy) + \")\");\n            }\n        }\n        // rasterize to bitmap (optional)\n        Graphics2D printerGraphics = null;\n        BufferedImage image = null;\n        if ((dpi > 0) || (dpi == RASTERIZE_DPI_AUTO)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"dpi set to \" + rasterDpi);\n            }\n            float dpiScale = rasterDpi / 72;\n            image = new BufferedImage(((int) ((imageableWidth * dpiScale) / scale)), ((int) ((imageableHeight * dpiScale) / scale)), BufferedImage.TYPE_INT_ARGB);\n            printerGraphics = graphics2D;\n            graphics2D = image.createGraphics();\n            // rescale\n            printerGraphics.scale(scale / dpiScale, scale / dpiScale);\n            scale = dpiScale;\n        }\n        // draw to graphics using PDFRender\n        AffineTransform transform = graphics2D.getTransform();\n        graphics2D.setBackground(Color.WHITE);\n        renderer.setSubsamplingAllowed(subsamplingAllowed);\n        renderer.setRenderingHints(renderingHints);\n        renderer.renderPageToGraphics(pageIndex, graphics2D, ((float) (scale)), ((float) (scale)), RenderDestination.PRINT);\n        // draw crop box\n        if (showPageBorder) {\n            graphics2D.setTransform(transform);\n            graphics2D.setClip(0, 0, ((int) (imageableWidth)), ((int) (imageableHeight)));\n            graphics2D.scale(scale, scale);\n            graphics2D.setColor(Color.GRAY);\n            graphics2D.setStroke(new BasicStroke(0.5F));\n            graphics.drawRect(0, 0, ((int) (cropBox.getWidth())), ((int) (cropBox.getHeight())));\n        }\n        // draw rasterized bitmap (optional)\n        if (printerGraphics != null) {\n            printerGraphics.setBackground(Color.WHITE);\n            printerGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());\n            printerGraphics.drawImage(image, 0, 0, null);\n            graphics2D.dispose();\n        }\n        return PAGE_EXISTS;\n    } catch (IOException e) {\n        throw new PrinterIOException(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth" ],
    "fullMethods" : [ "/**\n * Determines the width of the space character. This is very important for text extraction.\n *\n * @return the width of the space character\n */\npublic float getSpaceWidth() {\n    if (Float.compare(fontWidthOfSpace, -1.0F) == 0) {\n        try {\n            if ((toUnicodeCMap != null) && dict.containsKey(COSName.TO_UNICODE)) {\n                int spaceMapping = toUnicodeCMap.getSpaceMapping();\n                if (spaceMapping > (-1)) {\n                    fontWidthOfSpace = getWidth(spaceMapping);\n                }\n            } else {\n                try {\n                    // PDFBOX-5920: try with encoding, which gets the correct code\n                    fontWidthOfSpace = getStringWidth(\" \");\n                } catch (IllegalArgumentException | UnsupportedOperationException ex) {\n                    // Happens if space is not available in the font\n                    // or if encoding isn't implemented\n                    LOG.debug(ex.getMessage(), ex);\n                }\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getWidth(32);\n                }\n            }\n            // try to get it from the font itself\n            if (fontWidthOfSpace <= 0) {\n                fontWidthOfSpace = getWidthFromFont(32);\n                // use the average font width as fall back\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getAverageFontWidth();\n                }\n            }\n        } catch (Exception e) {\n            LOG.error((\"Can't determine the width of the space character for font \" + getName()) + \", assuming 250\", e);\n            fontWidthOfSpace = 250.0F;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Space width for font \" + getName()) + \" is \") + fontWidthOfSpace);\n        }\n    }\n    return fontWidthOfSpace;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getTrueTypeFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getTrueTypeFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFont" ],
    "fullMethods" : [ "/**\n * Finds a TrueType font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param fontDescriptor\n * \t\tFontDescriptor\n */\n@Override\npublic FontMapping<TrueTypeFont> getTrueTypeFont(String baseFont, PDFontDescriptor fontDescriptor) {\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, baseFont)));\n    if (ttf != null) {\n        return new FontMapping<>(ttf, false);\n    } else {\n        // fallback - todo: i.e. fuzzy match\n        String fontName = getFallbackFontName(fontDescriptor);\n        ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, fontName)));\n        if (ttf == null) {\n            // we have to return something here as TTFs aren't strictly required on the system\n            ttf = lastResortFont;\n        }\n        return new FontMapping<>(ttf, true);\n    }\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFont(FontFormat format, String postScriptName) {\n    // handle damaged PDFs, see PDFBOX-2884\n    if (postScriptName == null) {\n        return null;\n    }\n    // make sure the font provider is initialized\n    if (fontProvider == null) {\n        getProvider();\n    }\n    // first try to match the PostScript name\n    FontInfo info = getFont(format, postScriptName);\n    if (info != null) {\n        return info.getFont();\n    }\n    // remove hyphens (e.g. Arial-Black -> ArialBlack)\n    info = getFont(format, postScriptName.replace(\"-\", \"\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    // then try named substitutes\n    for (String substituteName : getSubstitutes(postScriptName)) {\n        info = getFont(format, substituteName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // then try converting Windows names e.g. (ArialNarrow,Bold) -> (ArialNarrow-Bold)\n    info = getFont(format, postScriptName.replace(\",\", \"-\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    if (postScriptName.contains(\",\")) {\n        postScriptName = postScriptName.substring(0, postScriptName.indexOf(\",\"));\n        // PDFBOX-5806: try cutting font style and getting the basefont\n        // eg. for \"Wingdings,Bolt\" to \"Wingding-Regular\" (including the following step)\n        info = getFont(format, postScriptName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // try appending \"-Regular\", works for Wingdings on windows\n    info = getFont(format, postScriptName + \"-Regular\");\n    if (info != null) {\n        return info.getFont();\n    }\n    // no matches\n    return null;\n}", "/**\n * Finds the named font with the given format.\n */\nprivate FontInfo getFont(FontFormat format, String postScriptName) {\n    int index = postScriptName.indexOf('+');\n    // strip subset tag (happens when we substitute a corrupt embedded font, see PDFBOX-2642)\n    if (index > (-1)) {\n        postScriptName = postScriptName.substring(index + 1);\n    }\n    // look up the PostScript name\n    FontInfo info = fontInfoByName.get(postScriptName.toLowerCase(Locale.ENGLISH));\n    if ((info != null) && (info.getFormat() == format)) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"getFont('%s','%s') returns %s\", format, postScriptName, info));\n        }\n        return info;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setFont" ],
    "fullMethods" : [ "/**\n * Set the font and font size to draw text with.\n *\n * @param font\n * \t\tThe font to use.\n * @param fontSize\n * \t\tThe font size to draw the text.\n * @throws IOException\n * \t\tIf there is an error writing the font information.\n */\npublic void setFont(PDFont font, float fontSize) throws IOException {\n    if (fontStack.isEmpty()) {\n        fontStack.add(font);\n    } else {\n        fontStack.pop();\n        fontStack.push(font);\n    }\n    // keep track of fonts which are configured for subsetting\n    if (font.willBeSubset()) {\n        if (document != null) {\n            document.getFontsToSubset().add(font);\n        } else {\n            LOG.warn((\"Using the subsetted font '\" + font.getName()) + \"' without a PDDocument context; call subset() before saving\");\n        }\n    } else if ((!font.isEmbedded()) && (!font.isStandard14())) {\n        LOG.warn((\"attempting to use font '\" + font.getName()) + \"' that isn't embedded\");\n    }\n    // complex text layout\n    if (font instanceof PDType0Font) {\n        PDType0Font type0Font = ((PDType0Font) (font));\n        GsubData gsubData = type0Font.getGsubData();\n        if (gsubData != GsubData.NO_DATA_FOUND) {\n            GsubWorker gsubWorker = gsubWorkerFactory.getGsubWorker(type0Font.getCmapLookup(), gsubData);\n            gsubWorkers.put(((PDType0Font) (font)), gsubWorker);\n        } else if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No GSUB data found in font\" + font.getName());\n        }\n    }\n    writeOperand(resources.add(font));\n    writeOperand(fontSize);\n    writeOperator(OperatorName.SET_FONT_AND_SIZE);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getType1Font" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n * <p>\n * The method returns null if there was an error opening the font.\n */\n@Override\npublic synchronized FontBoxFont getFont() {\n    // synchronized to avoid race condition on cache access,\n    // which could result in an unreferenced but open font\n    FontBoxFont cached = parent.cache.getFont(this);\n    if (cached != null) {\n        return cached;\n    } else {\n        FontBoxFont font;\n        switch (format) {\n            case PFB :\n                font = getType1Font(postScriptName, file);\n                break;\n            case TTF :\n                font = getTrueTypeFont(postScriptName, file);\n                break;\n            case OTF :\n                font = getOTFFont(postScriptName, file);\n                break;\n            default :\n                throw new RuntimeException(\"can't happen\");\n        }\n        if (font != null) {\n            parent.cache.addFont(this, font);\n        }\n        return font;\n    }\n}", "private Type1Font getType1Font(String postScriptName, File file) {\n    try (InputStream input = new FileInputStream(file)) {\n        Type1Font type1 = Type1Font.createWithPFB(input);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Loaded \" + postScriptName) + \" from \") + file);\n        }\n        return type1;\n    } catch (IOException e) {\n        LOG.warn(\"Could not load font file: \" + file, e);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFontBoxFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFontBoxFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFontBoxFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFont" ],
    "fullMethods" : [ "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null. This allows\n * any font to be substituted with a PFB, TTF or OTF.\n *\n * @param fontDescriptor\n * \t\tthe FontDescriptor of the font to find\n */\n@Override\npublic FontMapping<FontBoxFont> getFontBoxFont(String baseFont, PDFontDescriptor fontDescriptor) {\n    FontBoxFont font = findFontBoxFont(baseFont);\n    if (font != null) {\n        return new FontMapping<>(font, false);\n    } else {\n        // fallback - todo: i.e. fuzzy match\n        String fallbackName = getFallbackFontName(fontDescriptor);\n        font = findFontBoxFont(fallbackName);\n        if (font == null) {\n            // we have to return something here as TTFs aren't strictly required on the system\n            font = lastResortFont;\n        }\n        return new FontMapping<>(font, true);\n    }\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFontBoxFont(String postScriptName) {\n    Type1Font t1 = ((Type1Font) (findFont(FontFormat.PFB, postScriptName)));\n    if (t1 != null) {\n        return t1;\n    }\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, postScriptName)));\n    if (ttf != null) {\n        return ttf;\n    }\n    OpenTypeFont otf = ((OpenTypeFont) (findFont(FontFormat.OTF, postScriptName)));\n    if (otf != null) {\n        return otf;\n    }\n    return null;\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFont(FontFormat format, String postScriptName) {\n    // handle damaged PDFs, see PDFBOX-2884\n    if (postScriptName == null) {\n        return null;\n    }\n    // make sure the font provider is initialized\n    if (fontProvider == null) {\n        getProvider();\n    }\n    // first try to match the PostScript name\n    FontInfo info = getFont(format, postScriptName);\n    if (info != null) {\n        return info.getFont();\n    }\n    // remove hyphens (e.g. Arial-Black -> ArialBlack)\n    info = getFont(format, postScriptName.replace(\"-\", \"\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    // then try named substitutes\n    for (String substituteName : getSubstitutes(postScriptName)) {\n        info = getFont(format, substituteName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // then try converting Windows names e.g. (ArialNarrow,Bold) -> (ArialNarrow-Bold)\n    info = getFont(format, postScriptName.replace(\",\", \"-\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    if (postScriptName.contains(\",\")) {\n        postScriptName = postScriptName.substring(0, postScriptName.indexOf(\",\"));\n        // PDFBOX-5806: try cutting font style and getting the basefont\n        // eg. for \"Wingdings,Bolt\" to \"Wingding-Regular\" (including the following step)\n        info = getFont(format, postScriptName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // try appending \"-Regular\", works for Wingdings on windows\n    info = getFont(format, postScriptName + \"-Regular\");\n    if (info != null) {\n        return info.getFont();\n    }\n    // no matches\n    return null;\n}", "/**\n * Finds the named font with the given format.\n */\nprivate FontInfo getFont(FontFormat format, String postScriptName) {\n    int index = postScriptName.indexOf('+');\n    // strip subset tag (happens when we substitute a corrupt embedded font, see PDFBOX-2642)\n    if (index > (-1)) {\n        postScriptName = postScriptName.substring(index + 1);\n    }\n    // look up the PostScript name\n    FontInfo info = fontInfoByName.get(postScriptName.toLowerCase(Locale.ENGLISH));\n    if ((info != null) && (info.getFormat() == format)) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"getFont('%s','%s') returns %s\", format, postScriptName, info));\n        }\n        return info;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.visitFromDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isDebugEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.visitFromDictionary", "org.apache.pdfbox.pdfwriter.COSWriter.detectPossibleSignature" ],
    "fullMethods" : [ "@Override\npublic void visitFromDictionary(COSDictionary obj) throws IOException {\n    detectPossibleSignature(obj);\n    getStandardOutput().write(DICT_OPEN);\n    getStandardOutput().writeEOL();\n    for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {\n        COSBase value = entry.getValue();\n        if (value != null) {\n            entry.getKey().accept(this);\n            getStandardOutput().write(SPACE);\n            if (value instanceof COSDictionary) {\n                COSDictionary dict = ((COSDictionary) (value));\n                if (!incrementalUpdate) {\n                    // write all XObjects as direct objects, this will save some size\n                    // PDFBOX-3684: but avoid dictionary that references itself\n                    COSBase item = dict.getItem(COSName.XOBJECT);\n                    if ((item != null) && (!COSName.XOBJECT.equals(entry.getKey()))) {\n                        item.setDirect(true);\n                    }\n                    item = dict.getItem(COSName.RESOURCES);\n                    if ((item != null) && (!COSName.RESOURCES.equals(entry.getKey()))) {\n                        item.setDirect(true);\n                    }\n                }\n                writeDictionary(dict);\n            } else if (value instanceof COSObject) {\n                addObjectToWrite(value);\n                writeReference(value);\n            } else // If we reach the pdf signature, we need to determinate the position of the\n            // content and byterange\n            if (reachedSignature && COSName.CONTENTS.equals(entry.getKey())) {\n                signatureOffset = getStandardOutput().getPos();\n                value.accept(this);\n                signatureLength = getStandardOutput().getPos() - signatureOffset;\n            } else if (reachedSignature && COSName.BYTERANGE.equals(entry.getKey())) {\n                byteRangeArray = ((COSArray) (entry.getValue()));\n                byteRangeOffset = getStandardOutput().getPos() + 1;\n                value.accept(this);\n                byteRangeLength = (getStandardOutput().getPos() - 1) - byteRangeOffset;\n                reachedSignature = false;\n            } else if (value instanceof COSArray) {\n                writeArray(((COSArray) (value)));\n            } else {\n                value.accept(this);\n            }\n            getStandardOutput().writeEOL();\n        } else {\n            // then we won't write anything, there are a couple cases\n            // were the value of an entry in the COSDictionary will\n            // be a dangling reference that points to nothing\n            // so we will just not write out the entry if that is the case\n        }\n    }\n    getStandardOutput().write(DICT_CLOSE);\n    getStandardOutput().writeEOL();\n}", "private void detectPossibleSignature(COSDictionary obj) throws IOException {\n    if ((!reachedSignature) && incrementalUpdate) {\n        COSBase itemType = obj.getItem(COSName.TYPE);\n        if (COSName.SIG.equals(itemType) || COSName.DOC_TIME_STAMP.equals(itemType)) {\n            COSArray byteRange = obj.getCOSArray(COSName.BYTERANGE);\n            if ((byteRange != null) && (byteRange.size() == 4)) {\n                COSBase base2 = byteRange.get(2);\n                if (base2 instanceof COSInteger) {\n                    // PDFBOX-5521 avoid hitting \"old\" signatures\n                    long br2 = ((COSInteger) (base2)).longValue();\n                    if (br2 > incrementalInput.length()) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(((((\"reachedSignature at offset \" + getStandardOutput().getPos()) + \", byteRange: \") + byteRange) + \", input length: \") + incrementalInput.length());\n                        }\n                        reachedSignature = true;\n                    }\n                }\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.prepareDocumentForEncryption",
    "thirdPartyMethod" : "org.bouncycastle.asn1.cms.EncryptedContentInfo.<init>",
    "thirdPartyPackage" : "org.bouncycastle.asn1.cms",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.prepareDocumentForEncryption", "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.computeRecipientsField", "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.createDERForRecipient" ],
    "fullMethods" : [ "/**\n * Prepare the document for encryption.\n *\n * @param doc\n * \t\tThe document that will be encrypted.\n * @throws IOException\n * \t\tIf there is an error while encrypting.\n */\n@Override\npublic void prepareDocumentForEncryption(PDDocument doc) throws IOException {\n    try {\n        PDEncryption dictionary = doc.getEncryption();\n        if (dictionary == null) {\n            dictionary = new PDEncryption();\n        }\n        dictionary.setFilter(FILTER);\n        dictionary.setLength(getKeyLength());\n        int version = computeVersionNumber();\n        dictionary.setVersion(version);\n        // remove CF, StmF, and StrF entries that may be left from a previous encryption\n        dictionary.removeV45filters();\n        // create the 20 bytes seed\n        byte[] seed = new byte[20];\n        KeyGenerator key;\n        try {\n            key = KeyGenerator.getInstance(\"AES\");\n        } catch (NoSuchAlgorithmException e) {\n            // should never happen\n            throw new RuntimeException(e);\n        }\n        key.init(192, new SecureRandom());\n        SecretKey sk = key.generateKey();\n        // create the 20 bytes seed\n        System.arraycopy(sk.getEncoded(), 0, seed, 0, 20);\n        byte[][] recipientsFields = computeRecipientsField(seed);\n        int shaInputLength = seed.length;\n        for (byte[] field : recipientsFields) {\n            shaInputLength += field.length;\n        }\n        byte[] shaInput = new byte[shaInputLength];\n        System.arraycopy(seed, 0, shaInput, 0, 20);\n        int shaInputOffset = 20;\n        for (byte[] recipientsField : recipientsFields) {\n            System.arraycopy(recipientsField, 0, shaInput, shaInputOffset, recipientsField.length);\n            shaInputOffset += recipientsField.length;\n        }\n        byte[] mdResult;\n        switch (version) {\n            case 4 :\n                dictionary.setSubFilter(SUBFILTER5);\n                mdResult = MessageDigests.getSHA1().digest(shaInput);\n                prepareEncryptionDictAES(dictionary, COSName.AESV2, recipientsFields);\n                break;\n            case 5 :\n                dictionary.setSubFilter(SUBFILTER5);\n                mdResult = MessageDigests.getSHA256().digest(shaInput);\n                prepareEncryptionDictAES(dictionary, COSName.AESV3, recipientsFields);\n                break;\n            default :\n                dictionary.setSubFilter(SUBFILTER4);\n                mdResult = MessageDigests.getSHA1().digest(shaInput);\n                dictionary.setRecipients(recipientsFields);\n                break;\n        }\n        setEncryptionKey(new byte[getKeyLength() / 8]);\n        System.arraycopy(mdResult, 0, getEncryptionKey(), 0, getKeyLength() / 8);\n        doc.setEncryptionDictionary(dictionary);\n        doc.getDocument().setEncryptionDictionary(dictionary.getCOSObject());\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n}", "private byte[][] computeRecipientsField(byte[] seed) throws GeneralSecurityException, IOException {\n    PublicKeyProtectionPolicy protectionPolicy = getProtectionPolicy();\n    byte[][] recipientsField = new byte[protectionPolicy.getNumberOfRecipients()][];\n    Iterator<PublicKeyRecipient> it = protectionPolicy.getRecipientsIterator();\n    int i = 0;\n    while (it.hasNext()) {\n        PublicKeyRecipient recipient = it.next();\n        X509Certificate certificate = recipient.getX509();\n        int permission = recipient.getPermission().getPermissionBytesForPublicKey();\n        byte[] pkcs7input = new byte[24];\n        byte one = ((byte) (permission));\n        byte two = ((byte) (permission >>> 8));\n        byte three = ((byte) (permission >>> 16));\n        byte four = ((byte) (permission >>> 24));\n        // put this seed in the pkcs7 input\n        System.arraycopy(seed, 0, pkcs7input, 0, 20);\n        pkcs7input[20] = four;\n        pkcs7input[21] = three;\n        pkcs7input[22] = two;\n        pkcs7input[23] = one;\n        ASN1Primitive obj = createDERForRecipient(pkcs7input, certificate);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        obj.encodeTo(baos, ASN1Encoding.DER);\n        recipientsField[i] = baos.toByteArray();\n        i++;\n    } \n    return recipientsField;\n}", "private ASN1Primitive createDERForRecipient(byte[] in, X509Certificate cert) throws IOException, GeneralSecurityException {\n    String algorithm = PKCSObjectIdentifiers.RC2_CBC.getId();\n    AlgorithmParameterGenerator apg;\n    KeyGenerator keygen;\n    Cipher cipher;\n    try {\n        Provider provider = SecurityProvider.getProvider();\n        apg = AlgorithmParameterGenerator.getInstance(algorithm, provider);\n        keygen = KeyGenerator.getInstance(algorithm, provider);\n        cipher = Cipher.getInstance(algorithm, provider);\n    } catch (NoSuchAlgorithmException e) {\n        // happens when using the command line app .jar file\n        throw new IOException((\"Could not find a suitable javax.crypto provider for algorithm \" + algorithm) + \"; possible reason: using an unsigned .jar file\", e);\n    } catch (NoSuchPaddingException e) {\n        // should never happen, if this happens throw IOException instead\n        throw new RuntimeException(\"Could not find a suitable javax.crypto provider\", e);\n    }\n    AlgorithmParameters parameters = apg.generateParameters();\n    ASN1Primitive object;\n    try (ASN1InputStream input = new ASN1InputStream(parameters.getEncoded(\"ASN.1\"))) {\n        object = input.readObject();\n    }\n    keygen.init(128);\n    SecretKey secretkey = keygen.generateKey();\n    cipher.init(1, secretkey, parameters);\n    byte[] bytes = cipher.doFinal(in);\n    KeyTransRecipientInfo recipientInfo = computeRecipientInfo(cert, secretkey.getEncoded());\n    DERSet set = new DERSet(new RecipientInfo(recipientInfo));\n    AlgorithmIdentifier algorithmId = new AlgorithmIdentifier(new ASN1ObjectIdentifier(algorithm), object);\n    EncryptedContentInfo encryptedInfo = new EncryptedContentInfo(PKCSObjectIdentifiers.data, algorithmId, new DEROctetString(bytes));\n    EnvelopedData enveloped = new EnvelopedData(null, set, encryptedInfo, ((ASN1Set) (null)));\n    ContentInfo contentInfo = new ContentInfo(PKCSObjectIdentifiers.envelopedData, enveloped);\n    return contentInfo.toASN1Primitive();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isWarnEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.toUnicode" ],
    "fullMethods" : [ "@Override\npublic String toUnicode(int code) {\n    // try to use a ToUnicode CMap\n    String unicode = super.toUnicode(code);\n    if (unicode != null) {\n        return unicode;\n    }\n    // Use identity mapping if the given ToUnicode CMap doesn't provide any valid mapping\n    // a predefined map shall only be used if there isn't any ToUnicode CMap\n    // PDFBOX-6022: not when there's a predefined cmap\n    if ((getToUnicodeCMap() != null) && (!isCMapPredefined)) {\n        return Character.toString(((char) (code)));\n    }\n    if ((isCMapPredefined || isDescendantCJK) && (cMapUCS2 != null)) {\n        // if the font is composite and uses a predefined cmap (excluding Identity-H/V) then\n        // or if its descendant font uses Adobe-GB1/CNS1/Japan1/Korea1\n        // a) Map the character code to a character identifier (CID) according to the font?s CMap\n        int cid = codeToCID(code);\n        // e) Map the CID according to the CMap from step d), producing a Unicode value\n        return cMapUCS2.toUnicode(cid);\n    }\n    // PDFBOX-5324: try to get unicode from font cmap\n    if (descendantFont instanceof PDCIDFontType2) {\n        TrueTypeFont font = ((PDCIDFontType2) (descendantFont)).getTrueTypeFont();\n        if (font != null) {\n            try {\n                CmapLookup cmap = font.getUnicodeCmapLookup(false);\n                if (cmap != null) {\n                    int gid;\n                    if (descendantFont.isEmbedded()) {\n                        // original PDFBOX-5324 supported only embedded fonts\n                        gid = descendantFont.codeToGID(code);\n                    } else {\n                        // PDFBOX-5331: this bypasses the fallback attempt in\n                        // PDCIDFontType2.codeToGID() which would bring a stackoverflow\n                        gid = descendantFont.codeToCID(code);\n                    }\n                    List<Integer> codes = cmap.getCharCodes(gid);\n                    if ((codes != null) && (!codes.isEmpty())) {\n                        return Character.toString(((char) (int) (codes.get(0))));\n                    }\n                }\n            } catch (IOException e) {\n                LOG.warn(\"get unicode from font cmap fail\", e);\n            }\n        }\n    }\n    if (LOG.isWarnEnabled() && (!noUnicode.contains(code))) {\n        // if no value has been produced, there is no way to obtain Unicode for the character.\n        String cid = \"CID+\" + codeToCID(code);\n        LOG.warn(((((\"No Unicode mapping for \" + cid) + \" (\") + code) + \") in font \") + getName());\n        // we keep track of which warnings have been issued, so we don't log multiple times\n        noUnicode.add(code);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isWarnEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType1Font.repairLength1" ],
    "fullMethods" : [ "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}", "/**\n * Some Type 1 fonts have an invalid Length1, which causes the binary segment of the font\n * to be truncated, see PDFBOX-2350, PDFBOX-3677.\n *\n * @param bytes\n * \t\tType 1 stream bytes\n * @param length1\n * \t\tLength1 from the Type 1 stream\n * @return repaired Length1 value\n */\nprivate int repairLength1(byte[] bytes, int length1) {\n    // scan backwards from the end of the first segment to find 'exec'\n    int offset = Math.max(0, length1 - 4);\n    if ((offset <= 0) || (offset > (bytes.length - 4))) {\n        offset = bytes.length - 4;\n    }\n    offset = findBinaryOffsetAfterExec(bytes, offset);\n    if ((offset == 0) && (length1 > 0)) {\n        // 2nd try with brute force\n        offset = findBinaryOffsetAfterExec(bytes, bytes.length - 4);\n    }\n    if (((length1 - offset) != 0) && (offset > 0)) {\n        if (LOG.isWarnEnabled()) {\n            LOG.warn(((\"Ignored invalid Length1 \" + length1) + \" for Type 1 font \") + getName());\n        }\n        return offset;\n    }\n    return length1;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDSimpleFont.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.isWarnEnabled",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDSimpleFont.toUnicode" ],
    "fullMethods" : [ "@Override\npublic String toUnicode(int code, GlyphList customGlyphList) {\n    // allow the glyph list to be overridden for the purpose of extracting Unicode\n    // we only do this when the font's glyph list is the AGL, to avoid breaking Zapf Dingbats\n    GlyphList unicodeGlyphList;\n    if (this.glyphList == GlyphList.getAdobeGlyphList()) {\n        unicodeGlyphList = customGlyphList;\n    } else {\n        unicodeGlyphList = this.glyphList;\n    }\n    // first try to use a ToUnicode CMap\n    String unicode = super.toUnicode(code);\n    if (unicode != null) {\n        return unicode;\n    }\n    // if the font is a \"simple font\" and uses MacRoman/MacExpert/WinAnsi[Encoding]\n    // or has Differences with names from only Adobe Standard and/or Symbol, then:\n    // \n    // a) Map the character codes to names\n    // b) Look up the name in the Adobe Glyph List to obtain the Unicode value\n    String name = null;\n    if (encoding != null) {\n        name = encoding.getName(code);\n        unicode = unicodeGlyphList.toUnicode(name);\n        if (unicode != null) {\n            return unicode;\n        }\n    }\n    // if no value has been produced, there is no way to obtain Unicode for the character.\n    if (LOG.isWarnEnabled() && (!noUnicode.contains(code))) {\n        // we keep track of which warnings have been issued, so we don't log multiple times\n        noUnicode.add(code);\n        if (name != null) {\n            LOG.warn(((((\"No Unicode mapping for \" + name) + \" (\") + code) + \") in font \") + getName());\n        } else {\n            LOG.warn(((\"No Unicode mapping for character code \" + code) + \" in font \") + getName());\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerComponent",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerComponent" ],
    "fullMethods" : [ "/**\n * The bits per component of this shading. This will return -1 if one has not been set.\n *\n * @return the number of bits per component\n */\npublic int getBitsPerComponent() {\n    if (bitsPerColorComponent == (-1)) {\n        bitsPerColorComponent = getCOSObject().getInt(COSName.BITS_PER_COMPONENT, -1);\n        LOG.debug(\"bitsPerColorComponent: \" + bitsPerColorComponent);\n    }\n    return bitsPerColorComponent;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Set the selected option given its index, and try to update the visual appearance.\n *\n * NOTE: this method is only usable if there are export values and used for\n * radio buttons with FLAG_RADIOS_IN_UNISON not set.\n *\n * @param index\n * \t\tindex of option to be selected\n * @throws IOException\n * \t\tif the value could not be set\n * @throws IllegalArgumentException\n * \t\tif the index provided is not a valid index.\n */\npublic void setValue(int index) throws IOException {\n    List<String> exportValues = getExportValues();\n    if ((exportValues.isEmpty() || (index < 0)) || (index >= exportValues.size())) {\n        throw new IllegalArgumentException(((((\"index '\" + index) + \"' is not a valid index for the field \") + getFullyQualifiedName()) + \", valid indices are from 0 to \") + (exportValues.size() - 1));\n    }\n    updateByValue(String.valueOf(index));\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getCIDFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getCIDFont" ],
    "fullMethods" : [ "/**\n * Finds a CFF CID-Keyed font with the given PostScript name, or a suitable substitute, or null.\n * This method can also map CJK fonts via their CIDSystemInfo (ROS).\n *\n * @param fontDescriptor\n * \t\tFontDescriptor\n * @param cidSystemInfo\n * \t\tthe CID system info, e.g. \"Adobe-Japan1\", if any.\n */\n@Override\npublic CIDFontMapping getCIDFont(String baseFont, PDFontDescriptor fontDescriptor, PDCIDSystemInfo cidSystemInfo) {\n    // try name match or substitute with OTF\n    OpenTypeFont otf1 = ((OpenTypeFont) (findFont(FontFormat.OTF, baseFont)));\n    if (otf1 != null) {\n        return new CIDFontMapping(otf1, null, false);\n    }\n    // try name match or substitute with TTF\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, baseFont)));\n    if (ttf != null) {\n        return new CIDFontMapping(null, ttf, false);\n    }\n    if (cidSystemInfo != null) {\n        // \"In Acrobat 3.0.1 and later, Type 0 fonts that use a CMap whose CIDSystemInfo\n        // dictionary defines the Adobe-GB1, Adobe-CNS1 Adobe-Japan1, or Adobe-Korea1 character\n        // collection can also be substituted.\" - Adobe Supplement to the ISO 32000\n        String collection = (cidSystemInfo.getRegistry() + \"-\") + cidSystemInfo.getOrdering();\n        if (((collection.equals(\"Adobe-GB1\") || collection.equals(\"Adobe-CNS1\")) || collection.equals(\"Adobe-Japan1\")) || collection.equals(\"Adobe-Korea1\")) {\n            // try automatic substitutes via character collection\n            PriorityQueue<FontMatch> queue = getFontMatches(fontDescriptor, cidSystemInfo);\n            FontMatch bestMatch = queue.poll();\n            if (bestMatch != null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(((\"Best match for '\" + baseFont) + \"': \") + bestMatch.info);\n                }\n                FontBoxFont font = bestMatch.info.getFont();\n                if (font instanceof OpenTypeFont) {\n                    return new CIDFontMapping(((OpenTypeFont) (font)), null, true);\n                } else if (font != null) {\n                    return new CIDFontMapping(null, font, true);\n                }\n            }\n        }\n    }\n    // last-resort fallback\n    return new CIDFontMapping(null, lastResortFont, true);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.PNGConverter.convertPNGImage", "org.apache.pdfbox.pdmodel.graphics.image.PNGConverter.parsePNGChunks" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image byte array. This overloaded version allows providing\n * a custom factory to handle specific image formats, such as BMP and GIF, or to act as a\n * fallback strategy when the default converters (e.g., for PNG or TIFF) fail.\n *\n * @param document\n * \t\tthe document that shall use this PDImageXObject.\n * @param byteArray\n * \t\tbytes from an image file.\n * @param name\n * \t\tname of image file for exception messages, can be null.\n * @param customFactory\n * \t\toptional factory used to handle BMP, GIF, or fallback cases\n * \t\t(e.g., for PNG or TIFF). If {@code null}, this method delegates to\n * \t\t{@link #createFromByteArray(PDDocument, byte[], String)}.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray, String name, CustomFactory customFactory) throws IOException {\n    FileType fileType = FileTypeDetector.detectFileType(byteArray);\n    if (fileType == null) {\n        throw new IllegalArgumentException(\"Image type not supported: \" + name);\n    }\n    if (fileType == FileType.JPEG) {\n        return JPEGFactory.createFromByteArray(document, byteArray);\n    }\n    if (fileType == FileType.PNG) {\n        // Try to directly convert the image without recoding it.\n        PDImageXObject image = PNGConverter.convertPNGImage(document, byteArray);\n        if (image != null) {\n            return image;\n        }\n    }\n    if (fileType == FileType.TIFF) {\n        try {\n            return CCITTFactory.createFromByteArray(document, byteArray);\n        } catch (IOException ex) {\n            LOG.debug(\"Reading as TIFF failed, setting fileType to PNG\", ex);\n            // Plan B: try reading with ImageIO\n            // common exception:\n            // First image in tiff is not CCITT T4 or T6 compressed\n            fileType = FileType.PNG;\n        }\n    }\n    if (((fileType == FileType.BMP) || (fileType == FileType.GIF)) || (fileType == FileType.PNG)) {\n        if (customFactory != null) {\n            return customFactory.createFromByteArray(document, byteArray);\n        }\n        ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);\n        BufferedImage bim = ImageIO.read(bais);\n        return LosslessFactory.createFromImage(document, bim);\n    }\n    throw new IllegalArgumentException(((\"Image type \" + fileType) + \" not supported: \") + name);\n}", "/**\n * Try to convert a PNG into a PDImageXObject. If for any reason the PNG can not\n * be converted, null is returned.\n * <p>\n * This usually means the PNG structure is damaged (CRC error, etc.) or it uses\n * some features which can not be mapped to PDF.\n *\n * @param doc\n * \t\tthe document to put the image in\n * @param imageData\n * \t\tthe byte data of the PNG\n * @return null or the PDImageXObject built from the png\n */\nstatic PDImageXObject convertPNGImage(PDDocument doc, byte[] imageData) throws IOException {\n    PNGConverterState state = parsePNGChunks(imageData);\n    if (!checkConverterState(state)) {\n        // There is something wrong, we can't convert this PNG\n        return null;\n    }\n    return convertPng(doc, state);\n}", "/**\n * Parse the PNG structure into the PNGConverterState. If we can't handle\n * something, this method will return null.\n *\n * @param imageData\n * \t\tthe byte array with the PNG data\n * @return null or the converter state with all relevant chunks\n */\nprivate static PNGConverterState parsePNGChunks(byte[] imageData) {\n    if (imageData.length < 20) {\n        LOG.error(\"ByteArray way to small: \" + imageData.length);\n        return null;\n    }\n    PNGConverterState state = new PNGConverterState();\n    int ptr = 8;\n    int firstChunkType = readInt(imageData, ptr + 4);\n    if (firstChunkType != CHUNK_IHDR) {\n        LOG.error(String.format(\"First Chunktype was %08X, not IHDR\", firstChunkType));\n        return null;\n    }\n    while ((ptr + 12) <= imageData.length) {\n        int chunkLength = readInt(imageData, ptr);\n        int chunkType = readInt(imageData, ptr + 4);\n        ptr += 8;\n        if (((ptr + chunkLength) + 4) > imageData.length) {\n            LOG.error(((((\"Not enough bytes. At offset \" + ptr) + \" are \") + chunkLength) + \" bytes expected. Overall length is \") + imageData.length);\n            return null;\n        }\n        Chunk chunk = new Chunk();\n        chunk.chunkType = chunkType;\n        chunk.bytes = imageData;\n        chunk.start = ptr;\n        chunk.length = chunkLength;\n        switch (chunkType) {\n            case CHUNK_IHDR :\n                if (state.IHDR != null) {\n                    LOG.error(\"Two IHDR chunks? There is something wrong.\");\n                    return null;\n                }\n                state.IHDR = chunk;\n                break;\n            case CHUNK_IDAT :\n                // The image data itself\n                state.IDATs.add(chunk);\n                break;\n            case CHUNK_PLTE :\n                // For indexed images the palette table\n                if (state.PLTE != null) {\n                    LOG.error(\"Two PLTE chunks? There is something wrong.\");\n                    return null;\n                }\n                state.PLTE = chunk;\n                break;\n            case CHUNK_IEND :\n                // We are done, return the state\n                return state;\n            case CHUNK_TRNS :\n                // For indexed images the alpha transparency table\n                if (state.tRNS != null) {\n                    LOG.error(\"Two tRNS chunks? There is something wrong.\");\n                    return null;\n                }\n                state.tRNS = chunk;\n                break;\n            case CHUNK_GAMA :\n                // Gama\n                state.gAMA = chunk;\n                break;\n            case CHUNK_CHRM :\n                // Chroma\n                state.cHRM = chunk;\n                break;\n            case CHUNK_ICCP :\n                // ICC Profile\n                state.iCCP = chunk;\n                break;\n            case CHUNK_SBIT :\n                LOG.debug(\"Can't convert PNGs with sBIT chunk.\");\n                break;\n            case CHUNK_SRGB :\n                // We use the rendering intent from the chunk\n                state.sRGB = chunk;\n                break;\n            case CHUNK_TEXT :\n            case CHUNK_ZTXT :\n            case CHUNK_ITXT :\n                // We don't care about this text infos / metadata\n                break;\n            case CHUNK_KBKG :\n                // As we can handle transparency we don't need the background color information.\n                break;\n            case CHUNK_HIST :\n                // We don't need the color histogram\n                break;\n            case CHUNK_PHYS :\n                // The PDImageXObject will be placed by the user however he wants,\n                // so we can not enforce the physical dpi information stored here.\n                // We just ignore it.\n                break;\n            case CHUNK_SPLT :\n                // This palette stuff seems editor related, we don't need it.\n                break;\n            case CHUNK_TIME :\n                // We don't need the last image change time either\n                break;\n            default :\n                LOG.debug(String.format(\"Unknown chunk type %08X, skipping.\", chunkType));\n                break;\n        }\n        ptr += chunkLength;\n        // Read the CRC\n        chunk.crc = readInt(imageData, ptr);\n        ptr += 4;\n    } \n    LOG.error(\"No IEND chunk found.\");\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormGenerateAppearancesProcessor.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormGenerateAppearancesProcessor.process" ],
    "fullMethods" : [ "@Override\npublic void process() {\n    /* Get the AcroForm in it's current state.\n\n    Also note: getAcroForm() applies a default fixup which this processor\n    is part of. So keep the null parameter otherwise this will end\n    in an endless recursive call\n     */\n    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm(null);\n    if (acroForm != null) {\n        try {\n            LOG.debug(\"trying to generate appearance streams for fields as NeedAppearances is true()\");\n            acroForm.refreshAppearances();\n            acroForm.setNeedAppearances(false);\n        } catch (IOException | IllegalArgumentException ex) {\n            LOG.debug(\"couldn't generate appearance stream for some fields - check output\");\n            LOG.debug(ex.getMessage());\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth" ],
    "fullMethods" : [ "/**\n * Determines the width of the space character. This is very important for text extraction.\n *\n * @return the width of the space character\n */\npublic float getSpaceWidth() {\n    if (Float.compare(fontWidthOfSpace, -1.0F) == 0) {\n        try {\n            if ((toUnicodeCMap != null) && dict.containsKey(COSName.TO_UNICODE)) {\n                int spaceMapping = toUnicodeCMap.getSpaceMapping();\n                if (spaceMapping > (-1)) {\n                    fontWidthOfSpace = getWidth(spaceMapping);\n                }\n            } else {\n                try {\n                    // PDFBOX-5920: try with encoding, which gets the correct code\n                    fontWidthOfSpace = getStringWidth(\" \");\n                } catch (IllegalArgumentException | UnsupportedOperationException ex) {\n                    // Happens if space is not available in the font\n                    // or if encoding isn't implemented\n                    LOG.debug(ex.getMessage(), ex);\n                }\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getWidth(32);\n                }\n            }\n            // try to get it from the font itself\n            if (fontWidthOfSpace <= 0) {\n                fontWidthOfSpace = getWidthFromFont(32);\n                // use the average font width as fall back\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getAverageFontWidth();\n                }\n            }\n        } catch (Exception e) {\n            LOG.error((\"Can't determine the width of the space character for font \" + getName()) + \", assuming 250\", e);\n            fontWidthOfSpace = 250.0F;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Space width for font \" + getName()) + \" is \") + fontWidthOfSpace);\n        }\n    }\n    return fontWidthOfSpace;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<init>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.loadDiskCache" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "/**\n * Constructor.\n */\nFileSystemFontProvider(FontCache cache) {\n    this.cache = cache;\n    try {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Will search the local system for fonts\");\n        }\n        // scan the local system for font files\n        FontFileFinder fontFileFinder = new FontFileFinder();\n        List<URI> fonts = fontFileFinder.find();\n        List<File> files = new ArrayList<>(fonts.size());\n        for (URI font : fonts) {\n            files.add(new File(font));\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace((\"Found \" + files.size()) + \" fonts on the local system\");\n        }\n        if (!files.isEmpty()) {\n            // load cached FontInfo objects\n            List<FSFontInfo> cachedInfos = loadDiskCache(files);\n            if ((cachedInfos != null) && (!cachedInfos.isEmpty())) {\n                fontInfoList.addAll(cachedInfos);\n            } else {\n                LOG.info(\"Building on-disk font cache, this may take a while\");\n                scanFonts(files);\n                saveDiskCache();\n                LOG.info((\"Finished building on-disk font cache, found \" + fontInfoList.size()) + \" fonts\");\n            }\n        }\n    } catch (AccessControlException e) {\n        LOG.error(\"Error accessing the file system\", e);\n    }\n}", "/**\n * Loads the font metadata cache from disk.\n */\nprivate List<FSFontInfo> loadDiskCache(List<File> files) {\n    Set<String> pending = new HashSet<>(files.size());\n    for (File file : files) {\n        pending.add(file.getAbsolutePath());\n    }\n    List<FSFontInfo> results = new ArrayList<>();\n    // Get the disk cache\n    File diskCacheFile = null;\n    boolean fileExists = false;\n    try {\n        diskCacheFile = getDiskCacheFile();\n        fileExists = diskCacheFile.exists();\n    } catch (SecurityException e) {\n        LOG.debug(\"Error checking for file existence\", e);\n    }\n    if (fileExists) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(diskCacheFile), StandardCharsets.UTF_8))) {\n            // consequent lines usually share the same font file (e.g. \"Courier\", \"Courier-Bold\", \"Courier-Oblique\").\n            // unused if SKIP_CHECKSUMS\n            File lastFile = null;\n            String lastHash = null;\n            // \n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\"\\\\|\", 12);\n                if (parts.length < 10) {\n                    LOG.warn((\"Incorrect line '\" + line) + \"' in font disk cache is skipped\");\n                    continue;\n                }\n                String postScriptName;\n                FontFormat format;\n                CIDSystemInfo cidSystemInfo = null;\n                int usWeightClass = -1;\n                int sFamilyClass = -1;\n                int ulCodePageRange1;\n                int ulCodePageRange2;\n                int macStyle = -1;\n                byte[] panose = null;\n                File fontFile;\n                String hash = \"\";\n                long lastModified = 0;\n                postScriptName = parts[0];\n                format = FontFormat.valueOf(parts[1]);\n                if (parts[2].length() > 0) {\n                    String[] ros = parts[2].split(\"-\");\n                    cidSystemInfo = new CIDSystemInfo(ros[0], ros[1], Integer.parseInt(ros[2]));\n                }\n                if (parts[3].length() > 0) {\n                    usWeightClass = ((int) (Long.parseLong(parts[3], 16)));\n                }\n                if (parts[4].length() > 0) {\n                    sFamilyClass = ((int) (Long.parseLong(parts[4], 16)));\n                }\n                ulCodePageRange1 = ((int) (Long.parseLong(parts[5], 16)));\n                ulCodePageRange2 = ((int) (Long.parseLong(parts[6], 16)));\n                if (parts[7].length() > 0) {\n                    macStyle = ((int) (Long.parseLong(parts[7], 16)));\n                }\n                if (parts[8].length() > 0) {\n                    panose = new byte[10];\n                    for (int i = 0; i < 10; i++) {\n                        String str = parts[8].substring(i * 2, (i * 2) + 2);\n                        int b = Integer.parseInt(str, 16);\n                        panose[i] = ((byte) (b & 0xff));\n                    }\n                }\n                fontFile = new File(parts[9]);\n                if (((parts.length >= 12) && (!parts[10].isEmpty())) && (!parts[11].isEmpty())) {\n                    hash = parts[10];\n                    lastModified = Long.parseLong(parts[11]);\n                }\n                if (fontFile.exists()) {\n                    // if the file exists, find out whether it's the same file.\n                    // first check whether time is different and if yes, whether hash is different\n                    boolean keep = fontFile.lastModified() == lastModified;\n                    if ((!keep) && (!SKIP_CHECKSUMS)) {\n                        String newHash;\n                        if (hash.equals(lastHash) && fontFile.equals(lastFile)) {\n                            newHash = lastHash;// already computed\n\n                        } else {\n                            try {\n                                newHash = computeHash(Files.newInputStream(fontFile.toPath()));\n                                lastFile = fontFile;\n                                lastHash = newHash;\n                            } catch (IOException ex) {\n                                LOG.debug(\"Error reading font file \" + fontFile.getAbsolutePath(), ex);\n                                newHash = \"<err>\";\n                            }\n                        }\n                        if (hash.equals(newHash)) {\n                            keep = true;\n                            lastModified = fontFile.lastModified();\n                        }\n                    }\n                    if (keep) {\n                        FSFontInfo info = new FSFontInfo(fontFile, format, postScriptName, cidSystemInfo, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this, hash, lastModified);\n                        results.add(info);\n                    } else {\n                        LOG.debug((\"Font file \" + fontFile.getAbsolutePath()) + \" is different\");\n                        continue;// don't remove from \"pending\"\n\n                    }\n                } else {\n                    LOG.debug((\"Font file \" + fontFile.getAbsolutePath()) + \" not found, skipped\");\n                }\n                pending.remove(fontFile.getAbsolutePath());\n            } \n        } catch (IOException e) {\n            LOG.warn(\"Error loading font cache, will be re-built\", e);\n            return null;\n        }\n    }\n    if (!pending.isEmpty()) {\n        // re-build the entire cache if we encounter un-cached fonts (could be optimised)\n        LOG.info(pending.size() + \" new font files found, font cache will be re-built\");\n        return null;\n    }\n    return results;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getMediaBox",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getMediaBox" ],
    "fullMethods" : [ "/**\n * A rectangle, expressed in default user space units, defining the boundaries of the physical medium on which the\n * page is intended to be displayed or printed.\n *\n * @return the media box of the page\n */\npublic PDRectangle getMediaBox() {\n    if (mediaBox == null) {\n        COSBase base = PDPageTree.getInheritableAttribute(page, COSName.MEDIA_BOX);\n        if (base instanceof COSArray) {\n            mediaBox = new PDRectangle(((COSArray) (base)));\n        } else {\n            LOG.debug(\"Can't find MediaBox, will use U.S. Letter\");\n            mediaBox = PDRectangle.LETTER;\n        }\n    }\n    return mediaBox;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getType1Font" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n * <p>\n * The method returns null if there was an error opening the font.\n */\n@Override\npublic synchronized FontBoxFont getFont() {\n    // synchronized to avoid race condition on cache access,\n    // which could result in an unreferenced but open font\n    FontBoxFont cached = parent.cache.getFont(this);\n    if (cached != null) {\n        return cached;\n    } else {\n        FontBoxFont font;\n        switch (format) {\n            case PFB :\n                font = getType1Font(postScriptName, file);\n                break;\n            case TTF :\n                font = getTrueTypeFont(postScriptName, file);\n                break;\n            case OTF :\n                font = getOTFFont(postScriptName, file);\n                break;\n            default :\n                throw new RuntimeException(\"can't happen\");\n        }\n        if (font != null) {\n            parent.cache.addFont(this, font);\n        }\n        return font;\n    }\n}", "private Type1Font getType1Font(String postScriptName, File file) {\n    try (InputStream input = new FileInputStream(file)) {\n        Type1Font type1 = Type1Font.createWithPFB(input);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Loaded \" + postScriptName) + \" from \") + file);\n        }\n        return type1;\n    } catch (IOException e) {\n        LOG.warn(\"Could not load font file: \" + file, e);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.FDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.FDFParser.parse", "org.apache.pdfbox.pdfparser.COSParser.parseFDFHeader", "org.apache.pdfbox.pdfparser.COSParser.parseHeader" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the FDFDocument object.\n *\n * @return the parsed FDFDocument\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic FDFDocument parse() throws IOException {\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        if (!parseFDFHeader()) {\n            throw new IOException(\"Error: Header doesn't contain versioninfo\");\n        }\n        initialParse();\n        exceptionOccurred = false;\n        return new FDFDocument(document, source);\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * Parse the header of a fdf.\n *\n * @return true if a FDF header was found\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected boolean parseFDFHeader() throws IOException {\n    return parseHeader(FDF_HEADER, FDF_DEFAULT_VERSION);\n}", "private boolean parseHeader(String headerMarker, String defaultVersion) throws IOException {\n    // read first line\n    String header = readLine();\n    // some pdf-documents are broken and the pdf-version is in one of the following lines\n    if (!header.contains(headerMarker)) {\n        header = readLine();\n        while (!header.contains(headerMarker)) {\n            // if a line starts with a digit, it has to be the first one with data in it\n            if ((header.length() > 0) && Character.isDigit(header.charAt(0))) {\n                break;\n            }\n            header = readLine();\n        } \n    }\n    // nothing found\n    if (!header.contains(headerMarker)) {\n        source.seek(0);\n        return false;\n    }\n    // sometimes there is some garbage in the header before the header\n    // actually starts, so lets try to find the header first.\n    int headerStart = header.indexOf(headerMarker);\n    // greater than zero because if it is zero then there is no point of trimming\n    if (headerStart > 0) {\n        // trim off any leading characters\n        header = header.substring(headerStart);\n    }\n    // This is used if there is garbage after the header on the same line\n    if (header.startsWith(headerMarker) && (!header.matches(headerMarker + \"\\\\d.\\\\d\"))) {\n        if (header.length() < (headerMarker.length() + 3)) {\n            // No version number at all, set to 1.4 as default\n            header = headerMarker + defaultVersion;\n            LOG.debug((\"No version found, set to \" + defaultVersion) + \" as default.\");\n        } else {\n            String headerGarbage = header.substring(headerMarker.length() + 3) + \"\\n\";\n            header = header.substring(0, headerMarker.length() + 3);\n            source.rewind(headerGarbage.getBytes(StandardCharsets.ISO_8859_1).length);\n        }\n    }\n    float headerVersion = -1;\n    try {\n        String[] headerParts = header.split(\"-\");\n        if (headerParts.length == 2) {\n            headerVersion = Float.parseFloat(headerParts[1]);\n        }\n    } catch (NumberFormatException exception) {\n        LOG.debug(\"Can't parse the header version.\", exception);\n    }\n    if (headerVersion < 0) {\n        if (isLenient) {\n            headerVersion = 1.7F;\n        } else {\n            throw new IOException(\"Error getting header version: \" + header);\n        }\n    }\n    document.setVersion(headerVersion);\n    // rewind\n    source.seek(0);\n    return true;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Set the selected value of this field, and try to update the visual appearance.\n *\n * @param value\n * \t\tThe name of the selected item.\n * @throws IOException\n * \t\tif the value could not be set\n */\n@Override\npublic void setValue(String value) throws IOException {\n    getCOSObject().setString(COSName.V, value);\n    // remove I key for single valued choice field\n    setSelectedOptionsIndex(null);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingContext.<init>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type5ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param cm\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @throws IOException\n * \t\tif something went wrong\n */\nType5ShadingContext(PDShadingType5 shading, ColorModel cm, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, cm, xform, matrix);\n    LOG.debug(\"Type5ShadingContext\");\n    setTriangleList(shading.collectTriangles(xform, matrix));\n    createPixelTable(deviceBounds);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType5.collectTriangles", "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.readVertex" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    Rectangle2D bounds = null;\n    for (ShadedTriangle shadedTriangle : collectTriangles(xform, matrix)) {\n        if (bounds == null) {\n            bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n        }\n        bounds.add(shadedTriangle.corner[0]);\n        bounds.add(shadedTriangle.corner[1]);\n        bounds.add(shadedTriangle.corner[2]);\n    }\n    if (bounds == null) {\n        // Speeds up files where triangles are empty, e.g. ghostscript file 690425\n        return new Rectangle2D.Float();\n    }\n    return bounds;\n}", "@SuppressWarnings(\"squid:S1166\")\n@Override\nList<ShadedTriangle> collectTriangles(AffineTransform xform, Matrix matrix) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int numPerRow = getVerticesPerRow();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Vertex> vlist = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            boolean eof = false;\n            while (!eof) {\n                Vertex p;\n                try {\n                    p = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                    vlist.add(p);\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    int rowNum = vlist.size() / numPerRow;\n    if (rowNum < 2) {\n        // must have at least two rows; if not, return empty list\n        return Collections.emptyList();\n    }\n    Vertex[][] latticeArray = new Vertex[rowNum][numPerRow];\n    for (int i = 0; i < rowNum; i++) {\n        for (int j = 0; j < numPerRow; j++) {\n            latticeArray[i][j] = vlist.get((i * numPerRow) + j);\n        }\n    }\n    return createShadedTriangleList(rowNum, numPerRow, latticeArray);\n}", "/**\n * Read a vertex from the bit input stream performs interpolations.\n *\n * @param input\n * \t\tbit input stream\n * @param maxSrcCoord\n * \t\tmax value for source coordinate (2^bits-1)\n * @param maxSrcColor\n * \t\tmax value for source color (2^bits-1)\n * @param rangeX\n * \t\tdest range for X\n * @param rangeY\n * \t\tdest range for Y\n * @param colRangeTab\n * \t\tdest range array for colors\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param xform\n * \t\tthe affine transformation\n * @return a new vertex with the flag and the interpolated values\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected Vertex readVertex(ImageInputStream input, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRangeTab, Matrix matrix, AffineTransform xform) throws IOException {\n    if (((bitsPerCoordinate <= 0) || (numberOfColorComponents <= 0)) || (bitsPerColorComponent <= 0)) {\n        throw new IOException(\"nothing to read, check bitsPerCoordinate, numberOfColorComponents and bitsPerColorComponent\");\n    }\n    float[] colorComponentTab = new float[numberOfColorComponents];\n    long x = input.readBits(bitsPerCoordinate);\n    long y = input.readBits(bitsPerCoordinate);\n    float dstX = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());\n    float dstY = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());\n    LOG.debug(\"coord: \" + String.format(\"[%06X,%06X] -> [%f,%f]\", x, y, dstX, dstY));\n    Point2D p = matrix.transformPoint(dstX, dstY);\n    xform.transform(p, p);\n    for (int n = 0; n < numberOfColorComponents; ++n) {\n        int color = ((int) (input.readBits(bitsPerColorComponent)));\n        colorComponentTab[n] = interpolate(color, maxSrcColor, colRangeTab[n].getMin(), colRangeTab[n].getMax());\n        LOG.debug(((((((((\"color[\" + n) + \"]: \") + color) + \"/\") + String.format(\"%02x\", color)) + \"-> color[\") + n) + \"]: \") + colorComponentTab[n]);\n    }\n    // \"Each set of vertex data shall occupy a whole number of bytes.\n    // If the total number of bits required is not divisible by 8, the last data byte\n    // for each vertex is padded at the end with extra bits, which shall be ignored.\"\n    int bitOffset = input.getBitOffset();\n    if (bitOffset != 0) {\n        input.readBits(8 - bitOffset);\n    }\n    return new Vertex(p, colorComponentTab);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationStamp(COSDictionary a) {\n    super(a);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.visitFromDictionary",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.visitFromDictionary", "org.apache.pdfbox.pdfwriter.COSWriter.detectPossibleSignature" ],
    "fullMethods" : [ "@Override\npublic void visitFromDictionary(COSDictionary obj) throws IOException {\n    detectPossibleSignature(obj);\n    getStandardOutput().write(DICT_OPEN);\n    getStandardOutput().writeEOL();\n    for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {\n        COSBase value = entry.getValue();\n        if (value != null) {\n            entry.getKey().accept(this);\n            getStandardOutput().write(SPACE);\n            if (value instanceof COSDictionary) {\n                COSDictionary dict = ((COSDictionary) (value));\n                if (!incrementalUpdate) {\n                    // write all XObjects as direct objects, this will save some size\n                    // PDFBOX-3684: but avoid dictionary that references itself\n                    COSBase item = dict.getItem(COSName.XOBJECT);\n                    if ((item != null) && (!COSName.XOBJECT.equals(entry.getKey()))) {\n                        item.setDirect(true);\n                    }\n                    item = dict.getItem(COSName.RESOURCES);\n                    if ((item != null) && (!COSName.RESOURCES.equals(entry.getKey()))) {\n                        item.setDirect(true);\n                    }\n                }\n                writeDictionary(dict);\n            } else if (value instanceof COSObject) {\n                addObjectToWrite(value);\n                writeReference(value);\n            } else // If we reach the pdf signature, we need to determinate the position of the\n            // content and byterange\n            if (reachedSignature && COSName.CONTENTS.equals(entry.getKey())) {\n                signatureOffset = getStandardOutput().getPos();\n                value.accept(this);\n                signatureLength = getStandardOutput().getPos() - signatureOffset;\n            } else if (reachedSignature && COSName.BYTERANGE.equals(entry.getKey())) {\n                byteRangeArray = ((COSArray) (entry.getValue()));\n                byteRangeOffset = getStandardOutput().getPos() + 1;\n                value.accept(this);\n                byteRangeLength = (getStandardOutput().getPos() - 1) - byteRangeOffset;\n                reachedSignature = false;\n            } else if (value instanceof COSArray) {\n                writeArray(((COSArray) (value)));\n            } else {\n                value.accept(this);\n            }\n            getStandardOutput().writeEOL();\n        } else {\n            // then we won't write anything, there are a couple cases\n            // were the value of an entry in the COSDictionary will\n            // be a dangling reference that points to nothing\n            // so we will just not write out the entry if that is the case\n        }\n    }\n    getStandardOutput().write(DICT_CLOSE);\n    getStandardOutput().writeEOL();\n}", "private void detectPossibleSignature(COSDictionary obj) throws IOException {\n    if ((!reachedSignature) && incrementalUpdate) {\n        COSBase itemType = obj.getItem(COSName.TYPE);\n        if (COSName.SIG.equals(itemType) || COSName.DOC_TIME_STAMP.equals(itemType)) {\n            COSArray byteRange = obj.getCOSArray(COSName.BYTERANGE);\n            if ((byteRange != null) && (byteRange.size() == 4)) {\n                COSBase base2 = byteRange.get(2);\n                if (base2 instanceof COSInteger) {\n                    // PDFBOX-5521 avoid hitting \"old\" signatures\n                    long br2 = ((COSInteger) (base2)).longValue();\n                    if (br2 > incrementalInput.length()) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(((((\"reachedSignature at offset \" + getStandardOutput().getPos()) + \", byteRange: \") + byteRange) + \", input length: \") + incrementalInput.length());\n                        }\n                        reachedSignature = true;\n                    }\n                }\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Refreshes the appearance streams and appearance dictionaries for the widget annotations of the specified fields.\n *\n * @param fields\n * \t\ta list of fields to be refreshed\n * @throws IOException\n * \t\tif the appearance streams could not be refreshed\n */\npublic void refreshAppearances(List<PDField> fields) throws IOException {\n    for (PDField field : fields) {\n        if (field instanceof PDTerminalField) {\n            ((PDTerminalField) (field)).constructAppearances();\n        }\n    }\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Refreshes the appearance streams and appearance dictionaries for the widget annotations of all fields.\n *\n * @throws IOException\n * \t\tif the appearance streams could not be refreshed\n */\npublic void refreshAppearances() throws IOException {\n    for (PDField field : getFieldTree()) {\n        if (field instanceof PDTerminalField) {\n            ((PDTerminalField) (field)).constructAppearances();\n        }\n    }\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fixup.processor.AcroFormOrphanWidgetsProcessor.process", "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getAcroForm" ],
    "fullMethods" : [ "@Override\npublic void process() {\n    /* Get the AcroForm in it's current state.\n\n    Also note: getAcroForm() applies a default fixup which this processor\n    is part of. So keep the null parameter otherwise this will end\n    in an endless recursive call\n     */\n    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm(null);\n    if (acroForm != null) {\n        resolveFieldsFromWidgets(acroForm);\n    }\n}", "/**\n * Get the documents AcroForm. This will return null if no AcroForm is part of the document.\n *\n * Dependent on setting <code>acroFormFixup</code> some fixing/changes will be done to the AcroForm.\n * If you need to ensure that there are no fixes applied call <code>getAcroForm</code> with <code>null</code>.\n *\n * Using <code>getAcroForm(PDDocumentFixup acroFormFixup)</code> might change the original content and\n * subsequent calls with <code>getAcroForm(null)</code> will return the changed content.\n *\n * @param acroFormFixup\n * \t\tthe fix up action or null\n * @return The document's AcroForm.\n */\npublic PDAcroForm getAcroForm(PDDocumentFixup acroFormFixup) {\n    if ((acroFormFixup != null) && (acroFormFixup != acroFormFixupApplied)) {\n        acroFormFixup.apply();\n        cachedAcroForm = null;\n        acroFormFixupApplied = acroFormFixup;\n    } else if (acroFormFixupApplied != null) {\n        LOG.debug(\"AcroForm content has already been retrieved with fixes applied - original content changed because of that\");\n    }\n    if (cachedAcroForm == null) {\n        COSDictionary dict = root.getCOSDictionary(COSName.ACRO_FORM);\n        cachedAcroForm = (dict == null) ? null : new PDAcroForm(document, dict);\n    }\n    return cachedAcroForm;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream" ],
    "fullMethods" : [ "/**\n * This will decrypt a stream.\n *\n * @param stream\n * \t\tThe stream to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void decryptStream(COSStream stream, long objNum, long genNum) throws IOException {\n    // Stream encrypted with identity filter\n    if (COSName.IDENTITY.equals(streamFilterName)) {\n        return;\n    }\n    COSBase type = stream.getCOSName(COSName.TYPE);\n    if ((!decryptMetadata) && COSName.METADATA.equals(type)) {\n        return;\n    }\n    // \"The cross-reference stream shall not be encrypted\"\n    if (COSName.XREF.equals(type)) {\n        return;\n    }\n    if (COSName.METADATA.equals(type)) {\n        byte[] buf;\n        // PDFBOX-3229 check case where metadata is not encrypted despite /EncryptMetadata missing\n        try (InputStream is = stream.createRawInputStream()) {\n            buf = new byte[10];\n            long isResult = IOUtils.populateBuffer(is, buf);\n            if (Long.compare(isResult, buf.length) != 0) {\n                LOG.debug((((\"Tried reading \" + buf.length) + \" bytes but only \") + isResult) + \" bytes read\");\n            }\n        }\n        if (Arrays.equals(buf, \"<?xpacket \".getBytes(StandardCharsets.ISO_8859_1))) {\n            LOG.warn(\"Metadata is not encrypted, but was expected to be\");\n            LOG.warn(\"Read PDF specification about EncryptMetadata (default value: true)\");\n            return;\n        }\n    }\n    decryptDictionary(stream, objNum, genNum);\n    // the input and the output stream of a still encrypted COSStream aren't no longer based\n    // on the same object so that it is safe to omit the intermediate ByteArrayStream\n    // \n    try (InputStream encryptedStream = stream.createRawInputStream();OutputStream output = stream.createRawOutputStream()) {\n        /* decrypt */\n        encryptData(objNum, genNum, encryptedStream, output, true);\n    } catch (IOException ex) {\n        LOG.error(((((ex.getClass().getSimpleName() + \" thrown when decrypting object \") + objNum) + \" \") + genNum) + \" obj\");\n        throw ex;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument", "org.apache.pdfbox.pdmodel.PDPage.getMediaBox" ],
    "fullMethods" : [ "/**\n * append all pages from source to destination.\n *\n * @param destination\n * \t\tthe document to receive the pages\n * @param source\n * \t\tthe document originating the new pages\n * @throws IOException\n * \t\tIf there is an error accessing data from either\n * \t\tdocument.\n */\npublic void appendDocument(PDDocument destination, PDDocument source) throws IOException {\n    PDFCloneUtility cloner = new PDFCloneUtility(destination);\n    if (source.getDocument().isClosed()) {\n        throw new IOException(\"Error: source PDF is closed.\");\n    }\n    if (destination.getDocument().isClosed()) {\n        throw new IOException(\"Error: destination PDF is closed.\");\n    }\n    PDDocumentCatalog srcCatalog = source.getDocumentCatalog();\n    if (isDynamicXfa(srcCatalog.getAcroForm())) {\n        throw new IOException(\"Error: can't merge source document containing dynamic XFA form content.\");\n    }\n    PDDocumentInformation destInfo = destination.getDocumentInformation();\n    PDDocumentInformation srcInfo = source.getDocumentInformation();\n    mergeInto(srcInfo.getCOSObject(), destInfo.getCOSObject(), cloner, Collections.emptySet());\n    // use the highest version number for the resulting pdf\n    float destVersion = destination.getVersion();\n    float srcVersion = source.getVersion();\n    if (destVersion < srcVersion) {\n        destination.setVersion(srcVersion);\n    }\n    PDDocumentCatalog destCatalog = destination.getDocumentCatalog();\n    mergeAcroForm(cloner, destCatalog, srcCatalog);\n    COSArray destThreads = destCatalog.getCOSObject().getCOSArray(COSName.THREADS);\n    COSArray srcThreads = cloner.cloneForNewDocument(destCatalog.getCOSObject().getCOSArray(COSName.THREADS));\n    if (destThreads == null) {\n        destCatalog.getCOSObject().setItem(COSName.THREADS, srcThreads);\n    } else {\n        destThreads.addAll(srcThreads);\n    }\n    PDDocumentNameDictionary destNames = destCatalog.getNames();\n    PDDocumentNameDictionary srcNames = srcCatalog.getNames();\n    if (srcNames != null) {\n        if (destNames == null) {\n            destCatalog.getCOSObject().setItem(COSName.NAMES, cloner.cloneForNewDocument(srcNames.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcNames, destNames);\n        }\n    }\n    if ((destNames != null) && destNames.getCOSObject().containsKey(COSName.ID_TREE)) {\n        // found in 001031.pdf from PDFBOX-4417 and doesn't belong there\n        destNames.getCOSObject().removeItem(COSName.ID_TREE);\n        LOG.warn(\"Removed /IDTree from /Names dictionary, doesn't belong there\");\n    }\n    PDDocumentNameDestinationDictionary srcDests = srcCatalog.getDests();\n    if (srcDests != null) {\n        PDDocumentNameDestinationDictionary destDests = destCatalog.getDests();\n        if (destDests == null) {\n            destCatalog.getCOSObject().setItem(COSName.DESTS, cloner.cloneForNewDocument(srcDests.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcDests, destDests);\n        }\n    }\n    PDDocumentOutline srcOutline = srcCatalog.getDocumentOutline();\n    if (srcOutline != null) {\n        PDDocumentOutline destOutline = destCatalog.getDocumentOutline();\n        if ((destOutline == null) || (destOutline.getFirstChild() == null)) {\n            PDDocumentOutline cloned = new PDDocumentOutline(cloner.cloneForNewDocument(srcOutline.getCOSObject()));\n            destCatalog.setDocumentOutline(cloned);\n        } else {\n            // search last sibling for dest, because /Last entry is sometimes wrong\n            PDOutlineItem destLastOutlineItem = destOutline.getFirstChild();\n            while (true) {\n                PDOutlineItem outlineItem = destLastOutlineItem.getNextSibling();\n                if (outlineItem == null) {\n                    break;\n                }\n                destLastOutlineItem = outlineItem;\n            } \n            for (PDOutlineItem item : srcOutline.children()) {\n                // get each child, clone its dictionary, remove siblings info,\n                // append outline item created from there\n                COSDictionary clonedDict = cloner.cloneForNewDocument(item.getCOSObject());\n                clonedDict.removeItem(COSName.PREV);\n                clonedDict.removeItem(COSName.NEXT);\n                PDOutlineItem clonedItem = new PDOutlineItem(clonedDict);\n                destLastOutlineItem.insertSiblingAfter(clonedItem);\n                destLastOutlineItem = destLastOutlineItem.getNextSibling();\n            }\n        }\n    }\n    PageMode destPageMode = destCatalog.getPageMode();\n    if (destPageMode == null) {\n        PageMode srcPageMode = srcCatalog.getPageMode();\n        destCatalog.setPageMode(srcPageMode);\n    }\n    COSDictionary srcLabels = srcCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n    if (srcLabels != null) {\n        int destPageCount = destination.getNumberOfPages();\n        COSArray destNums;\n        COSDictionary destLabels = destCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n        if (destLabels == null) {\n            destLabels = new COSDictionary();\n            destNums = new COSArray();\n            destLabels.setItem(COSName.NUMS, destNums);\n            destCatalog.getCOSObject().setItem(COSName.PAGE_LABELS, destLabels);\n        } else {\n            destNums = destLabels.getCOSArray(COSName.NUMS);\n        }\n        COSArray srcNums = srcLabels.getCOSArray(COSName.NUMS);\n        if (srcNums != null) {\n            int startSize = destNums.size();\n            for (int i = 0; i < srcNums.size(); i += 2) {\n                COSBase base = srcNums.getObject(i);\n                if (!(base instanceof COSNumber)) {\n                    LOG.error(((\"page labels ignored, index \" + i) + \" should be a number, but is \") + base);\n                    // remove what we added\n                    while (destNums.size() > startSize) {\n                        destNums.remove(startSize);\n                    } \n                    break;\n                }\n                COSNumber labelIndex = ((COSNumber) (base));\n                long labelIndexValue = labelIndex.intValue();\n                destNums.add(COSInteger.get(labelIndexValue + destPageCount));\n                destNums.add(cloner.cloneForNewDocument(srcNums.getObject(i + 1)));\n            }\n        }\n    }\n    COSStream destMetadata = destCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    COSStream srcMetadata = srcCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    if ((destMetadata == null) && (srcMetadata != null)) {\n        try {\n            PDStream newStream = new PDStream(destination, srcMetadata.createInputStream(), ((COSName) (null)));\n            mergeInto(srcMetadata, newStream.getCOSObject(), cloner, new HashSet<>(Arrays.asList(COSName.FILTER, COSName.LENGTH)));\n            destCatalog.getCOSObject().setItem(COSName.METADATA, newStream);\n        } catch (IOException ex) {\n            // PDFBOX-4227 cleartext XMP stream with /Flate\n            LOG.error(\"Metadata skipped because it could not be read\", ex);\n        }\n    }\n    COSDictionary destOCP = destCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    COSDictionary srcOCP = srcCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    if ((destOCP == null) && (srcOCP != null)) {\n        destCatalog.getCOSObject().setItem(COSName.OCPROPERTIES, cloner.cloneForNewDocument(srcOCP));\n    } else if ((destOCP != null) && (srcOCP != null)) {\n        cloner.cloneMerge(srcOCP, destOCP);\n    }\n    mergeOutputIntents(srcCatalog, destCatalog, cloner);\n    // merge logical structure hierarchy\n    boolean mergeStructTree = false;\n    int destParentTreeNextKey = -1;\n    Map<Integer, COSObjectable> srcNumberTreeAsMap = null;\n    Map<Integer, COSObjectable> destNumberTreeAsMap = null;\n    PDStructureTreeRoot srcStructTree = srcCatalog.getStructureTreeRoot();\n    PDStructureTreeRoot destStructTree = destCatalog.getStructureTreeRoot();\n    if ((destStructTree == null) && (srcStructTree != null)) {\n        // create a dummy structure tree in the destination, so that the source\n        // tree is cloned. (We can't just copy the tree reference due to PDFBOX-3999)\n        destStructTree = new PDStructureTreeRoot();\n        destCatalog.setStructureTreeRoot(destStructTree);\n        destStructTree.setParentTree(new PDNumberTreeNode(PDParentTreeValue.class));\n        // PDFBOX-4429: remove bogus StructParent(s)\n        for (PDPage page : destCatalog.getPages()) {\n            page.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : page.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n    }\n    if (destStructTree != null) {\n        PDNumberTreeNode destParentTree = destStructTree.getParentTree();\n        destParentTreeNextKey = destStructTree.getParentTreeNextKey();\n        if (destParentTree != null) {\n            destNumberTreeAsMap = getNumberTreeAsMap(destParentTree);\n            if (destParentTreeNextKey < 0) {\n                if (destNumberTreeAsMap.isEmpty()) {\n                    destParentTreeNextKey = 0;\n                } else {\n                    destParentTreeNextKey = Collections.max(destNumberTreeAsMap.keySet()) + 1;\n                }\n            }\n            if ((destParentTreeNextKey >= 0) && (srcStructTree != null)) {\n                PDNumberTreeNode srcParentTree = srcStructTree.getParentTree();\n                if (srcParentTree != null) {\n                    srcNumberTreeAsMap = getNumberTreeAsMap(srcParentTree);\n                    if (!srcNumberTreeAsMap.isEmpty()) {\n                        mergeStructTree = true;\n                    }\n                }\n            }\n        }\n    }\n    Map<COSDictionary, COSDictionary> objMapping = new HashMap<>();\n    PDPageTree destinationPageTree = destination.getPages();// cache PageTree\n\n    for (PDPage page : srcCatalog.getPages()) {\n        PDPage newPage = new PDPage(cloner.cloneForNewDocument(page.getCOSObject()));\n        if (!mergeStructTree) {\n            // PDFBOX-4429: remove bogus StructParent(s)\n            newPage.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : newPage.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n        newPage.setCropBox(page.getCropBox());\n        newPage.setMediaBox(page.getMediaBox());\n        newPage.setRotation(page.getRotation());\n        PDResources resources = page.getResources();\n        if (resources != null) {\n            // this is smart enough to just create references for resources that are used on multiple pages\n            newPage.setResources(new PDResources(cloner.cloneForNewDocument(resources.getCOSObject())));\n        } else {\n            newPage.setResources(new PDResources());\n        }\n        if (mergeStructTree) {\n            // add the value of the destination ParentTreeNextKey to every source element\n            // StructParent(s) value so that these don't overlap with the existing values\n            updateStructParentEntries(newPage, destParentTreeNextKey);\n            objMapping.put(page.getCOSObject(), newPage.getCOSObject());\n            List<PDAnnotation> oldAnnots = page.getAnnotations();\n            List<PDAnnotation> newAnnots = newPage.getAnnotations();\n            for (int i = 0; i < oldAnnots.size(); i++) {\n                objMapping.put(oldAnnots.get(i).getCOSObject(), newAnnots.get(i).getCOSObject());\n            }\n            // TODO update mapping for XObjects\n        }\n        destinationPageTree.add(newPage);\n    }\n    mergeOpenAction(srcCatalog, destCatalog, cloner);\n    if (mergeStructTree) {\n        updatePageReferences(cloner, srcNumberTreeAsMap, objMapping);\n        int maxSrcKey = -1;\n        for (Map.Entry<Integer, COSObjectable> entry : srcNumberTreeAsMap.entrySet()) {\n            int srcKey = entry.getKey();\n            maxSrcKey = Math.max(srcKey, maxSrcKey);\n            COSObjectable value = entry.getValue();\n            if (value != null) {\n                value = cloner.cloneForNewDocument(value.getCOSObject());\n                destNumberTreeAsMap.put(destParentTreeNextKey + srcKey, value);\n            }\n        }\n        destParentTreeNextKey += maxSrcKey + 1;\n        PDNumberTreeNode newParentTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);\n        // Note that all elements are stored flatly. This could become a problem for large files\n        // when these are opened in a viewer that uses the tagging information.\n        // If this happens, then PDNumberTreeNode should be improved with a convenience method that\n        // stores the map into a B+Tree, see https://en.wikipedia.org/wiki/B+_tree\n        newParentTreeNode.setNumbers(destNumberTreeAsMap);\n        destStructTree.setParentTree(newParentTreeNode);\n        destStructTree.setParentTreeNextKey(destParentTreeNextKey);\n        mergeKEntries(cloner, srcStructTree, destStructTree);\n        mergeRoleMap(srcStructTree, destStructTree, cloner);\n        mergeIDTree(cloner, srcStructTree, destStructTree);\n        mergeMarkInfo(destCatalog, srcCatalog);\n        mergeLanguage(destCatalog, srcCatalog);\n        mergeViewerPreferences(destCatalog, srcCatalog, cloner);\n    }\n}", "/**\n * A rectangle, expressed in default user space units, defining the boundaries of the physical medium on which the\n * page is intended to be displayed or printed.\n *\n * @return the media box of the page\n */\npublic PDRectangle getMediaBox() {\n    if (mediaBox == null) {\n        COSBase base = PDPageTree.getInheritableAttribute(page, COSName.MEDIA_BOX);\n        if (base instanceof COSArray) {\n            mediaBox = new PDRectangle(((COSArray) (base)));\n        } else {\n            LOG.debug(\"Can't find MediaBox, will use U.S. Letter\");\n            mediaBox = PDRectangle.LETTER;\n        }\n    }\n    return mediaBox;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingContext.<init>" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type4ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param cm\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n */\nType4ShadingContext(PDShadingType4 shading, ColorModel cm, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, cm, xform, matrix);\n    LOG.debug(\"Type4ShadingContext\");\n    bitsPerFlag = shading.getBitsPerFlag();\n    // TODO handle cases where bitperflag isn't 8\n    LOG.debug(\"bitsPerFlag: \" + bitsPerFlag);\n    setTriangleList(shading.collectTriangles(xform, matrix));\n    createPixelTable(deviceBounds);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Sets the entry \"V\" to the given values. Requires {@link #isMultiSelect()} to be true.\n *\n * @param values\n * \t\tthe list of values\n * @throws IOException\n * \t\tif the appearance couldn't be generated.\n */\npublic void setValue(List<String> values) throws IOException {\n    if ((values != null) && (!values.isEmpty())) {\n        if (!isMultiSelect()) {\n            throw new IllegalArgumentException(\"The list box does not allow multiple selections.\");\n        }\n        List<String> options = getOptions();\n        if (!options.containsAll(values)) {\n            throw new IllegalArgumentException(\"The values are not contained in the selectable options.\");\n        }\n        getCOSObject().setItem(COSName.V, COSArray.ofCOSStrings(values));\n        updateSelectedOptionsIndex(values, options);\n    } else {\n        getCOSObject().removeItem(COSName.V);\n        getCOSObject().removeItem(COSName.I);\n    }\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.from8bit" ],
    "fullMethods" : [ "/**\n * Returns the content of the given image as an AWT buffered image with an RGB color space.\n * If a color key mask is provided then an ARGB image is returned instead.\n * This method never returns null.\n *\n * @param pdImage\n * \t\tthe image to read\n * @param region\n * \t\tThe region of the source image to get, or null if the entire image is needed.\n * \t\tThe actual region will be clipped to the dimensions of the source image.\n * @param subsampling\n * \t\tThe amount of rows and columns to advance for every output pixel, a value\n * \t\tof 1 meaning every pixel will be read. It must not be larger than the image width or height.\n * @param colorKey\n * \t\tan optional color key mask\n * @return content of this image as an (A)RGB buffered image\n * @throws IOException\n * \t\tif the image cannot be read\n */\npublic static BufferedImage getRGBImage(PDImage pdImage, Rectangle region, int subsampling, COSArray colorKey) throws IOException {\n    if (pdImage.isEmpty()) {\n        throw new IOException(\"Image stream is empty\");\n    }\n    Rectangle clipped = clipRegion(pdImage, region);\n    // get parameters, they must be valid or have been repaired\n    final PDColorSpace colorSpace = pdImage.getColorSpace();\n    final int numComponents = colorSpace.getNumberOfComponents();\n    final int width = ((int) (Math.ceil(clipped.getWidth() / subsampling)));\n    final int height = ((int) (Math.ceil(clipped.getHeight() / subsampling)));\n    final int bitsPerComponent = pdImage.getBitsPerComponent();\n    if ((((width <= 0) || (height <= 0)) || (pdImage.getWidth() <= 0)) || (pdImage.getHeight() <= 0)) {\n        throw new IOException(\"image width and height must be positive\");\n    }\n    try {\n        if (((bitsPerComponent == 1) && (colorKey == null)) && (numComponents == 1)) {\n            return from1Bit(pdImage, clipped, subsampling, width, height);\n        }\n        // An AWT raster must use 8/16/32 bits per component. Images with < 8bpc\n        // will be unpacked into a byte-backed raster. Images with 16bpc will be reduced\n        // in depth to 8bpc as they will be drawn to TYPE_INT_RGB images anyway. All code\n        // in PDColorSpace#toRGBImage expects an 8-bit range, i.e. 0-255.\n        // Interleaved raster allows chunk-copying for 8-bit images.\n        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, width, height, numComponents, new Point(0, 0));\n        final float[] defaultDecode = pdImage.getColorSpace().getDefaultDecode(8);\n        final float[] decode = getDecodeArray(pdImage);\n        if (((bitsPerComponent == 8) && (colorKey == null)) && Arrays.equals(decode, defaultDecode)) {\n            // convert image, faster path for non-decoded, non-colormasked 8-bit images\n            return from8bit(pdImage, raster, clipped, subsampling, width, height);\n        }\n        return fromAny(pdImage, raster, colorKey, clipped, subsampling, width, height);\n    } catch (NegativeArraySizeException | IllegalArgumentException ex) {\n        throw new IOException(ex);\n    }\n}", "// faster, 8-bit non-decoded, non-colormasked image conversion\nprivate static BufferedImage from8bit(PDImage pdImage, WritableRaster raster, Rectangle clipped, final int subsampling, final int width, final int height) throws IOException {\n    int currentSubsampling = subsampling;\n    DecodeOptions options = new DecodeOptions(currentSubsampling);\n    options.setSourceRegion(clipped);\n    try (InputStream input = pdImage.createInputStream(options)) {\n        final int inputWidth;\n        final int startx;\n        final int starty;\n        final int scanWidth;\n        final int scanHeight;\n        if (options.isFilterSubsampled()) {\n            // Decode options were honored, and so there is no need for additional clipping or subsampling\n            inputWidth = width;\n            startx = 0;\n            starty = 0;\n            scanWidth = width;\n            scanHeight = height;\n            currentSubsampling = 1;\n        } else {\n            // Decode options not honored, so we need to clip and subsample ourselves.\n            inputWidth = pdImage.getWidth();\n            startx = clipped.x;\n            starty = clipped.y;\n            scanWidth = clipped.width;\n            scanHeight = clipped.height;\n        }\n        final int numComponents = pdImage.getColorSpace().getNumberOfComponents();\n        // get the raster's underlying byte buffer\n        byte[] bank = ((DataBufferByte) (raster.getDataBuffer())).getData();\n        if (((((startx == 0) && (starty == 0)) && (scanWidth == width)) && (scanHeight == height)) && (currentSubsampling == 1)) {\n            // we just need to copy all sample data, then convert to RGB image.\n            long inputResult = IOUtils.populateBuffer(input, bank);\n            if (Long.compare(inputResult, (((long) (width)) * height) * numComponents) != 0) {\n                LOG.debug((((\"Tried reading \" + ((((long) (width)) * height) * numComponents)) + \" bytes but only \") + inputResult) + \" bytes read\");\n            }\n            return pdImage.getColorSpace().toRGBImage(raster);\n        }\n        // either subsampling is required, or reading only part of the image, so its\n        // not possible to blindly copy all data.\n        byte[] tempBytes = new byte[numComponents * inputWidth];\n        // compromise between memory and time usage:\n        // reading the whole image consumes too much memory\n        // reading one pixel at a time makes it slow in our buffering infrastructure\n        int i = 0;\n        for (int y = 0; y < (starty + scanHeight); ++y) {\n            long inputResult = IOUtils.populateBuffer(input, tempBytes);\n            if (Long.compare(inputResult, tempBytes.length) != 0) {\n                LOG.debug((((\"Tried reading \" + tempBytes.length) + \" bytes but only \") + inputResult) + \" bytes read\");\n            }\n            if ((y < starty) || ((y % currentSubsampling) > 0)) {\n                continue;\n            }\n            if (currentSubsampling == 1) {\n                // Not the entire region was requested, but if no subsampling should\n                // be performed, we can still copy the entire part of this row\n                System.arraycopy(tempBytes, startx * numComponents, bank, (y * inputWidth) * numComponents, scanWidth * numComponents);\n            } else {\n                for (int x = startx; x < (startx + scanWidth); x += currentSubsampling) {\n                    for (int c = 0; c < numComponents; c++) {\n                        bank[i] = tempBytes[(x * numComponents) + c];\n                        ++i;\n                    }\n                }\n            }\n        }\n        // use the color space to convert the image to RGB\n        return pdImage.getColorSpace().toRGBImage(raster);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Sets the value of this field to be the given signature.\n *\n * @param value\n * \t\tis the PDSignatureField\n * @throws IOException\n * \t\tif the new value could not be applied\n */\npublic void setValue(PDSignature value) throws IOException {\n    getCOSObject().setItem(COSName.V, value);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.createAnnotation",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.createAnnotation" ],
    "fullMethods" : [ "/**\n * Create the correct annotation from the base COS object.\n *\n * @param base\n * \t\tThe COS object that is the annotation.\n * @return The correctly typed annotation object, never null.\n * @throws IOException\n * \t\tIf the annotation type is unknown.\n */\npublic static PDAnnotation createAnnotation(COSBase base) throws IOException {\n    if (base instanceof COSDictionary) {\n        COSDictionary annotDic = ((COSDictionary) (base));\n        String subtype = annotDic.getNameAsString(COSName.SUBTYPE);\n        if (null == subtype) {\n            LOG.debug(\"Unknown annotation subtype\");\n            return new PDAnnotationUnknown(annotDic);\n        }\n        switch (subtype) {\n            case PDAnnotationFileAttachment.SUB_TYPE :\n                return new PDAnnotationFileAttachment(annotDic);\n            case PDAnnotationLine.SUB_TYPE :\n                return new PDAnnotationLine(annotDic);\n            case PDAnnotationLink.SUB_TYPE :\n                return new PDAnnotationLink(annotDic);\n            case PDAnnotationPopup.SUB_TYPE :\n                return new PDAnnotationPopup(annotDic);\n            case PDAnnotationRubberStamp.SUB_TYPE :\n                return new PDAnnotationRubberStamp(annotDic);\n            case PDAnnotationSquare.SUB_TYPE :\n                return new PDAnnotationSquare(annotDic);\n            case PDAnnotationCircle.SUB_TYPE :\n                return new PDAnnotationCircle(annotDic);\n            case PDAnnotationPolygon.SUB_TYPE :\n                return new PDAnnotationPolygon(annotDic);\n            case PDAnnotationPolyline.SUB_TYPE :\n                return new PDAnnotationPolyline(annotDic);\n            case PDAnnotationInk.SUB_TYPE :\n                return new PDAnnotationInk(annotDic);\n            case PDAnnotationText.SUB_TYPE :\n                return new PDAnnotationText(annotDic);\n            case PDAnnotationHighlight.SUB_TYPE :\n                return new PDAnnotationHighlight(annotDic);\n            case PDAnnotationUnderline.SUB_TYPE :\n                return new PDAnnotationUnderline(annotDic);\n            case PDAnnotationStrikeout.SUB_TYPE :\n                return new PDAnnotationStrikeout(annotDic);\n            case PDAnnotationSquiggly.SUB_TYPE :\n                return new PDAnnotationSquiggly(annotDic);\n            case PDAnnotationWidget.SUB_TYPE :\n                return new PDAnnotationWidget(annotDic);\n            case PDAnnotationFreeText.SUB_TYPE :\n                return new PDAnnotationFreeText(annotDic);\n            case PDAnnotationCaret.SUB_TYPE :\n                return new PDAnnotationCaret(annotDic);\n            case PDAnnotationSound.SUB_TYPE :\n                return new PDAnnotationSound(annotDic);\n            default :\n                // TODO not yet implemented:\n                // Movie, Screen, PrinterMark, TrapNet, Watermark, 3D, Redact\n                LOG.debug(\"Unknown or unsupported annotation subtype \" + subtype);\n                return new PDAnnotationUnknown(annotDic);\n        }\n    } else {\n        throw new IOException(\"Error: Unknown annotation type \" + base);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Set the plain text value of this field, and try to update the visual appearance.\n *\n * @param value\n * \t\tPlain text\n * @throws IOException\n * \t\tif the value could not be set\n */\n@Override\npublic void setValue(String value) throws IOException {\n    getCOSObject().setString(COSName.V, value);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDComboBox.constructAppearances", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.<init>", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.validateAndEnsureAcroFormResources" ],
    "fullMethods" : [ "/**\n * Set the selected option given its name, and try to update the visual appearance.\n *\n * @param value\n * \t\tName of option to select\n * @throws IOException\n * \t\tif the value could not be set\n * @throws IllegalArgumentException\n * \t\tif the value is not a valid option.\n */\n@Override\npublic void setValue(String value) throws IOException {\n    checkValue(value);\n    // if there are export values/an Opt entry there is a different\n    // approach to setting the value\n    if (!getExportValues().isEmpty()) {\n        updateByOption(value);\n    } else {\n        updateByValue(value);\n    }\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    AppearanceGeneratorHelper apHelper;\n    apHelper = new AppearanceGeneratorHelper(this);\n    List<String> values = getValue();\n    if (!values.isEmpty()) {\n        apHelper.setAppearanceValue(values.get(0));\n    } else {\n        apHelper.setAppearanceValue(\"\");\n    }\n}", "/**\n * Constructs a COSAppearance from the given field.\n *\n * @param field\n * \t\tthe field which you wish to control the appearance of\n * @throws IOException\n */\nAppearanceGeneratorHelper(PDVariableText field) throws IOException {\n    this.field = field;\n    validateAndEnsureAcroFormResources();\n    try {\n        this.defaultAppearance = field.getDefaultAppearanceString();\n    } catch (IOException ex) {\n        throw new IOException(((((\"Could not process default appearance string '\" + field.getDefaultAppearance()) + \"' for field '\") + field.getFullyQualifiedName()) + \"': \") + ex.getMessage(), ex);\n    }\n}", "/* Adobe Reader/Acrobat are adding resources which are at the field/widget level\nto the AcroForm level.\n */\nprivate void validateAndEnsureAcroFormResources() {\n    // add font resources which might be available at the field\n    // level but are not at the AcroForm level to the AcroForm\n    // to match Adobe Reader/Acrobat behavior\n    PDResources acroFormResources = field.getAcroForm().getDefaultResources();\n    if (acroFormResources == null) {\n        return;\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        PDAppearanceStream stream = widget.getNormalAppearanceStream();\n        if (stream == null) {\n            continue;\n        }\n        PDResources widgetResources = stream.getResources();\n        if (widgetResources == null) {\n            continue;\n        }\n        COSDictionary widgetFontDict = widgetResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        COSDictionary acroFormFontDict = acroFormResources.getCOSObject().getCOSDictionary(COSName.FONT);\n        for (COSName fontResourceName : widgetResources.getFontNames()) {\n            try {\n                if (acroFormResources.getFont(fontResourceName) == null) {\n                    LOG.debug((\"Adding font resource \" + fontResourceName) + \" from widget to AcroForm\");\n                    // use the COS-object to preserve a possible indirect object reference\n                    acroFormFontDict.setItem(fontResourceName, widgetFontDict.getItem(fontResourceName));\n                }\n            } catch (IOException e) {\n                LOG.warn(\"Unable to match field level font with AcroForm font\", e);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerCoordinate",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBitsPerCoordinate" ],
    "fullMethods" : [ "/**\n * The bits per coordinate of this shading. This will return -1 if one has\n * not been set.\n *\n * @return the number of bits per coordinate\n */\npublic int getBitsPerCoordinate() {\n    if (bitsPerCoordinate == (-1)) {\n        bitsPerCoordinate = getCOSObject().getInt(COSName.BITS_PER_COORDINATE, -1);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"bitsPerCoordinate: \" + (Math.pow(2, bitsPerCoordinate) - 1));\n        }\n    }\n    return bitsPerCoordinate;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject", "org.apache.pdfbox.pdfparser.COSParser.parseObjectDynamically", "org.apache.pdfbox.pdfparser.COSParser.getObjectOffset" ],
    "fullMethods" : [ "@Override\npublic COSBase dereferenceCOSObject(COSObject obj) throws IOException {\n    long currentPos = source.getPosition();\n    COSObjectKey key = obj.getKey();\n    COSBase parsedObj = parseObjectDynamically(key, false);\n    if (parsedObj != null) {\n        parsedObj.setDirect(false);\n        parsedObj.setKey(key);\n    }\n    if (currentPos > 0) {\n        source.seek(currentPos);\n    }\n    return parsedObj;\n}", "/**\n * Parse the object for the given object key.\n *\n * @param objKey\n * \t\tkey of object to be parsed\n * @param requireExistingNotCompressedObj\n * \t\tif <code>true</code> the object to be parsed must be defined in xref\n * \t\t(comment: null objects may be missing from xref) and it must not be a compressed object within object stream\n * \t\t(this is used to circumvent being stuck in a loop in a malicious PDF)\n * @return the parsed object (which is also added to document object)\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprotected synchronized COSBase parseObjectDynamically(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    COSObject pdfObject = document.getObjectFromPool(objKey);\n    if (!pdfObject.isObjectNull()) {\n        return pdfObject.getObject();\n    }\n    Long offsetOrObjstmObNr = getObjectOffset(objKey, requireExistingNotCompressedObj);\n    COSBase referencedObject = null;\n    if (offsetOrObjstmObNr != null) {\n        if (offsetOrObjstmObNr > 0) {\n            referencedObject = parseFileObject(offsetOrObjstmObNr, objKey);\n        } else {\n            // xref value is object nr of object stream containing object to be parsed\n            // since our object was not found it means object stream was not parsed so far\n            referencedObject = parseObjectStreamObject(-offsetOrObjstmObNr, objKey);\n        }\n    }\n    if ((referencedObject == null) || (referencedObject instanceof COSNull)) {\n        // not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)\n        // or some other issue with dereferencing\n        // remove parser to avoid endless recursion\n        pdfObject.setToNull();\n    }\n    return referencedObject;\n}", "private Long getObjectOffset(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    // read offset or object stream object number from xref table\n    Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);\n    // maybe something is wrong with the xref table -> perform brute force search for all objects\n    if ((offsetOrObjstmObNr == null) && isLenient) {\n        offsetOrObjstmObNr = getBruteForceParser().getBFCOSObjectOffsets().get(objKey);\n        if (offsetOrObjstmObNr != null) {\n            LOG.debug(((\"Set missing offset \" + offsetOrObjstmObNr) + \" for object \") + objKey);\n            document.getXrefTable().put(objKey, offsetOrObjstmObNr);\n        }\n    }\n    // test to circumvent loops with broken documents\n    if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null) || (offsetOrObjstmObNr <= 0))) {\n        throw new IOException(((\"Object must be defined and must not be compressed object: \" + objKey.getNumber()) + \":\") + objKey.getGeneration());\n    }\n    return offsetOrObjstmObNr;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getTrueTypeFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getTrueTypeFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFont" ],
    "fullMethods" : [ "/**\n * Finds a TrueType font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param fontDescriptor\n * \t\tFontDescriptor\n */\n@Override\npublic FontMapping<TrueTypeFont> getTrueTypeFont(String baseFont, PDFontDescriptor fontDescriptor) {\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, baseFont)));\n    if (ttf != null) {\n        return new FontMapping<>(ttf, false);\n    } else {\n        // fallback - todo: i.e. fuzzy match\n        String fontName = getFallbackFontName(fontDescriptor);\n        ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, fontName)));\n        if (ttf == null) {\n            // we have to return something here as TTFs aren't strictly required on the system\n            ttf = lastResortFont;\n        }\n        return new FontMapping<>(ttf, true);\n    }\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFont(FontFormat format, String postScriptName) {\n    // handle damaged PDFs, see PDFBOX-2884\n    if (postScriptName == null) {\n        return null;\n    }\n    // make sure the font provider is initialized\n    if (fontProvider == null) {\n        getProvider();\n    }\n    // first try to match the PostScript name\n    FontInfo info = getFont(format, postScriptName);\n    if (info != null) {\n        return info.getFont();\n    }\n    // remove hyphens (e.g. Arial-Black -> ArialBlack)\n    info = getFont(format, postScriptName.replace(\"-\", \"\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    // then try named substitutes\n    for (String substituteName : getSubstitutes(postScriptName)) {\n        info = getFont(format, substituteName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // then try converting Windows names e.g. (ArialNarrow,Bold) -> (ArialNarrow-Bold)\n    info = getFont(format, postScriptName.replace(\",\", \"-\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    if (postScriptName.contains(\",\")) {\n        postScriptName = postScriptName.substring(0, postScriptName.indexOf(\",\"));\n        // PDFBOX-5806: try cutting font style and getting the basefont\n        // eg. for \"Wingdings,Bolt\" to \"Wingding-Regular\" (including the following step)\n        info = getFont(format, postScriptName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // try appending \"-Regular\", works for Wingdings on windows\n    info = getFont(format, postScriptName + \"-Regular\");\n    if (info != null) {\n        return info.getFont();\n    }\n    // no matches\n    return null;\n}", "/**\n * Finds the named font with the given format.\n */\nprivate FontInfo getFont(FontFormat format, String postScriptName) {\n    int index = postScriptName.indexOf('+');\n    // strip subset tag (happens when we substitute a corrupt embedded font, see PDFBOX-2642)\n    if (index > (-1)) {\n        postScriptName = postScriptName.substring(index + 1);\n    }\n    // look up the PostScript name\n    FontInfo info = fontInfoByName.get(postScriptName.toLowerCase(Locale.ENGLISH));\n    if ((info != null) && (info.getFormat() == format)) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"getFont('%s','%s') returns %s\", format, postScriptName, info));\n        }\n        return info;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setFont" ],
    "fullMethods" : [ "/**\n * Set the font and font size to draw text with.\n *\n * @param font\n * \t\tThe font to use.\n * @param fontSize\n * \t\tThe font size to draw the text.\n * @throws IOException\n * \t\tIf there is an error writing the font information.\n */\npublic void setFont(PDFont font, float fontSize) throws IOException {\n    if (fontStack.isEmpty()) {\n        fontStack.add(font);\n    } else {\n        fontStack.pop();\n        fontStack.push(font);\n    }\n    // keep track of fonts which are configured for subsetting\n    if (font.willBeSubset()) {\n        if (document != null) {\n            document.getFontsToSubset().add(font);\n        } else {\n            LOG.warn((\"Using the subsetted font '\" + font.getName()) + \"' without a PDDocument context; call subset() before saving\");\n        }\n    } else if ((!font.isEmbedded()) && (!font.isStandard14())) {\n        LOG.warn((\"attempting to use font '\" + font.getName()) + \"' that isn't embedded\");\n    }\n    // complex text layout\n    if (font instanceof PDType0Font) {\n        PDType0Font type0Font = ((PDType0Font) (font));\n        GsubData gsubData = type0Font.getGsubData();\n        if (gsubData != GsubData.NO_DATA_FOUND) {\n            GsubWorker gsubWorker = gsubWorkerFactory.getGsubWorker(type0Font.getCmapLookup(), gsubData);\n            gsubWorkers.put(((PDType0Font) (font)), gsubWorker);\n        } else if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No GSUB data found in font\" + font.getName());\n        }\n    }\n    writeOperand(resources.add(font));\n    writeOperand(fontSize);\n    writeOperator(OperatorName.SET_FONT_AND_SIZE);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFontBoxFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFontBoxFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFontBoxFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.findFont", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getFont" ],
    "fullMethods" : [ "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null. This allows\n * any font to be substituted with a PFB, TTF or OTF.\n *\n * @param fontDescriptor\n * \t\tthe FontDescriptor of the font to find\n */\n@Override\npublic FontMapping<FontBoxFont> getFontBoxFont(String baseFont, PDFontDescriptor fontDescriptor) {\n    FontBoxFont font = findFontBoxFont(baseFont);\n    if (font != null) {\n        return new FontMapping<>(font, false);\n    } else {\n        // fallback - todo: i.e. fuzzy match\n        String fallbackName = getFallbackFontName(fontDescriptor);\n        font = findFontBoxFont(fallbackName);\n        if (font == null) {\n            // we have to return something here as TTFs aren't strictly required on the system\n            font = lastResortFont;\n        }\n        return new FontMapping<>(font, true);\n    }\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFontBoxFont(String postScriptName) {\n    Type1Font t1 = ((Type1Font) (findFont(FontFormat.PFB, postScriptName)));\n    if (t1 != null) {\n        return t1;\n    }\n    TrueTypeFont ttf = ((TrueTypeFont) (findFont(FontFormat.TTF, postScriptName)));\n    if (ttf != null) {\n        return ttf;\n    }\n    OpenTypeFont otf = ((OpenTypeFont) (findFont(FontFormat.OTF, postScriptName)));\n    if (otf != null) {\n        return otf;\n    }\n    return null;\n}", "/**\n * Finds a font with the given PostScript name, or a suitable substitute, or null.\n *\n * @param postScriptName\n * \t\tPostScript font name\n */\nprivate FontBoxFont findFont(FontFormat format, String postScriptName) {\n    // handle damaged PDFs, see PDFBOX-2884\n    if (postScriptName == null) {\n        return null;\n    }\n    // make sure the font provider is initialized\n    if (fontProvider == null) {\n        getProvider();\n    }\n    // first try to match the PostScript name\n    FontInfo info = getFont(format, postScriptName);\n    if (info != null) {\n        return info.getFont();\n    }\n    // remove hyphens (e.g. Arial-Black -> ArialBlack)\n    info = getFont(format, postScriptName.replace(\"-\", \"\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    // then try named substitutes\n    for (String substituteName : getSubstitutes(postScriptName)) {\n        info = getFont(format, substituteName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // then try converting Windows names e.g. (ArialNarrow,Bold) -> (ArialNarrow-Bold)\n    info = getFont(format, postScriptName.replace(\",\", \"-\"));\n    if (info != null) {\n        return info.getFont();\n    }\n    if (postScriptName.contains(\",\")) {\n        postScriptName = postScriptName.substring(0, postScriptName.indexOf(\",\"));\n        // PDFBOX-5806: try cutting font style and getting the basefont\n        // eg. for \"Wingdings,Bolt\" to \"Wingding-Regular\" (including the following step)\n        info = getFont(format, postScriptName);\n        if (info != null) {\n            return info.getFont();\n        }\n    }\n    // try appending \"-Regular\", works for Wingdings on windows\n    info = getFont(format, postScriptName + \"-Regular\");\n    if (info != null) {\n        return info.getFont();\n    }\n    // no matches\n    return null;\n}", "/**\n * Finds the named font with the given format.\n */\nprivate FontInfo getFont(FontFormat format, String postScriptName) {\n    int index = postScriptName.indexOf('+');\n    // strip subset tag (happens when we substitute a corrupt embedded font, see PDFBOX-2642)\n    if (index > (-1)) {\n        postScriptName = postScriptName.substring(index + 1);\n    }\n    // look up the PostScript name\n    FontInfo info = fontInfoByName.get(postScriptName.toLowerCase(Locale.ENGLISH));\n    if ((info != null) && (info.getFormat() == format)) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"getFont('%s','%s') returns %s\", format, postScriptName, info));\n        }\n        return info;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.compress.COSWriterObjectStream.writeObjectsToStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.compress.COSWriterObjectStream.writeObjectsToStream", "org.apache.pdfbox.pdfwriter.compress.COSWriterObjectStream.writeObject" ],
    "fullMethods" : [ "/**\n * Writes all prepared {@link COSObject}s to the given {@link COSStream}.\n *\n * @param stream\n * \t\tThe stream for the compressed objects.\n * @return The given {@link COSStream} of this object stream.\n * @throws IOException\n * \t\tShall be thrown, if writing the object stream failed.\n */\npublic COSStream writeObjectsToStream(COSStream stream) throws IOException {\n    int objectCount = preparedKeys.size();\n    stream.setItem(COSName.TYPE, COSName.OBJ_STM);\n    stream.setInt(COSName.N, objectCount);\n    // Prepare the compressible objects for writing.\n    List<Long> objectNumbers = new ArrayList<>(objectCount);\n    List<byte[]> objectsBuffer = new ArrayList<>(objectCount);\n    for (int i = 0; i < objectCount; i++) {\n        try (ByteArrayOutputStream partialOutput = new ByteArrayOutputStream()) {\n            objectNumbers.add(preparedKeys.get(i).getNumber());\n            COSBase base = preparedObjects.get(i);\n            writeObject(partialOutput, base, true);\n            objectsBuffer.add(partialOutput.toByteArray());\n        }\n    }\n    // Deduce the object stream byte offset map.\n    byte[] offsetsMapBuffer;\n    long nextObjectOffset = 0;\n    try (ByteArrayOutputStream partialOutput = new ByteArrayOutputStream()) {\n        for (int i = 0; i < objectNumbers.size(); i++) {\n            partialOutput.write(String.valueOf(objectNumbers.get(i)).getBytes(StandardCharsets.ISO_8859_1));\n            partialOutput.write(COSWriter.SPACE);\n            partialOutput.write(String.valueOf(nextObjectOffset).getBytes(StandardCharsets.ISO_8859_1));\n            partialOutput.write(COSWriter.SPACE);\n            nextObjectOffset += objectsBuffer.get(i).length;\n        }\n        offsetsMapBuffer = partialOutput.toByteArray();\n    }\n    // Write Flate compressed object stream data.\n    try (OutputStream output = stream.createOutputStream(COSName.FLATE_DECODE)) {\n        output.write(offsetsMapBuffer);\n        stream.setInt(COSName.FIRST, offsetsMapBuffer.length);\n        for (byte[] rawObject : objectsBuffer) {\n            output.write(rawObject);\n        }\n    }\n    return stream;\n}", "/**\n * This method prepares and writes COS data to the object stream by selecting appropriate specialized methods for\n * the content.\n *\n * @param output\n * \t\tThe stream, that shall be written to.\n * @param object\n * \t\tThe content, that shall be written.\n * @param topLevel\n * \t\tTrue, if the currently written object is a top level entry of this object stream.\n * @throws IOException\n * \t\tShall be thrown, when an exception occurred for the write operation.\n */\nprivate void writeObject(OutputStream output, COSBase object, boolean topLevel) throws IOException {\n    if (object == null) {\n        return;\n    }\n    COSBase base;\n    if (object instanceof COSObject) {\n        if (!topLevel) {\n            COSObjectKey actualKey = ((COSObject) (object)).getKey();\n            if (actualKey != null) {\n                writeObjectReference(output, actualKey);\n                return;\n            }\n        }\n        base = ((COSObject) (object)).getObject();\n        if (base == null) {\n            LOG.debug(\"Can't dereference indirect object, writing COSNull instead \" + object);\n            writeCOSNull(output);\n            return;\n        }\n    } else {\n        base = object;\n    }\n    if ((!topLevel) && this.compressionPool.contains(base)) {\n        COSObjectKey key = this.compressionPool.getKey(base);\n        if (key == null) {\n            throw new IOException(\"Error: Adding unknown object reference to object stream:\" + object);\n        }\n        writeObjectReference(output, key);\n        return;\n    }\n    if (base instanceof COSString) {\n        writeCOSString(output, ((COSString) (base)));\n    } else if (base instanceof COSFloat) {\n        writeCOSFloat(output, ((COSFloat) (base)));\n    } else if (base instanceof COSInteger) {\n        writeCOSInteger(output, ((COSInteger) (base)));\n    } else if (base instanceof COSBoolean) {\n        writeCOSBoolean(output, ((COSBoolean) (base)));\n    } else if (base instanceof COSName) {\n        writeCOSName(output, ((COSName) (base)));\n    } else if (base instanceof COSArray) {\n        writeCOSArray(output, ((COSArray) (base)));\n    } else if (base instanceof COSDictionary) {\n        writeCOSDictionary(output, ((COSDictionary) (base)));\n    } else if (base instanceof COSNull) {\n        writeCOSNull(output);\n    } else {\n        throw new IOException(\"Error: Unknown type in object stream:\" + object);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getAcroForm",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getAcroForm" ],
    "fullMethods" : [ "/**\n * Get the documents AcroForm. This will return null if no AcroForm is part of the document.\n *\n * Dependent on setting <code>acroFormFixup</code> some fixing/changes will be done to the AcroForm.\n * If you need to ensure that there are no fixes applied call <code>getAcroForm</code> with <code>null</code>.\n *\n * Using <code>getAcroForm(PDDocumentFixup acroFormFixup)</code> might change the original content and\n * subsequent calls with <code>getAcroForm(null)</code> will return the changed content.\n *\n * @param acroFormFixup\n * \t\tthe fix up action or null\n * @return The document's AcroForm.\n */\npublic PDAcroForm getAcroForm(PDDocumentFixup acroFormFixup) {\n    if ((acroFormFixup != null) && (acroFormFixup != acroFormFixupApplied)) {\n        acroFormFixup.apply();\n        cachedAcroForm = null;\n        acroFormFixupApplied = acroFormFixup;\n    } else if (acroFormFixupApplied != null) {\n        LOG.debug(\"AcroForm content has already been retrieved with fixes applied - original content changed because of that\");\n    }\n    if (cachedAcroForm == null) {\n        COSDictionary dict = root.getCOSDictionary(COSName.ACRO_FORM);\n        cachedAcroForm = (dict == null) ? null : new PDAcroForm(document, dict);\n    }\n    return cachedAcroForm;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getNumberOfColorComponents",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getNumberOfColorComponents" ],
    "fullMethods" : [ "/**\n * The number of color components of this shading.\n *\n * @return number of color components of this shading\n * @throws IOException\n * \t\tif the data could not be read\n */\npublic int getNumberOfColorComponents() throws IOException {\n    if (numberOfColorComponents == (-1)) {\n        numberOfColorComponents = (getFunction() != null) ? 1 : getColorSpace().getNumberOfComponents();\n        LOG.debug(\"numberOfColorComponents: \" + numberOfColorComponents);\n    }\n    return numberOfColorComponents;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.printing.PDFPrintable.print",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.printing.PDFPrintable.print" ],
    "fullMethods" : [ "@Override\npublic int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n    if ((pageIndex < 0) || (pageIndex >= pageTree.getCount())) {\n        return NO_SUCH_PAGE;\n    }\n    try {\n        Graphics2D graphics2D = ((Graphics2D) (graphics));\n        // capture the DPI that will be used for rasterizing the image\n        // if rasterizing is specified\n        float rasterDpi = dpi;\n        if (rasterDpi == RASTERIZE_DPI_AUTO) {\n            rasterDpi = ((float) (graphics2D.getTransform().getScaleX())) * 72.0F;\n            LOG.debug(\"auto raster dpi: \" + rasterDpi);\n        }\n        PDPage page = pageTree.get(pageIndex);\n        PDRectangle cropBox = getRotatedCropBox(page);\n        // the imageable area is the area within the page margins\n        final double imageableWidth = pageFormat.getImageableWidth();\n        final double imageableHeight = pageFormat.getImageableHeight();\n        double scale = 1;\n        if (scaling != Scaling.ACTUAL_SIZE) {\n            // scale to fit\n            double scaleX = imageableWidth / cropBox.getWidth();\n            double scaleY = imageableHeight / cropBox.getHeight();\n            scale = Math.min(scaleX, scaleY);\n            // only shrink to fit when enabled\n            if ((scale > 1) && (scaling == Scaling.SHRINK_TO_FIT)) {\n                scale = 1;\n            }\n            // only stretch to fit when enabled\n            if ((scale < 1) && (scaling == Scaling.STRETCH_TO_FIT)) {\n                scale = 1;\n            }\n        }\n        // set the graphics origin to the origin of the imageable area (i.e the margins)\n        graphics2D.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n        // center on page\n        if (center) {\n            double dx = (imageableWidth - (cropBox.getWidth() * scale)) / 2;\n            double dy = (imageableHeight - (cropBox.getHeight() * scale)) / 2;\n            if ((dx >= 0) && (dy >= 0)) {\n                graphics2D.translate(dx, dy);\n            } else {\n                // PDFBOX-3117 and https://lists.apache.org/thread/12s9tc93ofgmjfq1dpqfps9p725l0wwr\n                LOG.warn((((\"Centering disabled because of negative translation value (\" + dx) + \",\") + dy) + \")\");\n            }\n        }\n        // rasterize to bitmap (optional)\n        Graphics2D printerGraphics = null;\n        BufferedImage image = null;\n        if ((dpi > 0) || (dpi == RASTERIZE_DPI_AUTO)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"dpi set to \" + rasterDpi);\n            }\n            float dpiScale = rasterDpi / 72;\n            image = new BufferedImage(((int) ((imageableWidth * dpiScale) / scale)), ((int) ((imageableHeight * dpiScale) / scale)), BufferedImage.TYPE_INT_ARGB);\n            printerGraphics = graphics2D;\n            graphics2D = image.createGraphics();\n            // rescale\n            printerGraphics.scale(scale / dpiScale, scale / dpiScale);\n            scale = dpiScale;\n        }\n        // draw to graphics using PDFRender\n        AffineTransform transform = graphics2D.getTransform();\n        graphics2D.setBackground(Color.WHITE);\n        renderer.setSubsamplingAllowed(subsamplingAllowed);\n        renderer.setRenderingHints(renderingHints);\n        renderer.renderPageToGraphics(pageIndex, graphics2D, ((float) (scale)), ((float) (scale)), RenderDestination.PRINT);\n        // draw crop box\n        if (showPageBorder) {\n            graphics2D.setTransform(transform);\n            graphics2D.setClip(0, 0, ((int) (imageableWidth)), ((int) (imageableHeight)));\n            graphics2D.scale(scale, scale);\n            graphics2D.setColor(Color.GRAY);\n            graphics2D.setStroke(new BasicStroke(0.5F));\n            graphics.drawRect(0, 0, ((int) (cropBox.getWidth())), ((int) (cropBox.getHeight())));\n        }\n        // draw rasterized bitmap (optional)\n        if (printerGraphics != null) {\n            printerGraphics.setBackground(Color.WHITE);\n            printerGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());\n            printerGraphics.drawImage(image, 0, 0, null);\n            graphics2D.dispose();\n        }\n        return PAGE_EXISTS;\n    } catch (IOException e) {\n        throw new PrinterIOException(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceContent", "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.insertGeneratedAppearance" ],
    "fullMethods" : [ "/**\n * This is the public method for setting the appearance stream.\n *\n * @param apValue\n * \t\tthe String value which the appearance should represent\n * @throws IOException\n * \t\tIf there is an error creating the stream.\n */\npublic void setAppearanceValue(String apValue) throws IOException {\n    value = getFormattedValue(apValue);\n    // Treat multiline field values in single lines as single lime values.\n    // This is in line with how Adobe Reader behaves when entering text\n    // interactively but NOT how it behaves when the field value has been\n    // set programmatically and Reader is forced to generate the appearance\n    // using PDAcroForm.setNeedAppearances\n    // see PDFBOX-3911\n    if ((field instanceof PDTextField) && (!((PDTextField) (field)).isMultiline())) {\n        value = value.replaceAll(\"\\\\u000D\\\\u000A|[\\\\u000A\\\\u000B\\\\u000C\\\\u000D\\\\u0085\\\\u2028\\\\u2029]\", \" \");\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        if (widget.getCOSObject().containsKey(\"PMD\")) {\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" is a PaperMetaData widget, no appearance stream created\");\n            continue;\n        }\n        // some fields have the /Da at the widget level if the\n        // widgets differ in layout.\n        PDDefaultAppearanceString acroFormAppearance = defaultAppearance;\n        if (widget.getCOSObject().getDictionaryObject(COSName.DA) != null) {\n            defaultAppearance = getWidgetDefaultAppearanceString(widget);\n        }\n        PDRectangle rect = widget.getRectangle();\n        if (rect == null) {\n            widget.getCOSObject().removeItem(COSName.AP);\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" has no rectangle, no appearance stream created\");\n            continue;\n        }\n        PDAppearanceDictionary appearanceDict = widget.getAppearance();\n        if (appearanceDict == null) {\n            appearanceDict = new PDAppearanceDictionary();\n            widget.setAppearance(appearanceDict);\n        }\n        PDAppearanceEntry appearance = appearanceDict.getNormalAppearance();\n        // TODO support appearances other than \"normal\"\n        PDAppearanceStream appearanceStream;\n        if (isValidAppearanceStream(appearance)) {\n            appearanceStream = appearance.getAppearanceStream();\n        } else {\n            appearanceStream = prepareNormalAppearanceStream(widget);\n            appearanceDict.setNormalAppearance(appearanceStream);\n            // TODO support appearances other than \"normal\"\n        }\n        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();\n        /* Adobe Acrobat always recreates the complete appearance stream if there is an appearance characteristics\n        entry (the widget dictionaries MK entry). In addition if there is no content yet also create the appearance\n        stream from the entries.\n         */\n        if ((appearanceCharacteristics != null) || (appearanceStream.getContentStream().getLength() == 0)) {\n            initializeAppearanceContent(widget, appearanceCharacteristics, appearanceStream);\n        }\n        setAppearanceContent(widget, appearanceStream);\n        // restore the field level appearance\n        defaultAppearance = acroFormAppearance;\n    }\n}", "/**\n * Constructs and sets new contents for given appearance stream.\n */\nprivate void setAppearanceContent(PDAnnotationWidget widget, PDAppearanceStream appearanceStream) throws IOException {\n    // first copy any needed resources from the documentâs DR dictionary into\n    // the streamâs Resources dictionary\n    defaultAppearance.copyNeededResourcesTo(appearanceStream);\n    // then replace the existing contents of the appearance stream from /Tx BMC\n    // to the matching EMC\n    try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n        ContentStreamWriter writer = new ContentStreamWriter(output);\n        List<Object> tokens = new PDFStreamParser(appearanceStream).parse();\n        int bmcIndex = tokens.indexOf(BMC);\n        if (bmcIndex == (-1)) {\n            // append to existing stream\n            writer.writeTokens(tokens);\n            writer.writeTokens(COSName.TX, BMC);\n        } else {\n            // prepend content before BMC\n            writer.writeTokens(tokens.subList(0, bmcIndex + 1));\n        }\n        // insert field contents\n        insertGeneratedAppearance(widget, appearanceStream, output);\n        int emcIndex = tokens.indexOf(EMC);\n        if (emcIndex == (-1)) {\n            // append EMC\n            writer.writeTokens(EMC);\n        } else {\n            // append contents after EMC\n            writer.writeTokens(tokens.subList(emcIndex, tokens.size()));\n        }\n        writeToStream(output.toByteArray(), appearanceStream);\n    }\n}", "/**\n * Generate and insert text content and clipping around it.\n */\nprivate void insertGeneratedAppearance(PDAnnotationWidget widget, PDAppearanceStream appearanceStream, OutputStream output) throws IOException {\n    try (PDAppearanceContentStream contents = new PDAppearanceContentStream(appearanceStream, output)) {\n        PDRectangle bbox = resolveBoundingBox(widget, appearanceStream);\n        // Acrobat calculates the left and right padding dependent on the offset of the border edge\n        // This calculation works for forms having been generated by Acrobat.\n        // The minimum distance is always 1f even if there is no rectangle being drawn around.\n        float borderWidth = 0;\n        if (widget.getBorderStyle() != null) {\n            borderWidth = widget.getBorderStyle().getWidth();\n        }\n        float padding = Math.max(1.0F, borderWidth);\n        PDRectangle clipRect = applyPadding(bbox, padding);\n        float clipRectLowerLeftY = clipRect.getLowerLeftY();\n        float clipRectHeight = clipRect.getHeight();\n        PDRectangle contentRect = applyPadding(clipRect, padding);\n        contents.saveGraphicsState();\n        // Acrobat always adds a clipping path\n        contents.addRect(clipRect.getLowerLeftX(), clipRectLowerLeftY, clipRect.getWidth(), clipRectHeight);\n        contents.clip();\n        // get the font\n        PDFont font = defaultAppearance.getFont();\n        if (font == null) {\n            throw new IllegalArgumentException(\"font is null, check whether /DA entry is incomplete or incorrect\");\n        }\n        if (font.getName().contains(\"+\")) {\n            LOG.warn((((((\"Font '\" + defaultAppearance.getFontName().getName()) + \"' of field '\") + field.getFullyQualifiedName()) + \"' contains subsetted font '\") + font.getName()) + \"'\");\n            LOG.warn(\"This may bring trouble with PDField.setValue(), PDAcroForm.flatten() or \" + \"PDAcroForm.refreshAppearances()\");\n            LOG.warn(\"You should replace this font with a non-subsetted font:\");\n            LOG.warn(\"PDFont font = PDType0Font.load(doc, new FileInputStream(fontfile), false);\");\n            LOG.warn((\"acroForm.getDefaultResources().put(COSName.getPDFName(\\\"\" + defaultAppearance.getFontName().getName()) + \"\\\", font);\");\n        }\n        // calculate the fontSize (because 0 = autosize)\n        float fontSize = defaultAppearance.getFontSize();\n        if (Float.compare(fontSize, 0) == 0) {\n            fontSize = calculateFontSize(font, contentRect);\n        }\n        // for a listbox generate the highlight rectangle for the selected\n        // options\n        if (field instanceof PDListBox) {\n            insertGeneratedListboxSelectionHighlight(contents, appearanceStream, font, fontSize);\n        }\n        // start the text output\n        contents.beginText();\n        // write font and color from the /DA string, with the calculated font size\n        defaultAppearance.writeTo(contents, fontSize);\n        // calculate the y-position of the baseline\n        float y;\n        // calculate font metrics at font size\n        float fontScaleY = fontSize / FONTSCALE;\n        float fontBoundingBoxAtSize = font.getBoundingBox().getHeight() * fontScaleY;\n        float fontCapAtSize;\n        float fontDescentAtSize;\n        if (font.getFontDescriptor() != null) {\n            fontCapAtSize = font.getFontDescriptor().getCapHeight() * fontScaleY;\n            fontDescentAtSize = font.getFontDescriptor().getDescent() * fontScaleY;\n        } else {\n            float fontCapHeight = resolveCapHeight(font);\n            float fontDescent = resolveDescent(font);\n            LOG.debug(((\"missing font descriptor - resolved Cap/Descent to \" + fontCapHeight) + \"/\") + fontDescent);\n            fontCapAtSize = fontCapHeight * fontScaleY;\n            fontDescentAtSize = fontDescent * fontScaleY;\n        }\n        if ((field instanceof PDTextField) && ((PDTextField) (field)).isMultiline()) {\n            y = contentRect.getUpperRightY() - fontBoundingBoxAtSize;\n        } else // Adobe shows the text 'shifted up' in case the caps don't fit into the clipping area\n        if (fontCapAtSize > clipRectHeight) {\n            y = clipRectLowerLeftY + (-fontDescentAtSize);\n        } else {\n            // calculate the position based on the content rectangle\n            y = clipRectLowerLeftY + ((clipRectHeight - fontCapAtSize) / 2);\n            // check to ensure that ascents and descents fit\n            if ((y - clipRectLowerLeftY) < (-fontDescentAtSize)) {\n                float contentRectLowerLeftY = contentRect.getLowerLeftY();\n                float fontDescentBased = (-fontDescentAtSize) + contentRectLowerLeftY;\n                float fontCapBased = (contentRect.getHeight() - contentRectLowerLeftY) - fontCapAtSize;\n                y = Math.min(fontDescentBased, Math.max(y, fontCapBased));\n            }\n        }\n        // show the text\n        float x = contentRect.getLowerLeftX();\n        // special handling for comb boxes as these are like table cells with individual\n        // chars\n        if (shallComb()) {\n            insertGeneratedCombAppearance(contents, appearanceStream, font, fontSize);\n        } else if (field instanceof PDListBox) {\n            insertGeneratedListboxAppearance(contents, appearanceStream, contentRect, font, fontSize);\n        } else {\n            PlainText textContent = new PlainText(value);\n            AppearanceStyle appearanceStyle = new AppearanceStyle();\n            appearanceStyle.setFont(font);\n            appearanceStyle.setFontSize(fontSize);\n            // Adobe Acrobat uses the font's bounding box for the leading between the lines\n            appearanceStyle.setLeading(font.getBoundingBox().getHeight() * fontScaleY);\n            PlainTextFormatter formatter = new PlainTextFormatter.Builder(contents).style(appearanceStyle).text(textContent).width(contentRect.getWidth()).wrapLines(isMultiLine()).initialOffset(x, y).textAlign(getTextAlign(widget)).build();\n            formatter.format();\n        }\n        contents.endText();\n        contents.restoreGraphicsState();\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFParser.parse", "org.apache.pdfbox.pdfparser.COSParser.parsePDFHeader", "org.apache.pdfbox.pdfparser.COSParser.parseHeader" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the PDDocument object. This will close the keystore stream when it is\n * done parsing.\n *\n * @param lenient\n * \t\tactivate leniency if set to true\n * @return the populated PDDocument\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic PDDocument parse(boolean lenient) throws IOException {\n    setLenient(lenient);\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        // PDFBOX-1922 read the version header and rewind\n        if ((!parsePDFHeader()) && (!parseFDFHeader())) {\n            if (lenient) {\n                LOG.warn(\"Error: Header doesn't contain versioninfo\");\n            } else {\n                throw new IOException(\"Error: Header doesn't contain versioninfo\");\n            }\n        }\n        if (!initialParseDone) {\n            initialParse();\n        }\n        exceptionOccurred = false;\n        PDDocument pdDocument = createDocument();\n        pdDocument.setEncryptionDictionary(getEncryption());\n        return pdDocument;\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * Parse the header of a pdf.\n *\n * @return true if a PDF header was found\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected boolean parsePDFHeader() throws IOException {\n    return parseHeader(PDF_HEADER, PDF_DEFAULT_VERSION);\n}", "private boolean parseHeader(String headerMarker, String defaultVersion) throws IOException {\n    // read first line\n    String header = readLine();\n    // some pdf-documents are broken and the pdf-version is in one of the following lines\n    if (!header.contains(headerMarker)) {\n        header = readLine();\n        while (!header.contains(headerMarker)) {\n            // if a line starts with a digit, it has to be the first one with data in it\n            if ((header.length() > 0) && Character.isDigit(header.charAt(0))) {\n                break;\n            }\n            header = readLine();\n        } \n    }\n    // nothing found\n    if (!header.contains(headerMarker)) {\n        source.seek(0);\n        return false;\n    }\n    // sometimes there is some garbage in the header before the header\n    // actually starts, so lets try to find the header first.\n    int headerStart = header.indexOf(headerMarker);\n    // greater than zero because if it is zero then there is no point of trimming\n    if (headerStart > 0) {\n        // trim off any leading characters\n        header = header.substring(headerStart);\n    }\n    // This is used if there is garbage after the header on the same line\n    if (header.startsWith(headerMarker) && (!header.matches(headerMarker + \"\\\\d.\\\\d\"))) {\n        if (header.length() < (headerMarker.length() + 3)) {\n            // No version number at all, set to 1.4 as default\n            header = headerMarker + defaultVersion;\n            LOG.debug((\"No version found, set to \" + defaultVersion) + \" as default.\");\n        } else {\n            String headerGarbage = header.substring(headerMarker.length() + 3) + \"\\n\";\n            header = header.substring(0, headerMarker.length() + 3);\n            source.rewind(headerGarbage.getBytes(StandardCharsets.ISO_8859_1).length);\n        }\n    }\n    float headerVersion = -1;\n    try {\n        String[] headerParts = header.split(\"-\");\n        if (headerParts.length == 2) {\n            headerVersion = Float.parseFloat(headerParts[1]);\n        }\n    } catch (NumberFormatException exception) {\n        LOG.debug(\"Can't parse the header version.\", exception);\n    }\n    if (headerVersion < 0) {\n        if (isLenient) {\n            headerVersion = 1.7F;\n        } else {\n            throw new IOException(\"Error getting header version: \" + header);\n        }\n    }\n    document.setVersion(headerVersion);\n    // rewind\n    source.seek(0);\n    return true;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolylineAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolylineAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationPolyline annotation = ((PDAnnotationPolyline) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getVertices();\n    if ((pathsArray == null) || (pathsArray.length < 4)) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if (((color == null) || (color.getComponents().length == 0)) || (Float.compare(ab.width, 0) == 0)) {\n        return;\n    }\n    // Adjust rectangle even if not empty\n    // CTAN-example-Annotations.pdf and pdf_commenting_new.pdf p11\n    // TODO in a class structure this should be overridable\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    // arrow length is 9 * width at about 30Â° => 10 * width seems to be enough\n    rect.setLowerLeftX(Math.min(minX - (ab.width * 10), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width * 10), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width * 10), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width * 10), rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        setOpacity(cs, annotation.getConstantOpacity());\n        boolean hasStroke = cs.setStrokingColorOnDemand(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        for (int i = 0; i < (pathsArray.length / 2); ++i) {\n            float x = pathsArray[i * 2];\n            float y = pathsArray[(i * 2) + 1];\n            if (i == 0) {\n                if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                    // modify coordinate to shorten the segment\n                    // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n                    float x1 = pathsArray[2];\n                    float y1 = pathsArray[3];\n                    float len = ((float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2))));\n                    if (Float.compare(len, 0) != 0) {\n                        x += ((x1 - x) / len) * ab.width;\n                        y += ((y1 - y) / len) * ab.width;\n                    }\n                }\n                cs.moveTo(x, y);\n            } else {\n                if ((i == ((pathsArray.length / 2) - 1)) && SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                    // modify coordinate to shorten the segment\n                    // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n                    float x0 = pathsArray[pathsArray.length - 4];\n                    float y0 = pathsArray[pathsArray.length - 3];\n                    float len = ((float) (Math.sqrt(Math.pow(x0 - x, 2) + Math.pow(y0 - y, 2))));\n                    if (Float.compare(len, 0) != 0) {\n                        x -= ((x - x0) / len) * ab.width;\n                        y -= ((y - y0) / len) * ab.width;\n                    }\n                }\n                cs.lineTo(x, y);\n            }\n        }\n        cs.stroke();\n        // do a transform so that first and last \"arms\" are imagined flat, like in line handler\n        // the alternative would be to apply the transform to the LE shapes directly,\n        // which would be more work and produce code difficult to understand\n        // paint the styles here and after polyline draw, to avoid line crossing a filled shape\n        if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {\n            // check only needed to avoid q cm Q if LE_NONE\n            float x2 = pathsArray[2];\n            float y2 = pathsArray[3];\n            float x1 = pathsArray[0];\n            float y1 = pathsArray[1];\n            cs.saveGraphicsState();\n            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                double angle = Math.atan2(y2 - y1, x2 - x1);\n                cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n            } else {\n                cs.transform(Matrix.getTranslateInstance(x1, y1));\n            }\n            drawStyle(annotation.getStartPointEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, false);\n            cs.restoreGraphicsState();\n        }\n        if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {\n            // check only needed to avoid q cm Q if LE_NONE\n            float x1 = pathsArray[pathsArray.length - 4];\n            float y1 = pathsArray[pathsArray.length - 3];\n            float x2 = pathsArray[pathsArray.length - 2];\n            float y2 = pathsArray[pathsArray.length - 1];\n            // save / restore not needed because it's the last one\n            if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                double angle = Math.atan2(y2 - y1, x2 - x1);\n                cs.transform(Matrix.getRotateInstance(angle, x2, y2));\n            } else {\n                cs.transform(Matrix.getTranslateInstance(x2, y2));\n            }\n            drawStyle(annotation.getEndPointEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, true);\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.iterator",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.iterator", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.<init>", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.<init>", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.enqueueKids" ],
    "fullMethods" : [ "/**\n * Returns an iterator which walks all pages in the tree, in order.\n */\n@Override\npublic Iterator<PDPage> iterator() {\n    return new PageIterator(root);\n}", "private PageIterator(COSDictionary node) {\n    enqueueKids(node);\n    set = null;// release memory, we don't use this anymore\n\n}", "private PageIterator(COSDictionary node) {\n    enqueueKids(node);\n    set = null;// release memory, we don't use this anymore\n\n}", "private void enqueueKids(COSDictionary node) {\n    if (isPageTreeNode(node)) {\n        List<COSDictionary> kids = getKids(node);\n        for (COSDictionary kid : kids) {\n            if (set.contains(kid)) {\n                // PDFBOX-5009, PDFBOX-3953: prevent stack overflow with malformed PDFs\n                LOG.error(\"This page tree node has already been visited\");\n                continue;\n            } else if (kid.containsKey(COSName.KIDS)) {\n                set.add(kid);\n            }\n            enqueueKids(kid);\n        }\n    } else if ((node != null) && COSName.PAGE.equals(node.getCOSName(COSName.TYPE))) {\n        queue.add(node);\n    } else {\n        LOG.error(\"Page skipped due to an invalid or missing type \" + (node == null ? \"(null)\" : node.getCOSName(COSName.TYPE)));\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolygonAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDPolygonAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationPolygon annotation = ((PDAnnotationPolygon) (getAnnotation()));\n    float lineWidth = getLineWidth();\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    // Adjust rectangle even if not empty\n    // CTAN-example-Annotations.pdf p2\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    float[][] pathArray = getPathArray(annotation);\n    if (pathArray == null) {\n        return;\n    }\n    for (int i = 0; i < pathArray.length; ++i) {\n        for (int j = 0; j < (pathArray[i].length / 2); ++j) {\n            float x = pathArray[i][j * 2];\n            float y = pathArray[i][(j * 2) + 1];\n            minX = Math.min(minX, x);\n            minY = Math.min(minY, y);\n            maxX = Math.max(maxX, x);\n            maxY = Math.max(maxY, y);\n        }\n    }\n    rect.setLowerLeftX(Math.min(minX - lineWidth, rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - lineWidth, rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + lineWidth, rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + lineWidth, rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());\n        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());\n            cloudyBorder.createCloudyPolygon(pathArray);\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            // Acrobat applies a padding to each side of the bbox so the line is\n            // completely within the bbox.\n            for (int i = 0; i < pathArray.length; i++) {\n                float[] pointsArray = pathArray[i];\n                // first array shall be of size 2 and specify the moveto operator\n                if ((i == 0) && (pointsArray.length == 2)) {\n                    contentStream.moveTo(pointsArray[0], pointsArray[1]);\n                } else // entries of length 2 shall be treated as lineto operator\n                if (pointsArray.length == 2) {\n                    contentStream.lineTo(pointsArray[0], pointsArray[1]);\n                } else if (pointsArray.length == 6) {\n                    contentStream.curveTo(pointsArray[0], pointsArray[1], pointsArray[2], pointsArray[3], pointsArray[4], pointsArray[5]);\n                }\n            }\n            contentStream.closePath();\n        }\n        contentStream.drawShape(lineWidth, hasStroke, hasBackground);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PatchMeshesShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type7ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @throws IOException\n * \t\tif something went wrong\n */\nType7ShadingContext(PDShadingType7 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix, deviceBounds, 16);\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected PatchMeshesShadingContext(PDMeshBasedShadingType shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds, int controlPoints) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    patchList = shading.collectPatches(xform, matrix, controlPoints);\n    createPixelTable(deviceBounds);\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.FDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.FDFParser.parse", "org.apache.pdfbox.pdfparser.FDFParser.initialParse", "org.apache.pdfbox.pdfparser.COSParser.retrieveTrailer", "org.apache.pdfbox.pdfparser.COSParser.parseXref" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the FDFDocument object.\n *\n * @return the parsed FDFDocument\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic FDFDocument parse() throws IOException {\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        if (!parseFDFHeader()) {\n            throw new IOException(\"Error: Header doesn't contain versioninfo\");\n        }\n        initialParse();\n        exceptionOccurred = false;\n        return new FDFDocument(document, source);\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * The initial parse will first parse only the trailer, the xrefstart and all xref tables to have a pointer (offset)\n * to all the pdf's objects. It can handle linearized pdfs, which will have an xref at the end pointing to an xref\n * at the beginning of the file. Last the root object is parsed.\n *\n * @throws IOException\n * \t\tIf something went wrong.\n */\nprivate void initialParse() throws IOException {\n    COSDictionary trailer = retrieveTrailer();\n    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);\n    if (root == null) {\n        throw new IOException(\"Missing root object specification in trailer.\");\n    }\n    initialParseDone = true;\n}", "/**\n * Read the trailer information and provide a COSDictionary containing the trailer information.\n *\n * @return a COSDictionary containing the trailer information\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected COSDictionary retrieveTrailer() throws IOException {\n    COSDictionary trailer = null;\n    boolean rebuildTrailer = false;\n    try {\n        // parse startxref\n        // TODO FDF files don't have a startxref value, so that rebuildTrailer is triggered\n        long startXRefOffset = getStartxrefOffset();\n        if (startXRefOffset > (-1)) {\n            trailer = parseXref(startXRefOffset);\n        } else {\n            rebuildTrailer = isLenient();\n        }\n    } catch (IOException exception) {\n        if (isLenient()) {\n            rebuildTrailer = true;\n        } else {\n            throw exception;\n        }\n    }\n    // check if the trailer contains a Root object\n    if ((trailer != null) && (trailer.getItem(COSName.ROOT) == null)) {\n        rebuildTrailer = isLenient();\n    }\n    if (rebuildTrailer) {\n        trailer = getBruteForceParser().rebuildTrailer(xrefTrailerResolver, null);\n        trailerWasRebuild = true;\n        // transfer encryption information from BruteForceParser\n        encryption = getBruteForceParser().getEncryption();\n        if (encryption != null) {\n            securityHandler = encryption.getSecurityHandler();\n            accessPermission = securityHandler.getCurrentAccessPermission();\n        }\n    } else {\n        // prepare decryption if necessary\n        prepareDecryption();\n        // don't use the getter as it creates an instance of BruteForceParser\n        if ((bruteForceParser != null) && bruteForceParser.bfSearchTriggered()) {\n            getBruteForceParser().bfSearchForObjStreams(xrefTrailerResolver, securityHandler);\n        }\n    }\n    if (resetTrailerResolver()) {\n        xrefTrailerResolver.reset();\n        xrefTrailerResolver = null;\n    }\n    return trailer;\n}", "/**\n * Parses cross reference tables.\n *\n * @param startXRefOffset\n * \t\tstart offset of the first table\n * @return the trailer dictionary\n * @throws IOException\n * \t\tif something went wrong\n */\nprivate COSDictionary parseXref(long startXRefOffset) throws IOException {\n    source.seek(startXRefOffset);\n    long startXrefOffset = Math.max(0, parseStartXref());\n    // check the startxref offset\n    long fixedOffset = checkXRefOffset(startXrefOffset);\n    if (fixedOffset > (-1)) {\n        startXrefOffset = fixedOffset;\n    }\n    document.setStartXref(startXrefOffset);\n    long prev = startXrefOffset;\n    // ---- parse whole chain of xref tables/object streams using PREV reference\n    Set<Long> prevSet = new HashSet<>();\n    COSDictionary trailer = null;\n    while (prev > 0) {\n        // save expected position for loop detection\n        prevSet.add(prev);\n        // seek to xref table\n        source.seek(prev);\n        // skip white spaces\n        skipSpaces();\n        // save current position as well due to skipped spaces\n        prevSet.add(source.getPosition());\n        // -- parse xref\n        if (source.peek() == X) {\n            // xref table and trailer\n            // use existing parser to parse xref table\n            if ((!parseXrefTable(prev)) || (!parseTrailer())) {\n                throw new IOException(\"Expected trailer object at offset \" + source.getPosition());\n            }\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n            // check for a XRef stream, it may contain some object ids of compressed objects\n            if (trailer.containsKey(COSName.XREF_STM)) {\n                int streamOffset = trailer.getInt(COSName.XREF_STM);\n                // check the xref stream reference\n                fixedOffset = checkXRefOffset(streamOffset);\n                if ((fixedOffset > (-1)) && (fixedOffset != streamOffset)) {\n                    LOG.warn(((\"/XRefStm offset \" + streamOffset) + \" is incorrect, corrected to \") + fixedOffset);\n                    streamOffset = ((int) (fixedOffset));\n                    trailer.setInt(COSName.XREF_STM, streamOffset);\n                }\n                if (streamOffset > 0) {\n                    source.seek(streamOffset);\n                    skipSpaces();\n                    try {\n                        parseXrefObjStream(prev, false);\n                        document.setHasHybridXRef();\n                    } catch (IOException ex) {\n                        if (isLenient) {\n                            LOG.error(\"Failed to parse /XRefStm at offset \" + streamOffset, ex);\n                        } else {\n                            throw ex;\n                        }\n                    }\n                } else if (isLenient) {\n                    LOG.error(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                } else {\n                    throw new IOException(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                }\n            }\n            prev = trailer.getLong(COSName.PREV);\n        } else {\n            // parse xref stream\n            prev = parseXrefObjStream(prev, true);\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n        }\n        if (prev > 0) {\n            // check the xref table reference\n            fixedOffset = checkXRefOffset(prev);\n            if ((fixedOffset > (-1)) && (fixedOffset != prev)) {\n                prev = fixedOffset;\n                trailer.setLong(COSName.PREV, prev);\n            }\n        }\n        if (prevSet.contains(prev)) {\n            throw new IOException(\"/Prev loop at offset \" + prev);\n        }\n    } \n    // ---- build valid xrefs out of the xref chain\n    xrefTrailerResolver.setStartxref(startXrefOffset);\n    trailer = xrefTrailerResolver.getTrailer();\n    document.setTrailer(trailer);\n    document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());\n    // check the offsets of all referenced objects\n    if (isLenient) {\n        checkXrefOffsets();\n    }\n    // copy xref table\n    document.addXRefTable(xrefTrailerResolver.getXrefTable());\n    // remember the highest XRef object number to avoid it being reused in incremental saving\n    Optional<Long> maxValue = // \n    // \n    document.getXrefTable().keySet().stream().map(COSObjectKey::getNumber).reduce(Long::max);\n    document.setHighestXRefObjectNumber(maxValue.isPresent() ? maxValue.get() : 0);\n    return trailer;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.decreaseLevel",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.decreaseLevel" ],
    "fullMethods" : [ "/**\n * Decrease the level. Call this after running a potentially recursive operation. A log message\n * is shown if the level is below 0. This can happen if the level is not decreased after an\n * operation is done, e.g. by using a \"finally\" block.\n */\npublic void decreaseLevel() {\n    --level;\n    if (level < 0) {\n        LOG.error(\"level is \" + level);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationStamp(COSDictionary a) {\n    super(a);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    return getBounds(xform, matrix, 12);\n}", "Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    Rectangle2D bounds = null;\n    for (Patch patch : collectPatches(xform, matrix, controlPoints)) {\n        for (ShadedTriangle shadedTriangle : patch.listOfTriangles) {\n            if (bounds == null) {\n                bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n            }\n            bounds.add(shadedTriangle.corner[0]);\n            bounds.add(shadedTriangle.corner[1]);\n            bounds.add(shadedTriangle.corner[2]);\n        }\n    }\n    return bounds;\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream" ],
    "fullMethods" : [ "/**\n * This will decrypt a stream.\n *\n * @param stream\n * \t\tThe stream to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void decryptStream(COSStream stream, long objNum, long genNum) throws IOException {\n    // Stream encrypted with identity filter\n    if (COSName.IDENTITY.equals(streamFilterName)) {\n        return;\n    }\n    COSBase type = stream.getCOSName(COSName.TYPE);\n    if ((!decryptMetadata) && COSName.METADATA.equals(type)) {\n        return;\n    }\n    // \"The cross-reference stream shall not be encrypted\"\n    if (COSName.XREF.equals(type)) {\n        return;\n    }\n    if (COSName.METADATA.equals(type)) {\n        byte[] buf;\n        // PDFBOX-3229 check case where metadata is not encrypted despite /EncryptMetadata missing\n        try (InputStream is = stream.createRawInputStream()) {\n            buf = new byte[10];\n            long isResult = IOUtils.populateBuffer(is, buf);\n            if (Long.compare(isResult, buf.length) != 0) {\n                LOG.debug((((\"Tried reading \" + buf.length) + \" bytes but only \") + isResult) + \" bytes read\");\n            }\n        }\n        if (Arrays.equals(buf, \"<?xpacket \".getBytes(StandardCharsets.ISO_8859_1))) {\n            LOG.warn(\"Metadata is not encrypted, but was expected to be\");\n            LOG.warn(\"Read PDF specification about EncryptMetadata (default value: true)\");\n            return;\n        }\n    }\n    decryptDictionary(stream, objNum, genNum);\n    // the input and the output stream of a still encrypted COSStream aren't no longer based\n    // on the same object so that it is safe to omit the intermediate ByteArrayStream\n    // \n    try (InputStream encryptedStream = stream.createRawInputStream();OutputStream output = stream.createRawOutputStream()) {\n        /* decrypt */\n        encryptData(objNum, genNum, encryptedStream, output, true);\n    } catch (IOException ex) {\n        LOG.error(((((ex.getClass().getSimpleName() + \" thrown when decrypting object \") + objNum) + \" \") + genNum) + \" obj\");\n        throw ex;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument" ],
    "fullMethods" : [ "/**\n * append all pages from source to destination.\n *\n * @param destination\n * \t\tthe document to receive the pages\n * @param source\n * \t\tthe document originating the new pages\n * @throws IOException\n * \t\tIf there is an error accessing data from either\n * \t\tdocument.\n */\npublic void appendDocument(PDDocument destination, PDDocument source) throws IOException {\n    PDFCloneUtility cloner = new PDFCloneUtility(destination);\n    if (source.getDocument().isClosed()) {\n        throw new IOException(\"Error: source PDF is closed.\");\n    }\n    if (destination.getDocument().isClosed()) {\n        throw new IOException(\"Error: destination PDF is closed.\");\n    }\n    PDDocumentCatalog srcCatalog = source.getDocumentCatalog();\n    if (isDynamicXfa(srcCatalog.getAcroForm())) {\n        throw new IOException(\"Error: can't merge source document containing dynamic XFA form content.\");\n    }\n    PDDocumentInformation destInfo = destination.getDocumentInformation();\n    PDDocumentInformation srcInfo = source.getDocumentInformation();\n    mergeInto(srcInfo.getCOSObject(), destInfo.getCOSObject(), cloner, Collections.emptySet());\n    // use the highest version number for the resulting pdf\n    float destVersion = destination.getVersion();\n    float srcVersion = source.getVersion();\n    if (destVersion < srcVersion) {\n        destination.setVersion(srcVersion);\n    }\n    PDDocumentCatalog destCatalog = destination.getDocumentCatalog();\n    mergeAcroForm(cloner, destCatalog, srcCatalog);\n    COSArray destThreads = destCatalog.getCOSObject().getCOSArray(COSName.THREADS);\n    COSArray srcThreads = cloner.cloneForNewDocument(destCatalog.getCOSObject().getCOSArray(COSName.THREADS));\n    if (destThreads == null) {\n        destCatalog.getCOSObject().setItem(COSName.THREADS, srcThreads);\n    } else {\n        destThreads.addAll(srcThreads);\n    }\n    PDDocumentNameDictionary destNames = destCatalog.getNames();\n    PDDocumentNameDictionary srcNames = srcCatalog.getNames();\n    if (srcNames != null) {\n        if (destNames == null) {\n            destCatalog.getCOSObject().setItem(COSName.NAMES, cloner.cloneForNewDocument(srcNames.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcNames, destNames);\n        }\n    }\n    if ((destNames != null) && destNames.getCOSObject().containsKey(COSName.ID_TREE)) {\n        // found in 001031.pdf from PDFBOX-4417 and doesn't belong there\n        destNames.getCOSObject().removeItem(COSName.ID_TREE);\n        LOG.warn(\"Removed /IDTree from /Names dictionary, doesn't belong there\");\n    }\n    PDDocumentNameDestinationDictionary srcDests = srcCatalog.getDests();\n    if (srcDests != null) {\n        PDDocumentNameDestinationDictionary destDests = destCatalog.getDests();\n        if (destDests == null) {\n            destCatalog.getCOSObject().setItem(COSName.DESTS, cloner.cloneForNewDocument(srcDests.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcDests, destDests);\n        }\n    }\n    PDDocumentOutline srcOutline = srcCatalog.getDocumentOutline();\n    if (srcOutline != null) {\n        PDDocumentOutline destOutline = destCatalog.getDocumentOutline();\n        if ((destOutline == null) || (destOutline.getFirstChild() == null)) {\n            PDDocumentOutline cloned = new PDDocumentOutline(cloner.cloneForNewDocument(srcOutline.getCOSObject()));\n            destCatalog.setDocumentOutline(cloned);\n        } else {\n            // search last sibling for dest, because /Last entry is sometimes wrong\n            PDOutlineItem destLastOutlineItem = destOutline.getFirstChild();\n            while (true) {\n                PDOutlineItem outlineItem = destLastOutlineItem.getNextSibling();\n                if (outlineItem == null) {\n                    break;\n                }\n                destLastOutlineItem = outlineItem;\n            } \n            for (PDOutlineItem item : srcOutline.children()) {\n                // get each child, clone its dictionary, remove siblings info,\n                // append outline item created from there\n                COSDictionary clonedDict = cloner.cloneForNewDocument(item.getCOSObject());\n                clonedDict.removeItem(COSName.PREV);\n                clonedDict.removeItem(COSName.NEXT);\n                PDOutlineItem clonedItem = new PDOutlineItem(clonedDict);\n                destLastOutlineItem.insertSiblingAfter(clonedItem);\n                destLastOutlineItem = destLastOutlineItem.getNextSibling();\n            }\n        }\n    }\n    PageMode destPageMode = destCatalog.getPageMode();\n    if (destPageMode == null) {\n        PageMode srcPageMode = srcCatalog.getPageMode();\n        destCatalog.setPageMode(srcPageMode);\n    }\n    COSDictionary srcLabels = srcCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n    if (srcLabels != null) {\n        int destPageCount = destination.getNumberOfPages();\n        COSArray destNums;\n        COSDictionary destLabels = destCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n        if (destLabels == null) {\n            destLabels = new COSDictionary();\n            destNums = new COSArray();\n            destLabels.setItem(COSName.NUMS, destNums);\n            destCatalog.getCOSObject().setItem(COSName.PAGE_LABELS, destLabels);\n        } else {\n            destNums = destLabels.getCOSArray(COSName.NUMS);\n        }\n        COSArray srcNums = srcLabels.getCOSArray(COSName.NUMS);\n        if (srcNums != null) {\n            int startSize = destNums.size();\n            for (int i = 0; i < srcNums.size(); i += 2) {\n                COSBase base = srcNums.getObject(i);\n                if (!(base instanceof COSNumber)) {\n                    LOG.error(((\"page labels ignored, index \" + i) + \" should be a number, but is \") + base);\n                    // remove what we added\n                    while (destNums.size() > startSize) {\n                        destNums.remove(startSize);\n                    } \n                    break;\n                }\n                COSNumber labelIndex = ((COSNumber) (base));\n                long labelIndexValue = labelIndex.intValue();\n                destNums.add(COSInteger.get(labelIndexValue + destPageCount));\n                destNums.add(cloner.cloneForNewDocument(srcNums.getObject(i + 1)));\n            }\n        }\n    }\n    COSStream destMetadata = destCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    COSStream srcMetadata = srcCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    if ((destMetadata == null) && (srcMetadata != null)) {\n        try {\n            PDStream newStream = new PDStream(destination, srcMetadata.createInputStream(), ((COSName) (null)));\n            mergeInto(srcMetadata, newStream.getCOSObject(), cloner, new HashSet<>(Arrays.asList(COSName.FILTER, COSName.LENGTH)));\n            destCatalog.getCOSObject().setItem(COSName.METADATA, newStream);\n        } catch (IOException ex) {\n            // PDFBOX-4227 cleartext XMP stream with /Flate\n            LOG.error(\"Metadata skipped because it could not be read\", ex);\n        }\n    }\n    COSDictionary destOCP = destCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    COSDictionary srcOCP = srcCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    if ((destOCP == null) && (srcOCP != null)) {\n        destCatalog.getCOSObject().setItem(COSName.OCPROPERTIES, cloner.cloneForNewDocument(srcOCP));\n    } else if ((destOCP != null) && (srcOCP != null)) {\n        cloner.cloneMerge(srcOCP, destOCP);\n    }\n    mergeOutputIntents(srcCatalog, destCatalog, cloner);\n    // merge logical structure hierarchy\n    boolean mergeStructTree = false;\n    int destParentTreeNextKey = -1;\n    Map<Integer, COSObjectable> srcNumberTreeAsMap = null;\n    Map<Integer, COSObjectable> destNumberTreeAsMap = null;\n    PDStructureTreeRoot srcStructTree = srcCatalog.getStructureTreeRoot();\n    PDStructureTreeRoot destStructTree = destCatalog.getStructureTreeRoot();\n    if ((destStructTree == null) && (srcStructTree != null)) {\n        // create a dummy structure tree in the destination, so that the source\n        // tree is cloned. (We can't just copy the tree reference due to PDFBOX-3999)\n        destStructTree = new PDStructureTreeRoot();\n        destCatalog.setStructureTreeRoot(destStructTree);\n        destStructTree.setParentTree(new PDNumberTreeNode(PDParentTreeValue.class));\n        // PDFBOX-4429: remove bogus StructParent(s)\n        for (PDPage page : destCatalog.getPages()) {\n            page.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : page.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n    }\n    if (destStructTree != null) {\n        PDNumberTreeNode destParentTree = destStructTree.getParentTree();\n        destParentTreeNextKey = destStructTree.getParentTreeNextKey();\n        if (destParentTree != null) {\n            destNumberTreeAsMap = getNumberTreeAsMap(destParentTree);\n            if (destParentTreeNextKey < 0) {\n                if (destNumberTreeAsMap.isEmpty()) {\n                    destParentTreeNextKey = 0;\n                } else {\n                    destParentTreeNextKey = Collections.max(destNumberTreeAsMap.keySet()) + 1;\n                }\n            }\n            if ((destParentTreeNextKey >= 0) && (srcStructTree != null)) {\n                PDNumberTreeNode srcParentTree = srcStructTree.getParentTree();\n                if (srcParentTree != null) {\n                    srcNumberTreeAsMap = getNumberTreeAsMap(srcParentTree);\n                    if (!srcNumberTreeAsMap.isEmpty()) {\n                        mergeStructTree = true;\n                    }\n                }\n            }\n        }\n    }\n    Map<COSDictionary, COSDictionary> objMapping = new HashMap<>();\n    PDPageTree destinationPageTree = destination.getPages();// cache PageTree\n\n    for (PDPage page : srcCatalog.getPages()) {\n        PDPage newPage = new PDPage(cloner.cloneForNewDocument(page.getCOSObject()));\n        if (!mergeStructTree) {\n            // PDFBOX-4429: remove bogus StructParent(s)\n            newPage.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : newPage.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n        newPage.setCropBox(page.getCropBox());\n        newPage.setMediaBox(page.getMediaBox());\n        newPage.setRotation(page.getRotation());\n        PDResources resources = page.getResources();\n        if (resources != null) {\n            // this is smart enough to just create references for resources that are used on multiple pages\n            newPage.setResources(new PDResources(cloner.cloneForNewDocument(resources.getCOSObject())));\n        } else {\n            newPage.setResources(new PDResources());\n        }\n        if (mergeStructTree) {\n            // add the value of the destination ParentTreeNextKey to every source element\n            // StructParent(s) value so that these don't overlap with the existing values\n            updateStructParentEntries(newPage, destParentTreeNextKey);\n            objMapping.put(page.getCOSObject(), newPage.getCOSObject());\n            List<PDAnnotation> oldAnnots = page.getAnnotations();\n            List<PDAnnotation> newAnnots = newPage.getAnnotations();\n            for (int i = 0; i < oldAnnots.size(); i++) {\n                objMapping.put(oldAnnots.get(i).getCOSObject(), newAnnots.get(i).getCOSObject());\n            }\n            // TODO update mapping for XObjects\n        }\n        destinationPageTree.add(newPage);\n    }\n    mergeOpenAction(srcCatalog, destCatalog, cloner);\n    if (mergeStructTree) {\n        updatePageReferences(cloner, srcNumberTreeAsMap, objMapping);\n        int maxSrcKey = -1;\n        for (Map.Entry<Integer, COSObjectable> entry : srcNumberTreeAsMap.entrySet()) {\n            int srcKey = entry.getKey();\n            maxSrcKey = Math.max(srcKey, maxSrcKey);\n            COSObjectable value = entry.getValue();\n            if (value != null) {\n                value = cloner.cloneForNewDocument(value.getCOSObject());\n                destNumberTreeAsMap.put(destParentTreeNextKey + srcKey, value);\n            }\n        }\n        destParentTreeNextKey += maxSrcKey + 1;\n        PDNumberTreeNode newParentTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);\n        // Note that all elements are stored flatly. This could become a problem for large files\n        // when these are opened in a viewer that uses the tagging information.\n        // If this happens, then PDNumberTreeNode should be improved with a convenience method that\n        // stores the map into a B+Tree, see https://en.wikipedia.org/wiki/B+_tree\n        newParentTreeNode.setNumbers(destNumberTreeAsMap);\n        destStructTree.setParentTree(newParentTreeNode);\n        destStructTree.setParentTreeNextKey(destParentTreeNextKey);\n        mergeKEntries(cloner, srcStructTree, destStructTree);\n        mergeRoleMap(srcStructTree, destStructTree, cloner);\n        mergeIDTree(cloner, srcStructTree, destStructTree);\n        mergeMarkInfo(destCatalog, srcCatalog);\n        mergeLanguage(destCatalog, srcCatalog);\n        mergeViewerPreferences(destCatalog, srcCatalog, cloner);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getDecodeArray" ],
    "fullMethods" : [ "/**\n * Returns the content of the given image as an AWT buffered image with an RGB color space.\n * If a color key mask is provided then an ARGB image is returned instead.\n * This method never returns null.\n *\n * @param pdImage\n * \t\tthe image to read\n * @param region\n * \t\tThe region of the source image to get, or null if the entire image is needed.\n * \t\tThe actual region will be clipped to the dimensions of the source image.\n * @param subsampling\n * \t\tThe amount of rows and columns to advance for every output pixel, a value\n * \t\tof 1 meaning every pixel will be read. It must not be larger than the image width or height.\n * @param colorKey\n * \t\tan optional color key mask\n * @return content of this image as an (A)RGB buffered image\n * @throws IOException\n * \t\tif the image cannot be read\n */\npublic static BufferedImage getRGBImage(PDImage pdImage, Rectangle region, int subsampling, COSArray colorKey) throws IOException {\n    if (pdImage.isEmpty()) {\n        throw new IOException(\"Image stream is empty\");\n    }\n    Rectangle clipped = clipRegion(pdImage, region);\n    // get parameters, they must be valid or have been repaired\n    final PDColorSpace colorSpace = pdImage.getColorSpace();\n    final int numComponents = colorSpace.getNumberOfComponents();\n    final int width = ((int) (Math.ceil(clipped.getWidth() / subsampling)));\n    final int height = ((int) (Math.ceil(clipped.getHeight() / subsampling)));\n    final int bitsPerComponent = pdImage.getBitsPerComponent();\n    if ((((width <= 0) || (height <= 0)) || (pdImage.getWidth() <= 0)) || (pdImage.getHeight() <= 0)) {\n        throw new IOException(\"image width and height must be positive\");\n    }\n    try {\n        if (((bitsPerComponent == 1) && (colorKey == null)) && (numComponents == 1)) {\n            return from1Bit(pdImage, clipped, subsampling, width, height);\n        }\n        // An AWT raster must use 8/16/32 bits per component. Images with < 8bpc\n        // will be unpacked into a byte-backed raster. Images with 16bpc will be reduced\n        // in depth to 8bpc as they will be drawn to TYPE_INT_RGB images anyway. All code\n        // in PDColorSpace#toRGBImage expects an 8-bit range, i.e. 0-255.\n        // Interleaved raster allows chunk-copying for 8-bit images.\n        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, width, height, numComponents, new Point(0, 0));\n        final float[] defaultDecode = pdImage.getColorSpace().getDefaultDecode(8);\n        final float[] decode = getDecodeArray(pdImage);\n        if (((bitsPerComponent == 8) && (colorKey == null)) && Arrays.equals(decode, defaultDecode)) {\n            // convert image, faster path for non-decoded, non-colormasked 8-bit images\n            return from8bit(pdImage, raster, clipped, subsampling, width, height);\n        }\n        return fromAny(pdImage, raster, colorKey, clipped, subsampling, width, height);\n    } catch (NegativeArraySizeException | IllegalArgumentException ex) {\n        throw new IOException(ex);\n    }\n}", "// gets decode array from dictionary or returns default\nprivate static float[] getDecodeArray(PDImage pdImage) throws IOException {\n    final COSArray cosDecode = pdImage.getDecode();\n    float[] decode = null;\n    if (cosDecode != null) {\n        int numberOfComponents = pdImage.getColorSpace().getNumberOfComponents();\n        if (cosDecode.size() != (numberOfComponents * 2)) {\n            if (((pdImage.isStencil() && (cosDecode.size() >= 2)) && (cosDecode.get(0) instanceof COSNumber)) && (cosDecode.get(1) instanceof COSNumber)) {\n                float decode0 = ((COSNumber) (cosDecode.get(0))).floatValue();\n                float decode1 = ((COSNumber) (cosDecode.get(1))).floatValue();\n                if ((((decode0 >= 0) && (decode0 <= 1)) && (decode1 >= 0)) && (decode1 <= 1)) {\n                    LOG.warn((\"decode array \" + cosDecode) + \" not compatible with color space, using the first two entries\");\n                    return new float[]{ decode0, decode1 };\n                }\n            }\n            LOG.error((\"decode array \" + cosDecode) + \" not compatible with color space, using default\");\n        } else {\n            decode = cosDecode.toFloatArray();\n        }\n    }\n    // use color space default\n    if (decode == null) {\n        return pdImage.getColorSpace().getDefaultDecode(pdImage.getBitsPerComponent());\n    }\n    return decode;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.DrawObject.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.DrawObject.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.isEmpty()) {\n        throw new MissingOperandException(operator, operands);\n    }\n    COSBase base0 = operands.get(0);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    COSName objectName = ((COSName) (base0));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    PDXObject xobject = context.getResources().getXObject(objectName);\n    if (xobject == null) {\n        throw new MissingResourceException(\"Missing XObject: \" + objectName.getName());\n    } else if (xobject instanceof PDImageXObject) {\n        PDImageXObject image = ((PDImageXObject) (xobject));\n        if ((!image.isStencil()) && (!context.isShouldProcessColorOperators())) {\n            return;\n        }\n        context.drawImage(image);\n    } else if (xobject instanceof PDFormXObject) {\n        try {\n            context.increaseLevel();\n            if (context.getLevel() > 50) {\n                LOG.error(\"recursion is too deep, skipping form XObject\");\n                return;\n            }\n            if (xobject instanceof PDTransparencyGroup) {\n                context.showTransparencyGroup(((PDTransparencyGroup) (xobject)));\n            } else {\n                context.showForm(((PDFormXObject) (xobject)));\n            }\n        } finally {\n            context.decreaseLevel();\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PatchMeshesShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type6ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @throws IOException\n * \t\tif something went wrong\n */\nType6ShadingContext(PDShadingType6 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix, deviceBounds, 12);\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected PatchMeshesShadingContext(PDMeshBasedShadingType shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds, int controlPoints) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    patchList = shading.collectPatches(xform, matrix, controlPoints);\n    createPixelTable(deviceBounds);\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.FlateFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.FlateFilter.decode", "org.apache.pdfbox.filter.Filter.getDecodeParams" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    final COSDictionary decodeParams = getDecodeParams(parameters, index);\n    try (FlateFilterDecoderStream decoderStream = new FlateFilterDecoderStream(encoded)) {\n        OutputStream wrapPredictor = Predictor.wrapPredictor(decoded, decodeParams);\n        IOUtils.copy(decoderStream, wrapPredictor);\n        wrapPredictor.flush();\n    }\n    return new DecodeResult(parameters);\n}", "// gets the decode params for a specific filter index, this is used to\n// normalise the DecodeParams entry so that it is always a dictionary\nprotected COSDictionary getDecodeParams(COSDictionary dictionary, int index) {\n    COSBase filter = dictionary.getDictionaryObject(COSName.F, COSName.FILTER);\n    COSBase obj = dictionary.getDictionaryObject(COSName.DP, COSName.DECODE_PARMS);\n    if ((filter instanceof COSName) && (obj instanceof COSDictionary)) {\n        // PDFBOX-3932: The PDF specification requires \"If there is only one filter and that\n        // filter has parameters, DecodeParms shall be set to the filterâs parameter dictionary\"\n        // but tests show that Adobe means \"one filter name object\".\n        return ((COSDictionary) (obj));\n    } else if ((filter instanceof COSArray) && (obj instanceof COSArray)) {\n        COSArray array = ((COSArray) (obj));\n        if (index < array.size()) {\n            COSBase objAtIndex = array.getObject(index);\n            if (objAtIndex instanceof COSDictionary) {\n                return ((COSDictionary) (objAtIndex));\n            }\n        }\n    } else if ((obj != null) && (!((filter instanceof COSArray) || (obj instanceof COSArray)))) {\n        LOG.error(\"Expected DecodeParams to be an Array or Dictionary but found \" + obj.getClass().getName());\n    }\n    return new COSDictionary();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDTextAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDTextAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationText annotation = ((PDAnnotationText) (getAnnotation()));\n    if (!SUPPORTED_NAMES.contains(annotation.getName())) {\n        return;\n    }\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        PDColor bgColor = getColor();\n        if (bgColor == null) {\n            // White is used by Adobe when /C entry is missing\n            contentStream.setNonStrokingColor(1.0F);\n        } else {\n            contentStream.setNonStrokingColor(bgColor);\n        }\n        // stroking color is always black which is the PDF default\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        switch (annotation.getName()) {\n            case PDAnnotationText.NAME_NOTE :\n                drawNote(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_CROSS :\n                drawZapf(annotation, contentStream, 19, 0, \"a22\");// 0x2716\n\n                break;\n            case PDAnnotationText.NAME_CIRCLE :\n                drawCircles(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_INSERT :\n                drawInsert(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_HELP :\n                drawHelp(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_PARAGRAPH :\n                drawParagraph(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_NEW_PARAGRAPH :\n                drawNewParagraph(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_STAR :\n                drawZapf(annotation, contentStream, 19, 0, \"a35\");// 0x2605\n\n                break;\n            case PDAnnotationText.NAME_CHECK :\n                drawZapf(annotation, contentStream, 19, 50, \"a20\");// 0x2714\n\n                break;\n            case PDAnnotationText.NAME_RIGHT_ARROW :\n                drawRightArrow(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_RIGHT_POINTER :\n                drawZapf(annotation, contentStream, 17, 50, \"a174\");// 0x27A4\n\n                break;\n            case PDAnnotationText.NAME_CROSS_HAIRS :\n                drawCrossHairs(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_UP_ARROW :\n                drawUpArrow(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_UP_LEFT_ARROW :\n                drawUpLeftArrow(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_COMMENT :\n                drawComment(annotation, contentStream);\n                break;\n            case PDAnnotationText.NAME_KEY :\n                drawKey(annotation, contentStream);\n                break;\n            default :\n                break;\n        }\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.shadingFill",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.shadingFill" ],
    "fullMethods" : [ "@Override\npublic void shadingFill(COSName shadingName) throws IOException {\n    if (!isContentRendered()) {\n        return;\n    }\n    PDShading shading = getResources().getShading(shadingName);\n    if (shading == null) {\n        LOG.error((\"shading \" + shadingName) + \" does not exist in resources dictionary\");\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    Shape savedClip = graphics.getClip();\n    graphics.setClip(null);\n    lastClips = null;\n    // get the transformed BBox and intersect with current clipping path\n    // need to do it here and not in shading getRaster() because it may have been rotated\n    PDRectangle bbox = shading.getBBox();\n    Area area;\n    if (bbox != null) {\n        area = new Area(bbox.transform(ctm));\n        area.intersect(getGraphicsState().getCurrentClippingPath());\n    } else {\n        Rectangle2D bounds = shading.getBounds(new AffineTransform(), ctm);\n        if (bounds != null) {\n            bounds.add(new Point2D.Double(Math.floor(bounds.getMinX() - 1), Math.floor(bounds.getMinY() - 1)));\n            bounds.add(new Point2D.Double(Math.ceil(bounds.getMaxX() + 1), Math.ceil(bounds.getMaxY() + 1)));\n            area = new Area(bounds);\n            area.intersect(getGraphicsState().getCurrentClippingPath());\n        } else {\n            area = getGraphicsState().getCurrentClippingPath();\n        }\n    }\n    if (!area.isEmpty()) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        Paint paint = shading.toPaint(ctm);\n        paint = applySoftMaskToPaint(paint, getGraphicsState().getSoftMask());\n        graphics.setPaint(paint);\n        graphics.fill(area);\n    }\n    graphics.setClip(savedClip);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLineAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLineAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationLine annotation = ((PDAnnotationLine) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getLine();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    float ll = annotation.getLeaderLineLength();\n    float lle = annotation.getLeaderLineExtensionLength();\n    float llo = annotation.getLeaderLineOffsetLength();\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    // Leader lines\n    if (ll < 0) {\n        // /LLO and /LLE go in the same direction as /LL\n        llo = -llo;\n        lle = -lle;\n    }\n    // observed with diagonal line of AnnotationSample.Standard.pdf\n    // for line endings, very small widths must be treated as size 1.\n    // However the border of the line ending shapes is not drawn.\n    float lineEndingSize = (ab.width < 1.0E-5) ? 1 : ab.width;\n    // add/subtract with, font height, and arrows\n    // arrow length is 9 * width at about 30Â° => 10 * width seems to be enough\n    // but need to consider /LL, /LLE and /LLO too\n    // TODO find better way to calculate padding\n    float max = Math.max(lineEndingSize * 10, Math.abs((llo + ll) + lle));\n    rect.setLowerLeftX(Math.min(minX - max, rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - max, rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + max, rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + max, rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        // Tested with Adobe Reader:\n        // text is written first (TODO)\n        // width 0 is used by Adobe as such (but results in a visible line in rendering)\n        // empty color array results in an invisible line (\"n\" operator) but the rest is visible\n        // empty content is like no caption\n        boolean hasStroke = cs.setStrokingColorOnDemand(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        float x1 = pathsArray[0];\n        float y1 = pathsArray[1];\n        float x2 = pathsArray[2];\n        float y2 = pathsArray[3];\n        // if there are leader lines, then the /L coordinates represent\n        // the endpoints of the leader lines rather than the endpoints of the line itself.\n        // so for us, llo + ll is the vertical offset for the line.\n        float y = llo + ll;\n        String contents = annotation.getContents();\n        if (contents == null) {\n            contents = \"\";\n        }\n        cs.saveGraphicsState();\n        double angle = Math.atan2(y2 - y1, x2 - x1);\n        cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n        float lineLength = ((float) (Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)))));\n        // Leader lines\n        cs.moveTo(0, llo);\n        cs.lineTo(0, (llo + ll) + lle);\n        cs.moveTo(lineLength, llo);\n        cs.lineTo(lineLength, (llo + ll) + lle);\n        if (annotation.hasCaption() && (!contents.isEmpty())) {\n            // Note that Adobe places the text as a caption even if /CP is not set\n            // when the text is so long that it would cross arrows, but we ignore this for now\n            // and stick to the specification.\n            PDFont font = getDefaultFont();\n            // TODO: support newlines!!!!!\n            // see https://www.pdfill.com/example/pdf_commenting_new.pdf\n            float contentLength = 0;\n            try {\n                contentLength = (font.getStringWidth(annotation.getContents()) / 1000) * FONT_SIZE;\n                // TODO How to decide the size of the font?\n                // 9 seems to be standard, but if the text doesn't fit, a scaling is done\n                // see AnnotationSample.Standard.pdf, diagonal line\n            } catch (IllegalArgumentException ex) {\n                // Adobe Reader displays placeholders instead\n                LOG.error((\"line text '\" + annotation.getContents()) + \"' can't be shown\", ex);\n            }\n            float xOffset = (lineLength - contentLength) / 2;\n            float yOffset;\n            String captionPositioning = annotation.getCaptionPositioning();\n            // draw the line horizontally, using the rotation CTM to get to correct final position\n            // that's the easiest way to calculate the positions for the line before and after inline caption\n            if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.moveTo(lineEndingSize, y);\n            } else {\n                cs.moveTo(0, y);\n            }\n            if (\"Top\".equals(captionPositioning)) {\n                // this arbitrary number is from Adobe\n                yOffset = 1.908F;\n            } else {\n                // Inline\n                // this arbitrary number is from Adobe\n                yOffset = -2.6F;\n                cs.lineTo(xOffset - lineEndingSize, y);\n                cs.moveTo((lineLength - xOffset) + lineEndingSize, y);\n            }\n            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.lineTo(lineLength - lineEndingSize, y);\n            } else {\n                cs.lineTo(lineLength, y);\n            }\n            cs.drawShape(lineEndingSize, hasStroke, false);\n            // /CO entry (caption offset)\n            float captionHorizontalOffset = annotation.getCaptionHorizontalOffset();\n            float captionVerticalOffset = annotation.getCaptionVerticalOffset();\n            // check contentLength so we don't show if there was trouble before\n            if (contentLength > 0) {\n                cs.beginText();\n                cs.setFont(font, FONT_SIZE);\n                cs.newLineAtOffset(xOffset + captionHorizontalOffset, (y + yOffset) + captionVerticalOffset);\n                cs.showText(annotation.getContents());\n                cs.endText();\n            }\n            if (Float.compare(captionVerticalOffset, 0) != 0) {\n                // Adobe paints vertical bar to the caption\n                cs.moveTo(0 + (lineLength / 2), y);\n                cs.lineTo(0 + (lineLength / 2), y + captionVerticalOffset);\n                cs.drawShape(lineEndingSize, hasStroke, false);\n            }\n        } else {\n            if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.moveTo(lineEndingSize, y);\n            } else {\n                cs.moveTo(0, y);\n            }\n            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.lineTo(lineLength - lineEndingSize, y);\n            } else {\n                cs.lineTo(lineLength, y);\n            }\n            cs.drawShape(lineEndingSize, hasStroke, false);\n        }\n        cs.restoreGraphicsState();\n        // paint the styles here and not before showing the text, or the text would appear\n        // with the interior color\n        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        // observed with diagonal line of file AnnotationSample.Standard.pdf\n        // when width is very small, the border of the line ending shapes\n        // is not drawn.\n        if (ab.width < 1.0E-5) {\n            hasStroke = false;\n        }\n        // check for LE_NONE only needed to avoid q cm Q for that case\n        if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {\n            cs.saveGraphicsState();\n            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n                drawStyle(annotation.getStartPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, false);\n            } else {\n                // Support of non-angled styles is more difficult than in the other handlers\n                // because the lines do not always go from (x1,y1) to (x2,y2) due to the leader lines\n                // when the \"y\" value above is not 0.\n                // We use the angle we already know and the distance y to translate to the new coordinate.\n                float xx1 = x1 - ((float) (y * Math.sin(angle)));\n                float yy1 = y1 + ((float) (y * Math.cos(angle)));\n                drawStyle(annotation.getStartPointEndingStyle(), cs, xx1, yy1, lineEndingSize, hasStroke, hasBackground, false);\n            }\n            cs.restoreGraphicsState();\n        }\n        // check for LE_NONE only needed to avoid q cm Q for that case\n        if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {\n            // save / restore not needed because it's the last one\n            if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.transform(Matrix.getRotateInstance(angle, x2, y2));\n                drawStyle(annotation.getEndPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, true);\n            } else {\n                // Support of non-angled styles is more difficult than in the other handlers\n                // because the lines do not always go from (x1,y1) to (x2,y2) due to the leader lines\n                // when the \"y\" value above is not 0.\n                // We use the angle we already know and the distance y to translate to the new coordinate.\n                float xx2 = x2 - ((float) (y * Math.sin(angle)));\n                float yy2 = y2 + ((float) (y * Math.cos(angle)));\n                drawStyle(annotation.getEndPointEndingStyle(), cs, xx2, yy2, lineEndingSize, hasStroke, hasBackground, true);\n            }\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tthe corresponding dictionary\n * @throws IOException\n * \t\tit something went wrong\n */\npublic PDType1CFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    boolean fontIsDamaged = false;\n    CFFType1Font cffEmbedded = null;\n    PDFontDescriptor fd = getFontDescriptor();\n    if (fd != null) {\n        PDStream ff3Stream = fd.getFontFile3();\n        if (ff3Stream != null) {\n            try (RandomAccessRead randomAccessRead = ff3Stream.getCOSObject().createView()) {\n                if (randomAccessRead.length() == 0) {\n                    LOG.error(\"Invalid data for embedded Type1C font \" + getName());\n                } else {\n                    // note: this could be an OpenType file, fortunately CFFParser can handle that\n                    CFFParser cffParser = new CFFParser();\n                    CFFFont parsedCffFont = cffParser.parse(randomAccessRead).get(0);\n                    if (parsedCffFont instanceof CFFType1Font) {\n                        cffEmbedded = ((CFFType1Font) (parsedCffFont));\n                    } else {\n                        LOG.error(\"Expected CFFType1Font, got \" + parsedCffFont.getClass().getSimpleName());\n                        fontIsDamaged = true;\n                    }\n                }\n            } catch (IOException e) {\n                LOG.error(\"Can't read the embedded Type1C font \" + getName(), e);\n                fontIsDamaged = true;\n            }\n        }\n    }\n    isDamaged = fontIsDamaged;\n    cffFont = cffEmbedded;\n    if (cffFont != null) {\n        genericFont = cffFont;\n        isEmbedded = true;\n    } else {\n        String baseFont = getBaseFont();\n        FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(baseFont, fd);\n        genericFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + genericFont.getName()) + \" for \") + baseFont);\n        }\n        isEmbedded = false;\n    }\n    readEncoding();\n    fontMatrixTransform = getFontMatrix().createAffineTransform();\n    fontMatrixTransform.scale(1000, 1000);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRawRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRawRaster", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.readRasterFromAny", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getDecodeArray" ],
    "fullMethods" : [ "/**\n * Extract the raw unconverted raster of the given image\n *\n * @param pdImage\n * \t\tThe image to get the raw raster data from\n * @return the raw raster of this image\n * @throws IOException\n */\npublic static WritableRaster getRawRaster(PDImage pdImage) throws IOException {\n    if (pdImage.isEmpty()) {\n        throw new IOException(\"Image stream is empty\");\n    }\n    // get parameters, they must be valid or have been repaired\n    final PDColorSpace colorSpace = pdImage.getColorSpace();\n    final int numComponents = colorSpace.getNumberOfComponents();\n    final int width = pdImage.getWidth();\n    final int height = pdImage.getHeight();\n    final int bitsPerComponent = pdImage.getBitsPerComponent();\n    if ((width <= 0) || (height <= 0)) {\n        throw new IOException(\"image width and height must be positive\");\n    }\n    try {\n        int dataBufferType = DataBuffer.TYPE_BYTE;\n        if (bitsPerComponent > 8) {\n            dataBufferType = DataBuffer.TYPE_USHORT;\n        }\n        WritableRaster raster = Raster.createInterleavedRaster(dataBufferType, width, height, numComponents, new Point(0, 0));\n        readRasterFromAny(pdImage, raster);\n        return raster;\n    } catch (NegativeArraySizeException | IllegalArgumentException ex) {\n        throw new IOException(ex);\n    }\n}", "private static void readRasterFromAny(PDImage pdImage, WritableRaster raster) throws IOException {\n    final PDColorSpace colorSpace = pdImage.getColorSpace();\n    final int numComponents = colorSpace.getNumberOfComponents();\n    final int bitsPerComponent = pdImage.getBitsPerComponent();\n    final float[] decode = getDecodeArray(pdImage);\n    DecodeOptions options = new DecodeOptions();\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = pdImage.createInputStream(options)) {\n        // read bit stream\n        try (ImageInputStream iis = new MemoryCacheImageInputStream(imageStream)) {\n            final int inputWidth = pdImage.getWidth();\n            final int scanWidth = pdImage.getWidth();\n            final int scanHeight = pdImage.getHeight();\n            // create stream\n            final float sampleMax = ((float) (Math.pow(2, bitsPerComponent))) - 1.0F;\n            final boolean isIndexed = colorSpace instanceof PDIndexed;\n            // calculate row padding\n            int padding = 0;\n            if ((((inputWidth * numComponents) * bitsPerComponent) % 8) > 0) {\n                padding = 8 - (((inputWidth * numComponents) * bitsPerComponent) % 8);\n            }\n            // read stream\n            final boolean isShort = raster.getDataBuffer().getDataType() == DataBuffer.TYPE_USHORT;\n            assert (!isIndexed) || (!isShort);\n            final byte[] srcColorValuesBytes = (isShort) ? null : new byte[numComponents];\n            final short[] srcColorValuesShort = (isShort) ? new short[numComponents] : null;\n            for (int y = 0; y < scanHeight; y++) {\n                for (int x = 0; x < scanWidth; x++) {\n                    for (int c = 0; c < numComponents; c++) {\n                        int value = ((int) (iis.readBits(bitsPerComponent)));\n                        // decode array\n                        final float dMin = decode[c * 2];\n                        final float dMax = decode[(c * 2) + 1];\n                        // interpolate to domain\n                        float output = dMin + (value * ((dMax - dMin) / sampleMax));\n                        if (isIndexed) {\n                            // indexed color spaces get the raw value, because the TYPE_BYTE\n                            // below cannot be reversed by the color space without it having\n                            // knowledge of the number of bits per component\n                            srcColorValuesBytes[c] = ((byte) (Math.round(output)));\n                        } else if (isShort) {\n                            // interpolate to TYPE_SHORT\n                            int outputShort = Math.round(((output - Math.min(dMin, dMax)) / Math.abs(dMax - dMin)) * 65535.0F);\n                            srcColorValuesShort[c] = ((short) (outputShort));\n                        } else {\n                            // interpolate to TYPE_BYTE\n                            int outputByte = Math.round(((output - Math.min(dMin, dMax)) / Math.abs(dMax - dMin)) * 255.0F);\n                            srcColorValuesBytes[c] = ((byte) (outputByte));\n                        }\n                    }\n                    if (isShort) {\n                        raster.setDataElements(x, y, srcColorValuesShort);\n                    } else {\n                        raster.setDataElements(x, y, srcColorValuesBytes);\n                    }\n                }\n                // rows are padded to the nearest byte\n                iis.readBits(padding);\n            }\n        }\n    }\n}", "// gets decode array from dictionary or returns default\nprivate static float[] getDecodeArray(PDImage pdImage) throws IOException {\n    final COSArray cosDecode = pdImage.getDecode();\n    float[] decode = null;\n    if (cosDecode != null) {\n        int numberOfComponents = pdImage.getColorSpace().getNumberOfComponents();\n        if (cosDecode.size() != (numberOfComponents * 2)) {\n            if (((pdImage.isStencil() && (cosDecode.size() >= 2)) && (cosDecode.get(0) instanceof COSNumber)) && (cosDecode.get(1) instanceof COSNumber)) {\n                float decode0 = ((COSNumber) (cosDecode.get(0))).floatValue();\n                float decode1 = ((COSNumber) (cosDecode.get(1))).floatValue();\n                if ((((decode0 >= 0) && (decode0 <= 1)) && (decode1 >= 0)) && (decode1 <= 1)) {\n                    LOG.warn((\"decode array \" + cosDecode) + \" not compatible with color space, using the first two entries\");\n                    return new float[]{ decode0, decode1 };\n                }\n            }\n            LOG.error((\"decode array \" + cosDecode) + \" not compatible with color space, using default\");\n        } else {\n            decode = cosDecode.toFloatArray();\n        }\n    }\n    // use color space default\n    if (decode == null) {\n        return pdImage.getColorSpace().getDefaultDecode(pdImage.getBitsPerComponent());\n    }\n    return decode;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.extractMatte" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    if (((region == null) && (subsampling == cachedImageSubsampling)) && (cachedImage != null)) {\n        BufferedImage cached = cachedImage.get();\n        if (cached != null) {\n            return cached;\n        }\n    }\n    initJPXValues();\n    // get RGB image w/o reference because applyMask might modify it, take long time and a lot of memory.\n    final BufferedImage image;\n    final PDImageXObject softMask = getSoftMask();\n    final PDImageXObject mask = getMask();\n    if (jpxSMask != null) {\n        // PDFBOX-5657: handle JPEG2000 SMaskInData\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), jpxSMask, false, true, null);\n    } else if (softMask != null) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), softMask.getOpaqueImage(region, subsampling), softMask.getInterpolate(), true, extractMatte(softMask));\n    } else if ((mask != null) && mask.isStencil()) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), mask.getOpaqueImage(region, subsampling), mask.getInterpolate(), false, null);\n    } else {\n        image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());\n    }\n    if ((region == null) && (subsampling <= cachedImageSubsampling)) {\n        // only cache full-image renders, and prefer lower subsampling frequency, as lower\n        // subsampling means higher quality and longer render times.\n        cachedImageSubsampling = subsampling;\n        cachedImage = new SoftReference<>(image);\n    }\n    return image;\n}", "/**\n * Extract the matte color from a softmask.\n *\n * @param softMask\n * @return the matte color.\n * @throws IOException\n * \t\tif the color conversion fails.\n */\nprivate float[] extractMatte(PDImageXObject softMask) throws IOException {\n    COSBase base = softMask.getCOSObject().getItem(COSName.MATTE);\n    float[] matte = null;\n    if (base instanceof COSArray) {\n        // PDFBOX-4267: process /Matte\n        // see PDF specification 1.7, 11.6.5.3 Soft-Mask Images\n        matte = ((COSArray) (base)).toFloatArray();\n        // convert to RGB\n        if (matte.length < getColorSpace().getNumberOfComponents()) {\n            LOG.error(\"Image /Matte entry not long enough for colorspace, skipped\");\n            return null;\n        }\n        matte = getColorSpace().toRGB(matte);\n    }\n    return matte;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDInkAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDInkAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationInk ink = ((PDAnnotationInk) (getAnnotation()));\n    PDColor color = ink.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    // PDF spec does not mention /Border for ink annotations, but it is used if /BS is not available\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\n    if (Float.compare(ab.width, 0) == 0) {\n        return;\n    }\n    // Adjust rectangle even if not empty\n    // file from PDF.js issue 13447\n    // TODO in a class structure this should be overridable\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (float[] pathArray : ink.getInkList()) {\n        int nPoints = pathArray.length / 2;\n        for (int i = 0; i < nPoints; ++i) {\n            float x = pathArray[i * 2];\n            float y = pathArray[(i * 2) + 1];\n            minX = Math.min(minX, x);\n            minY = Math.min(minY, y);\n            maxX = Math.max(maxX, x);\n            maxY = Math.max(maxY, y);\n        }\n    }\n    PDRectangle rect = ink.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    rect.setLowerLeftX(Math.min(minX - (ab.width * 2), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width * 2), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width * 2), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width * 2), rect.getUpperRightY()));\n    ink.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, ink.getConstantOpacity());\n        cs.setStrokingColor(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        for (float[] pathArray : ink.getInkList()) {\n            int nPoints = pathArray.length / 2;\n            // \"When drawn, the points shall be connected by straight lines or curves\n            // in an implementation-dependent way\" - we do lines.\n            for (int i = 0; i < nPoints; ++i) {\n                float x = pathArray[i * 2];\n                float y = pathArray[(i * 2) + 1];\n                if (i == 0) {\n                    cs.moveTo(x, y);\n                } else {\n                    cs.lineTo(x, y);\n                }\n            }\n            cs.stroke();\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getNumbers",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getNumbers" ],
    "fullMethods" : [ "/**\n * This will return a map of numbers on this level. The key will be a java.lang.Integer, the\n * value will depend on where this class is being used.\n *\n * @return A map of COS objects.\n * @throws IOException\n * \t\tIf there is a problem creating the values.\n */\npublic Map<Integer, COSObjectable> getNumbers() throws IOException {\n    Map<Integer, COSObjectable> indices = null;\n    COSArray numbersArray = node.getCOSArray(COSName.NUMS);\n    if (numbersArray != null) {\n        int size = numbersArray.size();\n        indices = new HashMap<>();\n        if ((size % 2) != 0) {\n            LOG.warn(\"Numbers array has odd size: \" + size);\n        }\n        for (int i = 0; (i + 1) < size; i += 2) {\n            COSBase base = numbersArray.getObject(i);\n            if (!(base instanceof COSInteger)) {\n                LOG.error(((\"page labels ignored, index \" + i) + \" should be a number, but is \") + base);\n                return null;\n            }\n            COSInteger key = ((COSInteger) (base));\n            COSBase cosValue = numbersArray.getObject(i + 1);\n            indices.put(key.intValue(), cosValue == null ? null : convertCOSToPD(cosValue));\n        }\n        indices = Collections.unmodifiableMap(indices);\n    }\n    return indices;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPopup.getParent",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPopup.getParent" ],
    "fullMethods" : [ "/**\n * This will retrieve the markup annotation which this popup relates to.\n *\n * @return The parent markup annotation.\n */\npublic PDAnnotationMarkup getParent() {\n    try {\n        PDAnnotation ann = PDAnnotation.createAnnotation(getCOSObject().getDictionaryObject(COSName.PARENT, COSName.P));\n        if (!(ann instanceof PDAnnotationMarkup)) {\n            LOG.error((\"parent annotation is of type \" + ann.getClass().getSimpleName()) + \" but should be of type PDAnnotationMarkup\");\n            return null;\n        }\n        return ((PDAnnotationMarkup) (ann));\n    } catch (IOException ioe) {\n        LOG.debug(\"An exception while trying to get the parent markup - ignoring\", ioe);\n        // Couldn't construct the annotation, so return null i.e. do nothing\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCircleAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCircleAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    float lineWidth = getLineWidth();\n    PDAnnotationCircle annotation = ((PDAnnotationCircle) (getAnnotation()));\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());\n        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());\n            cloudyBorder.createCloudyEllipse(annotation.getRectDifference());\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            annotation.setRectDifference(cloudyBorder.getRectDifference());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            // Acrobat applies a padding to each side of the bbox so the line is completely within\n            // the bbox.\n            PDRectangle borderBox = handleBorderBox(annotation, lineWidth);\n            // lower left corner\n            float x0 = borderBox.getLowerLeftX();\n            float y0 = borderBox.getLowerLeftY();\n            // upper right corner\n            float x1 = borderBox.getUpperRightX();\n            float y1 = borderBox.getUpperRightY();\n            // mid points\n            float xm = x0 + (borderBox.getWidth() / 2);\n            float ym = y0 + (borderBox.getHeight() / 2);\n            // see http://spencermortensen.com/articles/bezier-circle/\n            // the below number was calculated from sampling content streams\n            // generated using Adobe Reader\n            float magic = 0.55555415F;\n            // control point offsets\n            float vOffset = (borderBox.getHeight() / 2) * magic;\n            float hOffset = (borderBox.getWidth() / 2) * magic;\n            contentStream.moveTo(xm, y1);\n            contentStream.curveTo(xm + hOffset, y1, x1, ym + vOffset, x1, ym);\n            contentStream.curveTo(x1, ym - vOffset, xm + hOffset, y0, xm, y0);\n            contentStream.curveTo(xm - hOffset, y0, x0, ym - vOffset, x0, ym);\n            contentStream.curveTo(x0, ym + vOffset, xm - hOffset, y1, xm, y1);\n            contentStream.closePath();\n        }\n        contentStream.drawShape(lineWidth, hasStroke, hasBackground);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDUnderlineAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDUnderlineAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationUnderline annotation = ((PDAnnotationUnderline) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getQuadPoints();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    if (Float.compare(ab.width, 0) == 0) {\n        // value found in adobe reader\n        ab.width = 1.5F;\n    }\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    // TODO in a class structure this should be overridable\n    // this is similar to polyline but different data type\n    // all coordinates (unlike painting) are used because I'm lazy\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    rect.setLowerLeftX(Math.min(minX - (ab.width / 2), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width / 2), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width / 2), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width / 2), rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        cs.setStrokingColor(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        // spec is incorrect\n        // https://stackoverflow.com/questions/9855814/pdf-spec-vs-acrobat-creation-quadpoints\n        for (int i = 0; i < (pathsArray.length / 8); ++i) {\n            // Adobe doesn't use the lower coordinate for the line, it uses lower + delta / 7.\n            // do the math for diagonal annotations with this weird old trick:\n            // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n            float len0 = ((float) (Math.sqrt(Math.pow(pathsArray[i * 8] - pathsArray[(i * 8) + 4], 2) + Math.pow(pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5], 2))));\n            float x0 = pathsArray[(i * 8) + 4];\n            float y0 = pathsArray[(i * 8) + 5];\n            if (Float.compare(len0, 0) != 0) {\n                // only if both coordinates are not identical to avoid divide by zero\n                x0 += (((pathsArray[i * 8] - pathsArray[(i * 8) + 4]) / len0) * len0) / 7;\n                y0 += ((pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5]) / len0) * (len0 / 7);\n            }\n            float len1 = ((float) (Math.sqrt(Math.pow(pathsArray[(i * 8) + 2] - pathsArray[(i * 8) + 6], 2) + Math.pow(pathsArray[(i * 8) + 3] - pathsArray[(i * 8) + 7], 2))));\n            float x1 = pathsArray[(i * 8) + 6];\n            float y1 = pathsArray[(i * 8) + 7];\n            if (Float.compare(len1, 0) != 0) {\n                // only if both coordinates are not identical to avoid divide by zero\n                x1 += (((pathsArray[(i * 8) + 2] - pathsArray[(i * 8) + 6]) / len1) * len1) / 7;\n                y1 += (((pathsArray[(i * 8) + 3] - pathsArray[(i * 8) + 7]) / len1) * len1) / 7;\n            }\n            cs.moveTo(x0, y0);\n            cs.lineTo(x1, y1);\n        }\n        cs.stroke();\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.LZWFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.LZWFilter.decode", "org.apache.pdfbox.filter.Filter.getDecodeParams" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    COSDictionary decodeParams = getDecodeParams(parameters, index);\n    boolean earlyChange = decodeParams.getInt(COSName.EARLY_CHANGE, 1) != 0;\n    doLZWDecode(encoded, Predictor.wrapPredictor(decoded, decodeParams), earlyChange);\n    return new DecodeResult(parameters);\n}", "// gets the decode params for a specific filter index, this is used to\n// normalise the DecodeParams entry so that it is always a dictionary\nprotected COSDictionary getDecodeParams(COSDictionary dictionary, int index) {\n    COSBase filter = dictionary.getDictionaryObject(COSName.F, COSName.FILTER);\n    COSBase obj = dictionary.getDictionaryObject(COSName.DP, COSName.DECODE_PARMS);\n    if ((filter instanceof COSName) && (obj instanceof COSDictionary)) {\n        // PDFBOX-3932: The PDF specification requires \"If there is only one filter and that\n        // filter has parameters, DecodeParms shall be set to the filterâs parameter dictionary\"\n        // but tests show that Adobe means \"one filter name object\".\n        return ((COSDictionary) (obj));\n    } else if ((filter instanceof COSArray) && (obj instanceof COSArray)) {\n        COSArray array = ((COSArray) (obj));\n        if (index < array.size()) {\n            COSBase objAtIndex = array.getObject(index);\n            if (objAtIndex instanceof COSDictionary) {\n                return ((COSDictionary) (objAtIndex));\n            }\n        }\n    } else if ((obj != null) && (!((filter instanceof COSArray) || (obj instanceof COSArray)))) {\n        LOG.error(\"Expected DecodeParams to be an Array or Dictionary but found \" + obj.getClass().getName());\n    }\n    return new COSDictionary();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLinkAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLinkAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationLink annotation = ((PDAnnotationLink) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        // 660402-p1-AnnotationEmptyRect.pdf has /Rect entry with 0 elements\n        return;\n    }\n    // Adobe doesn't generate an appearance for a link annotation\n    float lineWidth = getLineWidth();\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        PDColor color = annotation.getColor();\n        if (color == null) {\n            // spec is unclear, but black is what Adobe does\n            color = new PDColor(new float[]{ 0 }, PDDeviceGray.INSTANCE);\n        }\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(color);\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        // Acrobat applies a padding to each side of the bbox so the line is completely within\n        // the bbox.\n        PDRectangle borderEdge = getPaddedRectangle(getRectangle(), lineWidth / 2);\n        float[] pathsArray = annotation.getQuadPoints();\n        if (pathsArray != null) {\n            // QuadPoints shall be ignored if any coordinate in the array lies outside\n            // the region specified by Rect.\n            for (int i = 0; i < (pathsArray.length / 2); ++i) {\n                if (!rect.contains(pathsArray[i * 2], pathsArray[(i * 2) + 1])) {\n                    LOG.warn((((((\"At least one /QuadPoints entry (\" + pathsArray[i * 2]) + \";\") + pathsArray[(i * 2) + 1]) + \") is outside of rectangle, \") + rect) + \", /QuadPoints are ignored and /Rect is used instead\");\n                    pathsArray = null;\n                    break;\n                }\n            }\n        }\n        if (pathsArray == null) {\n            // Convert rectangle coordinates as if it was a /QuadPoints entry\n            pathsArray = new float[8];\n            pathsArray[0] = borderEdge.getLowerLeftX();\n            pathsArray[1] = borderEdge.getLowerLeftY();\n            pathsArray[2] = borderEdge.getUpperRightX();\n            pathsArray[3] = borderEdge.getLowerLeftY();\n            pathsArray[4] = borderEdge.getUpperRightX();\n            pathsArray[5] = borderEdge.getUpperRightY();\n            pathsArray[6] = borderEdge.getLowerLeftX();\n            pathsArray[7] = borderEdge.getUpperRightY();\n        }\n        boolean underlined = false;\n        if (pathsArray.length >= 8) {\n            PDBorderStyleDictionary borderStyleDic = annotation.getBorderStyle();\n            if (borderStyleDic != null) {\n                underlined = PDBorderStyleDictionary.STYLE_UNDERLINE.equals(borderStyleDic.getStyle());\n            }\n        }\n        int of = 0;\n        while ((of + 7) < pathsArray.length) {\n            contentStream.moveTo(pathsArray[of], pathsArray[of + 1]);\n            contentStream.lineTo(pathsArray[of + 2], pathsArray[of + 3]);\n            if (!underlined) {\n                contentStream.lineTo(pathsArray[of + 4], pathsArray[of + 5]);\n                contentStream.lineTo(pathsArray[of + 6], pathsArray[of + 7]);\n                contentStream.closePath();\n            }\n            of += 8;\n        } \n        contentStream.drawShape(lineWidth, hasStroke, false);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.markedcontent.DrawObject.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.markedcontent.DrawObject.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    if (arguments.isEmpty()) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    COSName name = ((COSName) (base0));\n    PDFStreamEngine context = getContext();\n    PDXObject xobject = context.getResources().getXObject(name);\n    ((PDFMarkedContentExtractor) (context)).xobject(xobject);\n    if (xobject instanceof PDFormXObject) {\n        try {\n            context.increaseLevel();\n            if (context.getLevel() > 50) {\n                LOG.error(\"recursion is too deep, skipping form XObject\");\n                return;\n            }\n            if (xobject instanceof PDTransparencyGroup) {\n                context.showTransparencyGroup(((PDTransparencyGroup) (xobject)));\n            } else {\n                context.showForm(((PDFormXObject) (xobject)));\n            }\n        } finally {\n            context.decreaseLevel();\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFreeTextAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationFreeText annotation = ((PDAnnotationFreeText) (getAnnotation()));\n    float[] pathsArray;\n    if (PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent())) {\n        pathsArray = annotation.getCallout();\n        if ((pathsArray == null) || ((pathsArray.length != 4) && (pathsArray.length != 6))) {\n            pathsArray = new float[0];\n        }\n    } else {\n        pathsArray = new float[0];\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream(true)) {\n        // The fill color is the /C entry, there is no /IC entry defined\n        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getColor());\n        setOpacity(cs, annotation.getConstantOpacity());\n        // Adobe uses the last non stroking color from /DA as stroking color!\n        // But if there is a color in /DS, then that one is used for text.\n        PDColor strokingColor = extractNonStrokingColor(annotation);\n        boolean hasStroke = cs.setStrokingColorOnDemand(strokingColor);\n        PDColor textColor = strokingColor;\n        String defaultStyleString = annotation.getDefaultStyleString();\n        if (defaultStyleString != null) {\n            Matcher m = COLOR_PATTERN.matcher(defaultStyleString);\n            if (m.find()) {\n                int color = Integer.parseInt(m.group(1), 16);\n                float r = ((color >> 16) & 0xff) / 255.0F;\n                float g = ((color >> 8) & 0xff) / 255.0F;\n                float b = (color & 0xff) / 255.0F;\n                textColor = new PDColor(new float[]{ r, g, b }, PDDeviceRGB.INSTANCE);\n            }\n        }\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        String lineEndingStyle = annotation.getLineEndingStyle();\n        // draw callout line(s)\n        // must be done before retangle paint to avoid a line cutting through cloud\n        // see CTAN-example-Annotations.pdf\n        for (int i = 0; i < (pathsArray.length / 2); ++i) {\n            float x = pathsArray[i * 2];\n            float y = pathsArray[(i * 2) + 1];\n            if (i == 0) {\n                if (SHORT_STYLES.contains(lineEndingStyle)) {\n                    // modify coordinate to shorten the segment\n                    // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n                    float x1 = pathsArray[2];\n                    float y1 = pathsArray[3];\n                    float len = ((float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2))));\n                    if (Float.compare(len, 0) != 0) {\n                        x += ((x1 - x) / len) * ab.width;\n                        y += ((y1 - y) / len) * ab.width;\n                    }\n                }\n                cs.moveTo(x, y);\n            } else {\n                cs.lineTo(x, y);\n            }\n        }\n        if (pathsArray.length > 0) {\n            cs.stroke();\n        }\n        // paint the styles here and after line(s) draw, to avoid line crossing a filled shape\n        if ((PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent()) && // check only needed to avoid q cm Q if LE_NONE\n        (!LE_NONE.equals(lineEndingStyle))) && (pathsArray.length >= 4)) {\n            float x2 = pathsArray[2];\n            float y2 = pathsArray[3];\n            float x1 = pathsArray[0];\n            float y1 = pathsArray[1];\n            cs.saveGraphicsState();\n            if (ANGLED_STYLES.contains(lineEndingStyle)) {\n                // do a transform so that first \"arm\" is imagined flat,\n                // like in line handler.\n                // The alternative would be to apply the transform to the\n                // LE shape coordinates directly, which would be more work\n                // and produce code difficult to understand\n                double angle = Math.atan2(y2 - y1, x2 - x1);\n                cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n            } else {\n                cs.transform(Matrix.getTranslateInstance(x1, y1));\n            }\n            drawStyle(lineEndingStyle, cs, 0, 0, ab.width, hasStroke, hasBackground, false);\n            cs.restoreGraphicsState();\n        }\n        PDRectangle borderBox;\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            // Adobe draws the text with the original rectangle in mind.\n            // but if there is an /RD, then writing area get smaller.\n            // do this here because /RD is overwritten in a few lines\n            borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());\n            // TODO this segment was copied from square handler. Refactor?\n            CloudyBorder cloudyBorder = new CloudyBorder(cs, borderEffect.getIntensity(), ab.width, getRectangle());\n            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            annotation.setRectDifference(cloudyBorder.getRectDifference());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            // handle the border box\n            // \n            // There are two options. The handling is not part of the PDF specification but\n            // implementation specific to Adobe Reader\n            // - if /RD is set the border box is the /Rect entry inset by the respective\n            // border difference.\n            // - if /RD is not set then we don't touch /RD etc because Adobe doesn't either.\n            borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());\n            annotation.getNormalAppearanceStream().setBBox(borderBox);\n            // note that borderBox is not modified\n            PDRectangle paddedRectangle = getPaddedRectangle(borderBox, ab.width / 2);\n            cs.addRect(paddedRectangle.getLowerLeftX(), paddedRectangle.getLowerLeftY(), paddedRectangle.getWidth(), paddedRectangle.getHeight());\n        }\n        cs.drawShape(ab.width, hasStroke, hasBackground);\n        // rotation is an undocumented feature, but Adobe uses it. Examples can be found\n        // in pdf_commenting_new.pdf file, page 3.\n        int rotation = annotation.getCOSObject().getInt(COSName.ROTATE, 0);\n        cs.transform(Matrix.getRotateInstance(Math.toRadians(rotation), 0, 0));\n        float xOffset;\n        float yOffset;\n        float width = ((rotation == 90) || (rotation == 270)) ? borderBox.getHeight() : borderBox.getWidth();\n        // strategy to write formatted text is somewhat inspired by\n        // AppearanceGeneratorHelper.insertGeneratedAppearance()\n        PDFont font = null;\n        float clipY;\n        float clipWidth = width - (ab.width * 4);\n        float clipHeight = ((rotation == 90) || (rotation == 270)) ? borderBox.getWidth() - (ab.width * 4) : borderBox.getHeight() - (ab.width * 4);\n        extractFontDetails(annotation);\n        if (document != null) {\n            PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();\n            if (acroForm != null) {\n                // Try to get font from AcroForm default resources\n                // Sample file: https://gitlab.freedesktop.org/poppler/poppler/issues/6\n                PDResources defaultResources = acroForm.getDefaultResources();\n                if (defaultResources != null) {\n                    PDFont defaultResourcesFont = defaultResources.getFont(fontName);\n                    if (defaultResourcesFont != null) {\n                        font = defaultResourcesFont;\n                    }\n                }\n            }\n        }\n        if (font == null) {\n            font = getDefaultFont();\n        }\n        // value used by Adobe, no idea where it comes from, actual font bbox max y is 0.931\n        // gathered by creating an annotation with width 0.\n        float yDelta = 0.7896F;\n        switch (rotation) {\n            case 180 :\n                xOffset = (-borderBox.getUpperRightX()) + (ab.width * 2);\n                yOffset = ((-borderBox.getLowerLeftY()) - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = (-borderBox.getUpperRightY()) + (ab.width * 2);\n                break;\n            case 90 :\n                xOffset = borderBox.getLowerLeftY() + (ab.width * 2);\n                yOffset = ((-borderBox.getLowerLeftX()) - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = (-borderBox.getUpperRightX()) + (ab.width * 2);\n                break;\n            case 270 :\n                xOffset = (-borderBox.getUpperRightY()) + (ab.width * 2);\n                yOffset = (borderBox.getUpperRightX() - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = borderBox.getLowerLeftX() + (ab.width * 2);\n                break;\n            case 0 :\n            default :\n                xOffset = borderBox.getLowerLeftX() + (ab.width * 2);\n                yOffset = (borderBox.getUpperRightY() - (ab.width * 2)) - (yDelta * fontSize);\n                clipY = borderBox.getLowerLeftY() + (ab.width * 2);\n                break;\n        }\n        // clip writing area\n        cs.addRect(xOffset, clipY, clipWidth, clipHeight);\n        cs.clip();\n        String annotationContents = annotation.getContents();\n        if (annotationContents != null) {\n            cs.beginText();\n            cs.setFont(font, fontSize);\n            cs.setNonStrokingColor(textColor.getComponents());\n            AppearanceStyle appearanceStyle = new AppearanceStyle();\n            appearanceStyle.setFont(font);\n            appearanceStyle.setFontSize(fontSize);\n            PlainTextFormatter formatter = // Adobe ignores the /Q\n            // .textAlign(annotation.getQ())\n            new PlainTextFormatter.Builder(cs).style(appearanceStyle).text(new PlainText(annotationContents)).width(width - (ab.width * 4)).wrapLines(true).initialOffset(xOffset, yOffset).build();\n            try {\n                formatter.format();\n            } catch (IllegalArgumentException ex) {\n                throw new IOException(ex);\n            } finally {\n                cs.endText();\n            }\n        }\n        if (pathsArray.length > 0) {\n            PDRectangle rect = getRectangle();\n            // Adjust rectangle\n            // important to do this after the rectangle has been painted, because the\n            // final rectangle will be bigger due to callout\n            // CTAN-example-Annotations.pdf p1\n            // TODO in a class structure this should be overridable\n            float minX = Float.MAX_VALUE;\n            float minY = Float.MAX_VALUE;\n            float maxX = Float.MIN_VALUE;\n            float maxY = Float.MIN_VALUE;\n            for (int i = 0; i < (pathsArray.length / 2); ++i) {\n                float x = pathsArray[i * 2];\n                float y = pathsArray[(i * 2) + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n            // arrow length is 9 * width at about 30Â° => 10 * width seems to be enough\n            rect.setLowerLeftX(Math.min(minX - (ab.width * 10), rect.getLowerLeftX()));\n            rect.setLowerLeftY(Math.min(minY - (ab.width * 10), rect.getLowerLeftY()));\n            rect.setUpperRightX(Math.max(maxX + (ab.width * 10), rect.getUpperRightX()));\n            rect.setUpperRightY(Math.max(maxY + (ab.width * 10), rect.getUpperRightY()));\n            annotation.setRectangle(rect);\n            // need to set the BBox too, because rectangle modification came later\n            annotation.getNormalAppearanceStream().setBBox(getRectangle());\n            // TODO when callout is used, /RD should be so that the result is the writable part\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.PNGConverter.convertPNGImage", "org.apache.pdfbox.pdmodel.graphics.image.PNGConverter.parsePNGChunks" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image byte array. This overloaded version allows providing\n * a custom factory to handle specific image formats, such as BMP and GIF, or to act as a\n * fallback strategy when the default converters (e.g., for PNG or TIFF) fail.\n *\n * @param document\n * \t\tthe document that shall use this PDImageXObject.\n * @param byteArray\n * \t\tbytes from an image file.\n * @param name\n * \t\tname of image file for exception messages, can be null.\n * @param customFactory\n * \t\toptional factory used to handle BMP, GIF, or fallback cases\n * \t\t(e.g., for PNG or TIFF). If {@code null}, this method delegates to\n * \t\t{@link #createFromByteArray(PDDocument, byte[], String)}.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray, String name, CustomFactory customFactory) throws IOException {\n    FileType fileType = FileTypeDetector.detectFileType(byteArray);\n    if (fileType == null) {\n        throw new IllegalArgumentException(\"Image type not supported: \" + name);\n    }\n    if (fileType == FileType.JPEG) {\n        return JPEGFactory.createFromByteArray(document, byteArray);\n    }\n    if (fileType == FileType.PNG) {\n        // Try to directly convert the image without recoding it.\n        PDImageXObject image = PNGConverter.convertPNGImage(document, byteArray);\n        if (image != null) {\n            return image;\n        }\n    }\n    if (fileType == FileType.TIFF) {\n        try {\n            return CCITTFactory.createFromByteArray(document, byteArray);\n        } catch (IOException ex) {\n            LOG.debug(\"Reading as TIFF failed, setting fileType to PNG\", ex);\n            // Plan B: try reading with ImageIO\n            // common exception:\n            // First image in tiff is not CCITT T4 or T6 compressed\n            fileType = FileType.PNG;\n        }\n    }\n    if (((fileType == FileType.BMP) || (fileType == FileType.GIF)) || (fileType == FileType.PNG)) {\n        if (customFactory != null) {\n            return customFactory.createFromByteArray(document, byteArray);\n        }\n        ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);\n        BufferedImage bim = ImageIO.read(bais);\n        return LosslessFactory.createFromImage(document, bim);\n    }\n    throw new IllegalArgumentException(((\"Image type \" + fileType) + \" not supported: \") + name);\n}", "/**\n * Try to convert a PNG into a PDImageXObject. If for any reason the PNG can not\n * be converted, null is returned.\n * <p>\n * This usually means the PNG structure is damaged (CRC error, etc.) or it uses\n * some features which can not be mapped to PDF.\n *\n * @param doc\n * \t\tthe document to put the image in\n * @param imageData\n * \t\tthe byte data of the PNG\n * @return null or the PDImageXObject built from the png\n */\nstatic PDImageXObject convertPNGImage(PDDocument doc, byte[] imageData) throws IOException {\n    PNGConverterState state = parsePNGChunks(imageData);\n    if (!checkConverterState(state)) {\n        // There is something wrong, we can't convert this PNG\n        return null;\n    }\n    return convertPng(doc, state);\n}", "/**\n * Parse the PNG structure into the PNGConverterState. If we can't handle\n * something, this method will return null.\n *\n * @param imageData\n * \t\tthe byte array with the PNG data\n * @return null or the converter state with all relevant chunks\n */\nprivate static PNGConverterState parsePNGChunks(byte[] imageData) {\n    if (imageData.length < 20) {\n        LOG.error(\"ByteArray way to small: \" + imageData.length);\n        return null;\n    }\n    PNGConverterState state = new PNGConverterState();\n    int ptr = 8;\n    int firstChunkType = readInt(imageData, ptr + 4);\n    if (firstChunkType != CHUNK_IHDR) {\n        LOG.error(String.format(\"First Chunktype was %08X, not IHDR\", firstChunkType));\n        return null;\n    }\n    while ((ptr + 12) <= imageData.length) {\n        int chunkLength = readInt(imageData, ptr);\n        int chunkType = readInt(imageData, ptr + 4);\n        ptr += 8;\n        if (((ptr + chunkLength) + 4) > imageData.length) {\n            LOG.error(((((\"Not enough bytes. At offset \" + ptr) + \" are \") + chunkLength) + \" bytes expected. Overall length is \") + imageData.length);\n            return null;\n        }\n        Chunk chunk = new Chunk();\n        chunk.chunkType = chunkType;\n        chunk.bytes = imageData;\n        chunk.start = ptr;\n        chunk.length = chunkLength;\n        switch (chunkType) {\n            case CHUNK_IHDR :\n                if (state.IHDR != null) {\n                    LOG.error(\"Two IHDR chunks? There is something wrong.\");\n                    return null;\n                }\n                state.IHDR = chunk;\n                break;\n            case CHUNK_IDAT :\n                // The image data itself\n                state.IDATs.add(chunk);\n                break;\n            case CHUNK_PLTE :\n                // For indexed images the palette table\n                if (state.PLTE != null) {\n                    LOG.error(\"Two PLTE chunks? There is something wrong.\");\n                    return null;\n                }\n                state.PLTE = chunk;\n                break;\n            case CHUNK_IEND :\n                // We are done, return the state\n                return state;\n            case CHUNK_TRNS :\n                // For indexed images the alpha transparency table\n                if (state.tRNS != null) {\n                    LOG.error(\"Two tRNS chunks? There is something wrong.\");\n                    return null;\n                }\n                state.tRNS = chunk;\n                break;\n            case CHUNK_GAMA :\n                // Gama\n                state.gAMA = chunk;\n                break;\n            case CHUNK_CHRM :\n                // Chroma\n                state.cHRM = chunk;\n                break;\n            case CHUNK_ICCP :\n                // ICC Profile\n                state.iCCP = chunk;\n                break;\n            case CHUNK_SBIT :\n                LOG.debug(\"Can't convert PNGs with sBIT chunk.\");\n                break;\n            case CHUNK_SRGB :\n                // We use the rendering intent from the chunk\n                state.sRGB = chunk;\n                break;\n            case CHUNK_TEXT :\n            case CHUNK_ZTXT :\n            case CHUNK_ITXT :\n                // We don't care about this text infos / metadata\n                break;\n            case CHUNK_KBKG :\n                // As we can handle transparency we don't need the background color information.\n                break;\n            case CHUNK_HIST :\n                // We don't need the color histogram\n                break;\n            case CHUNK_PHYS :\n                // The PDImageXObject will be placed by the user however he wants,\n                // so we can not enforce the physical dpi information stored here.\n                // We just ignore it.\n                break;\n            case CHUNK_SPLT :\n                // This palette stuff seems editor related, we don't need it.\n                break;\n            case CHUNK_TIME :\n                // We don't need the last image change time either\n                break;\n            default :\n                LOG.debug(String.format(\"Unknown chunk type %08X, skipping.\", chunkType));\n                break;\n        }\n        ptr += chunkLength;\n        // Read the CRC\n        chunk.crc = readInt(imageData, ptr);\n        ptr += 4;\n    } \n    LOG.error(\"No IEND chunk found.\");\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.setVersion",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.setVersion" ],
    "fullMethods" : [ "/**\n * Sets the PDF specification version for this document.\n *\n * @param newVersion\n * \t\tthe new PDF version (e.g. 1.4f)\n */\npublic void setVersion(float newVersion) {\n    float currentVersion = getVersion();\n    // nothing to do?\n    if (Float.compare(newVersion, currentVersion) == 0) {\n        return;\n    }\n    // the version can't be downgraded\n    if (newVersion < currentVersion) {\n        LOG.error(\"It's not allowed to downgrade the version of a pdf.\");\n        return;\n    }\n    // update the catalog version if the document version is >= 1.4\n    if (getDocument().getVersion() >= 1.4F) {\n        getDocumentCatalog().setVersion(Float.toString(newVersion));\n    } else {\n        // versions < 1.4f have a version header only\n        getDocument().setVersion(newVersion);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText", "org.apache.pdfbox.contentstream.PDFStreamEngine.showGlyph", "org.apache.pdfbox.rendering.PageDrawer.showFontGlyph", "org.apache.pdfbox.rendering.PageDrawer.drawGlyph", "org.apache.pdfbox.rendering.PageDrawer.getNonStrokingPaint", "org.apache.pdfbox.rendering.PageDrawer.getPaint" ],
    "fullMethods" : [ "/**\n * Called when a string of text is to be shown.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextString(byte[] string) throws IOException {\n    showText(string);\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}", "/**\n * Called when a glyph is to be processed. This method is intended for overriding in subclasses,\n * the default implementation does nothing.\n *\n * @param textRenderingMatrix\n * \t\tthe current text rendering matrix, T<sub>rm</sub>\n * @param font\n * \t\tthe current font\n * @param code\n * \t\tinternal PDF character code for the glyph\n * @param displacement\n * \t\tthe displacement (i.e. advance) of the glyph in text space\n * @throws IOException\n * \t\tif the glyph cannot be processed\n */\nprotected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, Vector displacement) throws IOException {\n    if (font instanceof PDType3Font) {\n        showType3Glyph(textRenderingMatrix, ((PDType3Font) (font)), code, displacement);\n    } else {\n        showFontGlyph(textRenderingMatrix, font, code, displacement);\n    }\n}", "@Override\nprotected void showFontGlyph(Matrix textRenderingMatrix, PDFont font, int code, Vector displacement) throws IOException {\n    AffineTransform at = textRenderingMatrix.createAffineTransform();\n    at.concatenate(font.getFontMatrix().createAffineTransform());\n    // create cache if it does not exist\n    PDVectorFont vectorFont = ((PDVectorFont) (font));\n    GlyphCache cache = glyphCaches.get(font);\n    if (cache == null) {\n        cache = new GlyphCache(vectorFont);\n        glyphCaches.put(font, cache);\n    }\n    GeneralPath path = cache.getPathForCharacterCode(code);\n    drawGlyph(path, font, code, displacement, at);\n}", "/**\n * Renders a glyph.\n *\n * @param path\n * \t\tthe GeneralPath for the glyph\n * @param font\n * \t\tthe font\n * @param code\n * \t\tcharacter code\n * @param displacement\n * \t\tthe glyph's displacement (advance)\n * @param at\n * \t\tthe transformation\n * @throws IOException\n * \t\tif something went wrong\n */\nprivate void drawGlyph(GeneralPath path, PDFont font, int code, Vector displacement, AffineTransform at) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    RenderingMode renderingMode = state.getTextState().getRenderingMode();\n    if (path != null) {\n        // Stretch non-embedded glyph if it does not match the height/width contained in the PDF.\n        // Vertical fonts have zero X displacement, so the following code scales to 0 if we don't skip it.\n        // TODO: How should vertical fonts be handled?\n        if ((((!font.isEmbedded()) && (!font.isVertical())) && (!font.isStandard14())) && font.hasExplicitWidth(code)) {\n            float fontWidth = font.getWidthFromFont(code);\n            if (((displacement.getX() > 0)// PDFBOX-5611: ignore zero widths\n             && (fontWidth > 0))// ignore spaces\n             && (Math.abs(fontWidth - (displacement.getX() * 1000)) > 1.0E-4)) {\n                float pdfWidth = displacement.getX() * 1000;\n                at.scale(pdfWidth / fontWidth, 1);\n            }\n        }\n        // render glyph\n        Shape glyph = at.createTransformedShape(path);\n        if (isContentRendered()) {\n            if (renderingMode.isFill()) {\n                graphics.setComposite(state.getNonStrokingJavaComposite());\n                graphics.setPaint(getNonStrokingPaint());\n                setClip();\n                graphics.fill(glyph);\n            }\n            if (renderingMode.isStroke()) {\n                graphics.setComposite(state.getStrokingJavaComposite());\n                graphics.setPaint(getStrokingPaint());\n                graphics.setStroke(getStroke());\n                setClip();\n                graphics.draw(glyph);\n            }\n        }\n        if (renderingMode.isClip()) {\n            textClippings.add(glyph);\n        }\n    }\n}", "/**\n * Returns the non-stroking AWT Paint. You may need to call this if you override\n * {@link #showGlyph(Matrix, PDFont, int, Vector) showGlyph()}. See\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-5093\">PDFBOX-5093</a> for more.\n *\n * @return The non-stroking AWT Paint.\n * @throws IOException\n * \t\tif the non-stroking AWT Paint could not be created\n */\nprotected final Paint getNonStrokingPaint() throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    return applySoftMaskToPaint(getPaint(graphicsState.getNonStrokingColor()), graphicsState.getSoftMask());\n}", "/**\n * Returns an AWT paint for the given PDColor.\n *\n * @param color\n * \t\tThe color to get a paint for. This can be an actual color or a pattern.\n * @return an AWT paint for the given PDColor\n * @throws IOException\n * \t\tif the AWT paint could not be created\n */\nprotected Paint getPaint(PDColor color) throws IOException {\n    PDColorSpace colorSpace = color.getColorSpace();\n    // PDFBOX-5782\n    if (colorSpace == null) {\n        LOG.error(\"colorSpace is null, will be rendered as transparency\");\n        return new Color(0, 0, 0, 0);\n    } else if ((colorSpace instanceof PDSeparation) && \"None\".equals(((PDSeparation) (colorSpace)).getColorantName())) {\n        // PDFBOX-4900: \"The special colorant name None shall not produce any visible output\"\n        // TODO better solution needs to be found for all occurences where toRGB is called\n        return new Color(0, 0, 0, 0);\n    } else if (!(colorSpace instanceof PDPattern)) {\n        float[] rgb = colorSpace.toRGB(color.getComponents());\n        return new Color(clampColor(rgb[0]), clampColor(rgb[1]), clampColor(rgb[2]));\n    } else {\n        PDPattern patternSpace = ((PDPattern) (colorSpace));\n        PDAbstractPattern pattern = patternSpace.getPattern(color);\n        if (pattern instanceof PDTilingPattern) {\n            PDTilingPattern tilingPattern = ((PDTilingPattern) (pattern));\n            if (tilingPattern.getPaintType() == PDTilingPattern.PAINT_COLORED) {\n                // colored tiling pattern\n                return tilingPaintFactory.create(tilingPattern, null, null, xform);\n            } else {\n                // uncolored tiling pattern\n                return tilingPaintFactory.create(tilingPattern, patternSpace.getUnderlyingColorSpace(), color, xform);\n            }\n        } else {\n            PDShadingPattern shadingPattern = ((PDShadingPattern) (pattern));\n            PDShading shading = shadingPattern.getShading();\n            if (shading == null) {\n                LOG.error(\"shadingPattern is null, will be filled with transparency\");\n                return new Color(0, 0, 0, 0);\n            }\n            return shading.toPaint(Matrix.concatenate(getInitialMatrix(), shadingPattern.getMatrix()));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDTriangleBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4.collectTriangles" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    Rectangle2D bounds = null;\n    for (ShadedTriangle shadedTriangle : collectTriangles(xform, matrix)) {\n        if (bounds == null) {\n            bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n        }\n        bounds.add(shadedTriangle.corner[0]);\n        bounds.add(shadedTriangle.corner[1]);\n        bounds.add(shadedTriangle.corner[2]);\n    }\n    if (bounds == null) {\n        // Speeds up files where triangles are empty, e.g. ghostscript file 690425\n        return new Rectangle2D.Float();\n    }\n    return bounds;\n}", "@SuppressWarnings(\"squid:S1166\")\n@Override\nList<ShadedTriangle> collectTriangles(AffineTransform xform, Matrix matrix) throws IOException {\n    int bitsPerFlag = getBitsPerFlag();\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<ShadedTriangle> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            byte flag = ((byte) (0));\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n            }\n            boolean eof = false;\n            while (!eof) {\n                Vertex p0;\n                Vertex p1;\n                Vertex p2;\n                Point2D[] ps;\n                float[][] cs;\n                int lastIndex;\n                try {\n                    switch (flag) {\n                        case 0 :\n                            p0 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            if (flag != 0) {\n                                LOG.error(\"bad triangle: \" + flag);\n                            }\n                            p1 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            mciis.readBits(bitsPerFlag);\n                            if (flag != 0) {\n                                LOG.error(\"bad triangle: \" + flag);\n                            }\n                            p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            ps = new Point2D[]{ p0.point, p1.point, p2.point };\n                            cs = new float[][]{ p0.color, p1.color, p2.color };\n                            list.add(new ShadedTriangle(ps, cs));\n                            flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            break;\n                        case 1 :\n                        case 2 :\n                            lastIndex = list.size() - 1;\n                            if (lastIndex < 0) {\n                                LOG.error((\"broken data stream: \" + list.size()) + \", aborting\");\n                                eof = true;\n                            } else {\n                                ShadedTriangle preTri = list.get(lastIndex);\n                                p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                                ps = new Point2D[]{ flag == 1 ? preTri.corner[1] : preTri.corner[0], preTri.corner[2], p2.point };\n                                cs = new float[][]{ flag == 1 ? preTri.color[1] : preTri.color[0], preTri.color[2], p2.color };\n                                list.add(new ShadedTriangle(ps, cs));\n                                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            }\n                            break;\n                        default :\n                            LOG.error((\"bad flag \" + flag) + \", aborting\");\n                            eof = true;\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.parseCOSName" ],
    "fullMethods" : [ "/**\n * Search for/parse the object with the given object number. The stream is closed after parsing the object with the\n * given number.\n *\n * @param objectNumber\n * \t\tthe number of the object to b e parsed\n * @return the parsed object or null if the object with the given number can't be found\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic COSBase parseObject(long objectNumber) throws IOException {\n    COSBase streamObject = null;\n    try {\n        Integer objectOffset = privateReadObjectNumbers().get(objectNumber);\n        if (objectOffset != null) {\n            // jump to the offset of the first object\n            long currentPosition = source.getPosition();\n            if ((firstObject > 0) && (currentPosition < firstObject)) {\n                source.skip(firstObject - ((int) (currentPosition)));\n            }\n            // jump to the offset of the object to be parsed\n            source.skip(objectOffset);\n            streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return streamObject;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "/**\n * This will parse a PDF name from the stream.\n *\n * @return The parsed PDF name.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected COSName parseCOSName() throws IOException {\n    readExpectedChar('/');\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int c = source.read();\n    while (!isEndOfName(c)) {\n        final int ch = c;\n        if (ch == '#') {\n            int ch1 = source.read();\n            int ch2 = source.read();\n            // Prior to PDF v1.2, the # was not a special character.  Also,\n            // it has been observed that various PDF tools do not follow the\n            // spec with respect to the # escape, even though they report\n            // PDF versions of 1.2 or later.  The solution here is that we\n            // interpret the # as an escape only when it is followed by two\n            // valid hex digits.\n            if (isHexDigit(((char) (ch1))) && isHexDigit(((char) (ch2)))) {\n                String hex = Character.toString(((char) (ch1))) + ((char) (ch2));\n                try {\n                    buffer.write(Integer.parseInt(hex, 16));\n                } catch (NumberFormatException e) {\n                    throw new IOException((\"Error: expected hex digit, actual='\" + hex) + \"'\", e);\n                }\n                c = source.read();\n            } else {\n                // check for premature EOF\n                if ((ch2 == (-1)) || (ch1 == (-1))) {\n                    LOG.error(\"Premature EOF in BaseParser#parseCOSName\");\n                    c = -1;\n                    break;\n                }\n                source.rewind(1);\n                c = ch1;\n                buffer.write(ch);\n            }\n        } else {\n            buffer.write(ch);\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n    return COSName.getPDFName(decodeBuffer(buffer));\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    return getBounds(xform, matrix, 16);\n}", "Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    Rectangle2D bounds = null;\n    for (Patch patch : collectPatches(xform, matrix, controlPoints)) {\n        for (ShadedTriangle shadedTriangle : patch.listOfTriangles) {\n            if (bounds == null) {\n                bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n            }\n            bounds.add(shadedTriangle.corner[0]);\n            bounds.add(shadedTriangle.corner[1]);\n            bounds.add(shadedTriangle.corner[2]);\n        }\n    }\n    return bounds;\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.DrawObject.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.DrawObject.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    if (arguments.isEmpty()) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    COSName name = ((COSName) (base0));\n    PDFStreamEngine context = getContext();\n    if (context.getResources().isImageXObject(name)) {\n        // we're done here, don't decode images when doing text extraction\n        return;\n    }\n    PDXObject xobject = context.getResources().getXObject(name);\n    if (xobject instanceof PDFormXObject) {\n        try {\n            context.increaseLevel();\n            if (context.getLevel() > 50) {\n                LOG.error(\"recursion is too deep, skipping form XObject\");\n                return;\n            }\n            if (xobject instanceof PDTransparencyGroup) {\n                context.showTransparencyGroup(((PDTransparencyGroup) (xobject)));\n            } else {\n                context.showForm(((PDFormXObject) (xobject)));\n            }\n        } finally {\n            context.decreaseLevel();\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getStencilImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getStencilImage", "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getDecodeArray" ],
    "fullMethods" : [ "/**\n * Returns an ARGB image filled with the given paint and using the given image as a mask.\n *\n * @param paint\n * \t\tthe paint to fill the visible portions of the image with\n * @return a masked image filled with the given paint\n * @throws IOException\n * \t\tif the image cannot be read\n * @throws IllegalStateException\n * \t\tif the image is not a stencil.\n */\npublic static BufferedImage getStencilImage(PDImage pdImage, Paint paint) throws IOException {\n    int width = pdImage.getWidth();\n    int height = pdImage.getHeight();\n    // compose to ARGB\n    BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    Graphics2D g = masked.createGraphics();\n    g.setPaint(paint);\n    g.fillRect(0, 0, width, height);\n    g.dispose();\n    // set the alpha\n    WritableRaster raster = masked.getRaster();\n    final int[] transparent = new int[4];\n    // avoid getting a BufferedImage for the mask to lessen memory footprint.\n    // Such masks are always bpc=1 and have no colorspace, but have a decode.\n    // (see 8.9.6.2 Stencil Masking)\n    try (InputStream iis = pdImage.createInputStream()) {\n        final float[] decode = getDecodeArray(pdImage);\n        int value = (decode[0] < decode[1]) ? 1 : 0;\n        int rowLen = width / 8;\n        if ((width % 8) > 0) {\n            rowLen++;\n        }\n        byte[] buff = new byte[rowLen];\n        for (int y = 0; y < height; y++) {\n            int x = 0;\n            int readLen = ((int) (IOUtils.populateBuffer(iis, buff)));\n            for (int r = 0; (r < rowLen) && (r < readLen); r++) {\n                int byteValue = buff[r];\n                int mask = 128;\n                int shift = 7;\n                for (int i = 0; i < 8; i++) {\n                    int bit = (byteValue & mask) >> shift;\n                    mask >>= 1;\n                    --shift;\n                    if (bit == value) {\n                        raster.setPixel(x, y, transparent);\n                    }\n                    x++;\n                    if (x == width) {\n                        break;\n                    }\n                }\n            }\n            if (readLen != rowLen) {\n                LOG.warn(\"premature EOF, image will be incomplete\");\n                break;\n            }\n        }\n    }\n    return masked;\n}", "// gets decode array from dictionary or returns default\nprivate static float[] getDecodeArray(PDImage pdImage) throws IOException {\n    final COSArray cosDecode = pdImage.getDecode();\n    float[] decode = null;\n    if (cosDecode != null) {\n        int numberOfComponents = pdImage.getColorSpace().getNumberOfComponents();\n        if (cosDecode.size() != (numberOfComponents * 2)) {\n            if (((pdImage.isStencil() && (cosDecode.size() >= 2)) && (cosDecode.get(0) instanceof COSNumber)) && (cosDecode.get(1) instanceof COSNumber)) {\n                float decode0 = ((COSNumber) (cosDecode.get(0))).floatValue();\n                float decode1 = ((COSNumber) (cosDecode.get(1))).floatValue();\n                if ((((decode0 >= 0) && (decode0 <= 1)) && (decode1 >= 0)) && (decode1 <= 1)) {\n                    LOG.warn((\"decode array \" + cosDecode) + \" not compatible with color space, using the first two entries\");\n                    return new float[]{ decode0, decode1 };\n                }\n            }\n            LOG.error((\"decode array \" + cosDecode) + \" not compatible with color space, using default\");\n        } else {\n            decode = cosDecode.toFloatArray();\n        }\n    }\n    // use color space default\n    if (decode == null) {\n        return pdImage.getColorSpace().getDefaultDecode(pdImage.getBitsPerComponent());\n    }\n    return decode;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4.collectTriangles" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type4ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param cm\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n */\nType4ShadingContext(PDShadingType4 shading, ColorModel cm, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, cm, xform, matrix);\n    LOG.debug(\"Type4ShadingContext\");\n    bitsPerFlag = shading.getBitsPerFlag();\n    // TODO handle cases where bitperflag isn't 8\n    LOG.debug(\"bitsPerFlag: \" + bitsPerFlag);\n    setTriangleList(shading.collectTriangles(xform, matrix));\n    createPixelTable(deviceBounds);\n}", "@SuppressWarnings(\"squid:S1166\")\n@Override\nList<ShadedTriangle> collectTriangles(AffineTransform xform, Matrix matrix) throws IOException {\n    int bitsPerFlag = getBitsPerFlag();\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<ShadedTriangle> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            byte flag = ((byte) (0));\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n            }\n            boolean eof = false;\n            while (!eof) {\n                Vertex p0;\n                Vertex p1;\n                Vertex p2;\n                Point2D[] ps;\n                float[][] cs;\n                int lastIndex;\n                try {\n                    switch (flag) {\n                        case 0 :\n                            p0 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            if (flag != 0) {\n                                LOG.error(\"bad triangle: \" + flag);\n                            }\n                            p1 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            mciis.readBits(bitsPerFlag);\n                            if (flag != 0) {\n                                LOG.error(\"bad triangle: \" + flag);\n                            }\n                            p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                            ps = new Point2D[]{ p0.point, p1.point, p2.point };\n                            cs = new float[][]{ p0.color, p1.color, p2.color };\n                            list.add(new ShadedTriangle(ps, cs));\n                            flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            break;\n                        case 1 :\n                        case 2 :\n                            lastIndex = list.size() - 1;\n                            if (lastIndex < 0) {\n                                LOG.error((\"broken data stream: \" + list.size()) + \", aborting\");\n                                eof = true;\n                            } else {\n                                ShadedTriangle preTri = list.get(lastIndex);\n                                p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);\n                                ps = new Point2D[]{ flag == 1 ? preTri.corner[1] : preTri.corner[0], preTri.corner[2], p2.point };\n                                cs = new float[][]{ flag == 1 ? preTri.color[1] : preTri.color[0], preTri.color[2], p2.color };\n                                list.add(new ShadedTriangle(ps, cs));\n                                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                            }\n                            break;\n                        default :\n                            LOG.error((\"bad flag \" + flag) + \", aborting\");\n                            eof = true;\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont" ],
    "fullMethods" : [ "/**\n * Creates a new PDFont instance with the appropriate subclass.\n *\n * @param dictionary\n * \t\ta font dictionary\n * @param resourceCache\n * \t\tresource cache, only useful for type 3 fonts, can be null\n * @return a PDFont instance, based on the SubType entry of the dictionary\n * @throws IOException\n * \t\tif something goes wrong\n */\npublic static PDFont createFont(COSDictionary dictionary, ResourceCache resourceCache) throws IOException {\n    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);\n    if (!COSName.FONT.equals(type)) {\n        LOG.error((\"Expected 'Font' dictionary but found '\" + type.getName()) + \"'\");\n    }\n    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);\n    if (COSName.TYPE1.equals(subType)) {\n        COSDictionary fd = dictionary.getCOSDictionary(COSName.FONT_DESC);\n        if ((fd != null) && fd.containsKey(COSName.FONT_FILE3)) {\n            return new PDType1CFont(dictionary);\n        }\n        return new PDType1Font(dictionary);\n    } else if (COSName.MM_TYPE1.equals(subType)) {\n        COSDictionary fd = dictionary.getCOSDictionary(COSName.FONT_DESC);\n        if ((fd != null) && fd.containsKey(COSName.FONT_FILE3)) {\n            return new PDType1CFont(dictionary);\n        }\n        return new PDMMType1Font(dictionary);\n    } else if (COSName.TRUE_TYPE.equals(subType)) {\n        return new PDTrueTypeFont(dictionary);\n    } else if (COSName.TYPE3.equals(subType)) {\n        return new PDType3Font(dictionary, resourceCache);\n    } else if (COSName.TYPE0.equals(subType)) {\n        COSDictionary fontDescriptor = getFontDescriptor(dictionary);\n        FontType fontTypeFromFont = getFontTypeFromFont(fontDescriptor, subType);\n        if (fontTypeFromFont != null) {\n            COSDictionary descendantFont = getDescendantFont(dictionary);\n            COSName descFontType = (descendantFont != null) ? descendantFont.getCOSName(COSName.SUBTYPE) : null;\n            if ((descFontType != null) && (!fontTypeFromFont.isCIDSubtype(descFontType))) {\n                fixType0Subtype(descendantFont, fontDescriptor, fontTypeFromFont.getSubtype());\n            }\n        }\n        return new PDType0Font(dictionary);\n    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {\n        throw new IOException(\"Type 0 descendant font not allowed\");\n    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {\n        throw new IOException(\"Type 2 descendant font not allowed\");\n    } else {\n        // assuming Type 1 font (see PDFBOX-1988) because it seems that Adobe Reader does this\n        // however, we may need more sophisticated logic perhaps looking at the FontFile\n        LOG.warn((\"Invalid font subtype '\" + subType) + \"'\");\n        return new PDType1Font(dictionary);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.parseCOSName" ],
    "fullMethods" : [ "/**\n * Parse all compressed objects. The stream is closed after parsing.\n *\n * @return a map containing all parsed objects using the object number as key\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic Map<COSObjectKey, COSBase> parseAllObjects() throws IOException {\n    Map<COSObjectKey, COSBase> allObjects = new HashMap<>();\n    try {\n        Map<Integer, Long> objectNumbers = privateReadObjectOffsets();\n        // count the number of object numbers eliminating double entries\n        long numberOfObjNumbers = objectNumbers.values().stream().distinct().count();\n        // the usage of the index should be restricted to cases where more than one\n        // object use the same object number.\n        // there are malformed pdfs in the wild which would lead to false results if\n        // pdfbox always relies on the index if available. In most cases the object number\n        // is sufficient to choose the correct object\n        boolean indexNeeded = objectNumbers.size() > numberOfObjNumbers;\n        long currentPosition = source.getPosition();\n        if ((firstObject > 0) && (currentPosition < firstObject)) {\n            source.skip(firstObject - ((int) (currentPosition)));\n        }\n        int index = 0;\n        for (Entry<Integer, Long> entry : objectNumbers.entrySet()) {\n            COSObjectKey objectKey = getObjectKey(entry.getValue(), 0);\n            // skip object if the index doesn't match\n            if ((indexNeeded && (objectKey.getStreamIndex() > (-1))) && (objectKey.getStreamIndex() != index)) {\n                index++;\n                continue;\n            }\n            int finalPosition = firstObject + entry.getKey();\n            currentPosition = source.getPosition();\n            if ((finalPosition > 0) && (currentPosition < finalPosition)) {\n                // jump to the offset of the object to be parsed\n                source.skip(finalPosition - ((int) (currentPosition)));\n            }\n            COSBase streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n            allObjects.put(objectKey, streamObject);\n            index++;\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return allObjects;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "/**\n * This will parse a PDF name from the stream.\n *\n * @return The parsed PDF name.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected COSName parseCOSName() throws IOException {\n    readExpectedChar('/');\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int c = source.read();\n    while (!isEndOfName(c)) {\n        final int ch = c;\n        if (ch == '#') {\n            int ch1 = source.read();\n            int ch2 = source.read();\n            // Prior to PDF v1.2, the # was not a special character.  Also,\n            // it has been observed that various PDF tools do not follow the\n            // spec with respect to the # escape, even though they report\n            // PDF versions of 1.2 or later.  The solution here is that we\n            // interpret the # as an escape only when it is followed by two\n            // valid hex digits.\n            if (isHexDigit(((char) (ch1))) && isHexDigit(((char) (ch2)))) {\n                String hex = Character.toString(((char) (ch1))) + ((char) (ch2));\n                try {\n                    buffer.write(Integer.parseInt(hex, 16));\n                } catch (NumberFormatException e) {\n                    throw new IOException((\"Error: expected hex digit, actual='\" + hex) + \"'\", e);\n                }\n                c = source.read();\n            } else {\n                // check for premature EOF\n                if ((ch2 == (-1)) || (ch1 == (-1))) {\n                    LOG.error(\"Premature EOF in BaseParser#parseCOSName\");\n                    c = -1;\n                    break;\n                }\n                source.rewind(1);\n                c = ch1;\n                buffer.write(ch);\n            }\n        } else {\n            buffer.write(ch);\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n    return COSName.getPDFName(decodeBuffer(buffer));\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Hex.decodeHex",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Hex.decodeHex" ],
    "fullMethods" : [ "/**\n * Decodes a hex String into a byte array.\n *\n * @param s\n * \t\tA String with ASCII hex.\n * @return decoded byte array.\n */\npublic static byte[] decodeHex(String s) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream((s.length() + 1) / 2);\n    int i = 0;\n    while (i < (s.length() - 1)) {\n        if ((s.charAt(i) == '\\n') || (s.charAt(i) == '\\r')) {\n            ++i;\n        } else {\n            int value = (16 * getHexValue(s.charAt(i))) + getHexValue(s.charAt(i + 1));\n            if (value >= 0) {\n                baos.write(value);\n            } else {\n                String hexByte = s.substring(i, i + 2);\n                LOG.error((\"Can't parse \" + hexByte) + \", aborting decode\");\n                break;\n            }\n            i += 2;\n        }\n    } \n    return baos.toByteArray();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCaretAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDCaretAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationCaret annotation = ((PDAnnotationCaret) (getAnnotation()));\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        PDColor color = getColor();\n        contentStream.setStrokingColor(color);\n        contentStream.setNonStrokingColor(color);\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        PDRectangle rect = getRectangle();\n        float rectWidth = rect.getWidth();\n        float rectHeight = rect.getHeight();\n        PDRectangle bbox = new PDRectangle(rectWidth, rectHeight);\n        PDAppearanceStream pdAppearanceStream = annotation.getNormalAppearanceStream();\n        if (!annotation.getCOSObject().containsKey(COSName.RD)) {\n            // Adobe creates the /RD entry with a number that is decided\n            // by dividing the height by 10, with a maximum result of 5.\n            // That number is then used to enlarge the bbox and the rectangle and added to the\n            // translation values in the matrix and also used for the line width\n            // (not here because it has no effect, see comment near fill() ).\n            // The curves are based on the original rectangle.\n            float rd = Math.min(rectHeight / 10, 5);\n            annotation.setRectDifferences(rd);\n            bbox = new PDRectangle(-rd, -rd, rectWidth + (2 * rd), rectHeight + (2 * rd));\n            Matrix matrix = pdAppearanceStream.getMatrix();\n            pdAppearanceStream.setMatrix(matrix.createAffineTransform());\n            PDRectangle rect2 = new PDRectangle(rect.getLowerLeftX() - rd, rect.getLowerLeftY() - rd, rectWidth + (2 * rd), rectHeight + (2 * rd));\n            annotation.setRectangle(rect2);\n        }\n        pdAppearanceStream.setBBox(bbox);\n        float halfX = rectWidth / 2;\n        float halfY = rectHeight / 2;\n        contentStream.moveTo(0, 0);\n        contentStream.curveTo(halfX, 0, halfX, halfY, halfX, rectHeight);\n        contentStream.curveTo(halfX, halfY, halfX, 0, rectWidth, 0);\n        contentStream.closePath();\n        contentStream.fill();\n        // Adobe has an additional stroke, but it has no effect\n        // because fill \"consumes\" the path.\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.fillPath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.fillPath", "org.apache.pdfbox.rendering.PageDrawer.getNonStrokingPaint", "org.apache.pdfbox.rendering.PageDrawer.getPaint" ],
    "fullMethods" : [ "@Override\npublic void fillPath(int windingRule) throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    graphics.setComposite(graphicsState.getNonStrokingJavaComposite());\n    setClip();\n    linePath.setWindingRule(windingRule);\n    // disable anti-aliasing for rectangular paths, this is a workaround to avoid small stripes\n    // which occur when solid fills are used to simulate piecewise gradients, see PDFBOX-2302\n    // note that we ignore paths with a width/height under 1 as these are fills used as strokes,\n    // see PDFBOX-1658 for an example\n    Rectangle2D bounds = linePath.getBounds2D();\n    boolean noAntiAlias = (isRectangular(linePath) && (bounds.getWidth() > 1)) && (bounds.getHeight() > 1);\n    if (noAntiAlias) {\n        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n    }\n    Shape shape;\n    if (graphicsState.getNonStrokingColorSpace() instanceof PDPattern) {\n        // apply clip to path to avoid oversized device bounds in shading contexts (PDFBOX-2901)\n        Area area = new Area(linePath);\n        Shape clip = graphics.getClip();\n        if (clip != null) {\n            area.intersect(new Area(clip));\n        }\n        intersectShadingBBox(graphicsState.getNonStrokingColor(), area);\n        shape = area;\n    } else {\n        shape = linePath;\n    }\n    if (isContentRendered() && (!shape.getPathIterator(null).isDone())) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        graphics.setPaint(getNonStrokingPaint());\n        graphics.fill(shape);\n    }\n    linePath.reset();\n    if (noAntiAlias) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "/**\n * Returns the non-stroking AWT Paint. You may need to call this if you override\n * {@link #showGlyph(Matrix, PDFont, int, Vector) showGlyph()}. See\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-5093\">PDFBOX-5093</a> for more.\n *\n * @return The non-stroking AWT Paint.\n * @throws IOException\n * \t\tif the non-stroking AWT Paint could not be created\n */\nprotected final Paint getNonStrokingPaint() throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    return applySoftMaskToPaint(getPaint(graphicsState.getNonStrokingColor()), graphicsState.getSoftMask());\n}", "/**\n * Returns an AWT paint for the given PDColor.\n *\n * @param color\n * \t\tThe color to get a paint for. This can be an actual color or a pattern.\n * @return an AWT paint for the given PDColor\n * @throws IOException\n * \t\tif the AWT paint could not be created\n */\nprotected Paint getPaint(PDColor color) throws IOException {\n    PDColorSpace colorSpace = color.getColorSpace();\n    // PDFBOX-5782\n    if (colorSpace == null) {\n        LOG.error(\"colorSpace is null, will be rendered as transparency\");\n        return new Color(0, 0, 0, 0);\n    } else if ((colorSpace instanceof PDSeparation) && \"None\".equals(((PDSeparation) (colorSpace)).getColorantName())) {\n        // PDFBOX-4900: \"The special colorant name None shall not produce any visible output\"\n        // TODO better solution needs to be found for all occurences where toRGB is called\n        return new Color(0, 0, 0, 0);\n    } else if (!(colorSpace instanceof PDPattern)) {\n        float[] rgb = colorSpace.toRGB(color.getComponents());\n        return new Color(clampColor(rgb[0]), clampColor(rgb[1]), clampColor(rgb[2]));\n    } else {\n        PDPattern patternSpace = ((PDPattern) (colorSpace));\n        PDAbstractPattern pattern = patternSpace.getPattern(color);\n        if (pattern instanceof PDTilingPattern) {\n            PDTilingPattern tilingPattern = ((PDTilingPattern) (pattern));\n            if (tilingPattern.getPaintType() == PDTilingPattern.PAINT_COLORED) {\n                // colored tiling pattern\n                return tilingPaintFactory.create(tilingPattern, null, null, xform);\n            } else {\n                // uncolored tiling pattern\n                return tilingPaintFactory.create(tilingPattern, patternSpace.getUnderlyingColorSpace(), color, xform);\n            }\n        } else {\n            PDShadingPattern shadingPattern = ((PDShadingPattern) (pattern));\n            PDShading shading = shadingPattern.getShading();\n            if (shading == null) {\n                LOG.error(\"shadingPattern is null, will be filled with transparency\");\n                return new Color(0, 0, 0, 0);\n            }\n            return shading.toPaint(Matrix.concatenate(getInitialMatrix(), shadingPattern.getMatrix()));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.iterator",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.iterator", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.FieldIterator.<init>", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.FieldIterator.<init>", "org.apache.pdfbox.pdmodel.interactive.form.PDFieldTree.FieldIterator.enqueueKids" ],
    "fullMethods" : [ "/**\n * Returns an iterator which walks all fields in the tree, in order.\n */\n@Override\npublic Iterator<PDField> iterator() {\n    return new FieldIterator(acroForm);\n}", "private FieldIterator(PDAcroForm form) {\n    List<PDField> fields = form.getFields();\n    for (PDField field : fields) {\n        enqueueKids(field);\n    }\n}", "private FieldIterator(PDAcroForm form) {\n    List<PDField> fields = form.getFields();\n    for (PDField field : fields) {\n        enqueueKids(field);\n    }\n}", "private void enqueueKids(PDField node) {\n    queue.add(node);\n    set.add(node.getCOSObject());\n    if (node instanceof PDNonTerminalField) {\n        List<PDField> kids = ((PDNonTerminalField) (node)).getChildren();\n        for (PDField kid : kids) {\n            if (set.contains(kid.getCOSObject())) {\n                LOG.error((\"Child of field '\" + node.getFullyQualifiedName()) + \"' already exists elsewhere, ignored to avoid recursion\");\n            } else {\n                enqueueKids(kid);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.strokePath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.strokePath", "org.apache.pdfbox.rendering.PageDrawer.getStrokingPaint", "org.apache.pdfbox.rendering.PageDrawer.getPaint" ],
    "fullMethods" : [ "@Override\npublic void strokePath() throws IOException {\n    if (isContentRendered()) {\n        graphics.setComposite(getGraphicsState().getStrokingJavaComposite());\n        graphics.setPaint(getStrokingPaint());\n        graphics.setStroke(getStroke());\n        setClip();\n        graphics.draw(linePath);\n    }\n    linePath.reset();\n}", "// returns the stroking AWT Paint\nprivate Paint getStrokingPaint() throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    return applySoftMaskToPaint(getPaint(graphicsState.getStrokingColor()), graphicsState.getSoftMask());\n}", "/**\n * Returns an AWT paint for the given PDColor.\n *\n * @param color\n * \t\tThe color to get a paint for. This can be an actual color or a pattern.\n * @return an AWT paint for the given PDColor\n * @throws IOException\n * \t\tif the AWT paint could not be created\n */\nprotected Paint getPaint(PDColor color) throws IOException {\n    PDColorSpace colorSpace = color.getColorSpace();\n    // PDFBOX-5782\n    if (colorSpace == null) {\n        LOG.error(\"colorSpace is null, will be rendered as transparency\");\n        return new Color(0, 0, 0, 0);\n    } else if ((colorSpace instanceof PDSeparation) && \"None\".equals(((PDSeparation) (colorSpace)).getColorantName())) {\n        // PDFBOX-4900: \"The special colorant name None shall not produce any visible output\"\n        // TODO better solution needs to be found for all occurences where toRGB is called\n        return new Color(0, 0, 0, 0);\n    } else if (!(colorSpace instanceof PDPattern)) {\n        float[] rgb = colorSpace.toRGB(color.getComponents());\n        return new Color(clampColor(rgb[0]), clampColor(rgb[1]), clampColor(rgb[2]));\n    } else {\n        PDPattern patternSpace = ((PDPattern) (colorSpace));\n        PDAbstractPattern pattern = patternSpace.getPattern(color);\n        if (pattern instanceof PDTilingPattern) {\n            PDTilingPattern tilingPattern = ((PDTilingPattern) (pattern));\n            if (tilingPattern.getPaintType() == PDTilingPattern.PAINT_COLORED) {\n                // colored tiling pattern\n                return tilingPaintFactory.create(tilingPattern, null, null, xform);\n            } else {\n                // uncolored tiling pattern\n                return tilingPaintFactory.create(tilingPattern, patternSpace.getUnderlyingColorSpace(), color, xform);\n            }\n        } else {\n            PDShadingPattern shadingPattern = ((PDShadingPattern) (pattern));\n            PDShading shading = shadingPattern.getShading();\n            if (shading == null) {\n                LOG.error(\"shadingPattern is null, will be filled with transparency\");\n                return new Color(0, 0, 0, 0);\n            }\n            return shading.toPaint(Matrix.concatenate(getInitialMatrix(), shadingPattern.getMatrix()));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject", "org.apache.pdfbox.pdfparser.COSParser.parseObjectDynamically", "org.apache.pdfbox.pdfparser.COSParser.parseFileObject", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.parseCOSName" ],
    "fullMethods" : [ "@Override\npublic COSBase dereferenceCOSObject(COSObject obj) throws IOException {\n    long currentPos = source.getPosition();\n    COSObjectKey key = obj.getKey();\n    COSBase parsedObj = parseObjectDynamically(key, false);\n    if (parsedObj != null) {\n        parsedObj.setDirect(false);\n        parsedObj.setKey(key);\n    }\n    if (currentPos > 0) {\n        source.seek(currentPos);\n    }\n    return parsedObj;\n}", "/**\n * Parse the object for the given object key.\n *\n * @param objKey\n * \t\tkey of object to be parsed\n * @param requireExistingNotCompressedObj\n * \t\tif <code>true</code> the object to be parsed must be defined in xref\n * \t\t(comment: null objects may be missing from xref) and it must not be a compressed object within object stream\n * \t\t(this is used to circumvent being stuck in a loop in a malicious PDF)\n * @return the parsed object (which is also added to document object)\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprotected synchronized COSBase parseObjectDynamically(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    COSObject pdfObject = document.getObjectFromPool(objKey);\n    if (!pdfObject.isObjectNull()) {\n        return pdfObject.getObject();\n    }\n    Long offsetOrObjstmObNr = getObjectOffset(objKey, requireExistingNotCompressedObj);\n    COSBase referencedObject = null;\n    if (offsetOrObjstmObNr != null) {\n        if (offsetOrObjstmObNr > 0) {\n            referencedObject = parseFileObject(offsetOrObjstmObNr, objKey);\n        } else {\n            // xref value is object nr of object stream containing object to be parsed\n            // since our object was not found it means object stream was not parsed so far\n            referencedObject = parseObjectStreamObject(-offsetOrObjstmObNr, objKey);\n        }\n    }\n    if ((referencedObject == null) || (referencedObject instanceof COSNull)) {\n        // not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)\n        // or some other issue with dereferencing\n        // remove parser to avoid endless recursion\n        pdfObject.setToNull();\n    }\n    return referencedObject;\n}", "private COSBase parseFileObject(Long objOffset, final COSObjectKey objKey) throws IOException {\n    // jump to the object start\n    source.seek(objOffset);\n    // an indirect object starts with the object number/generation number\n    final long readObjNr = readObjectNumber();\n    final int readObjGen = readGenerationNumber();\n    readExpectedString(OBJ_MARKER, true);\n    // consistency check\n    if ((readObjNr != objKey.getNumber()) || (readObjGen != objKey.getGeneration())) {\n        throw new IOException(((((((((\"XREF for \" + objKey.getNumber()) + \":\") + objKey.getGeneration()) + \" points to wrong object: \") + readObjNr) + \":\") + readObjGen) + \" at offset \") + objOffset);\n    }\n    skipSpaces();\n    COSBase parsedObject = parseDirObject();\n    if (parsedObject != null) {\n        parsedObject.setDirect(false);\n        parsedObject.setKey(objKey);\n    }\n    String endObjectKey = readString();\n    if (endObjectKey.equals(STREAM_STRING)) {\n        source.rewind(endObjectKey.getBytes(StandardCharsets.ISO_8859_1).length);\n        if (parsedObject instanceof COSDictionary) {\n            COSStream stream = parseCOSStream(((COSDictionary) (parsedObject)));\n            if (securityHandler != null) {\n                securityHandler.decryptStream(stream, objKey.getNumber(), objKey.getGeneration());\n            }\n            parsedObject = stream;\n        } else {\n            // this is not legal\n            // the combination of a dict and the stream/endstream\n            // forms a complete stream object\n            throw new IOException((\"Stream not preceded by dictionary (offset: \" + objOffset) + \").\");\n        }\n        skipSpaces();\n        endObjectKey = readLine();\n        // we have case with a second 'endstream' before endobj\n        if ((!endObjectKey.startsWith(ENDOBJ_STRING)) && endObjectKey.startsWith(ENDSTREAM_STRING)) {\n            endObjectKey = endObjectKey.substring(9).trim();\n            if (endObjectKey.length() == 0) {\n                // no other characters in extra endstream line\n                // read next line\n                endObjectKey = readLine();\n            }\n        }\n    } else if (securityHandler != null) {\n        securityHandler.decrypt(parsedObject, objKey.getNumber(), objKey.getGeneration());\n    }\n    if (!endObjectKey.startsWith(ENDOBJ_STRING)) {\n        if (isLenient) {\n            LOG.warn((((((((\"Object (\" + readObjNr) + \":\") + readObjGen) + \") at offset \") + objOffset) + \" does not end with 'endobj' but with '\") + endObjectKey) + \"'\");\n        } else {\n            throw new IOException((((((((\"Object (\" + readObjNr) + \":\") + readObjGen) + \") at offset \") + objOffset) + \" does not end with 'endobj' but with '\") + endObjectKey) + \"'\");\n        }\n    }\n    return parsedObject;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "/**\n * This will parse a PDF name from the stream.\n *\n * @return The parsed PDF name.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected COSName parseCOSName() throws IOException {\n    readExpectedChar('/');\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int c = source.read();\n    while (!isEndOfName(c)) {\n        final int ch = c;\n        if (ch == '#') {\n            int ch1 = source.read();\n            int ch2 = source.read();\n            // Prior to PDF v1.2, the # was not a special character.  Also,\n            // it has been observed that various PDF tools do not follow the\n            // spec with respect to the # escape, even though they report\n            // PDF versions of 1.2 or later.  The solution here is that we\n            // interpret the # as an escape only when it is followed by two\n            // valid hex digits.\n            if (isHexDigit(((char) (ch1))) && isHexDigit(((char) (ch2)))) {\n                String hex = Character.toString(((char) (ch1))) + ((char) (ch2));\n                try {\n                    buffer.write(Integer.parseInt(hex, 16));\n                } catch (NumberFormatException e) {\n                    throw new IOException((\"Error: expected hex digit, actual='\" + hex) + \"'\", e);\n                }\n                c = source.read();\n            } else {\n                // check for premature EOF\n                if ((ch2 == (-1)) || (ch1 == (-1))) {\n                    LOG.error(\"Premature EOF in BaseParser#parseCOSName\");\n                    c = -1;\n                    break;\n                }\n                source.rewind(1);\n                c = ch1;\n                buffer.write(ch);\n            }\n        } else {\n            buffer.write(ch);\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n    return COSName.getPDFName(decodeBuffer(buffer));\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.state.SetGraphicsStateParameters.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.state.SetGraphicsStateParameters.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    if (arguments.isEmpty()) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    // set parameters from graphics state parameter dictionary\n    COSName graphicsName = ((COSName) (base0));\n    PDFStreamEngine context = getContext();\n    PDExtendedGraphicsState gs = context.getResources().getExtGState(graphicsName);\n    if (gs == null) {\n        LOG.error(\"name for 'gs' operator not found in resources: /\" + graphicsName.getName());\n        return;\n    }\n    gs.copyIntoGraphicsState(context.getGraphicsState());\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.JBIG2Filter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.JBIG2Filter.decode", "org.apache.pdfbox.filter.Filter.getDecodeParams" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException {\n    ImageReader reader = findImageReader(\"JBIG2\", \"jbig2-imageio is not installed\");\n    if (reader.getClass().getName().contains(\"levigo\")) {\n        logLevigoDonated();\n    }\n    int bits = parameters.getInt(COSName.BITS_PER_COMPONENT, 1);\n    COSDictionary params = getDecodeParams(parameters, index);\n    ImageReadParam irp = reader.getDefaultReadParam();\n    irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());\n    irp.setSourceRegion(options.getSourceRegion());\n    options.setFilterSubsampled(true);\n    InputStream source = encoded;\n    if (params != null) {\n        COSStream globals = params.getCOSStream(COSName.JBIG2_GLOBALS);\n        if (globals != null) {\n            source = new SequenceInputStream(globals.createInputStream(), encoded);\n        }\n    }\n    try (ImageInputStream iis = ImageIO.createImageInputStream(source)) {\n        reader.setInput(iis);\n        BufferedImage image;\n        try {\n            image = reader.read(0, irp);\n        } catch (Exception e) {\n            // wrap and rethrow any exceptions\n            throw new IOException(\"Could not read JBIG2 image\", e);\n        }\n        // I am assuming since JBIG2 is always black and white\n        // depending on your renderer this might or might be needed\n        if (image.getColorModel().getPixelSize() != bits) {\n            if (bits != 1) {\n                LOG.warn(\"Attempting to handle a JBIG2 with more than 1-bit depth\");\n            }\n            BufferedImage packedImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);\n            Graphics graphics = packedImage.getGraphics();\n            graphics.drawImage(image, 0, 0, null);\n            graphics.dispose();\n            image = packedImage;\n        }\n        DataBuffer dBuf = image.getData().getDataBuffer();\n        if (dBuf.getDataType() == DataBuffer.TYPE_BYTE) {\n            decoded.write(((DataBufferByte) (dBuf)).getData());\n        } else {\n            throw new IOException(\"Unexpected image buffer type\");\n        }\n    } finally {\n        reader.dispose();\n    }\n    return new DecodeResult(parameters);\n}", "// gets the decode params for a specific filter index, this is used to\n// normalise the DecodeParams entry so that it is always a dictionary\nprotected COSDictionary getDecodeParams(COSDictionary dictionary, int index) {\n    COSBase filter = dictionary.getDictionaryObject(COSName.F, COSName.FILTER);\n    COSBase obj = dictionary.getDictionaryObject(COSName.DP, COSName.DECODE_PARMS);\n    if ((filter instanceof COSName) && (obj instanceof COSDictionary)) {\n        // PDFBOX-3932: The PDF specification requires \"If there is only one filter and that\n        // filter has parameters, DecodeParms shall be set to the filterâs parameter dictionary\"\n        // but tests show that Adobe means \"one filter name object\".\n        return ((COSDictionary) (obj));\n    } else if ((filter instanceof COSArray) && (obj instanceof COSArray)) {\n        COSArray array = ((COSArray) (obj));\n        if (index < array.size()) {\n            COSBase objAtIndex = array.getObject(index);\n            if (objAtIndex instanceof COSDictionary) {\n                return ((COSDictionary) (objAtIndex));\n            }\n        }\n    } else if ((obj != null) && (!((filter instanceof COSArray) || (obj instanceof COSArray)))) {\n        LOG.error(\"Expected DecodeParams to be an Array or Dictionary but found \" + obj.getClass().getName());\n    }\n    return new COSDictionary();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.IntPoint.equals",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.IntPoint.equals" ],
    "fullMethods" : [ "@Override\npublic boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        if (obj instanceof Point2D) {\n            // hitting this branch means that the warning on top of the class wasn't read\n            LOG.error(\"IntPoint should not be used together with its base class\");\n        }\n        return false;\n    }\n    final IntPoint other = ((IntPoint) (obj));\n    return (this.x == other.x) && (this.y == other.y);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings" ],
    "fullMethods" : [ "/**\n * Called when a string of text with spacing adjustments is to be shown.\n *\n * @param array\n * \t\tarray of encoded text strings and adjustments\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextStrings(COSArray array) throws IOException {\n    PDTextState textState = getGraphicsState().getTextState();\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    PDFont font = textState.getFont();\n    boolean isVertical = false;\n    if (font != null) {\n        isVertical = font.isVertical();\n    }\n    for (COSBase obj : array) {\n        if (obj instanceof COSNumber) {\n            float tj = ((COSNumber) (obj)).floatValue();\n            // calculate the combined displacements\n            float tx;\n            float ty;\n            if (isVertical) {\n                tx = 0;\n                ty = ((-tj) / 1000) * fontSize;\n            } else {\n                tx = (((-tj) / 1000) * fontSize) * horizontalScaling;\n                ty = 0;\n            }\n            applyTextAdjustment(tx, ty);\n        } else if (obj instanceof COSString) {\n            byte[] string = ((COSString) (obj)).getBytes();\n            showText(string);\n        } else if (obj instanceof COSArray) {\n            LOG.error(\"Nested arrays are not allowed in an array for TJ operation: \" + obj);\n        } else {\n            LOG.error(((\"Unknown type \" + obj.getClass().getSimpleName()) + \" in array for TJ operation: \") + obj);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquareAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquareAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    float lineWidth = getLineWidth();\n    PDAnnotationSquare annotation = ((PDAnnotationSquare) (getAnnotation()));\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());\n        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();\n        if ((borderEffect != null) && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {\n            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());\n            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());\n            annotation.setRectangle(cloudyBorder.getRectangle());\n            annotation.setRectDifference(cloudyBorder.getRectDifference());\n            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n            appearanceStream.setBBox(cloudyBorder.getBBox());\n            appearanceStream.setMatrix(cloudyBorder.getMatrix());\n        } else {\n            PDRectangle borderBox = handleBorderBox(annotation, lineWidth);\n            contentStream.addRect(borderBox.getLowerLeftX(), borderBox.getLowerLeftY(), borderBox.getWidth(), borderBox.getHeight());\n        }\n        contentStream.drawShape(lineWidth, hasStroke, hasBackground);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquigglyAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDSquigglyAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationSquiggly annotation = ((PDAnnotationSquiggly) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getQuadPoints();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    if (Float.compare(ab.width, 0) == 0) {\n        // value found in adobe reader\n        ab.width = 1.5F;\n    }\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    // TODO in a class structure this should be overridable\n    // this is similar to polyline but different data type\n    // all coordinates (unlike painting) are used because I'm lazy\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    rect.setLowerLeftX(Math.min(minX - (ab.width / 2), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width / 2), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width / 2), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width / 2), rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        cs.setStrokingColor(color);\n        // TODO we ignore dash pattern and line width for now. Do they have any effect?\n        // quadpoints spec is incorrect\n        // https://stackoverflow.com/questions/9855814/pdf-spec-vs-acrobat-creation-quadpoints\n        for (int i = 0; i < (pathsArray.length / 8); ++i) {\n            // Adobe uses a fixed pattern that assumes a height of 40, and it transforms to that height\n            // horizontally and the same / 1.8 vertically.\n            // translation apparently based on bottom left, but slightly different in Adobe\n            // TODO what if the annotation is not horizontal?\n            float height = pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5];\n            cs.transform(new Matrix(height / 40.0F, 0, 0, (height / 40.0F) / 1.8F, pathsArray[(i * 8) + 4], pathsArray[(i * 8) + 5]));\n            // Create form, BBox is mostly fixed, except for the horizontal size which is\n            // horizontal size divided by the horizontal transform factor from above\n            // (almost)\n            PDFormXObject form = new PDFormXObject(createCOSStream());\n            form.setBBox(new PDRectangle(-0.5F, -0.5F, (((pathsArray[(i * 8) + 2] - pathsArray[i * 8]) / height) * 40.0F) + 0.5F, 13));\n            form.setResources(new PDResources());\n            form.setMatrix(AffineTransform.getTranslateInstance(0.5F, 0.5F));\n            cs.drawForm(form);\n            try (PDFormContentStream formCS = new PDFormContentStream(form)) {\n                PDTilingPattern pattern = new PDTilingPattern();\n                pattern.setBBox(new PDRectangle(0, 0, 10, 12));\n                pattern.setXStep(10);\n                pattern.setYStep(13);\n                pattern.setTilingType(PDTilingPattern.TILING_CONSTANT_SPACING_FASTER_TILING);\n                pattern.setPaintType(PDTilingPattern.PAINT_UNCOLORED);\n                try (PDPatternContentStream patternCS = new PDPatternContentStream(pattern)) {\n                    // from Adobe\n                    patternCS.setLineCapStyle(1);\n                    patternCS.setLineJoinStyle(1);\n                    patternCS.setLineWidth(1);\n                    patternCS.setMiterLimit(10);\n                    patternCS.moveTo(0, 1);\n                    patternCS.lineTo(5, 11);\n                    patternCS.lineTo(10, 1);\n                    patternCS.stroke();\n                }\n                COSName patternName = form.getResources().add(pattern);\n                PDColorSpace patternColorSpace = new PDPattern(null, PDDeviceRGB.INSTANCE);\n                PDColor patternColor = new PDColor(color.getComponents(), patternName, patternColorSpace);\n                formCS.setNonStrokingColor(patternColor);\n                // With Adobe, the horizontal size is slightly different, don't know why\n                formCS.addRect(0, 0, ((pathsArray[(i * 8) + 2] - pathsArray[i * 8]) / height) * 40.0F, 12);\n                formCS.fill();\n            }\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.drawImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.drawImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.extractMatte" ],
    "fullMethods" : [ "@Override\npublic void drawImage(PDImage pdImage) throws IOException {\n    if ((pdImage instanceof PDImageXObject) && isHiddenOCG(((PDImageXObject) (pdImage)).getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    AffineTransform at = ctm.createAffineTransform();\n    if (!pdImage.getInterpolate()) {\n        // if the image is scaled down, we use smooth interpolation, eg PDFBOX-2364\n        // only when scaled up do we use nearest neighbour, eg PDFBOX-2302 / mori-cvpr01.pdf\n        // PDFBOX-4930: we use the sizes of the ARGB image. These can be different\n        // than the original sizes of the base image, when the mask is bigger.\n        // PDFBOX-5091: also consider subsampling, the sizes are different too.\n        BufferedImage bim;\n        if (subsamplingAllowed) {\n            bim = pdImage.getImage(null, getSubsampling(pdImage, at));\n        } else {\n            bim = pdImage.getImage();\n        }\n        boolean isScaledUp = (bim.getWidth() <= Math.abs(Math.round(ctm.getScalingFactorX() * xformScalingFactorX))) || (bim.getHeight() <= Math.abs(Math.round(ctm.getScalingFactorY() * xformScalingFactorY)));\n        if (isScaledUp) {\n            graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        }\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    if (pdImage.isStencil()) {\n        if (getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDPattern) {\n            // The earlier code for stencils (see \"else\") doesn't work with patterns because the\n            // CTM is not taken into consideration.\n            // this code is based on the fact that it is easily possible to draw the mask and\n            // the paint at the correct place with the existing code, but not in one step.\n            // Thus what we do is to draw both in separate images, then combine the two and draw\n            // the result.\n            // Note that the device scale is not used. In theory, some patterns can get better\n            // at higher resolutions but the stencil would become more and more \"blocky\".\n            // If anybody wants to do this, have a look at the code in showTransparencyGroup().\n            // draw the paint\n            Paint paint = getNonStrokingPaint();\n            Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);\n            Rectangle2D bounds = at.createTransformedShape(unitRect).getBounds2D();\n            int w = ((int) (Math.ceil(bounds.getWidth())));\n            int h = ((int) (Math.ceil(bounds.getHeight())));\n            BufferedImage renderedPaint = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n            Graphics2D g = ((Graphics2D) (renderedPaint.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setPaint(paint);\n            g.setRenderingHints(graphics.getRenderingHints());\n            g.fill(bounds);\n            g.dispose();\n            // draw the mask\n            BufferedImage mask = pdImage.getImage();\n            AffineTransform imageTransform = new AffineTransform(at);\n            imageTransform.scale(1.0 / mask.getWidth(), (-1.0) / mask.getHeight());\n            imageTransform.translate(0, -mask.getHeight());\n            AffineTransform full = new AffineTransform(g.getTransform());\n            full.concatenate(imageTransform);\n            Matrix m = new Matrix(full);\n            double scaleX = Math.abs(m.getScalingFactorX());\n            double scaleY = Math.abs(m.getScalingFactorY());\n            boolean smallMask = (mask.getWidth() <= 8) && (mask.getHeight() <= 8);\n            if ((mask.getWidth() == 1) && (mask.getHeight() == 1)) {\n                // PDFBOX-5802: force usage of the lookup table if it is only 1 pixel\n                // (See the comment for PDFBOX-5403 that it isn't done for some\n                // cases based purely on the rendering result of one file!)\n                smallMask = false;\n            }\n            if (!smallMask) {\n                // PDFBOX-5403:\n                // The mask is copied to RGB because this supports a smooth scaling, so we\n                // get a mask with 255 values instead of just 0 and 255.\n                // Inverting is done because when we don't do it, the getScaledInstance() call\n                // produces a black line in many masks. With the inversion we have a white line\n                // which is neutral. Because of the inversion we don't have to substract from 255\n                // in the \"apply the mask\" segment when rasterPixel[3] is assigned.\n                // The inversion is not done for very small ones, because of\n                // PDFBOX-2171-002-002710-p14.pdf where the \"New Harmony Consolidated\" and\n                // \"Sailor Springs\" patterns became almost invisible.\n                // (We may have to decide this differently in the future, e.g. on b/w relationship)\n                BufferedImage tmp = new BufferedImage(mask.getWidth(), mask.getHeight(), BufferedImage.TYPE_INT_RGB);\n                mask = new LookupOp(getInvLookupTable(), graphics.getRenderingHints()).filter(mask, tmp);\n            }\n            BufferedImage renderedMask = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n            g = ((Graphics2D) (renderedMask.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setRenderingHints(graphics.getRenderingHints());\n            if (smallMask) {\n                g.drawImage(mask, imageTransform, null);\n            } else if ((scaleX != 0) && (scaleY != 0)) {\n                while ((scaleX < 0.25) || (Math.round(mask.getWidth() * scaleX) < 1)) {\n                    scaleX *= 2.0;\n                } \n                while ((scaleY < 0.25) || (Math.round(mask.getHeight() * scaleY) < 1)) {\n                    scaleY *= 2.0;\n                } \n                int w2 = ((int) (Math.round(mask.getWidth() * scaleX)));\n                int h2 = ((int) (Math.round(mask.getHeight() * scaleY)));\n                Image scaledMask = mask.getScaledInstance(w2, h2, Image.SCALE_SMOOTH);\n                imageTransform.scale(1.0F / Math.abs(scaleX), 1.0F / Math.abs(scaleY));\n                g.drawImage(scaledMask, imageTransform, null);\n            }\n            g.dispose();\n            // apply the mask\n            int[] alphaPixel = null;\n            int[] rasterPixel = null;\n            WritableRaster raster = renderedPaint.getRaster();\n            WritableRaster alpha = renderedMask.getRaster();\n            for (int y = 0; y < h; y++) {\n                for (int x = 0; x < w; x++) {\n                    alphaPixel = alpha.getPixel(x, y, alphaPixel);\n                    rasterPixel = raster.getPixel(x, y, rasterPixel);\n                    rasterPixel[3] = alphaPixel[0];\n                    raster.setPixel(x, y, rasterPixel);\n                }\n            }\n            // draw the image\n            graphics.drawImage(renderedPaint, AffineTransform.getTranslateInstance(bounds.getMinX(), bounds.getMinY()), null);\n        } else {\n            // fill the image with stenciled paint\n            BufferedImage image = pdImage.getStencilImage(getNonStrokingPaint());\n            // draw the image\n            drawBufferedImage(pdImage, image, at);\n        }\n    } else if (subsamplingAllowed) {\n        int subsampling = getSubsampling(pdImage, at);\n        // draw the subsampled image\n        drawBufferedImage(pdImage, pdImage.getImage(null, subsampling), at);\n    } else {\n        // subsampling not allowed, draw the image\n        drawBufferedImage(pdImage, pdImage.getImage(), at);\n    }\n    if (!pdImage.getInterpolate()) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "/**\n * {@inheritDoc }\n */\n@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    if (((region == null) && (subsampling == cachedImageSubsampling)) && (cachedImage != null)) {\n        BufferedImage cached = cachedImage.get();\n        if (cached != null) {\n            return cached;\n        }\n    }\n    initJPXValues();\n    // get RGB image w/o reference because applyMask might modify it, take long time and a lot of memory.\n    final BufferedImage image;\n    final PDImageXObject softMask = getSoftMask();\n    final PDImageXObject mask = getMask();\n    if (jpxSMask != null) {\n        // PDFBOX-5657: handle JPEG2000 SMaskInData\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), jpxSMask, false, true, null);\n    } else if (softMask != null) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), softMask.getOpaqueImage(region, subsampling), softMask.getInterpolate(), true, extractMatte(softMask));\n    } else if ((mask != null) && mask.isStencil()) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), mask.getOpaqueImage(region, subsampling), mask.getInterpolate(), false, null);\n    } else {\n        image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());\n    }\n    if ((region == null) && (subsampling <= cachedImageSubsampling)) {\n        // only cache full-image renders, and prefer lower subsampling frequency, as lower\n        // subsampling means higher quality and longer render times.\n        cachedImageSubsampling = subsampling;\n        cachedImage = new SoftReference<>(image);\n    }\n    return image;\n}", "/**\n * Extract the matte color from a softmask.\n *\n * @param softMask\n * @return the matte color.\n * @throws IOException\n * \t\tif the color conversion fails.\n */\nprivate float[] extractMatte(PDImageXObject softMask) throws IOException {\n    COSBase base = softMask.getCOSObject().getItem(COSName.MATTE);\n    float[] matte = null;\n    if (base instanceof COSArray) {\n        // PDFBOX-4267: process /Matte\n        // see PDF specification 1.7, 11.6.5.3 Soft-Mask Images\n        matte = ((COSArray) (base)).toFloatArray();\n        // convert to RGB\n        if (matte.length < getColorSpace().getNumberOfComponents()) {\n            LOG.error(\"Image /Matte entry not long enough for colorspace, skipped\");\n            return null;\n        }\n        matte = getColorSpace().toRGB(matte);\n    }\n    return matte;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDStrikeoutAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDStrikeoutAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationStrikeout annotation = ((PDAnnotationStrikeout) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getQuadPoints();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    if (Float.compare(ab.width, 0) == 0) {\n        // value found in adobe reader\n        ab.width = 1.5F;\n    }\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    // TODO in a class structure this should be overridable\n    // this is similar to polyline but different data type\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    rect.setLowerLeftX(Math.min(minX - (ab.width / 2), rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - (ab.width / 2), rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + (ab.width / 2), rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + (ab.width / 2), rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        cs.setStrokingColor(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        // spec is incorrect\n        // https://stackoverflow.com/questions/9855814/pdf-spec-vs-acrobat-creation-quadpoints\n        for (int i = 0; i < (pathsArray.length / 8); ++i) {\n            // get mid point between bounds, subtract the line width to approximate what Adobe is doing\n            // See e.g. CTAN-example-Annotations.pdf and PLPDF.com-MarkupAnnotations.pdf\n            // and https://bugs.ghostscript.com/show_bug.cgi?id=693664\n            // do the math for diagonal annotations with this weird old trick:\n            // https://stackoverflow.com/questions/7740507/extend-a-line-segment-a-specific-distance\n            float len0 = ((float) (Math.sqrt(Math.pow(pathsArray[i * 8] - pathsArray[(i * 8) + 4], 2) + Math.pow(pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5], 2))));\n            float x0 = pathsArray[(i * 8) + 4];\n            float y0 = pathsArray[(i * 8) + 5];\n            if (Float.compare(len0, 0) != 0) {\n                // only if both coordinates are not identical to avoid divide by zero\n                x0 += ((pathsArray[i * 8] - pathsArray[(i * 8) + 4]) / len0) * ((len0 / 2) - ab.width);\n                y0 += ((pathsArray[(i * 8) + 1] - pathsArray[(i * 8) + 5]) / len0) * ((len0 / 2) - ab.width);\n            }\n            float len1 = ((float) (Math.sqrt(Math.pow(pathsArray[(i * 8) + 2] - pathsArray[(i * 8) + 6], 2) + Math.pow(pathsArray[(i * 8) + 3] - pathsArray[(i * 8) + 7], 2))));\n            float x1 = pathsArray[(i * 8) + 6];\n            float y1 = pathsArray[(i * 8) + 7];\n            if (Float.compare(len1, 0) != 0) {\n                // only if both coordinates are not identical to avoid divide by zero\n                x1 += ((pathsArray[(i * 8) + 2] - pathsArray[(i * 8) + 6]) / len1) * ((len1 / 2) - ab.width);\n                y1 += ((pathsArray[(i * 8) + 3] - pathsArray[(i * 8) + 7]) / len1) * ((len1 / 2) - ab.width);\n            }\n            cs.moveTo(x0, y0);\n            cs.lineTo(x1, y1);\n        }\n        cs.stroke();\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDHighlightAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDHighlightAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationHighlight annotation = ((PDAnnotationHighlight) (getAnnotation()));\n    float[] pathsArray = annotation.getQuadPoints();\n    if (pathsArray == null) {\n        return;\n    }\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    // TODO in a class structure this should be overridable\n    // this is similar to polyline but different data type\n    // TODO padding should consider the curves too; needs to know in advance where the curve is\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    // get the delta used for curves and use it for padding\n    float maxDelta = 0;\n    for (int i = 0; i < (pathsArray.length / 8); ++i) {\n        // one of the two is 0, depending whether the rectangle is\n        // horizontal or vertical\n        // if it is diagonal then... uh...\n        float delta = Math.max((pathsArray[i + 0] - pathsArray[i + 4]) / 4, (pathsArray[i + 1] - pathsArray[i + 5]) / 4);\n        maxDelta = Math.max(delta, maxDelta);\n    }\n    rect.setLowerLeftX(Math.min((minX - (ab.width / 2)) - maxDelta, rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min((minY - (ab.width / 2)) - maxDelta, rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max((maxX + ab.width) + maxDelta, rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max((maxY + ab.width) + maxDelta, rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        PDExtendedGraphicsState r0 = new PDExtendedGraphicsState();\n        PDExtendedGraphicsState r1 = new PDExtendedGraphicsState();\n        r0.setAlphaSourceFlag(false);\n        r0.setStrokingAlphaConstant(annotation.getConstantOpacity());\n        r0.setNonStrokingAlphaConstant(annotation.getConstantOpacity());\n        r1.setAlphaSourceFlag(false);\n        r1.setBlendMode(BlendMode.MULTIPLY);\n        cs.setGraphicsStateParameters(r0);\n        cs.setGraphicsStateParameters(r1);\n        PDFormXObject frm1 = new PDFormXObject(createCOSStream());\n        PDFormXObject frm2 = new PDFormXObject(createCOSStream());\n        frm1.setResources(new PDResources());\n        try (PDFormContentStream mwfofrmCS = new PDFormContentStream(frm1)) {\n            mwfofrmCS.drawForm(frm2);\n        }\n        frm1.setBBox(annotation.getRectangle());\n        frm1.setGroup(new PDTransparencyGroupAttributes());\n        cs.drawForm(frm1);\n        frm2.setBBox(annotation.getRectangle());\n        try (PDFormContentStream frm2CS = new PDFormContentStream(frm2)) {\n            frm2CS.setNonStrokingColor(color);\n            int of = 0;\n            while ((of + 7) < pathsArray.length) {\n                // quadpoints spec sequence is incorrect, correct one is (4,5 0,1 2,3 6,7)\n                // https://stackoverflow.com/questions/9855814/pdf-spec-vs-acrobat-creation-quadpoints\n                // for \"curvy\" highlighting, two BÃ©zier control points are used that seem to have a\n                // distance of about 1/4 of the height.\n                // note that curves won't appear if outside of the rectangle\n                float delta = 0;\n                if ((((Float.compare(pathsArray[of + 0], pathsArray[of + 4]) == 0) && (Float.compare(pathsArray[of + 1], pathsArray[of + 3]) == 0)) && (Float.compare(pathsArray[of + 2], pathsArray[of + 6]) == 0)) && (Float.compare(pathsArray[of + 5], pathsArray[of + 7]) == 0)) {\n                    // horizontal highlight\n                    delta = (pathsArray[of + 1] - pathsArray[of + 5]) / 4;\n                } else if ((((Float.compare(pathsArray[of + 1], pathsArray[of + 5]) == 0) && (Float.compare(pathsArray[of + 0], pathsArray[of + 2]) == 0)) && (Float.compare(pathsArray[of + 3], pathsArray[of + 7]) == 0)) && (Float.compare(pathsArray[of + 4], pathsArray[of + 6]) == 0)) {\n                    // vertical highlight\n                    delta = (pathsArray[of + 0] - pathsArray[of + 4]) / 4;\n                }\n                frm2CS.moveTo(pathsArray[of + 4], pathsArray[of + 5]);\n                if (Float.compare(pathsArray[of + 0], pathsArray[of + 4]) == 0) {\n                    // horizontal highlight\n                    frm2CS.curveTo(pathsArray[of + 4] - delta, pathsArray[of + 5] + delta, pathsArray[of + 0] - delta, pathsArray[of + 1] - delta, pathsArray[of + 0], pathsArray[of + 1]);\n                } else if (Float.compare(pathsArray[of + 5], pathsArray[of + 1]) == 0) {\n                    // vertical highlight\n                    frm2CS.curveTo(pathsArray[of + 4] + delta, pathsArray[of + 5] + delta, pathsArray[of + 0] - delta, pathsArray[of + 1] + delta, pathsArray[of + 0], pathsArray[of + 1]);\n                } else {\n                    frm2CS.lineTo(pathsArray[of + 0], pathsArray[of + 1]);\n                }\n                frm2CS.lineTo(pathsArray[of + 2], pathsArray[of + 3]);\n                if (Float.compare(pathsArray[of + 2], pathsArray[of + 6]) == 0) {\n                    // horizontal highlight\n                    frm2CS.curveTo(pathsArray[of + 2] + delta, pathsArray[of + 3] - delta, pathsArray[of + 6] + delta, pathsArray[of + 7] + delta, pathsArray[of + 6], pathsArray[of + 7]);\n                } else if (Float.compare(pathsArray[of + 3], pathsArray[of + 7]) == 0) {\n                    // vertical highlight\n                    frm2CS.curveTo(pathsArray[of + 2] - delta, pathsArray[of + 3] - delta, pathsArray[of + 6] + delta, pathsArray[of + 7] - delta, pathsArray[of + 6], pathsArray[of + 7]);\n                } else {\n                    frm2CS.lineTo(pathsArray[of + 6], pathsArray[of + 7]);\n                }\n                frm2CS.fill();\n                of += 8;\n            } \n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.ASCIIHexFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.ASCIIHexFilter.decode" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    int value;\n    int firstByte;\n    int secondByte;\n    while ((firstByte = encoded.read()) != (-1)) {\n        // always after first char\n        while (isWhitespace(firstByte)) {\n            firstByte = encoded.read();\n        } \n        if ((firstByte == (-1)) || isEOD(firstByte)) {\n            break;\n        }\n        if (REVERSE_HEX[firstByte] == (-1)) {\n            LOG.error(((\"Invalid hex, int: \" + firstByte) + \" char: \") + ((char) (firstByte)));\n        }\n        value = REVERSE_HEX[firstByte] * 16;\n        secondByte = encoded.read();\n        if ((secondByte == (-1)) || isEOD(secondByte)) {\n            // second value behaves like 0 in case of EOD\n            decoded.write(value);\n            break;\n        }\n        if (REVERSE_HEX[secondByte] == (-1)) {\n            LOG.error(((\"Invalid hex, int: \" + secondByte) + \" char: \") + ((char) (secondByte)));\n        }\n        value += REVERSE_HEX[secondByte];\n        decoded.write(value);\n    } \n    decoded.flush();\n    return new DecodeResult(parameters);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.CCITTFaxFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.CCITTFaxFilter.decode", "org.apache.pdfbox.filter.Filter.getDecodeParams" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException {\n    // get decode parameters\n    COSDictionary decodeParms = getDecodeParams(parameters, index);\n    // parse dimensions\n    int cols = decodeParms.getInt(COSName.COLUMNS, 1728);\n    int rows = decodeParms.getInt(COSName.ROWS, 0);\n    int height = parameters.getInt(COSName.HEIGHT, COSName.H, 0);\n    if ((rows > 0) && (height > 0)) {\n        // PDFBOX-771, PDFBOX-3727: rows in DecodeParms sometimes contains an incorrect value\n        rows = height;\n    } else {\n        // at least one of the values has to have a valid value\n        rows = Math.max(rows, height);\n    }\n    // decompress data\n    int k = decodeParms.getInt(COSName.K, 0);\n    boolean encodedByteAlign = decodeParms.getBoolean(COSName.ENCODED_BYTE_ALIGN, false);\n    int arraySize = ((cols + 7) / 8) * rows;\n    // TODO possible options??\n    byte[] decompressed = new byte[arraySize];\n    CCITTFaxDecoderStream s;\n    int type;\n    long tiffOptions = 0;\n    if (k == 0) {\n        if (decodeParms.containsKey(COSName.END_OF_LINE)) {\n            // PDFBOX-6080: respect the parameter if it exists\n            boolean hasEndOfLine = decodeParms.getBoolean(COSName.END_OF_LINE, false);\n            type = (hasEndOfLine) ? TIFFExtension.COMPRESSION_CCITT_T4 : TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE;\n        } else {\n            // In twelvemonkeys, this part is found in CCITTFaxDecoderStream.findCompressionType()\n            // needed for 015315-p8-ccitt.pdf, PDFBOX-2123-1bit.pdf, PDFBOX-2778.pdf\n            type = TIFFExtension.COMPRESSION_CCITT_T4;// Group 3 1D\n\n            byte[] streamData = new byte[20];\n            int bytesRead = encoded.read(streamData);\n            if (bytesRead == (-1)) {\n                throw new IOException(\"EOF while reading CCITT header\");\n            }\n            PushbackInputStream pushbackInputStream = new PushbackInputStream(encoded, streamData.length);\n            pushbackInputStream.unread(streamData, 0, bytesRead);\n            encoded = pushbackInputStream;\n            if ((streamData[0] != 0) || (((streamData[1] >> 4) != 1) && (streamData[1] != 1))) {\n                // leading EOL (0b000000000001) not found, search further and try RLE if not found\n                type = TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE;\n                short b = ((short) (((streamData[0] << 8) + (streamData[1] & 0xff)) >> 4));\n                for (int i = 12; i < (bytesRead * 8); i++) {\n                    b = ((short) ((b << 1) + ((streamData[i / 8] >> (7 - (i % 8))) & 0x1)));\n                    if ((b & 0xfff) == 1) {\n                        type = TIFFExtension.COMPRESSION_CCITT_T4;\n                        break;\n                    }\n                }\n            }\n        }\n    } else if (k > 0) {\n        // Group 3 2D\n        type = TIFFExtension.COMPRESSION_CCITT_T4;\n        tiffOptions = TIFFExtension.GROUP3OPT_2DENCODING;\n    } else {\n        // Group 4\n        type = TIFFExtension.COMPRESSION_CCITT_T6;\n    }\n    s = new CCITTFaxDecoderStream(encoded, cols, type, tiffOptions, encodedByteAlign);\n    readFromDecoderStream(s, decompressed);\n    // invert bitmap\n    boolean blackIsOne = decodeParms.getBoolean(COSName.BLACK_IS_1, false);\n    if (!blackIsOne) {\n        // Inverting the bitmap\n        // Note the previous approach with starting from an IndexColorModel didn't work\n        // reliably. In some cases the image wouldn't be painted for some reason.\n        // So a safe but slower approach was taken.\n        invertBitmap(decompressed);\n    }\n    decoded.write(decompressed);\n    return new DecodeResult(parameters);\n}", "// gets the decode params for a specific filter index, this is used to\n// normalise the DecodeParams entry so that it is always a dictionary\nprotected COSDictionary getDecodeParams(COSDictionary dictionary, int index) {\n    COSBase filter = dictionary.getDictionaryObject(COSName.F, COSName.FILTER);\n    COSBase obj = dictionary.getDictionaryObject(COSName.DP, COSName.DECODE_PARMS);\n    if ((filter instanceof COSName) && (obj instanceof COSDictionary)) {\n        // PDFBOX-3932: The PDF specification requires \"If there is only one filter and that\n        // filter has parameters, DecodeParms shall be set to the filterâs parameter dictionary\"\n        // but tests show that Adobe means \"one filter name object\".\n        return ((COSDictionary) (obj));\n    } else if ((filter instanceof COSArray) && (obj instanceof COSArray)) {\n        COSArray array = ((COSArray) (obj));\n        if (index < array.size()) {\n            COSBase objAtIndex = array.getObject(index);\n            if (objAtIndex instanceof COSDictionary) {\n                return ((COSDictionary) (objAtIndex));\n            }\n        }\n    } else if ((obj != null) && (!((filter instanceof COSArray) || (obj instanceof COSArray)))) {\n        LOG.error(\"Expected DecodeParams to be an Array or Dictionary but found \" + obj.getClass().getName());\n    }\n    return new COSDictionary();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFileAttachmentAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDFileAttachmentAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationFileAttachment annotation = ((PDAnnotationFileAttachment) (getAnnotation()));\n    PDRectangle rect = getRectangle();\n    if (rect == null) {\n        return;\n    }\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        setOpacity(contentStream, annotation.getConstantOpacity());\n        // minimum code of PDTextAppearanceHandler.adjustRectAndBBox()\n        int size = 18;\n        rect.setUpperRightX(rect.getLowerLeftX() + size);\n        rect.setLowerLeftY(rect.getUpperRightY() - size);\n        annotation.setRectangle(rect);\n        annotation.getNormalAppearanceStream().setBBox(new PDRectangle(size, size));\n        // test case: pdf_commenting_new.pdf page 7\n        String attachmentName = annotation.getAttachmentName();\n        switch (attachmentName) {\n            case \"Paperclip\" :\n                drawPaperclip(contentStream);\n                break;\n            case \"Graph\" :\n                drawGraph(contentStream);\n                break;\n            case \"Tag\" :\n                drawTag(contentStream);\n                break;\n            default :\n                drawPushPin(contentStream);\n                break;\n        }\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFParser.parse", "org.apache.pdfbox.pdfparser.PDFParser.initialParse", "org.apache.pdfbox.pdfparser.COSParser.retrieveTrailer", "org.apache.pdfbox.pdfparser.COSParser.parseXref" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the PDDocument object. This will close the keystore stream when it is\n * done parsing.\n *\n * @param lenient\n * \t\tactivate leniency if set to true\n * @return the populated PDDocument\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic PDDocument parse(boolean lenient) throws IOException {\n    setLenient(lenient);\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        // PDFBOX-1922 read the version header and rewind\n        if ((!parsePDFHeader()) && (!parseFDFHeader())) {\n            if (lenient) {\n                LOG.warn(\"Error: Header doesn't contain versioninfo\");\n            } else {\n                throw new IOException(\"Error: Header doesn't contain versioninfo\");\n            }\n        }\n        if (!initialParseDone) {\n            initialParse();\n        }\n        exceptionOccurred = false;\n        PDDocument pdDocument = createDocument();\n        pdDocument.setEncryptionDictionary(getEncryption());\n        return pdDocument;\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * The initial parse will first parse only the trailer, the xrefstart and all xref tables to have a pointer (offset)\n * to all the pdf's objects. It can handle linearized pdfs, which will have an xref at the end pointing to an xref\n * at the beginning of the file. Last the root object is parsed.\n *\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf something went wrong.\n */\nprotected void initialParse() throws IOException {\n    COSDictionary trailer = retrieveTrailer();\n    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);\n    if (root == null) {\n        throw new IOException(\"Missing root object specification in trailer.\");\n    }\n    // in some pdfs the type value \"Catalog\" is missing in the root object\n    if (isLenient() && (!root.containsKey(COSName.TYPE))) {\n        root.setItem(COSName.TYPE, COSName.CATALOG);\n    }\n    // check pages dictionaries\n    checkPages(root);\n    document.setDecrypted();\n    initialParseDone = true;\n}", "/**\n * Read the trailer information and provide a COSDictionary containing the trailer information.\n *\n * @return a COSDictionary containing the trailer information\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected COSDictionary retrieveTrailer() throws IOException {\n    COSDictionary trailer = null;\n    boolean rebuildTrailer = false;\n    try {\n        // parse startxref\n        // TODO FDF files don't have a startxref value, so that rebuildTrailer is triggered\n        long startXRefOffset = getStartxrefOffset();\n        if (startXRefOffset > (-1)) {\n            trailer = parseXref(startXRefOffset);\n        } else {\n            rebuildTrailer = isLenient();\n        }\n    } catch (IOException exception) {\n        if (isLenient()) {\n            rebuildTrailer = true;\n        } else {\n            throw exception;\n        }\n    }\n    // check if the trailer contains a Root object\n    if ((trailer != null) && (trailer.getItem(COSName.ROOT) == null)) {\n        rebuildTrailer = isLenient();\n    }\n    if (rebuildTrailer) {\n        trailer = getBruteForceParser().rebuildTrailer(xrefTrailerResolver, null);\n        trailerWasRebuild = true;\n        // transfer encryption information from BruteForceParser\n        encryption = getBruteForceParser().getEncryption();\n        if (encryption != null) {\n            securityHandler = encryption.getSecurityHandler();\n            accessPermission = securityHandler.getCurrentAccessPermission();\n        }\n    } else {\n        // prepare decryption if necessary\n        prepareDecryption();\n        // don't use the getter as it creates an instance of BruteForceParser\n        if ((bruteForceParser != null) && bruteForceParser.bfSearchTriggered()) {\n            getBruteForceParser().bfSearchForObjStreams(xrefTrailerResolver, securityHandler);\n        }\n    }\n    if (resetTrailerResolver()) {\n        xrefTrailerResolver.reset();\n        xrefTrailerResolver = null;\n    }\n    return trailer;\n}", "/**\n * Parses cross reference tables.\n *\n * @param startXRefOffset\n * \t\tstart offset of the first table\n * @return the trailer dictionary\n * @throws IOException\n * \t\tif something went wrong\n */\nprivate COSDictionary parseXref(long startXRefOffset) throws IOException {\n    source.seek(startXRefOffset);\n    long startXrefOffset = Math.max(0, parseStartXref());\n    // check the startxref offset\n    long fixedOffset = checkXRefOffset(startXrefOffset);\n    if (fixedOffset > (-1)) {\n        startXrefOffset = fixedOffset;\n    }\n    document.setStartXref(startXrefOffset);\n    long prev = startXrefOffset;\n    // ---- parse whole chain of xref tables/object streams using PREV reference\n    Set<Long> prevSet = new HashSet<>();\n    COSDictionary trailer = null;\n    while (prev > 0) {\n        // save expected position for loop detection\n        prevSet.add(prev);\n        // seek to xref table\n        source.seek(prev);\n        // skip white spaces\n        skipSpaces();\n        // save current position as well due to skipped spaces\n        prevSet.add(source.getPosition());\n        // -- parse xref\n        if (source.peek() == X) {\n            // xref table and trailer\n            // use existing parser to parse xref table\n            if ((!parseXrefTable(prev)) || (!parseTrailer())) {\n                throw new IOException(\"Expected trailer object at offset \" + source.getPosition());\n            }\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n            // check for a XRef stream, it may contain some object ids of compressed objects\n            if (trailer.containsKey(COSName.XREF_STM)) {\n                int streamOffset = trailer.getInt(COSName.XREF_STM);\n                // check the xref stream reference\n                fixedOffset = checkXRefOffset(streamOffset);\n                if ((fixedOffset > (-1)) && (fixedOffset != streamOffset)) {\n                    LOG.warn(((\"/XRefStm offset \" + streamOffset) + \" is incorrect, corrected to \") + fixedOffset);\n                    streamOffset = ((int) (fixedOffset));\n                    trailer.setInt(COSName.XREF_STM, streamOffset);\n                }\n                if (streamOffset > 0) {\n                    source.seek(streamOffset);\n                    skipSpaces();\n                    try {\n                        parseXrefObjStream(prev, false);\n                        document.setHasHybridXRef();\n                    } catch (IOException ex) {\n                        if (isLenient) {\n                            LOG.error(\"Failed to parse /XRefStm at offset \" + streamOffset, ex);\n                        } else {\n                            throw ex;\n                        }\n                    }\n                } else if (isLenient) {\n                    LOG.error(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                } else {\n                    throw new IOException(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                }\n            }\n            prev = trailer.getLong(COSName.PREV);\n        } else {\n            // parse xref stream\n            prev = parseXrefObjStream(prev, true);\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n        }\n        if (prev > 0) {\n            // check the xref table reference\n            fixedOffset = checkXRefOffset(prev);\n            if ((fixedOffset > (-1)) && (fixedOffset != prev)) {\n                prev = fixedOffset;\n                trailer.setLong(COSName.PREV, prev);\n            }\n        }\n        if (prevSet.contains(prev)) {\n            throw new IOException(\"/Prev loop at offset \" + prev);\n        }\n    } \n    // ---- build valid xrefs out of the xref chain\n    xrefTrailerResolver.setStartxref(startXrefOffset);\n    trailer = xrefTrailerResolver.getTrailer();\n    document.setTrailer(trailer);\n    document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());\n    // check the offsets of all referenced objects\n    if (isLenient) {\n        checkXrefOffsets();\n    }\n    // copy xref table\n    document.addXRefTable(xrefTrailerResolver.getXrefTable());\n    // remember the highest XRef object number to avoid it being reused in incremental saving\n    Optional<Long> maxValue = // \n    // \n    document.getXrefTable().keySet().stream().map(COSObjectKey::getNumber).reduce(Long::max);\n    document.setHighestXRefObjectNumber(maxValue.isPresent() ? maxValue.get() : 0);\n    return trailer;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken", "org.apache.pdfbox.pdfparser.BaseParser.parseCOSName" ],
    "fullMethods" : [ "/**\n * This will parse the next token in the stream.\n *\n * @return The next token in the stream or null if there are no more tokens in the stream.\n * @throws IOException\n * \t\tIf an io error occurs while parsing the stream.\n */\npublic Object parseNextToken() throws IOException {\n    if (source.isClosed()) {\n        return null;\n    }\n    skipSpaces();\n    if (source.isEOF()) {\n        close();\n        return null;\n    }\n    char c = ((char) (source.peek()));\n    switch (c) {\n        case '<' :\n            // pull off first left bracket\n            source.read();\n            // check for second left bracket\n            c = ((char) (source.peek()));\n            // put back first bracket\n            source.rewind(1);\n            if (c == '<') {\n                try {\n                    return parseCOSDictionary(true);\n                } catch (IOException exception) {\n                    LOG.warn(\"Stop reading invalid dictionary from content stream at offset \" + source.getPosition());\n                    close();\n                    return null;\n                }\n            } else {\n                return parseCOSString();\n            }\n        case '[' :\n            // array\n            try {\n                return parseCOSArray();\n            } catch (IOException exception) {\n                LOG.warn(\"Stop reading invalid array from content stream at offset \" + source.getPosition());\n                close();\n                return null;\n            }\n        case '(' :\n            // string\n            return parseCOSString();\n        case '/' :\n            // name\n            return parseCOSName();\n        case 'n' :\n            // null\n            String nullString = readString();\n            if (nullString.equals(\"null\")) {\n                return COSNull.NULL;\n            } else {\n                return Operator.getOperator(nullString);\n            }\n        case 't' :\n        case 'f' :\n            String next = readString();\n            if (next.equals(\"true\")) {\n                return COSBoolean.TRUE;\n            } else if (next.equals(\"false\")) {\n                return COSBoolean.FALSE;\n            } else {\n                return Operator.getOperator(next);\n            }\n        case '0' :\n        case '1' :\n        case '2' :\n        case '3' :\n        case '4' :\n        case '5' :\n        case '6' :\n        case '7' :\n        case '8' :\n        case '9' :\n        case '-' :\n        case '+' :\n        case '.' :\n            /* We will be filling buf with the rest of the number.  Only\n            allow 1 \".\" and \"-\" and \"+\" at start of number.\n             */\n            StringBuilder buf = new StringBuilder();\n            buf.append(c);\n            source.read();\n            // Ignore double negative (this is consistent with Adobe Reader)\n            if ((c == '-') && (source.peek() == c)) {\n                source.read();\n            }\n            boolean dotNotRead = c != '.';\n            while ((Character.isDigit(c = ((char) (source.peek()))) || (dotNotRead && (c == '.'))) || (c == '-')) {\n                if (c != '-') {\n                    // PDFBOX-4064: ignore \"-\" in the middle of a number\n                    buf.append(c);\n                }\n                source.read();\n                if (dotNotRead && (c == '.')) {\n                    dotNotRead = false;\n                }\n            } \n            String s = buf.toString();\n            if (\"+\".equals(s)) {\n                // PDFBOX-5906\n                LOG.warn(\"isolated '+' is ignored\");\n                return COSNull.NULL;\n            }\n            return COSNumber.get(s);\n        case 'B' :\n            String nextOperator = readString();\n            Operator beginImageOP = Operator.getOperator(nextOperator);\n            if (nextOperator.equals(OperatorName.BEGIN_INLINE_IMAGE)) {\n                inlineImageDepth++;\n                if (inlineImageDepth > 1) {\n                    // PDFBOX-6038\n                    throw new IOException(((((\"Nested '\" + OperatorName.BEGIN_INLINE_IMAGE) + \"' operator not allowed at offset \") + source.getPosition()) + \", first: \") + inlineOffset);\n                } else {\n                    inlineOffset = source.getPosition();\n                }\n                COSDictionary imageParams = new COSDictionary();\n                beginImageOP.setImageParameters(imageParams);\n                Object nextToken = null;\n                while ((nextToken = parseNextToken()) instanceof COSName) {\n                    Object value = parseNextToken();\n                    if (!(value instanceof COSBase)) {\n                        LOG.warn(\"Unexpected token in inline image dictionary at offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                        break;\n                    }\n                    imageParams.setItem(((COSName) (nextToken)), ((COSBase) (value)));\n                } \n                // final token will be the image data, maybe??\n                if (nextToken instanceof Operator) {\n                    Operator imageData = ((Operator) (nextToken));\n                    if ((imageData.getImageData() == null) || (imageData.getImageData().length == 0)) {\n                        LOG.warn(\"empty inline image at stream offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                    }\n                    beginImageOP.setImageData(imageData.getImageData());\n                    inlineImageDepth--;\n                } else {\n                    LOG.warn((((((\"nextToken \" + nextToken) + \" at position \") + (source.isClosed() ? \"EOF\" : source.getPosition())) + \", expected \") + OperatorName.BEGIN_INLINE_IMAGE_DATA) + \"?!\");\n                }\n            }\n            return beginImageOP;\n        case 'I' :\n            // Special case for ID operator\n            String id = Character.toString(((char) (source.read()))) + ((char) (source.read()));\n            if (!id.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA)) {\n                long currentPosition = source.getPosition();\n                close();\n                throw new IOException(((\"Error: Expected operator 'ID' actual='\" + id) + \"' at stream offset \") + currentPosition);\n            }\n            ByteArrayOutputStream imageData = new ByteArrayOutputStream();\n            // skip one line break (CR, LF or CRLF) or any one-byte whitespace\n            if ((!skipLinebreak()) && isWhitespace()) {\n                // pull off the whitespace character\n                source.read();\n            }\n            int lastByte = source.read();\n            int currentByte = source.read();\n            // PDF spec is kinda unclear about this. Should a whitespace\n            // always appear before EI? Not sure, so that we just read\n            // until EI<whitespace>.\n            // Be aware not all kind of whitespaces are allowed here. see PDFBOX-1561\n            while ((!((((lastByte == 'E') && (currentByte == 'I')) && hasNextSpaceOrReturn()) && hasNoFollowingBinData())) && (!isEOF())) {\n                imageData.write(lastByte);\n                lastByte = currentByte;\n                currentByte = source.read();\n            } \n            // the EI operator isn't unread, as it won't be processed anyway\n            Operator beginImageDataOP = Operator.getOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);\n            // save the image data to the operator, so that it can be accessed later\n            beginImageDataOP.setImageData(imageData.toByteArray());\n            return beginImageDataOP;\n        case ']' :\n            // some ']' around without its previous '['\n            // this means a PDF is somewhat corrupt but we will continue to parse.\n            source.read();\n            // must be a better solution than null...\n            return COSNull.NULL;\n        default :\n            // we must be an operator\n            String operator = readOperator().trim();\n            if (operator.length() > 0) {\n                return Operator.getOperator(operator);\n            }\n    }\n    return null;\n}", "/**\n * This will parse a PDF name from the stream.\n *\n * @return The parsed PDF name.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected COSName parseCOSName() throws IOException {\n    readExpectedChar('/');\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int c = source.read();\n    while (!isEndOfName(c)) {\n        final int ch = c;\n        if (ch == '#') {\n            int ch1 = source.read();\n            int ch2 = source.read();\n            // Prior to PDF v1.2, the # was not a special character.  Also,\n            // it has been observed that various PDF tools do not follow the\n            // spec with respect to the # escape, even though they report\n            // PDF versions of 1.2 or later.  The solution here is that we\n            // interpret the # as an escape only when it is followed by two\n            // valid hex digits.\n            if (isHexDigit(((char) (ch1))) && isHexDigit(((char) (ch2)))) {\n                String hex = Character.toString(((char) (ch1))) + ((char) (ch2));\n                try {\n                    buffer.write(Integer.parseInt(hex, 16));\n                } catch (NumberFormatException e) {\n                    throw new IOException((\"Error: expected hex digit, actual='\" + hex) + \"'\", e);\n                }\n                c = source.read();\n            } else {\n                // check for premature EOF\n                if ((ch2 == (-1)) || (ch1 == (-1))) {\n                    LOG.error(\"Premature EOF in BaseParser#parseCOSName\");\n                    c = -1;\n                    break;\n                }\n                source.rewind(1);\n                c = ch1;\n                buffer.write(ch);\n            }\n        } else {\n            buffer.write(ch);\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n    return COSName.getPDFName(decodeBuffer(buffer));\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.processPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.processPage", "org.apache.pdfbox.pdmodel.PDPage.hasContents", "org.apache.pdfbox.cos.COSDictionary.getDictionaryObject", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "/**\n * This will initialize and process the contents of the stream.\n *\n * @param page\n * \t\tthe page to process\n * @throws IOException\n * \t\tif there is an error accessing the stream\n */\npublic void processPage(PDPage page) throws IOException {\n    initPage(page);\n    if (page.hasContents()) {\n        isProcessingPage = true;\n        processStream(page);\n        isProcessingPage = false;\n    }\n}", "/**\n * Returns true if this page has one or more content streams.\n *\n * @return true if the page has a non empty content stream, otherwise false\n */\npublic boolean hasContents() {\n    COSBase contents = page.getDictionaryObject(COSName.CONTENTS);\n    if (contents instanceof COSStream) {\n        return ((COSStream) (contents)).size() > 0;\n    } else if (contents instanceof COSArray) {\n        return ((COSArray) (contents)).size() > 0;\n    }\n    return false;\n}", "/**\n * This will get an object from this dictionary. If the object is a reference then it will dereference it and get it\n * from the document. If the object is COSNull then null will be returned.\n *\n * @param key\n * \t\tThe key to the object that we are getting.\n * @return The object that matches the key.\n */\npublic COSBase getDictionaryObject(COSName key) {\n    COSBase retval = items.get(key);\n    if (retval instanceof COSObject) {\n        retval = ((COSObject) (retval)).getObject();\n    }\n    if (retval instanceof COSNull) {\n        retval = null;\n    }\n    return retval;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showAnnotation",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showAnnotation", "org.apache.pdfbox.contentstream.PDFStreamEngine.processAnnotation", "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getRectangle", "org.apache.pdfbox.cos.COSArray.getObject", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "/**\n * Shows the given annotation.\n *\n * @param annotation\n * \t\tAn annotation on the current page.\n * @throws IOException\n * \t\tIf an error occurred reading the annotation\n */\npublic void showAnnotation(PDAnnotation annotation) throws IOException {\n    PDAppearanceStream appearanceStream = getAppearance(annotation);\n    if (appearanceStream != null) {\n        processAnnotation(annotation, appearanceStream);\n    }\n}", "/**\n * Process the given annotation with the specified appearance stream.\n *\n * @param annotation\n * \t\tThe annotation containing the appearance stream to process.\n * @param appearance\n * \t\tThe appearance stream to process.\n * @throws IOException\n * \t\tIf there is an error reading or parsing the appearance content stream.\n */\nprotected void processAnnotation(PDAnnotation annotation, PDAppearanceStream appearance) throws IOException {\n    PDRectangle bbox = appearance.getBBox();\n    PDRectangle rect = annotation.getRectangle();\n    // zero-sized rectangles are not valid\n    if ((((((rect != null) && (rect.getWidth() > 0)) && (rect.getHeight() > 0)) && (bbox != null)) && (bbox.getWidth() > 0)) && (bbox.getHeight() > 0)) {\n        PDResources parent = pushResources(appearance);\n        Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n        Matrix matrix = appearance.getMatrix();\n        // transformed appearance box  fixme: may be an arbitrary shape\n        Rectangle2D transformedBox = bbox.transform(matrix).getBounds2D();\n        // compute a matrix which scales and translates the transformed appearance box to align\n        // with the edges of the annotation's rectangle\n        Matrix a = Matrix.getTranslateInstance(rect.getLowerLeftX(), rect.getLowerLeftY());\n        a.scale(((float) (rect.getWidth() / transformedBox.getWidth())), ((float) (rect.getHeight() / transformedBox.getHeight())));\n        a.translate(((float) (-transformedBox.getX())), ((float) (-transformedBox.getY())));\n        // Matrix shall be concatenated with A to form a matrix AA that maps from the appearance's\n        // coordinate system to the annotation's rectangle in default user space\n        // \n        // HOWEVER only the opposite order works for rotated pages with\n        // filled fields / annotations that have a matrix in the appearance stream, see PDFBOX-3083\n        Matrix aa = Matrix.concatenate(a, matrix);\n        // make matrix AA the CTM\n        getGraphicsState().setCurrentTransformationMatrix(aa);\n        // clip to bounding box\n        clipToRect(bbox);\n        // needed for patterns in appearance streams, e.g. PDFBOX-2182\n        initialMatrix = aa.clone();\n        try {\n            processStreamOperators(appearance);\n        } finally {\n            restoreGraphicsStack(savedStack);\n            popResources(parent);\n        }\n    }\n}", "/**\n * The annotation rectangle, defining the location of the annotation on the page in default user space units. This\n * is usually required and should not return null on valid PDF documents. But where this is a parent form field with\n * children, such as radio button collections then the rectangle will be null.\n *\n * @return The Rect value of this annotation.\n */\npublic PDRectangle getRectangle() {\n    COSArray rectArray = dictionary.getCOSArray(COSName.RECT);\n    PDRectangle rectangle = null;\n    if (rectArray != null) {\n        if (((((rectArray.size() == 4) && (rectArray.getObject(0) instanceof COSNumber)) && (rectArray.getObject(1) instanceof COSNumber)) && (rectArray.getObject(2) instanceof COSNumber)) && (rectArray.getObject(3) instanceof COSNumber)) {\n            rectangle = new PDRectangle(rectArray);\n        } else {\n            LOG.warn(rectArray + \" is not a rectangle array, returning null\");\n        }\n    }\n    return rectangle;\n}", "/**\n * This will get an object from the array.  This will dereference the object.\n * If the object is COSNull then null will be returned.\n *\n * @param index\n * \t\tThe index into the array to get the object.\n * @return The object at the requested index.\n */\npublic COSBase getObject(int index) {\n    COSBase obj = objects.get(index);\n    if (obj instanceof COSObject) {\n        obj = ((COSObject) (obj)).getObject();\n    }\n    if (obj instanceof COSNull) {\n        obj = null;\n    }\n    return obj;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTransparencyGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTransparencyGroup", "org.apache.pdfbox.contentstream.PDFStreamEngine.processTransparencyGroup", "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.getMatrix", "org.apache.pdfbox.cos.COSDictionary.getDictionaryObject", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "/**\n * Shows a transparency group from the content stream.\n *\n * @param form\n * \t\ttransparency group (form) XObject\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\npublic void showTransparencyGroup(PDTransparencyGroup form) throws IOException {\n    processTransparencyGroup(form);\n}", "/**\n * Processes a transparency group stream.\n *\n * @param group\n * \t\ttransparency group to be processed\n * @throws IOException\n * \t\tif the transparency group cannot be processed\n */\nprotected void processTransparencyGroup(PDTransparencyGroup group) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    PDResources parent = pushResources(group);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(group.getMatrix());\n    // Before execution of the transparency group XObjectâs content stream,\n    // the current blend mode in the graphics state shall be initialized to Normal,\n    // the current stroking and nonstroking alpha constants to 1.0, and the current soft mask to None.\n    graphicsState.setBlendMode(BlendMode.NORMAL);\n    graphicsState.setAlphaConstant(1);\n    graphicsState.setNonStrokeAlphaConstant(1);\n    graphicsState.setSoftMask(null);\n    // clip to bounding box\n    clipToRect(group.getBBox());\n    try {\n        processStreamOperators(group);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * This will get the optional matrix of an XObjectForm. It maps the form space to user space.\n *\n * @return the form matrix if available, or the identity matrix.\n */\n@Override\npublic Matrix getMatrix() {\n    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));\n}", "/**\n * This will get an object from this dictionary. If the object is a reference then it will dereference it and get it\n * from the document. If the object is COSNull then null will be returned.\n *\n * @param key\n * \t\tThe key to the object that we are getting.\n * @return The object that matches the key.\n */\npublic COSBase getDictionaryObject(COSName key) {\n    COSBase retval = items.get(key);\n    if (retval instanceof COSObject) {\n        retval = ((COSObject) (retval)).getObject();\n    }\n    if (retval instanceof COSNull) {\n        retval = null;\n    }\n    return retval;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingPaint.createContext" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new AxialShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3Font.<init>", "org.apache.pdfbox.pdmodel.font.PDSimpleFont.<init>", "org.apache.pdfbox.pdmodel.font.PDFont.<init>", "org.apache.pdfbox.pdmodel.font.PDFont.loadUnicodeCmap" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param resourceCache\n * \t\tResource cache, can be null.\n * @throws IOException\n * \t\tif the font could not be created\n */\npublic PDType3Font(COSDictionary fontDictionary, ResourceCache resourceCache) throws IOException {\n    super(fontDictionary);\n    this.resourceCache = resourceCache;\n    readEncoding();\n}", "/**\n * Constructor for Standard 14.\n */\nPDSimpleFont(FontName baseFont) {\n    super(baseFont);\n    assignGlyphList(baseFont);\n}", "/**\n * Constructor for Standard 14.\n */\nPDFont(FontName baseFont) {\n    dict = new COSDictionary();\n    dict.setItem(COSName.TYPE, COSName.FONT);\n    toUnicodeCMap = null;\n    afmStandard14 = Standard14Fonts.getAFM(baseFont.getName());\n    if (afmStandard14 == null) {\n        throw new IllegalArgumentException(\"No AFM for font \" + baseFont);\n    }\n    fontDescriptor = PDType1FontEmbedder.buildFontDescriptor(afmStandard14);\n    // standard 14 fonts may be accessed concurrently, as they are singletons\n    codeToWidthMap = new ConcurrentHashMap<>();\n}", "private CMap loadUnicodeCmap() {\n    COSBase toUnicode = dict.getDictionaryObject(COSName.TO_UNICODE);\n    if (toUnicode == null) {\n        return null;\n    }\n    CMap cmap = null;\n    try {\n        cmap = readCMap(toUnicode);\n        if ((cmap != null) && (!cmap.hasUnicodeMappings())) {\n            String name = getName();\n            LOG.warn(\"Invalid ToUnicode CMap in font \" + name);\n            String cmapName = (cmap.getName() != null) ? cmap.getName() : \"\";\n            String ordering = (cmap.getOrdering() != null) ? cmap.getOrdering() : \"\";\n            COSName encoding = dict.getCOSName(COSName.ENCODING);\n            if (((cmapName.contains(\"Identity\")// \n             || ordering.contains(\"Identity\"))// \n             || COSName.IDENTITY_H.equals(encoding))// \n             || COSName.IDENTITY_V.equals(encoding)) {\n                COSDictionary encodingDict = dict.getCOSDictionary(COSName.ENCODING);\n                if ((encodingDict == null) || (!encodingDict.containsKey(COSName.DIFFERENCES))) {\n                    // assume that if encoding is identity, then the reverse is also true\n                    cmap = CMapManager.getPredefinedCMap(COSName.IDENTITY_H.getName());\n                    LOG.warn(\"Using predefined identity CMap instead\");\n                }\n            }\n        }\n    } catch (IOException ex) {\n        LOG.error(\"Could not read ToUnicode CMap in font \" + getName(), ex);\n    }\n    return cmap;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.function.PDFunctionType0.eval",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.function.PDFunctionType0.eval", "org.apache.pdfbox.cos.COSArray.toFloatArray", "org.apache.pdfbox.cos.COSArray.getObject", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic float[] eval(float[] input) throws IOException {\n    // This involves linear interpolation based on a set of sample points.\n    // Theoretically it's not that difficult ... see section 3.9.1 of the PDF Reference.\n    float[] sizeValues = getSize().toFloatArray();\n    int bitsPerSample = getBitsPerSample();\n    float maxSample = ((float) (Math.pow(2, bitsPerSample) - 1.0));\n    int numberOfInputValues = input.length;\n    int numberOfOutputValues = getNumberOfOutputParameters();\n    int[] inputPrev = new int[numberOfInputValues];\n    int[] inputNext = new int[numberOfInputValues];\n    input = input.clone();// PDFBOX-4461\n\n    for (int i = 0; i < numberOfInputValues; i++) {\n        PDRange domain = getDomainForInput(i);\n        PDRange encodeValues = getEncodeForParameter(i);\n        float min = domain.getMin();\n        float max = domain.getMax();\n        input[i] = clipToRange(input[i], min, max);\n        input[i] = interpolate(input[i], min, max, encodeValues.getMin(), encodeValues.getMax());\n        input[i] = clipToRange(input[i], 0, sizeValues[i] - 1);\n        inputPrev[i] = ((int) (Math.floor(input[i])));\n        inputNext[i] = ((int) (Math.ceil(input[i])));\n    }\n    float[] outputValues = new Rinterpol(input, inputPrev, inputNext).rinterpolate();\n    for (int i = 0; i < numberOfOutputValues; i++) {\n        PDRange range = getRangeForOutput(i);\n        PDRange decodeValues = getDecodeForParameter(i);\n        if (decodeValues == null) {\n            throw new IOException(\"Range missing in function /Decode entry\");\n        }\n        outputValues[i] = interpolate(outputValues[i], 0, maxSample, decodeValues.getMin(), decodeValues.getMax());\n        outputValues[i] = clipToRange(outputValues[i], range.getMin(), range.getMax());\n    }\n    return outputValues;\n}", "/**\n * This will take an COSArray of numbers and convert it to a float[].\n *\n * @return This COSArray as an array of float numbers.\n */\npublic float[] toFloatArray() {\n    float[] retval = new float[size()];\n    for (int i = 0; i < retval.length; i++) {\n        COSBase base = getObject(i);\n        retval[i] = (base instanceof COSNumber) ? ((COSNumber) (base)).floatValue() : 0;\n    }\n    return retval;\n}", "/**\n * This will get an object from the array.  This will dereference the object.\n * If the object is COSNull then null will be returned.\n *\n * @param index\n * \t\tThe index into the array to get the object.\n * @return The object at the requested index.\n */\npublic COSBase getObject(int index) {\n    COSBase obj = objects.get(index);\n    if (obj instanceof COSObject) {\n        obj = ((COSObject) (obj)).getObject();\n    }\n    if (obj instanceof COSNull) {\n        obj = null;\n    }\n    return obj;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth" ],
    "fullMethods" : [ "/**\n * Determines the width of the space character. This is very important for text extraction.\n *\n * @return the width of the space character\n */\npublic float getSpaceWidth() {\n    if (Float.compare(fontWidthOfSpace, -1.0F) == 0) {\n        try {\n            if ((toUnicodeCMap != null) && dict.containsKey(COSName.TO_UNICODE)) {\n                int spaceMapping = toUnicodeCMap.getSpaceMapping();\n                if (spaceMapping > (-1)) {\n                    fontWidthOfSpace = getWidth(spaceMapping);\n                }\n            } else {\n                try {\n                    // PDFBOX-5920: try with encoding, which gets the correct code\n                    fontWidthOfSpace = getStringWidth(\" \");\n                } catch (IllegalArgumentException | UnsupportedOperationException ex) {\n                    // Happens if space is not available in the font\n                    // or if encoding isn't implemented\n                    LOG.debug(ex.getMessage(), ex);\n                }\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getWidth(32);\n                }\n            }\n            // try to get it from the font itself\n            if (fontWidthOfSpace <= 0) {\n                fontWidthOfSpace = getWidthFromFont(32);\n                // use the average font width as fall back\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getAverageFontWidth();\n                }\n            }\n        } catch (Exception e) {\n            LOG.error((\"Can't determine the width of the space character for font \" + getName()) + \", assuming 250\", e);\n            fontWidthOfSpace = 250.0F;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Space width for font \" + getName()) + \" is \") + fontWidthOfSpace);\n        }\n    }\n    return fontWidthOfSpace;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<init>" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "/**\n * Constructor.\n */\nFileSystemFontProvider(FontCache cache) {\n    this.cache = cache;\n    try {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Will search the local system for fonts\");\n        }\n        // scan the local system for font files\n        FontFileFinder fontFileFinder = new FontFileFinder();\n        List<URI> fonts = fontFileFinder.find();\n        List<File> files = new ArrayList<>(fonts.size());\n        for (URI font : fonts) {\n            files.add(new File(font));\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace((\"Found \" + files.size()) + \" fonts on the local system\");\n        }\n        if (!files.isEmpty()) {\n            // load cached FontInfo objects\n            List<FSFontInfo> cachedInfos = loadDiskCache(files);\n            if ((cachedInfos != null) && (!cachedInfos.isEmpty())) {\n                fontInfoList.addAll(cachedInfos);\n            } else {\n                LOG.info(\"Building on-disk font cache, this may take a while\");\n                scanFonts(files);\n                saveDiskCache();\n                LOG.info((\"Finished building on-disk font cache, found \" + fontInfoList.size()) + \" fonts\");\n            }\n        }\n    } catch (AccessControlException e) {\n        LOG.error(\"Error accessing the file system\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type7ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>" ],
    "fullMethods" : [ "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText", "org.apache.pdfbox.contentstream.PDFStreamEngine.showGlyph", "org.apache.pdfbox.rendering.PageDrawer.showFontGlyph", "org.apache.pdfbox.rendering.GlyphCache.getPathForCharacterCode" ],
    "fullMethods" : [ "/**\n * Called when a string of text is to be shown.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextString(byte[] string) throws IOException {\n    showText(string);\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}", "/**\n * Called when a glyph is to be processed. This method is intended for overriding in subclasses,\n * the default implementation does nothing.\n *\n * @param textRenderingMatrix\n * \t\tthe current text rendering matrix, T<sub>rm</sub>\n * @param font\n * \t\tthe current font\n * @param code\n * \t\tinternal PDF character code for the glyph\n * @param displacement\n * \t\tthe displacement (i.e. advance) of the glyph in text space\n * @throws IOException\n * \t\tif the glyph cannot be processed\n */\nprotected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, Vector displacement) throws IOException {\n    if (font instanceof PDType3Font) {\n        showType3Glyph(textRenderingMatrix, ((PDType3Font) (font)), code, displacement);\n    } else {\n        showFontGlyph(textRenderingMatrix, font, code, displacement);\n    }\n}", "@Override\nprotected void showFontGlyph(Matrix textRenderingMatrix, PDFont font, int code, Vector displacement) throws IOException {\n    AffineTransform at = textRenderingMatrix.createAffineTransform();\n    at.concatenate(font.getFontMatrix().createAffineTransform());\n    // create cache if it does not exist\n    PDVectorFont vectorFont = ((PDVectorFont) (font));\n    GlyphCache cache = glyphCaches.get(font);\n    if (cache == null) {\n        cache = new GlyphCache(vectorFont);\n        glyphCaches.put(font, cache);\n    }\n    GeneralPath path = cache.getPathForCharacterCode(code);\n    drawGlyph(path, font, code, displacement, at);\n}", "public GeneralPath getPathForCharacterCode(int code) {\n    GeneralPath path = cache.get(code);\n    if (path != null) {\n        return path;\n    }\n    try {\n        if (!font.hasGlyph(code)) {\n            String fontName = ((PDFontLike) (font)).getName();\n            if (font instanceof PDType0Font) {\n                int cid = ((PDType0Font) (font)).codeToCID(code);\n                String cidHex = String.format(\"%04x\", cid);\n                LOG.warn(((((\"No glyph for code \" + code) + \" (CID \") + cidHex) + \") in font \") + fontName);\n            } else if (font instanceof PDSimpleFont) {\n                PDSimpleFont simpleFont = ((PDSimpleFont) (font));\n                LOG.warn((((((((\"No glyph for code \" + code) + \" in \") + font.getClass().getSimpleName()) + \" \") + fontName) + \" (embedded or system font used: \") + simpleFont.getFontBoxFont().getName()) + \")\");\n                if ((code == 10) && simpleFont.isStandard14()) {\n                    // PDFBOX-4001 return empty path for line feed on std14\n                    path = new GeneralPath();\n                    cache.put(code, path);\n                    return path;\n                }\n            } else {\n                LOG.warn(((\"No glyph for code \" + code) + \" in font \") + fontName);\n            }\n        }\n        path = font.getNormalizedPath(code);\n        cache.put(code, path);\n        return path;\n    } catch (IOException e) {\n        // todo: escalate this error?\n        String fontName = ((PDFontLike) (font)).getName();\n        LOG.error(((\"Glyph rendering failed for code \" + code) + \" in font \") + fontName, e);\n        return new GeneralPath();\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getFont", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.FSFontInfo.getOTFFont" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n * <p>\n * The method returns null if there was an error opening the font.\n */\n@Override\npublic synchronized FontBoxFont getFont() {\n    // synchronized to avoid race condition on cache access,\n    // which could result in an unreferenced but open font\n    FontBoxFont cached = parent.cache.getFont(this);\n    if (cached != null) {\n        return cached;\n    } else {\n        FontBoxFont font;\n        switch (format) {\n            case PFB :\n                font = getType1Font(postScriptName, file);\n                break;\n            case TTF :\n                font = getTrueTypeFont(postScriptName, file);\n                break;\n            case OTF :\n                font = getOTFFont(postScriptName, file);\n                break;\n            default :\n                throw new RuntimeException(\"can't happen\");\n        }\n        if (font != null) {\n            parent.cache.addFont(this, font);\n        }\n        return font;\n    }\n}", "private OpenTypeFont getOTFFont(String postScriptName, File file) {\n    try {\n        if (file.getName().toLowerCase().endsWith(\".ttc\")) {\n            // ttc not closed here because it is needed later when ttf is accessed,\n            // e.g. rendering PDF with non-embedded font which is in ttc file in our font directory\n            @SuppressWarnings(\"squid:S2095\")\n            TrueTypeCollection ttc = new TrueTypeCollection(file);\n            TrueTypeFont ttf;\n            try {\n                ttf = ttc.getFontByName(postScriptName);\n            } catch (IOException ex) {\n                LOG.error(ex.getMessage(), ex);\n                ttc.close();\n                return null;\n            }\n            if (ttf == null) {\n                ttc.close();\n                throw new IOException(((\"Font \" + postScriptName) + \" not found in \") + file);\n            }\n            return ((OpenTypeFont) (ttf));\n        }\n        OTFParser parser = new OTFParser(false);\n        OpenTypeFont otf = parser.parse(new RandomAccessReadBufferedFile(file));\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Loaded \" + postScriptName) + \" from \") + file);\n        }\n        return otf;\n    } catch (IOException e) {\n        LOG.warn(\"Could not load font file: \" + file, e);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setKids",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setKids", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.calculateLimits" ],
    "fullMethods" : [ "/**\n * Set the children of this named tree.\n *\n * @param kids\n * \t\tThe children of this named tree. These have to be in sorted order. Because of\n * \t\tthat, it is usually easier to call {@link #setNames(Map)} with a map and pass a single\n * \t\telement list here.\n */\npublic void setKids(List<? extends PDNameTreeNode<T>> kids) {\n    if ((kids != null) && (!kids.isEmpty())) {\n        kids.forEach(kidsNode -> kidsNode.setParent(this));\n        node.setItem(COSName.KIDS, new COSArray(kids));\n        // root nodes with kids don't have Names\n        if (isRootNode()) {\n            node.setItem(COSName.NAMES, null);\n        }\n    } else {\n        // remove kids\n        node.setItem(COSName.KIDS, null);\n        // remove Limits\n        node.setItem(COSName.LIMITS, null);\n    }\n    calculateLimits();\n}", "private void calculateLimits() {\n    if (isRootNode()) {\n        node.setItem(COSName.LIMITS, null);\n    } else {\n        List<PDNameTreeNode<T>> kids = getKids();\n        if ((kids != null) && (!kids.isEmpty())) {\n            PDNameTreeNode<T> firstKid = kids.get(0);\n            PDNameTreeNode<T> lastKid = kids.get(kids.size() - 1);\n            String lowerLimit = firstKid.getLowerLimit();\n            setLowerLimit(lowerLimit);\n            String upperLimit = lastKid.getUpperLimit();\n            setUpperLimit(upperLimit);\n        } else {\n            try {\n                Map<String, T> names = getNames();\n                if ((names != null) && (names.size() > 0)) {\n                    Set<String> strings = names.keySet();\n                    String[] keys = strings.toArray(new String[strings.size()]);\n                    String lowerLimit = keys[0];\n                    setLowerLimit(lowerLimit);\n                    String upperLimit = keys[keys.length - 1];\n                    setUpperLimit(upperLimit);\n                } else {\n                    node.setItem(COSName.LIMITS, null);\n                }\n            } catch (IOException exception) {\n                node.setItem(COSName.LIMITS, null);\n                LOG.error(\"Error while calculating the Limits of a PageNameTreeNode:\", exception);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.FDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.FDFParser.parse", "org.apache.pdfbox.pdfparser.FDFParser.initialParse", "org.apache.pdfbox.pdfparser.COSParser.retrieveTrailer", "org.apache.pdfbox.pdfparser.COSParser.parseXref" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the FDFDocument object.\n *\n * @return the parsed FDFDocument\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic FDFDocument parse() throws IOException {\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        if (!parseFDFHeader()) {\n            throw new IOException(\"Error: Header doesn't contain versioninfo\");\n        }\n        initialParse();\n        exceptionOccurred = false;\n        return new FDFDocument(document, source);\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * The initial parse will first parse only the trailer, the xrefstart and all xref tables to have a pointer (offset)\n * to all the pdf's objects. It can handle linearized pdfs, which will have an xref at the end pointing to an xref\n * at the beginning of the file. Last the root object is parsed.\n *\n * @throws IOException\n * \t\tIf something went wrong.\n */\nprivate void initialParse() throws IOException {\n    COSDictionary trailer = retrieveTrailer();\n    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);\n    if (root == null) {\n        throw new IOException(\"Missing root object specification in trailer.\");\n    }\n    initialParseDone = true;\n}", "/**\n * Read the trailer information and provide a COSDictionary containing the trailer information.\n *\n * @return a COSDictionary containing the trailer information\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected COSDictionary retrieveTrailer() throws IOException {\n    COSDictionary trailer = null;\n    boolean rebuildTrailer = false;\n    try {\n        // parse startxref\n        // TODO FDF files don't have a startxref value, so that rebuildTrailer is triggered\n        long startXRefOffset = getStartxrefOffset();\n        if (startXRefOffset > (-1)) {\n            trailer = parseXref(startXRefOffset);\n        } else {\n            rebuildTrailer = isLenient();\n        }\n    } catch (IOException exception) {\n        if (isLenient()) {\n            rebuildTrailer = true;\n        } else {\n            throw exception;\n        }\n    }\n    // check if the trailer contains a Root object\n    if ((trailer != null) && (trailer.getItem(COSName.ROOT) == null)) {\n        rebuildTrailer = isLenient();\n    }\n    if (rebuildTrailer) {\n        trailer = getBruteForceParser().rebuildTrailer(xrefTrailerResolver, null);\n        trailerWasRebuild = true;\n        // transfer encryption information from BruteForceParser\n        encryption = getBruteForceParser().getEncryption();\n        if (encryption != null) {\n            securityHandler = encryption.getSecurityHandler();\n            accessPermission = securityHandler.getCurrentAccessPermission();\n        }\n    } else {\n        // prepare decryption if necessary\n        prepareDecryption();\n        // don't use the getter as it creates an instance of BruteForceParser\n        if ((bruteForceParser != null) && bruteForceParser.bfSearchTriggered()) {\n            getBruteForceParser().bfSearchForObjStreams(xrefTrailerResolver, securityHandler);\n        }\n    }\n    if (resetTrailerResolver()) {\n        xrefTrailerResolver.reset();\n        xrefTrailerResolver = null;\n    }\n    return trailer;\n}", "/**\n * Parses cross reference tables.\n *\n * @param startXRefOffset\n * \t\tstart offset of the first table\n * @return the trailer dictionary\n * @throws IOException\n * \t\tif something went wrong\n */\nprivate COSDictionary parseXref(long startXRefOffset) throws IOException {\n    source.seek(startXRefOffset);\n    long startXrefOffset = Math.max(0, parseStartXref());\n    // check the startxref offset\n    long fixedOffset = checkXRefOffset(startXrefOffset);\n    if (fixedOffset > (-1)) {\n        startXrefOffset = fixedOffset;\n    }\n    document.setStartXref(startXrefOffset);\n    long prev = startXrefOffset;\n    // ---- parse whole chain of xref tables/object streams using PREV reference\n    Set<Long> prevSet = new HashSet<>();\n    COSDictionary trailer = null;\n    while (prev > 0) {\n        // save expected position for loop detection\n        prevSet.add(prev);\n        // seek to xref table\n        source.seek(prev);\n        // skip white spaces\n        skipSpaces();\n        // save current position as well due to skipped spaces\n        prevSet.add(source.getPosition());\n        // -- parse xref\n        if (source.peek() == X) {\n            // xref table and trailer\n            // use existing parser to parse xref table\n            if ((!parseXrefTable(prev)) || (!parseTrailer())) {\n                throw new IOException(\"Expected trailer object at offset \" + source.getPosition());\n            }\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n            // check for a XRef stream, it may contain some object ids of compressed objects\n            if (trailer.containsKey(COSName.XREF_STM)) {\n                int streamOffset = trailer.getInt(COSName.XREF_STM);\n                // check the xref stream reference\n                fixedOffset = checkXRefOffset(streamOffset);\n                if ((fixedOffset > (-1)) && (fixedOffset != streamOffset)) {\n                    LOG.warn(((\"/XRefStm offset \" + streamOffset) + \" is incorrect, corrected to \") + fixedOffset);\n                    streamOffset = ((int) (fixedOffset));\n                    trailer.setInt(COSName.XREF_STM, streamOffset);\n                }\n                if (streamOffset > 0) {\n                    source.seek(streamOffset);\n                    skipSpaces();\n                    try {\n                        parseXrefObjStream(prev, false);\n                        document.setHasHybridXRef();\n                    } catch (IOException ex) {\n                        if (isLenient) {\n                            LOG.error(\"Failed to parse /XRefStm at offset \" + streamOffset, ex);\n                        } else {\n                            throw ex;\n                        }\n                    }\n                } else if (isLenient) {\n                    LOG.error(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                } else {\n                    throw new IOException(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                }\n            }\n            prev = trailer.getLong(COSName.PREV);\n        } else {\n            // parse xref stream\n            prev = parseXrefObjStream(prev, true);\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n        }\n        if (prev > 0) {\n            // check the xref table reference\n            fixedOffset = checkXRefOffset(prev);\n            if ((fixedOffset > (-1)) && (fixedOffset != prev)) {\n                prev = fixedOffset;\n                trailer.setLong(COSName.PREV, prev);\n            }\n        }\n        if (prevSet.contains(prev)) {\n            throw new IOException(\"/Prev loop at offset \" + prev);\n        }\n    } \n    // ---- build valid xrefs out of the xref chain\n    xrefTrailerResolver.setStartxref(startXrefOffset);\n    trailer = xrefTrailerResolver.getTrailer();\n    document.setTrailer(trailer);\n    document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());\n    // check the offsets of all referenced objects\n    if (isLenient) {\n        checkXrefOffsets();\n    }\n    // copy xref table\n    document.addXRefTable(xrefTrailerResolver.getXrefTable());\n    // remember the highest XRef object number to avoid it being reused in incremental saving\n    Optional<Long> maxValue = // \n    // \n    document.getXrefTable().keySet().stream().map(COSObjectKey::getNumber).reduce(Long::max);\n    document.setHighestXRefObjectNumber(maxValue.isPresent() ? maxValue.get() : 0);\n    return trailer;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showForm",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showForm", "org.apache.pdfbox.contentstream.PDFStreamEngine.processStream", "org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject.getMatrix", "org.apache.pdfbox.cos.COSDictionary.getDictionaryObject", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "/**\n * Shows a form from the content stream.\n *\n * @param form\n * \t\tform XObject\n * @throws IOException\n * \t\tif the form cannot be processed\n */\npublic void showForm(PDFormXObject form) throws IOException {\n    if (currentPage == null) {\n        throw new IllegalStateException(\"No current page, call \" + \"#processChildStream(PDContentStream, PDPage) instead\");\n    }\n    if (form.getCOSObject().getLength() > 0) {\n        processStream(form);\n    }\n}", "/**\n * Process a content stream.\n *\n * @param contentStream\n * \t\tthe content stream\n * @throws IOException\n * \t\tif there is an exception while processing the stream\n */\nprivate void processStream(PDContentStream contentStream) throws IOException {\n    PDResources parent = pushResources(contentStream);\n    Deque<PDGraphicsState> savedStack = saveGraphicsStack();\n    Matrix parentMatrix = initialMatrix;\n    PDGraphicsState graphicsState = getGraphicsState();\n    // transform the CTM using the stream's matrix\n    graphicsState.getCurrentTransformationMatrix().concatenate(contentStream.getMatrix());\n    // the stream's initial matrix includes the parent CTM, e.g. this allows a scaled form\n    initialMatrix = graphicsState.getCurrentTransformationMatrix().clone();\n    // clip to bounding box\n    PDRectangle bbox = contentStream.getBBox();\n    clipToRect(bbox);\n    try {\n        processStreamOperators(contentStream);\n    } finally {\n        initialMatrix = parentMatrix;\n        restoreGraphicsStack(savedStack);\n        popResources(parent);\n    }\n}", "/**\n * This will get the optional matrix of an XObjectForm. It maps the form space to user space.\n *\n * @return the form matrix if available, or the identity matrix.\n */\n@Override\npublic Matrix getMatrix() {\n    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));\n}", "/**\n * This will get an object from this dictionary. If the object is a reference then it will dereference it and get it\n * from the document. If the object is COSNull then null will be returned.\n *\n * @param key\n * \t\tThe key to the object that we are getting.\n * @return The object that matches the key.\n */\npublic COSBase getDictionaryObject(COSName key) {\n    COSBase retval = items.get(key);\n    if (retval instanceof COSObject) {\n        retval = ((COSObject) (retval)).getObject();\n    }\n    if (retval instanceof COSNull) {\n        retval = null;\n    }\n    return retval;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint.createContext" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type5ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.GlyphCache.getPathForCharacterCode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.GlyphCache.getPathForCharacterCode" ],
    "fullMethods" : [ "public GeneralPath getPathForCharacterCode(int code) {\n    GeneralPath path = cache.get(code);\n    if (path != null) {\n        return path;\n    }\n    try {\n        if (!font.hasGlyph(code)) {\n            String fontName = ((PDFontLike) (font)).getName();\n            if (font instanceof PDType0Font) {\n                int cid = ((PDType0Font) (font)).codeToCID(code);\n                String cidHex = String.format(\"%04x\", cid);\n                LOG.warn(((((\"No glyph for code \" + code) + \" (CID \") + cidHex) + \") in font \") + fontName);\n            } else if (font instanceof PDSimpleFont) {\n                PDSimpleFont simpleFont = ((PDSimpleFont) (font));\n                LOG.warn((((((((\"No glyph for code \" + code) + \" in \") + font.getClass().getSimpleName()) + \" \") + fontName) + \" (embedded or system font used: \") + simpleFont.getFontBoxFont().getName()) + \")\");\n                if ((code == 10) && simpleFont.isStandard14()) {\n                    // PDFBOX-4001 return empty path for line feed on std14\n                    path = new GeneralPath();\n                    cache.put(code, path);\n                    return path;\n                }\n            } else {\n                LOG.warn(((\"No glyph for code \" + code) + \" in font \") + fontName);\n            }\n        }\n        path = font.getNormalizedPath(code);\n        cache.put(code, path);\n        return path;\n    } catch (IOException e) {\n        // todo: escalate this error?\n        String fontName = ((PDFontLike) (font)).getName();\n        LOG.error(((\"Glyph rendering failed for code \" + code) + \" in font \") + fontName, e);\n        return new GeneralPath();\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.getRoleMap",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot.getRoleMap" ],
    "fullMethods" : [ "/**\n * Returns the role map.\n *\n * @return the role map\n */\npublic Map<String, Object> getRoleMap() {\n    COSDictionary rm = getCOSObject().getCOSDictionary(COSName.ROLE_MAP);\n    if (rm != null) {\n        try {\n            return COSDictionaryMap.convertBasicTypesToMap(rm);\n        } catch (IOException e) {\n            LOG.error(e, e);\n        }\n    }\n    return new HashMap<>();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationStamp(COSDictionary a) {\n    super(a);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator", "org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator", "org.apache.pdfbox.contentstream.PDFStreamEngine.operatorException" ],
    "fullMethods" : [ "/**\n * This is used to handle an operation.\n *\n * @param operation\n * \t\tThe operation to perform.\n * @param arguments\n * \t\tThe list of arguments.\n * @throws IOException\n * \t\tIf there is an error processing the operation.\n */\npublic void processOperator(String operation, List<COSBase> arguments) throws IOException {\n    Operator operator = Operator.getOperator(operation);\n    processOperator(operator, arguments);\n}", "/**\n * This is used to handle an operation.\n *\n * @param operator\n * \t\tThe operation to perform.\n * @param operands\n * \t\tThe list of arguments.\n * @throws IOException\n * \t\tIf there is an error processing the operation.\n */\nprotected void processOperator(Operator operator, List<COSBase> operands) throws IOException {\n    String name = operator.getName();\n    OperatorProcessor processor = operators.get(name);\n    if (processor != null) {\n        try {\n            processor.process(operator, operands);\n        } catch (IOException e) {\n            operatorException(operator, operands, e);\n        }\n    } else {\n        unsupportedOperator(operator, operands);\n    }\n}", "/**\n * Called when an exception is thrown by an operator.\n *\n * @param operator\n * \t\tThe unknown operator.\n * @param operands\n * \t\tThe list of operands.\n * @param exception\n * \t\tthe exception which occurred when processing the operator\n * @throws IOException\n * \t\tif there is an error processing the operator exception\n */\nprotected void operatorException(Operator operator, List<COSBase> operands, IOException exception) throws IOException {\n    if (((exception instanceof MissingOperandException) || (exception instanceof MissingResourceException)) || (exception instanceof MissingImageReaderException)) {\n        LOG.error(exception.getMessage(), exception);\n    } else if (exception instanceof EmptyGraphicsStackException) {\n        LOG.warn(exception.getMessage(), exception);\n    } else if (operator.getName().equals(\"Do\")) {\n        // todo: this too forgiving, but PDFBox has always worked this way for DrawObject\n        // some careful refactoring is needed\n        LOG.warn(exception.getMessage(), exception);\n    } else if (exception.getCause() instanceof DataFormatException) {\n        LOG.warn(exception.getMessage(), exception);\n    } else {\n        throw exception;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decrypt",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decrypt", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptString" ],
    "fullMethods" : [ "/**\n * This will dispatch to the correct method.\n *\n * @param obj\n * \t\tThe object to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation Number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void decrypt(COSBase obj, long objNum, long genNum) throws IOException {\n    // PDFBOX-4477: only cache strings and streams, this improves speed and memory footprint\n    if (obj instanceof COSString) {\n        if (objects.contains(obj)) {\n            return;\n        }\n        objects.add(obj);\n        decryptString(((COSString) (obj)), objNum, genNum);\n    } else if (obj instanceof COSStream) {\n        if (objects.contains(obj)) {\n            return;\n        }\n        objects.add(obj);\n        decryptStream(((COSStream) (obj)), objNum, genNum);\n    } else if (obj instanceof COSDictionary) {\n        decryptDictionary(((COSDictionary) (obj)), objNum, genNum);\n    } else if (obj instanceof COSArray) {\n        decryptArray(((COSArray) (obj)), objNum, genNum);\n    }\n}", "/**\n * This will decrypt a string.\n *\n * @param string\n * \t\tthe string to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n */\nprivate void decryptString(COSString string, long objNum, long genNum) {\n    // String encrypted with identity filter\n    if (COSName.IDENTITY.equals(stringFilterName)) {\n        return;\n    }\n    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    try {\n        /* decrypt */\n        encryptData(objNum, genNum, data, outputStream, true);\n        string.setValue(outputStream.toByteArray());\n    } catch (IOException ex) {\n        LOG.error(((((\"Failed to decrypt COSString of length \" + string.getBytes().length) + \" in object \") + objNum) + \": \") + ex.getMessage(), ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument" ],
    "fullMethods" : [ "/**\n * append all pages from source to destination.\n *\n * @param destination\n * \t\tthe document to receive the pages\n * @param source\n * \t\tthe document originating the new pages\n * @throws IOException\n * \t\tIf there is an error accessing data from either\n * \t\tdocument.\n */\npublic void appendDocument(PDDocument destination, PDDocument source) throws IOException {\n    PDFCloneUtility cloner = new PDFCloneUtility(destination);\n    if (source.getDocument().isClosed()) {\n        throw new IOException(\"Error: source PDF is closed.\");\n    }\n    if (destination.getDocument().isClosed()) {\n        throw new IOException(\"Error: destination PDF is closed.\");\n    }\n    PDDocumentCatalog srcCatalog = source.getDocumentCatalog();\n    if (isDynamicXfa(srcCatalog.getAcroForm())) {\n        throw new IOException(\"Error: can't merge source document containing dynamic XFA form content.\");\n    }\n    PDDocumentInformation destInfo = destination.getDocumentInformation();\n    PDDocumentInformation srcInfo = source.getDocumentInformation();\n    mergeInto(srcInfo.getCOSObject(), destInfo.getCOSObject(), cloner, Collections.emptySet());\n    // use the highest version number for the resulting pdf\n    float destVersion = destination.getVersion();\n    float srcVersion = source.getVersion();\n    if (destVersion < srcVersion) {\n        destination.setVersion(srcVersion);\n    }\n    PDDocumentCatalog destCatalog = destination.getDocumentCatalog();\n    mergeAcroForm(cloner, destCatalog, srcCatalog);\n    COSArray destThreads = destCatalog.getCOSObject().getCOSArray(COSName.THREADS);\n    COSArray srcThreads = cloner.cloneForNewDocument(destCatalog.getCOSObject().getCOSArray(COSName.THREADS));\n    if (destThreads == null) {\n        destCatalog.getCOSObject().setItem(COSName.THREADS, srcThreads);\n    } else {\n        destThreads.addAll(srcThreads);\n    }\n    PDDocumentNameDictionary destNames = destCatalog.getNames();\n    PDDocumentNameDictionary srcNames = srcCatalog.getNames();\n    if (srcNames != null) {\n        if (destNames == null) {\n            destCatalog.getCOSObject().setItem(COSName.NAMES, cloner.cloneForNewDocument(srcNames.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcNames, destNames);\n        }\n    }\n    if ((destNames != null) && destNames.getCOSObject().containsKey(COSName.ID_TREE)) {\n        // found in 001031.pdf from PDFBOX-4417 and doesn't belong there\n        destNames.getCOSObject().removeItem(COSName.ID_TREE);\n        LOG.warn(\"Removed /IDTree from /Names dictionary, doesn't belong there\");\n    }\n    PDDocumentNameDestinationDictionary srcDests = srcCatalog.getDests();\n    if (srcDests != null) {\n        PDDocumentNameDestinationDictionary destDests = destCatalog.getDests();\n        if (destDests == null) {\n            destCatalog.getCOSObject().setItem(COSName.DESTS, cloner.cloneForNewDocument(srcDests.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcDests, destDests);\n        }\n    }\n    PDDocumentOutline srcOutline = srcCatalog.getDocumentOutline();\n    if (srcOutline != null) {\n        PDDocumentOutline destOutline = destCatalog.getDocumentOutline();\n        if ((destOutline == null) || (destOutline.getFirstChild() == null)) {\n            PDDocumentOutline cloned = new PDDocumentOutline(cloner.cloneForNewDocument(srcOutline.getCOSObject()));\n            destCatalog.setDocumentOutline(cloned);\n        } else {\n            // search last sibling for dest, because /Last entry is sometimes wrong\n            PDOutlineItem destLastOutlineItem = destOutline.getFirstChild();\n            while (true) {\n                PDOutlineItem outlineItem = destLastOutlineItem.getNextSibling();\n                if (outlineItem == null) {\n                    break;\n                }\n                destLastOutlineItem = outlineItem;\n            } \n            for (PDOutlineItem item : srcOutline.children()) {\n                // get each child, clone its dictionary, remove siblings info,\n                // append outline item created from there\n                COSDictionary clonedDict = cloner.cloneForNewDocument(item.getCOSObject());\n                clonedDict.removeItem(COSName.PREV);\n                clonedDict.removeItem(COSName.NEXT);\n                PDOutlineItem clonedItem = new PDOutlineItem(clonedDict);\n                destLastOutlineItem.insertSiblingAfter(clonedItem);\n                destLastOutlineItem = destLastOutlineItem.getNextSibling();\n            }\n        }\n    }\n    PageMode destPageMode = destCatalog.getPageMode();\n    if (destPageMode == null) {\n        PageMode srcPageMode = srcCatalog.getPageMode();\n        destCatalog.setPageMode(srcPageMode);\n    }\n    COSDictionary srcLabels = srcCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n    if (srcLabels != null) {\n        int destPageCount = destination.getNumberOfPages();\n        COSArray destNums;\n        COSDictionary destLabels = destCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n        if (destLabels == null) {\n            destLabels = new COSDictionary();\n            destNums = new COSArray();\n            destLabels.setItem(COSName.NUMS, destNums);\n            destCatalog.getCOSObject().setItem(COSName.PAGE_LABELS, destLabels);\n        } else {\n            destNums = destLabels.getCOSArray(COSName.NUMS);\n        }\n        COSArray srcNums = srcLabels.getCOSArray(COSName.NUMS);\n        if (srcNums != null) {\n            int startSize = destNums.size();\n            for (int i = 0; i < srcNums.size(); i += 2) {\n                COSBase base = srcNums.getObject(i);\n                if (!(base instanceof COSNumber)) {\n                    LOG.error(((\"page labels ignored, index \" + i) + \" should be a number, but is \") + base);\n                    // remove what we added\n                    while (destNums.size() > startSize) {\n                        destNums.remove(startSize);\n                    } \n                    break;\n                }\n                COSNumber labelIndex = ((COSNumber) (base));\n                long labelIndexValue = labelIndex.intValue();\n                destNums.add(COSInteger.get(labelIndexValue + destPageCount));\n                destNums.add(cloner.cloneForNewDocument(srcNums.getObject(i + 1)));\n            }\n        }\n    }\n    COSStream destMetadata = destCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    COSStream srcMetadata = srcCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    if ((destMetadata == null) && (srcMetadata != null)) {\n        try {\n            PDStream newStream = new PDStream(destination, srcMetadata.createInputStream(), ((COSName) (null)));\n            mergeInto(srcMetadata, newStream.getCOSObject(), cloner, new HashSet<>(Arrays.asList(COSName.FILTER, COSName.LENGTH)));\n            destCatalog.getCOSObject().setItem(COSName.METADATA, newStream);\n        } catch (IOException ex) {\n            // PDFBOX-4227 cleartext XMP stream with /Flate\n            LOG.error(\"Metadata skipped because it could not be read\", ex);\n        }\n    }\n    COSDictionary destOCP = destCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    COSDictionary srcOCP = srcCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    if ((destOCP == null) && (srcOCP != null)) {\n        destCatalog.getCOSObject().setItem(COSName.OCPROPERTIES, cloner.cloneForNewDocument(srcOCP));\n    } else if ((destOCP != null) && (srcOCP != null)) {\n        cloner.cloneMerge(srcOCP, destOCP);\n    }\n    mergeOutputIntents(srcCatalog, destCatalog, cloner);\n    // merge logical structure hierarchy\n    boolean mergeStructTree = false;\n    int destParentTreeNextKey = -1;\n    Map<Integer, COSObjectable> srcNumberTreeAsMap = null;\n    Map<Integer, COSObjectable> destNumberTreeAsMap = null;\n    PDStructureTreeRoot srcStructTree = srcCatalog.getStructureTreeRoot();\n    PDStructureTreeRoot destStructTree = destCatalog.getStructureTreeRoot();\n    if ((destStructTree == null) && (srcStructTree != null)) {\n        // create a dummy structure tree in the destination, so that the source\n        // tree is cloned. (We can't just copy the tree reference due to PDFBOX-3999)\n        destStructTree = new PDStructureTreeRoot();\n        destCatalog.setStructureTreeRoot(destStructTree);\n        destStructTree.setParentTree(new PDNumberTreeNode(PDParentTreeValue.class));\n        // PDFBOX-4429: remove bogus StructParent(s)\n        for (PDPage page : destCatalog.getPages()) {\n            page.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : page.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n    }\n    if (destStructTree != null) {\n        PDNumberTreeNode destParentTree = destStructTree.getParentTree();\n        destParentTreeNextKey = destStructTree.getParentTreeNextKey();\n        if (destParentTree != null) {\n            destNumberTreeAsMap = getNumberTreeAsMap(destParentTree);\n            if (destParentTreeNextKey < 0) {\n                if (destNumberTreeAsMap.isEmpty()) {\n                    destParentTreeNextKey = 0;\n                } else {\n                    destParentTreeNextKey = Collections.max(destNumberTreeAsMap.keySet()) + 1;\n                }\n            }\n            if ((destParentTreeNextKey >= 0) && (srcStructTree != null)) {\n                PDNumberTreeNode srcParentTree = srcStructTree.getParentTree();\n                if (srcParentTree != null) {\n                    srcNumberTreeAsMap = getNumberTreeAsMap(srcParentTree);\n                    if (!srcNumberTreeAsMap.isEmpty()) {\n                        mergeStructTree = true;\n                    }\n                }\n            }\n        }\n    }\n    Map<COSDictionary, COSDictionary> objMapping = new HashMap<>();\n    PDPageTree destinationPageTree = destination.getPages();// cache PageTree\n\n    for (PDPage page : srcCatalog.getPages()) {\n        PDPage newPage = new PDPage(cloner.cloneForNewDocument(page.getCOSObject()));\n        if (!mergeStructTree) {\n            // PDFBOX-4429: remove bogus StructParent(s)\n            newPage.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : newPage.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n        newPage.setCropBox(page.getCropBox());\n        newPage.setMediaBox(page.getMediaBox());\n        newPage.setRotation(page.getRotation());\n        PDResources resources = page.getResources();\n        if (resources != null) {\n            // this is smart enough to just create references for resources that are used on multiple pages\n            newPage.setResources(new PDResources(cloner.cloneForNewDocument(resources.getCOSObject())));\n        } else {\n            newPage.setResources(new PDResources());\n        }\n        if (mergeStructTree) {\n            // add the value of the destination ParentTreeNextKey to every source element\n            // StructParent(s) value so that these don't overlap with the existing values\n            updateStructParentEntries(newPage, destParentTreeNextKey);\n            objMapping.put(page.getCOSObject(), newPage.getCOSObject());\n            List<PDAnnotation> oldAnnots = page.getAnnotations();\n            List<PDAnnotation> newAnnots = newPage.getAnnotations();\n            for (int i = 0; i < oldAnnots.size(); i++) {\n                objMapping.put(oldAnnots.get(i).getCOSObject(), newAnnots.get(i).getCOSObject());\n            }\n            // TODO update mapping for XObjects\n        }\n        destinationPageTree.add(newPage);\n    }\n    mergeOpenAction(srcCatalog, destCatalog, cloner);\n    if (mergeStructTree) {\n        updatePageReferences(cloner, srcNumberTreeAsMap, objMapping);\n        int maxSrcKey = -1;\n        for (Map.Entry<Integer, COSObjectable> entry : srcNumberTreeAsMap.entrySet()) {\n            int srcKey = entry.getKey();\n            maxSrcKey = Math.max(srcKey, maxSrcKey);\n            COSObjectable value = entry.getValue();\n            if (value != null) {\n                value = cloner.cloneForNewDocument(value.getCOSObject());\n                destNumberTreeAsMap.put(destParentTreeNextKey + srcKey, value);\n            }\n        }\n        destParentTreeNextKey += maxSrcKey + 1;\n        PDNumberTreeNode newParentTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);\n        // Note that all elements are stored flatly. This could become a problem for large files\n        // when these are opened in a viewer that uses the tagging information.\n        // If this happens, then PDNumberTreeNode should be improved with a convenience method that\n        // stores the map into a B+Tree, see https://en.wikipedia.org/wiki/B+_tree\n        newParentTreeNode.setNumbers(destNumberTreeAsMap);\n        destStructTree.setParentTree(newParentTreeNode);\n        destStructTree.setParentTreeNextKey(destParentTreeNextKey);\n        mergeKEntries(cloner, srcStructTree, destStructTree);\n        mergeRoleMap(srcStructTree, destStructTree, cloner);\n        mergeIDTree(cloner, srcStructTree, destStructTree);\n        mergeMarkInfo(destCatalog, srcCatalog);\n        mergeLanguage(destCatalog, srcCatalog);\n        mergeViewerPreferences(destCatalog, srcCatalog, cloner);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint.createContext" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type4ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont", "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>" ],
    "fullMethods" : [ "/**\n * Creates a new PDFont instance with the appropriate subclass.\n *\n * @param dictionary\n * \t\ta font dictionary\n * @param resourceCache\n * \t\tresource cache, only useful for type 3 fonts, can be null\n * @return a PDFont instance, based on the SubType entry of the dictionary\n * @throws IOException\n * \t\tif something goes wrong\n */\npublic static PDFont createFont(COSDictionary dictionary, ResourceCache resourceCache) throws IOException {\n    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);\n    if (!COSName.FONT.equals(type)) {\n        LOG.error((\"Expected 'Font' dictionary but found '\" + type.getName()) + \"'\");\n    }\n    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);\n    if (COSName.TYPE1.equals(subType)) {\n        COSDictionary fd = dictionary.getCOSDictionary(COSName.FONT_DESC);\n        if ((fd != null) && fd.containsKey(COSName.FONT_FILE3)) {\n            return new PDType1CFont(dictionary);\n        }\n        return new PDType1Font(dictionary);\n    } else if (COSName.MM_TYPE1.equals(subType)) {\n        COSDictionary fd = dictionary.getCOSDictionary(COSName.FONT_DESC);\n        if ((fd != null) && fd.containsKey(COSName.FONT_FILE3)) {\n            return new PDType1CFont(dictionary);\n        }\n        return new PDMMType1Font(dictionary);\n    } else if (COSName.TRUE_TYPE.equals(subType)) {\n        return new PDTrueTypeFont(dictionary);\n    } else if (COSName.TYPE3.equals(subType)) {\n        return new PDType3Font(dictionary, resourceCache);\n    } else if (COSName.TYPE0.equals(subType)) {\n        COSDictionary fontDescriptor = getFontDescriptor(dictionary);\n        FontType fontTypeFromFont = getFontTypeFromFont(fontDescriptor, subType);\n        if (fontTypeFromFont != null) {\n            COSDictionary descendantFont = getDescendantFont(dictionary);\n            COSName descFontType = (descendantFont != null) ? descendantFont.getCOSName(COSName.SUBTYPE) : null;\n            if ((descFontType != null) && (!fontTypeFromFont.isCIDSubtype(descFontType))) {\n                fixType0Subtype(descendantFont, fontDescriptor, fontTypeFromFont.getSubtype());\n            }\n        }\n        return new PDType0Font(dictionary);\n    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {\n        throw new IOException(\"Type 0 descendant font not allowed\");\n    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {\n        throw new IOException(\"Type 2 descendant font not allowed\");\n    } else {\n        // assuming Type 1 font (see PDFBOX-1988) because it seems that Adobe Reader does this\n        // however, we may need more sophisticated logic perhaps looking at the FontFile\n        LOG.warn((\"Invalid font subtype '\" + subType) + \"'\");\n        return new PDType1Font(dictionary);\n    }\n}", "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tthe corresponding dictionary\n * @throws IOException\n * \t\tit something went wrong\n */\npublic PDType1CFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    boolean fontIsDamaged = false;\n    CFFType1Font cffEmbedded = null;\n    PDFontDescriptor fd = getFontDescriptor();\n    if (fd != null) {\n        PDStream ff3Stream = fd.getFontFile3();\n        if (ff3Stream != null) {\n            try (RandomAccessRead randomAccessRead = ff3Stream.getCOSObject().createView()) {\n                if (randomAccessRead.length() == 0) {\n                    LOG.error(\"Invalid data for embedded Type1C font \" + getName());\n                } else {\n                    // note: this could be an OpenType file, fortunately CFFParser can handle that\n                    CFFParser cffParser = new CFFParser();\n                    CFFFont parsedCffFont = cffParser.parse(randomAccessRead).get(0);\n                    if (parsedCffFont instanceof CFFType1Font) {\n                        cffEmbedded = ((CFFType1Font) (parsedCffFont));\n                    } else {\n                        LOG.error(\"Expected CFFType1Font, got \" + parsedCffFont.getClass().getSimpleName());\n                        fontIsDamaged = true;\n                    }\n                }\n            } catch (IOException e) {\n                LOG.error(\"Can't read the embedded Type1C font \" + getName(), e);\n                fontIsDamaged = true;\n            }\n        }\n    }\n    isDamaged = fontIsDamaged;\n    cffFont = cffEmbedded;\n    if (cffFont != null) {\n        genericFont = cffFont;\n        isEmbedded = true;\n    } else {\n        String baseFont = getBaseFont();\n        FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(baseFont, fd);\n        genericFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + genericFont.getName()) + \" for \") + baseFont);\n        }\n        isEmbedded = false;\n    }\n    readEncoding();\n    fontMatrixTransform = getFontMatrix().createAffineTransform();\n    fontMatrixTransform.scale(1000, 1000);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSObject.getObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param parent\n * \t\tThe parent font.\n * @throws IOException\n * \t\tif the font could not be read\n */\npublic PDCIDFontType0(COSDictionary fontDictionary, PDType0Font parent) throws IOException {\n    super(fontDictionary, parent);\n    boolean fontIsDamaged = false;\n    CFFFont cffFont = null;\n    PDFontDescriptor fd = getFontDescriptor();\n    if (fd != null) {\n        PDStream ff3Stream = fd.getFontFile3();\n        if (ff3Stream != null) {\n            try (RandomAccessRead randomAccessRead = ff3Stream.getCOSObject().createView()) {\n                if ((randomAccessRead.length() > 0) && (randomAccessRead.peek() == '%')) {\n                    // PDFBOX-2642 contains a corrupt PFB font instead of a CFF\n                    LOG.warn(\"Found PFB but expected embedded CFF font \" + fd.getFontName());\n                    fontIsDamaged = true;\n                } else {\n                    CFFParser cffParser = new CFFParser();\n                    cffFont = cffParser.parse(randomAccessRead).get(0);\n                }\n            } catch (IOException e) {\n                LOG.error(\"Can't read the embedded CFF font \" + fd.getFontName(), e);\n                fontIsDamaged = true;\n            }\n        }\n    }\n    if (cffFont != null) {\n        // embedded\n        if (cffFont instanceof CFFCIDFont) {\n            cidFont = ((CFFCIDFont) (cffFont));\n            t1Font = null;\n        } else {\n            cidFont = null;\n            t1Font = cffFont;\n        }\n        cid2gid = readCIDToGIDMap();\n        isEmbedded = true;\n        isDamaged = false;\n    } else {\n        // find font or substitute\n        CIDFontMapping mapping = FontMappers.instance().getCIDFont(getBaseFont(), getFontDescriptor(), getCIDSystemInfo());\n        FontBoxFont font;\n        if (mapping.isCIDFont()) {\n            cffFont = mapping.getFont().getCFF().getFont();\n            if (cffFont instanceof CFFCIDFont) {\n                cidFont = ((CFFCIDFont) (cffFont));\n                t1Font = null;\n                font = cidFont;\n            } else {\n                // PDFBOX-3515: OpenType fonts are loaded as CFFType1Font\n                CFFType1Font f = ((CFFType1Font) (cffFont));\n                cidFont = null;\n                t1Font = f;\n                font = f;\n            }\n        } else {\n            cidFont = null;\n            t1Font = mapping.getTrueTypeFont();\n            font = t1Font;\n        }\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback \" + font.getName()) + \" for CID-keyed font \") + getBaseFont());\n        }\n        isEmbedded = false;\n        isDamaged = fontIsDamaged;\n    }\n    fontMatrixTransform = getFontMatrix().createAffineTransform();\n    fontMatrixTransform.scale(1000, 1000);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingContext.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingContext.<init>" ],
    "fullMethods" : [ "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tthe bounds of the area to paint, in device units\n * @throws IOException\n * \t\tif there is an error getting the color space or doing color conversion.\n */\npublic RadialShadingContext(PDShadingType3 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    this.radialShadingType = shading;\n    coords = shading.getCoords().toFloatArray();\n    // domain values\n    if (this.radialShadingType.getDomain() != null) {\n        domain = shading.getDomain().toFloatArray();\n    } else {\n        // set default values\n        domain = new float[]{ 0, 1 };\n    }\n    // extend values\n    COSArray extendValues = shading.getExtend();\n    if (extendValues != null) {\n        extend = new boolean[2];\n        extend[0] = ((COSBoolean) (extendValues.getObject(0))).getValue();\n        extend[1] = ((COSBoolean) (extendValues.getObject(1))).getValue();\n    } else {\n        // set default values\n        extend = new boolean[]{ false, false };\n    }\n    // calculate some constants to be used in getRaster\n    x1x0 = coords[3] - coords[0];\n    y1y0 = coords[4] - coords[1];\n    r1r0 = coords[5] - coords[2];\n    r0pow2 = Math.pow(coords[2], 2);\n    denom = (Math.pow(x1x0, 2) + Math.pow(y1y0, 2)) - Math.pow(r1r0, 2);\n    d1d0 = domain[1] - domain[0];\n    try {\n        // get inverse transform to be independent of current user / device space\n        // when handling actual pixels in getRaster()\n        rat = matrix.createAffineTransform().createInverse();\n        rat.concatenate(xform.createInverse());\n    } catch (NoninvertibleTransformException ex) {\n        LOG.error((ex.getMessage() + \", matrix: \") + matrix, ex);\n        rat = new AffineTransform();\n    }\n    // shading space -> device space\n    AffineTransform shadingToDevice = ((AffineTransform) (xform.clone()));\n    shadingToDevice.concatenate(matrix.createAffineTransform());\n    // worst case for the number of steps is opposite diagonal corners, so use that\n    double dist = Math.sqrt(Math.pow(deviceBounds.getMaxX() - deviceBounds.getMinX(), 2) + Math.pow(deviceBounds.getMaxY() - deviceBounds.getMinY(), 2));\n    factor = ((int) (Math.ceil(dist)));\n    // build the color table for the given number of steps\n    colorTable = calcColorTable();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup", "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroupOnGraphics" ],
    "fullMethods" : [ "@Override\npublic void showTransparencyGroup(PDTransparencyGroup form) throws IOException {\n    showTransparencyGroupOnGraphics(form, graphics);\n}", "/**\n * For advanced users, to extract the transparency group into a separate graphics device.\n *\n * @param form\n * \t\tthe transparency group to be extracted\n * @param graphics\n * \t\tthe target graphics device\n * @throws IOException\n * \t\tif the transparency group could not be extracted\n */\nprotected void showTransparencyGroupOnGraphics(PDTransparencyGroup form, Graphics2D graphics) throws IOException {\n    if (isHiddenOCG(form.getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    TransparencyGroup group = new TransparencyGroup(form, false, getGraphicsState().getCurrentTransformationMatrix(), null);\n    BufferedImage image = group.getImage();\n    if (image == null) {\n        // image is empty, don't bother\n        return;\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    // both the DPI xform and the CTM were already applied to the group, so all we do\n    // here is draw it directly onto the Graphics2D device at the appropriate position\n    AffineTransform savedTransform = graphics.getTransform();\n    AffineTransform transform = new AffineTransform(xform);\n    transform.scale(1.0 / xformScalingFactorX, 1.0 / xformScalingFactorY);\n    graphics.setTransform(transform);\n    // adjust bbox (x,y) position at the initial scale + cropbox\n    PDRectangle bbox = group.getBBox();\n    float x = bbox.getLowerLeftX() - pageSize.getLowerLeftX();\n    float y = pageSize.getUpperRightY() - bbox.getUpperRightY();\n    if (flipTG) {\n        graphics.translate(0, image.getHeight());\n        graphics.scale(1, -1);\n    } else {\n        graphics.translate(x * xformScalingFactorX, y * xformScalingFactorY);\n    }\n    PDSoftMask softMask = getGraphicsState().getSoftMask();\n    if (softMask != null) {\n        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Float(0, 0, image.getWidth(), image.getHeight()));\n        awtPaint = applySoftMaskToPaint(awtPaint, softMask);\n        graphics.setPaint(awtPaint);\n        graphics.fill(new Rectangle2D.Float(0, 0, bbox.getWidth() * xformScalingFactorX, bbox.getHeight() * xformScalingFactorY));\n    } else {\n        try {\n            graphics.drawImage(image, null, null);\n        } catch (InternalError ie) {\n            LOG.error(\"Exception drawing image, see JDK-6689349, \" + \"try rendering into a BufferedImage instead\", ie);\n        }\n    }\n    graphics.setTransform(savedTransform);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type6ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingPaint.createContext" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new RadialShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.fillPath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.fillPath", "org.apache.pdfbox.rendering.PageDrawer.intersectShadingBBox", "org.apache.pdfbox.pdmodel.graphics.pattern.PDAbstractPattern.getMatrix", "org.apache.pdfbox.cos.COSDictionary.getDictionaryObject", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "@Override\npublic void fillPath(int windingRule) throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    graphics.setComposite(graphicsState.getNonStrokingJavaComposite());\n    setClip();\n    linePath.setWindingRule(windingRule);\n    // disable anti-aliasing for rectangular paths, this is a workaround to avoid small stripes\n    // which occur when solid fills are used to simulate piecewise gradients, see PDFBOX-2302\n    // note that we ignore paths with a width/height under 1 as these are fills used as strokes,\n    // see PDFBOX-1658 for an example\n    Rectangle2D bounds = linePath.getBounds2D();\n    boolean noAntiAlias = (isRectangular(linePath) && (bounds.getWidth() > 1)) && (bounds.getHeight() > 1);\n    if (noAntiAlias) {\n        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n    }\n    Shape shape;\n    if (graphicsState.getNonStrokingColorSpace() instanceof PDPattern) {\n        // apply clip to path to avoid oversized device bounds in shading contexts (PDFBOX-2901)\n        Area area = new Area(linePath);\n        Shape clip = graphics.getClip();\n        if (clip != null) {\n            area.intersect(new Area(clip));\n        }\n        intersectShadingBBox(graphicsState.getNonStrokingColor(), area);\n        shape = area;\n    } else {\n        shape = linePath;\n    }\n    if (isContentRendered() && (!shape.getPathIterator(null).isDone())) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        graphics.setPaint(getNonStrokingPaint());\n        graphics.fill(shape);\n    }\n    linePath.reset();\n    if (noAntiAlias) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "// checks whether this is a shading pattern and if yes,\n// get the transformed BBox and intersect with current paint area\n// need to do it here and not in shading getRaster() because it may have been rotated\nprivate void intersectShadingBBox(PDColor color, Area area) throws IOException {\n    if (color.getColorSpace() instanceof PDPattern) {\n        PDColorSpace colorSpace = color.getColorSpace();\n        PDAbstractPattern pat = ((PDPattern) (colorSpace)).getPattern(color);\n        if (pat instanceof PDShadingPattern) {\n            PDShading shading = ((PDShadingPattern) (pat)).getShading();\n            PDRectangle bbox = shading.getBBox();\n            if (bbox != null) {\n                Matrix m = Matrix.concatenate(getInitialMatrix(), pat.getMatrix());\n                Area bboxArea = new Area(bbox.transform(m));\n                area.intersect(bboxArea);\n            }\n        }\n    }\n}", "/**\n * Returns the pattern matrix, or the identity matrix is none is available.\n *\n * @return the pattern matrix\n */\npublic Matrix getMatrix() {\n    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));\n}", "/**\n * This will get an object from this dictionary. If the object is a reference then it will dereference it and get it\n * from the document. If the object is COSNull then null will be returned.\n *\n * @param key\n * \t\tThe key to the object that we are getting.\n * @return The object that matches the key.\n */\npublic COSBase getDictionaryObject(COSName key) {\n    COSBase retval = items.get(key);\n    if (retval instanceof COSObject) {\n        retval = ((COSObject) (retval)).getObject();\n    }\n    if (retval instanceof COSNull) {\n        retval = null;\n    }\n    return retval;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.shadingFill",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.shadingFill", "org.apache.pdfbox.pdmodel.PDResources.getShading", "org.apache.pdfbox.pdmodel.PDResources.get", "org.apache.pdfbox.cos.COSDictionary.getDictionaryObject", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "@Override\npublic void shadingFill(COSName shadingName) throws IOException {\n    if (!isContentRendered()) {\n        return;\n    }\n    PDShading shading = getResources().getShading(shadingName);\n    if (shading == null) {\n        LOG.error((\"shading \" + shadingName) + \" does not exist in resources dictionary\");\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    Shape savedClip = graphics.getClip();\n    graphics.setClip(null);\n    lastClips = null;\n    // get the transformed BBox and intersect with current clipping path\n    // need to do it here and not in shading getRaster() because it may have been rotated\n    PDRectangle bbox = shading.getBBox();\n    Area area;\n    if (bbox != null) {\n        area = new Area(bbox.transform(ctm));\n        area.intersect(getGraphicsState().getCurrentClippingPath());\n    } else {\n        Rectangle2D bounds = shading.getBounds(new AffineTransform(), ctm);\n        if (bounds != null) {\n            bounds.add(new Point2D.Double(Math.floor(bounds.getMinX() - 1), Math.floor(bounds.getMinY() - 1)));\n            bounds.add(new Point2D.Double(Math.ceil(bounds.getMaxX() + 1), Math.ceil(bounds.getMaxY() + 1)));\n            area = new Area(bounds);\n            area.intersect(getGraphicsState().getCurrentClippingPath());\n        } else {\n            area = getGraphicsState().getCurrentClippingPath();\n        }\n    }\n    if (!area.isEmpty()) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        Paint paint = shading.toPaint(ctm);\n        paint = applySoftMaskToPaint(paint, getGraphicsState().getSoftMask());\n        graphics.setPaint(paint);\n        graphics.fill(area);\n    }\n    graphics.setClip(savedClip);\n}", "/**\n * Returns the shading resource with the given name, or null if none exists.\n *\n * @param name\n * \t\tName of the shading resource.\n * @return the shading state with the given name or null\n * @throws IOException\n * \t\tif something went wrong.\n */\npublic PDShading getShading(COSName name) throws IOException {\n    COSObject indirect = getIndirect(COSName.SHADING, name);\n    if ((cache != null) && (indirect != null)) {\n        PDShading cached = cache.getShading(indirect);\n        if (cached != null) {\n            return cached;\n        }\n    }\n    // get the instance\n    PDShading shading = null;\n    COSBase base = get(COSName.SHADING, name);\n    if (base instanceof COSDictionary) {\n        shading = PDShading.create(((COSDictionary) (base)));\n    }\n    if ((cache != null) && (indirect != null)) {\n        cache.put(indirect, shading);\n    }\n    return shading;\n}", "/**\n * Returns the resource with the given name and kind, or null.\n */\nprivate COSBase get(COSName kind, COSName name) {\n    COSDictionary dict = resources.getCOSDictionary(kind);\n    return dict != null ? dict.getDictionaryObject(name) : null;\n}", "/**\n * This will get an object from this dictionary. If the object is a reference then it will dereference it and get it\n * from the document. If the object is COSNull then null will be returned.\n *\n * @param key\n * \t\tThe key to the object that we are getting.\n * @return The object that matches the key.\n */\npublic COSBase getDictionaryObject(COSName key) {\n    COSBase retval = items.get(key);\n    if (retval instanceof COSObject) {\n        retval = ((COSObject) (retval)).getObject();\n    }\n    if (retval instanceof COSNull) {\n        retval = null;\n    }\n    return retval;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingContext.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingContext.<init>" ],
    "fullMethods" : [ "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tthe bounds of the area to paint, in device units\n * @throws IOException\n * \t\tif there is an error getting the color space or doing color conversion.\n */\npublic AxialShadingContext(PDShadingType2 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    this.axialShadingType = shading;\n    coords = shading.getCoords().toFloatArray();\n    // domain values\n    if (shading.getDomain() != null) {\n        domain = shading.getDomain().toFloatArray();\n    } else {\n        // set default values\n        domain = new float[]{ 0, 1 };\n    }\n    // extend values\n    COSArray extendValues = shading.getExtend();\n    if (extendValues != null) {\n        extend = new boolean[2];\n        extend[0] = ((COSBoolean) (extendValues.getObject(0))).getValue();\n        extend[1] = ((COSBoolean) (extendValues.getObject(1))).getValue();\n    } else {\n        // set default values\n        extend = new boolean[]{ false, false };\n    }\n    // calculate some constants to be used in getRaster\n    x1x0 = coords[2] - coords[0];\n    y1y0 = coords[3] - coords[1];\n    d1d0 = domain[1] - domain[0];\n    denom = Math.pow(x1x0, 2) + Math.pow(y1y0, 2);\n    try {\n        // get inverse transform to be independent of current user / device space\n        // when handling actual pixels in getRaster()\n        rat = matrix.createAffineTransform().createInverse();\n        rat.concatenate(xform.createInverse());\n    } catch (NoninvertibleTransformException ex) {\n        LOG.error((ex.getMessage() + \", matrix: \") + matrix, ex);\n        rat = new AffineTransform();\n    }\n    // shading space -> device space\n    AffineTransform shadingToDevice = ((AffineTransform) (xform.clone()));\n    shadingToDevice.concatenate(matrix.createAffineTransform());\n    // worst case for the number of steps is opposite diagonal corners, so use that\n    double dist = Math.sqrt(Math.pow(deviceBounds.getMaxX() - deviceBounds.getMinX(), 2) + Math.pow(deviceBounds.getMaxY() - deviceBounds.getMinY(), 2));\n    factor = ((int) (Math.ceil(dist)));\n    // build the color table for the given number of steps\n    colorTable = calcColorTable();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLineAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLineAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationLine annotation = ((PDAnnotationLine) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        return;\n    }\n    float[] pathsArray = annotation.getLine();\n    if (pathsArray == null) {\n        return;\n    }\n    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());\n    PDColor color = annotation.getColor();\n    if ((color == null) || (color.getComponents().length == 0)) {\n        return;\n    }\n    float ll = annotation.getLeaderLineLength();\n    float lle = annotation.getLeaderLineExtensionLength();\n    float llo = annotation.getLeaderLineOffsetLength();\n    // Adjust rectangle even if not empty, see PLPDF.com-MarkupAnnotations.pdf\n    float minX = Float.MAX_VALUE;\n    float minY = Float.MAX_VALUE;\n    float maxX = Float.MIN_VALUE;\n    float maxY = Float.MIN_VALUE;\n    for (int i = 0; i < (pathsArray.length / 2); ++i) {\n        float x = pathsArray[i * 2];\n        float y = pathsArray[(i * 2) + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n    }\n    // Leader lines\n    if (ll < 0) {\n        // /LLO and /LLE go in the same direction as /LL\n        llo = -llo;\n        lle = -lle;\n    }\n    // observed with diagonal line of AnnotationSample.Standard.pdf\n    // for line endings, very small widths must be treated as size 1.\n    // However the border of the line ending shapes is not drawn.\n    float lineEndingSize = (ab.width < 1.0E-5) ? 1 : ab.width;\n    // add/subtract with, font height, and arrows\n    // arrow length is 9 * width at about 30Â° => 10 * width seems to be enough\n    // but need to consider /LL, /LLE and /LLO too\n    // TODO find better way to calculate padding\n    float max = Math.max(lineEndingSize * 10, Math.abs((llo + ll) + lle));\n    rect.setLowerLeftX(Math.min(minX - max, rect.getLowerLeftX()));\n    rect.setLowerLeftY(Math.min(minY - max, rect.getLowerLeftY()));\n    rect.setUpperRightX(Math.max(maxX + max, rect.getUpperRightX()));\n    rect.setUpperRightY(Math.max(maxY + max, rect.getUpperRightY()));\n    annotation.setRectangle(rect);\n    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {\n        setOpacity(cs, annotation.getConstantOpacity());\n        // Tested with Adobe Reader:\n        // text is written first (TODO)\n        // width 0 is used by Adobe as such (but results in a visible line in rendering)\n        // empty color array results in an invisible line (\"n\" operator) but the rest is visible\n        // empty content is like no caption\n        boolean hasStroke = cs.setStrokingColorOnDemand(color);\n        if (ab.dashArray != null) {\n            cs.setLineDashPattern(ab.dashArray, 0);\n        }\n        cs.setLineWidth(ab.width);\n        float x1 = pathsArray[0];\n        float y1 = pathsArray[1];\n        float x2 = pathsArray[2];\n        float y2 = pathsArray[3];\n        // if there are leader lines, then the /L coordinates represent\n        // the endpoints of the leader lines rather than the endpoints of the line itself.\n        // so for us, llo + ll is the vertical offset for the line.\n        float y = llo + ll;\n        String contents = annotation.getContents();\n        if (contents == null) {\n            contents = \"\";\n        }\n        cs.saveGraphicsState();\n        double angle = Math.atan2(y2 - y1, x2 - x1);\n        cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n        float lineLength = ((float) (Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)))));\n        // Leader lines\n        cs.moveTo(0, llo);\n        cs.lineTo(0, (llo + ll) + lle);\n        cs.moveTo(lineLength, llo);\n        cs.lineTo(lineLength, (llo + ll) + lle);\n        if (annotation.hasCaption() && (!contents.isEmpty())) {\n            // Note that Adobe places the text as a caption even if /CP is not set\n            // when the text is so long that it would cross arrows, but we ignore this for now\n            // and stick to the specification.\n            PDFont font = getDefaultFont();\n            // TODO: support newlines!!!!!\n            // see https://www.pdfill.com/example/pdf_commenting_new.pdf\n            float contentLength = 0;\n            try {\n                contentLength = (font.getStringWidth(annotation.getContents()) / 1000) * FONT_SIZE;\n                // TODO How to decide the size of the font?\n                // 9 seems to be standard, but if the text doesn't fit, a scaling is done\n                // see AnnotationSample.Standard.pdf, diagonal line\n            } catch (IllegalArgumentException ex) {\n                // Adobe Reader displays placeholders instead\n                LOG.error((\"line text '\" + annotation.getContents()) + \"' can't be shown\", ex);\n            }\n            float xOffset = (lineLength - contentLength) / 2;\n            float yOffset;\n            String captionPositioning = annotation.getCaptionPositioning();\n            // draw the line horizontally, using the rotation CTM to get to correct final position\n            // that's the easiest way to calculate the positions for the line before and after inline caption\n            if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.moveTo(lineEndingSize, y);\n            } else {\n                cs.moveTo(0, y);\n            }\n            if (\"Top\".equals(captionPositioning)) {\n                // this arbitrary number is from Adobe\n                yOffset = 1.908F;\n            } else {\n                // Inline\n                // this arbitrary number is from Adobe\n                yOffset = -2.6F;\n                cs.lineTo(xOffset - lineEndingSize, y);\n                cs.moveTo((lineLength - xOffset) + lineEndingSize, y);\n            }\n            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.lineTo(lineLength - lineEndingSize, y);\n            } else {\n                cs.lineTo(lineLength, y);\n            }\n            cs.drawShape(lineEndingSize, hasStroke, false);\n            // /CO entry (caption offset)\n            float captionHorizontalOffset = annotation.getCaptionHorizontalOffset();\n            float captionVerticalOffset = annotation.getCaptionVerticalOffset();\n            // check contentLength so we don't show if there was trouble before\n            if (contentLength > 0) {\n                cs.beginText();\n                cs.setFont(font, FONT_SIZE);\n                cs.newLineAtOffset(xOffset + captionHorizontalOffset, (y + yOffset) + captionVerticalOffset);\n                cs.showText(annotation.getContents());\n                cs.endText();\n            }\n            if (Float.compare(captionVerticalOffset, 0) != 0) {\n                // Adobe paints vertical bar to the caption\n                cs.moveTo(0 + (lineLength / 2), y);\n                cs.lineTo(0 + (lineLength / 2), y + captionVerticalOffset);\n                cs.drawShape(lineEndingSize, hasStroke, false);\n            }\n        } else {\n            if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.moveTo(lineEndingSize, y);\n            } else {\n                cs.moveTo(0, y);\n            }\n            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.lineTo(lineLength - lineEndingSize, y);\n            } else {\n                cs.lineTo(lineLength, y);\n            }\n            cs.drawShape(lineEndingSize, hasStroke, false);\n        }\n        cs.restoreGraphicsState();\n        // paint the styles here and not before showing the text, or the text would appear\n        // with the interior color\n        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());\n        // observed with diagonal line of file AnnotationSample.Standard.pdf\n        // when width is very small, the border of the line ending shapes\n        // is not drawn.\n        if (ab.width < 1.0E-5) {\n            hasStroke = false;\n        }\n        // check for LE_NONE only needed to avoid q cm Q for that case\n        if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {\n            cs.saveGraphicsState();\n            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {\n                cs.transform(Matrix.getRotateInstance(angle, x1, y1));\n                drawStyle(annotation.getStartPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, false);\n            } else {\n                // Support of non-angled styles is more difficult than in the other handlers\n                // because the lines do not always go from (x1,y1) to (x2,y2) due to the leader lines\n                // when the \"y\" value above is not 0.\n                // We use the angle we already know and the distance y to translate to the new coordinate.\n                float xx1 = x1 - ((float) (y * Math.sin(angle)));\n                float yy1 = y1 + ((float) (y * Math.cos(angle)));\n                drawStyle(annotation.getStartPointEndingStyle(), cs, xx1, yy1, lineEndingSize, hasStroke, hasBackground, false);\n            }\n            cs.restoreGraphicsState();\n        }\n        // check for LE_NONE only needed to avoid q cm Q for that case\n        if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {\n            // save / restore not needed because it's the last one\n            if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {\n                cs.transform(Matrix.getRotateInstance(angle, x2, y2));\n                drawStyle(annotation.getEndPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, true);\n            } else {\n                // Support of non-angled styles is more difficult than in the other handlers\n                // because the lines do not always go from (x1,y1) to (x2,y2) due to the leader lines\n                // when the \"y\" value above is not 0.\n                // We use the angle we already know and the distance y to translate to the new coordinate.\n                float xx2 = x2 - ((float) (y * Math.sin(angle)));\n                float yy2 = y2 + ((float) (y * Math.cos(angle)));\n                drawStyle(annotation.getEndPointEndingStyle(), cs, xx2, yy2, lineEndingSize, hasStroke, hasBackground, true);\n            }\n        }\n    } catch (IOException ex) {\n        LOG.error(ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.strokePath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.strokePath", "org.apache.pdfbox.rendering.PageDrawer.getStrokingPaint", "org.apache.pdfbox.rendering.PageDrawer.getPaint", "org.apache.pdfbox.rendering.TilingPaintFactory.create", "org.apache.pdfbox.rendering.TilingPaint.<clinit>" ],
    "fullMethods" : [ "@Override\npublic void strokePath() throws IOException {\n    if (isContentRendered()) {\n        graphics.setComposite(getGraphicsState().getStrokingJavaComposite());\n        graphics.setPaint(getStrokingPaint());\n        graphics.setStroke(getStroke());\n        setClip();\n        graphics.draw(linePath);\n    }\n    linePath.reset();\n}", "// returns the stroking AWT Paint\nprivate Paint getStrokingPaint() throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    return applySoftMaskToPaint(getPaint(graphicsState.getStrokingColor()), graphicsState.getSoftMask());\n}", "/**\n * Returns an AWT paint for the given PDColor.\n *\n * @param color\n * \t\tThe color to get a paint for. This can be an actual color or a pattern.\n * @return an AWT paint for the given PDColor\n * @throws IOException\n * \t\tif the AWT paint could not be created\n */\nprotected Paint getPaint(PDColor color) throws IOException {\n    PDColorSpace colorSpace = color.getColorSpace();\n    // PDFBOX-5782\n    if (colorSpace == null) {\n        LOG.error(\"colorSpace is null, will be rendered as transparency\");\n        return new Color(0, 0, 0, 0);\n    } else if ((colorSpace instanceof PDSeparation) && \"None\".equals(((PDSeparation) (colorSpace)).getColorantName())) {\n        // PDFBOX-4900: \"The special colorant name None shall not produce any visible output\"\n        // TODO better solution needs to be found for all occurences where toRGB is called\n        return new Color(0, 0, 0, 0);\n    } else if (!(colorSpace instanceof PDPattern)) {\n        float[] rgb = colorSpace.toRGB(color.getComponents());\n        return new Color(clampColor(rgb[0]), clampColor(rgb[1]), clampColor(rgb[2]));\n    } else {\n        PDPattern patternSpace = ((PDPattern) (colorSpace));\n        PDAbstractPattern pattern = patternSpace.getPattern(color);\n        if (pattern instanceof PDTilingPattern) {\n            PDTilingPattern tilingPattern = ((PDTilingPattern) (pattern));\n            if (tilingPattern.getPaintType() == PDTilingPattern.PAINT_COLORED) {\n                // colored tiling pattern\n                return tilingPaintFactory.create(tilingPattern, null, null, xform);\n            } else {\n                // uncolored tiling pattern\n                return tilingPaintFactory.create(tilingPattern, patternSpace.getUnderlyingColorSpace(), color, xform);\n            }\n        } else {\n            PDShadingPattern shadingPattern = ((PDShadingPattern) (pattern));\n            PDShading shading = shadingPattern.getShading();\n            if (shading == null) {\n                LOG.error(\"shadingPattern is null, will be filled with transparency\");\n                return new Color(0, 0, 0, 0);\n            }\n            return shading.toPaint(Matrix.concatenate(getInitialMatrix(), shadingPattern.getMatrix()));\n        }\n    }\n}", "Paint create(PDTilingPattern pattern, PDColorSpace colorSpace, PDColor color, AffineTransform xform) throws IOException {\n    Paint paint = null;\n    TilingPaintParameter tilingPaintParameter = new TilingPaintParameter(drawer.getInitialMatrix(), pattern.getCOSObject(), colorSpace, color, xform);\n    WeakReference<Paint> weakRef = weakCache.get(tilingPaintParameter);\n    if (weakRef != null) {\n        // PDFBOX-4058: additional WeakReference makes gc work better\n        paint = weakRef.get();\n    }\n    if (paint == null) {\n        paint = new TilingPaint(drawer, pattern, colorSpace, color, xform);\n        weakCache.put(tilingPaintParameter, new WeakReference<>(paint));\n    }\n    return paint;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tthe corresponding dictionary\n * @throws IOException\n * \t\tit something went wrong\n */\npublic PDType1CFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    boolean fontIsDamaged = false;\n    CFFType1Font cffEmbedded = null;\n    PDFontDescriptor fd = getFontDescriptor();\n    if (fd != null) {\n        PDStream ff3Stream = fd.getFontFile3();\n        if (ff3Stream != null) {\n            try (RandomAccessRead randomAccessRead = ff3Stream.getCOSObject().createView()) {\n                if (randomAccessRead.length() == 0) {\n                    LOG.error(\"Invalid data for embedded Type1C font \" + getName());\n                } else {\n                    // note: this could be an OpenType file, fortunately CFFParser can handle that\n                    CFFParser cffParser = new CFFParser();\n                    CFFFont parsedCffFont = cffParser.parse(randomAccessRead).get(0);\n                    if (parsedCffFont instanceof CFFType1Font) {\n                        cffEmbedded = ((CFFType1Font) (parsedCffFont));\n                    } else {\n                        LOG.error(\"Expected CFFType1Font, got \" + parsedCffFont.getClass().getSimpleName());\n                        fontIsDamaged = true;\n                    }\n                }\n            } catch (IOException e) {\n                LOG.error(\"Can't read the embedded Type1C font \" + getName(), e);\n                fontIsDamaged = true;\n            }\n        }\n    }\n    isDamaged = fontIsDamaged;\n    cffFont = cffEmbedded;\n    if (cffFont != null) {\n        genericFont = cffFont;\n        isEmbedded = true;\n    } else {\n        String baseFont = getBaseFont();\n        FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(baseFont, fd);\n        genericFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + genericFont.getName()) + \" for \") + baseFont);\n        }\n        isEmbedded = false;\n    }\n    readEncoding();\n    fontMatrixTransform = getFontMatrix().createAffineTransform();\n    fontMatrixTransform.scale(1000, 1000);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setNames",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setNames", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.calculateLimits" ],
    "fullMethods" : [ "/**\n * Set the names for this node. This method will set the appropriate upper and lower limits\n * based on the keys in the map and take care of the ordering.\n *\n * @param names\n * \t\tmap of names to objects, or <code>null</code> for nothing.\n */\npublic void setNames(Map<String, T> names) {\n    if (names == null) {\n        node.setItem(COSName.NAMES, ((COSObjectable) (null)));\n        node.setItem(COSName.LIMITS, ((COSObjectable) (null)));\n    } else {\n        COSArray array = new COSArray();\n        List<String> keys = new ArrayList<>(names.keySet());\n        Collections.sort(keys);\n        for (String key : keys) {\n            array.add(new COSString(key));\n            array.add(names.get(key));\n        }\n        node.setItem(COSName.NAMES, array);\n        calculateLimits();\n    }\n}", "private void calculateLimits() {\n    if (isRootNode()) {\n        node.setItem(COSName.LIMITS, null);\n    } else {\n        List<PDNameTreeNode<T>> kids = getKids();\n        if ((kids != null) && (!kids.isEmpty())) {\n            PDNameTreeNode<T> firstKid = kids.get(0);\n            PDNameTreeNode<T> lastKid = kids.get(kids.size() - 1);\n            String lowerLimit = firstKid.getLowerLimit();\n            setLowerLimit(lowerLimit);\n            String upperLimit = lastKid.getUpperLimit();\n            setUpperLimit(upperLimit);\n        } else {\n            try {\n                Map<String, T> names = getNames();\n                if ((names != null) && (names.size() > 0)) {\n                    Set<String> strings = names.keySet();\n                    String[] keys = strings.toArray(new String[strings.size()]);\n                    String lowerLimit = keys[0];\n                    setLowerLimit(lowerLimit);\n                    String upperLimit = keys[keys.length - 1];\n                    setUpperLimit(upperLimit);\n                } else {\n                    node.setItem(COSName.LIMITS, null);\n                }\n            } catch (IOException exception) {\n                node.setItem(COSName.LIMITS, null);\n                LOG.error(\"Error while calculating the Limits of a PageNameTreeNode:\", exception);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject", "org.apache.pdfbox.pdfparser.COSParser.parseObjectDynamically", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "@Override\npublic COSBase dereferenceCOSObject(COSObject obj) throws IOException {\n    long currentPos = source.getPosition();\n    COSObjectKey key = obj.getKey();\n    COSBase parsedObj = parseObjectDynamically(key, false);\n    if (parsedObj != null) {\n        parsedObj.setDirect(false);\n        parsedObj.setKey(key);\n    }\n    if (currentPos > 0) {\n        source.seek(currentPos);\n    }\n    return parsedObj;\n}", "/**\n * Parse the object for the given object key.\n *\n * @param objKey\n * \t\tkey of object to be parsed\n * @param requireExistingNotCompressedObj\n * \t\tif <code>true</code> the object to be parsed must be defined in xref\n * \t\t(comment: null objects may be missing from xref) and it must not be a compressed object within object stream\n * \t\t(this is used to circumvent being stuck in a loop in a malicious PDF)\n * @return the parsed object (which is also added to document object)\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprotected synchronized COSBase parseObjectDynamically(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    COSObject pdfObject = document.getObjectFromPool(objKey);\n    if (!pdfObject.isObjectNull()) {\n        return pdfObject.getObject();\n    }\n    Long offsetOrObjstmObNr = getObjectOffset(objKey, requireExistingNotCompressedObj);\n    COSBase referencedObject = null;\n    if (offsetOrObjstmObNr != null) {\n        if (offsetOrObjstmObNr > 0) {\n            referencedObject = parseFileObject(offsetOrObjstmObNr, objKey);\n        } else {\n            // xref value is object nr of object stream containing object to be parsed\n            // since our object was not found it means object stream was not parsed so far\n            referencedObject = parseObjectStreamObject(-offsetOrObjstmObNr, objKey);\n        }\n    }\n    if ((referencedObject == null) || (referencedObject instanceof COSNull)) {\n        // not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)\n        // or some other issue with dereferencing\n        // remove parser to avoid endless recursion\n        pdfObject.setToNull();\n    }\n    return referencedObject;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.getVersion",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.getVersion" ],
    "fullMethods" : [ "/**\n * Returns the PDF specification version this document conforms to.\n *\n * @return the PDF version (e.g. 1.4f)\n */\npublic float getVersion() {\n    float headerVersionFloat = getDocument().getVersion();\n    // there may be a second version information in the document catalog starting with 1.4\n    if (headerVersionFloat >= 1.4F) {\n        String catalogVersion = getDocumentCatalog().getVersion();\n        float catalogVersionFloat = -1;\n        if (catalogVersion != null) {\n            try {\n                catalogVersionFloat = Float.parseFloat(catalogVersion);\n            } catch (NumberFormatException exception) {\n                LOG.error(\"Can't extract the version number of the document catalog.\", exception);\n            }\n        }\n        // the most recent version is the correct one\n        return Math.max(catalogVersionFloat, headerVersionFloat);\n    } else {\n        return headerVersionFloat;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingContext.getRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingContext.getRaster" ],
    "fullMethods" : [ "@Override\npublic Raster getRaster(int x, int y, int w, int h) {\n    WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);\n    int[] data = new int[(w * h) * 4];\n    float[] values = new float[2];\n    for (int j = 0; j < h; j++) {\n        for (int i = 0; i < w; i++) {\n            int index = ((j * w) + i) * 4;\n            boolean useBackground = false;\n            values[0] = x + i;\n            values[1] = y + j;\n            rat.transform(values, 0, values, 0, 1);\n            if ((((values[0] < domain[0]) || (values[0] > domain[1])) || (values[1] < domain[2])) || (values[1] > domain[3])) {\n                if (getBackground() == null) {\n                    continue;\n                }\n                useBackground = true;\n            }\n            // evaluate function\n            float[] tmpValues;// \"values\" can't be reused due to different length\n\n            if (useBackground) {\n                tmpValues = getBackground();\n            } else {\n                try {\n                    tmpValues = type1ShadingType.evalFunction(values);\n                } catch (IOException e) {\n                    LOG.error(\"error while processing a function\", e);\n                    continue;\n                }\n            }\n            // convert color values from shading color space to RGB\n            PDColorSpace shadingColorSpace = getShadingColorSpace();\n            if (shadingColorSpace != null) {\n                try {\n                    tmpValues = shadingColorSpace.toRGB(tmpValues);\n                } catch (IOException e) {\n                    LOG.error(\"error processing color space\", e);\n                    continue;\n                }\n            }\n            data[index] = ((int) (tmpValues[0] * 255));\n            data[index + 1] = ((int) (tmpValues[1] * 255));\n            data[index + 2] = ((int) (tmpValues[2] * 255));\n            data[index + 3] = 255;\n        }\n    }\n    raster.setPixels(0, 0, w, h, data);\n    return raster;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText", "org.apache.pdfbox.contentstream.PDFStreamEngine.showGlyph", "org.apache.pdfbox.rendering.PageDrawer.showFontGlyph", "org.apache.pdfbox.rendering.GlyphCache.getPathForCharacterCode" ],
    "fullMethods" : [ "/**\n * Called when a string of text with spacing adjustments is to be shown.\n *\n * @param array\n * \t\tarray of encoded text strings and adjustments\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextStrings(COSArray array) throws IOException {\n    PDTextState textState = getGraphicsState().getTextState();\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    PDFont font = textState.getFont();\n    boolean isVertical = false;\n    if (font != null) {\n        isVertical = font.isVertical();\n    }\n    for (COSBase obj : array) {\n        if (obj instanceof COSNumber) {\n            float tj = ((COSNumber) (obj)).floatValue();\n            // calculate the combined displacements\n            float tx;\n            float ty;\n            if (isVertical) {\n                tx = 0;\n                ty = ((-tj) / 1000) * fontSize;\n            } else {\n                tx = (((-tj) / 1000) * fontSize) * horizontalScaling;\n                ty = 0;\n            }\n            applyTextAdjustment(tx, ty);\n        } else if (obj instanceof COSString) {\n            byte[] string = ((COSString) (obj)).getBytes();\n            showText(string);\n        } else if (obj instanceof COSArray) {\n            LOG.error(\"Nested arrays are not allowed in an array for TJ operation: \" + obj);\n        } else {\n            LOG.error(((\"Unknown type \" + obj.getClass().getSimpleName()) + \" in array for TJ operation: \") + obj);\n        }\n    }\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}", "/**\n * Called when a glyph is to be processed. This method is intended for overriding in subclasses,\n * the default implementation does nothing.\n *\n * @param textRenderingMatrix\n * \t\tthe current text rendering matrix, T<sub>rm</sub>\n * @param font\n * \t\tthe current font\n * @param code\n * \t\tinternal PDF character code for the glyph\n * @param displacement\n * \t\tthe displacement (i.e. advance) of the glyph in text space\n * @throws IOException\n * \t\tif the glyph cannot be processed\n */\nprotected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, Vector displacement) throws IOException {\n    if (font instanceof PDType3Font) {\n        showType3Glyph(textRenderingMatrix, ((PDType3Font) (font)), code, displacement);\n    } else {\n        showFontGlyph(textRenderingMatrix, font, code, displacement);\n    }\n}", "@Override\nprotected void showFontGlyph(Matrix textRenderingMatrix, PDFont font, int code, Vector displacement) throws IOException {\n    AffineTransform at = textRenderingMatrix.createAffineTransform();\n    at.concatenate(font.getFontMatrix().createAffineTransform());\n    // create cache if it does not exist\n    PDVectorFont vectorFont = ((PDVectorFont) (font));\n    GlyphCache cache = glyphCaches.get(font);\n    if (cache == null) {\n        cache = new GlyphCache(vectorFont);\n        glyphCaches.put(font, cache);\n    }\n    GeneralPath path = cache.getPathForCharacterCode(code);\n    drawGlyph(path, font, code, displacement, at);\n}", "public GeneralPath getPathForCharacterCode(int code) {\n    GeneralPath path = cache.get(code);\n    if (path != null) {\n        return path;\n    }\n    try {\n        if (!font.hasGlyph(code)) {\n            String fontName = ((PDFontLike) (font)).getName();\n            if (font instanceof PDType0Font) {\n                int cid = ((PDType0Font) (font)).codeToCID(code);\n                String cidHex = String.format(\"%04x\", cid);\n                LOG.warn(((((\"No glyph for code \" + code) + \" (CID \") + cidHex) + \") in font \") + fontName);\n            } else if (font instanceof PDSimpleFont) {\n                PDSimpleFont simpleFont = ((PDSimpleFont) (font));\n                LOG.warn((((((((\"No glyph for code \" + code) + \" in \") + font.getClass().getSimpleName()) + \" \") + fontName) + \" (embedded or system font used: \") + simpleFont.getFontBoxFont().getName()) + \")\");\n                if ((code == 10) && simpleFont.isStandard14()) {\n                    // PDFBOX-4001 return empty path for line feed on std14\n                    path = new GeneralPath();\n                    cache.put(code, path);\n                    return path;\n                }\n            } else {\n                LOG.warn(((\"No glyph for code \" + code) + \" in font \") + fontName);\n            }\n        }\n        path = font.getNormalizedPath(code);\n        cache.put(code, path);\n        return path;\n    } catch (IOException e) {\n        // todo: escalate this error?\n        String fontName = ((PDFontLike) (font)).getName();\n        LOG.error(((\"Glyph rendering failed for code \" + code) + \" in font \") + fontName, e);\n        return new GeneralPath();\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDFont.<init>", "org.apache.pdfbox.pdmodel.font.PDFont.loadUnicodeCmap" ],
    "fullMethods" : [ "/**\n * Constructor for reading a Type0 font from a PDF file.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @throws IOException\n * \t\tif the descendant font is missing.\n */\npublic PDType0Font(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    gsubData = GsubData.NO_DATA_FOUND;\n    cmapLookup = null;\n    COSArray descendantFonts = dict.getCOSArray(COSName.DESCENDANT_FONTS);\n    if (descendantFonts == null) {\n        throw new IOException(\"Missing descendant font array\");\n    }\n    if (descendantFonts.size() == 0) {\n        throw new IOException(\"Descendant font array is empty\");\n    }\n    COSBase descendantFontDictBase = descendantFonts.getObject(0);\n    if (!(descendantFontDictBase instanceof COSDictionary)) {\n        throw new IOException(\"Missing descendant font dictionary\");\n    }\n    if (!COSName.FONT.equals(((COSDictionary) (descendantFontDictBase)).getCOSName(COSName.TYPE, COSName.FONT))) {\n        throw new IOException(\"Missing or wrong type in descendant font dictionary\");\n    }\n    descendantFont = PDFontFactory.createDescendantFont(((COSDictionary) (descendantFontDictBase)), this);\n    readEncoding();\n    fetchCMapUCS2();\n}", "/**\n * Constructor for Standard 14.\n */\nPDFont(FontName baseFont) {\n    dict = new COSDictionary();\n    dict.setItem(COSName.TYPE, COSName.FONT);\n    toUnicodeCMap = null;\n    afmStandard14 = Standard14Fonts.getAFM(baseFont.getName());\n    if (afmStandard14 == null) {\n        throw new IllegalArgumentException(\"No AFM for font \" + baseFont);\n    }\n    fontDescriptor = PDType1FontEmbedder.buildFontDescriptor(afmStandard14);\n    // standard 14 fonts may be accessed concurrently, as they are singletons\n    codeToWidthMap = new ConcurrentHashMap<>();\n}", "private CMap loadUnicodeCmap() {\n    COSBase toUnicode = dict.getDictionaryObject(COSName.TO_UNICODE);\n    if (toUnicode == null) {\n        return null;\n    }\n    CMap cmap = null;\n    try {\n        cmap = readCMap(toUnicode);\n        if ((cmap != null) && (!cmap.hasUnicodeMappings())) {\n            String name = getName();\n            LOG.warn(\"Invalid ToUnicode CMap in font \" + name);\n            String cmapName = (cmap.getName() != null) ? cmap.getName() : \"\";\n            String ordering = (cmap.getOrdering() != null) ? cmap.getOrdering() : \"\";\n            COSName encoding = dict.getCOSName(COSName.ENCODING);\n            if (((cmapName.contains(\"Identity\")// \n             || ordering.contains(\"Identity\"))// \n             || COSName.IDENTITY_H.equals(encoding))// \n             || COSName.IDENTITY_V.equals(encoding)) {\n                COSDictionary encodingDict = dict.getCOSDictionary(COSName.ENCODING);\n                if ((encodingDict == null) || (!encodingDict.containsKey(COSName.DIFFERENCES))) {\n                    // assume that if encoding is identity, then the reverse is also true\n                    cmap = CMapManager.getPredefinedCMap(COSName.IDENTITY_H.getName());\n                    LOG.warn(\"Using predefined identity CMap instead\");\n                }\n            }\n        }\n    } catch (IOException ex) {\n        LOG.error(\"Could not read ToUnicode CMap in font \" + getName(), ex);\n    }\n    return cmap;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setParent",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.setParent", "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.calculateLimits" ],
    "fullMethods" : [ "/**\n * Sets the parent to the given node.\n *\n * @param parentNode\n * \t\tthe node to be set as parent\n */\npublic void setParent(PDNameTreeNode<T> parentNode) {\n    parent = parentNode;\n    calculateLimits();\n}", "private void calculateLimits() {\n    if (isRootNode()) {\n        node.setItem(COSName.LIMITS, null);\n    } else {\n        List<PDNameTreeNode<T>> kids = getKids();\n        if ((kids != null) && (!kids.isEmpty())) {\n            PDNameTreeNode<T> firstKid = kids.get(0);\n            PDNameTreeNode<T> lastKid = kids.get(kids.size() - 1);\n            String lowerLimit = firstKid.getLowerLimit();\n            setLowerLimit(lowerLimit);\n            String upperLimit = lastKid.getUpperLimit();\n            setUpperLimit(upperLimit);\n        } else {\n            try {\n                Map<String, T> names = getNames();\n                if ((names != null) && (names.size() > 0)) {\n                    Set<String> strings = names.keySet();\n                    String[] keys = strings.toArray(new String[strings.size()]);\n                    String lowerLimit = keys[0];\n                    setLowerLimit(lowerLimit);\n                    String upperLimit = keys[keys.length - 1];\n                    setUpperLimit(upperLimit);\n                } else {\n                    node.setItem(COSName.LIMITS, null);\n                }\n            } catch (IOException exception) {\n                node.setItem(COSName.LIMITS, null);\n                LOG.error(\"Error while calculating the Limits of a PageNameTreeNode:\", exception);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.drawImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.drawImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getOptionalContent", "org.apache.pdfbox.cos.COSDictionary.getCOSDictionary", "org.apache.pdfbox.cos.COSDictionary.getDictionaryObject", "org.apache.pdfbox.cos.COSObject.getObject" ],
    "fullMethods" : [ "@Override\npublic void drawImage(PDImage pdImage) throws IOException {\n    if ((pdImage instanceof PDImageXObject) && isHiddenOCG(((PDImageXObject) (pdImage)).getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    AffineTransform at = ctm.createAffineTransform();\n    if (!pdImage.getInterpolate()) {\n        // if the image is scaled down, we use smooth interpolation, eg PDFBOX-2364\n        // only when scaled up do we use nearest neighbour, eg PDFBOX-2302 / mori-cvpr01.pdf\n        // PDFBOX-4930: we use the sizes of the ARGB image. These can be different\n        // than the original sizes of the base image, when the mask is bigger.\n        // PDFBOX-5091: also consider subsampling, the sizes are different too.\n        BufferedImage bim;\n        if (subsamplingAllowed) {\n            bim = pdImage.getImage(null, getSubsampling(pdImage, at));\n        } else {\n            bim = pdImage.getImage();\n        }\n        boolean isScaledUp = (bim.getWidth() <= Math.abs(Math.round(ctm.getScalingFactorX() * xformScalingFactorX))) || (bim.getHeight() <= Math.abs(Math.round(ctm.getScalingFactorY() * xformScalingFactorY)));\n        if (isScaledUp) {\n            graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        }\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    if (pdImage.isStencil()) {\n        if (getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDPattern) {\n            // The earlier code for stencils (see \"else\") doesn't work with patterns because the\n            // CTM is not taken into consideration.\n            // this code is based on the fact that it is easily possible to draw the mask and\n            // the paint at the correct place with the existing code, but not in one step.\n            // Thus what we do is to draw both in separate images, then combine the two and draw\n            // the result.\n            // Note that the device scale is not used. In theory, some patterns can get better\n            // at higher resolutions but the stencil would become more and more \"blocky\".\n            // If anybody wants to do this, have a look at the code in showTransparencyGroup().\n            // draw the paint\n            Paint paint = getNonStrokingPaint();\n            Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);\n            Rectangle2D bounds = at.createTransformedShape(unitRect).getBounds2D();\n            int w = ((int) (Math.ceil(bounds.getWidth())));\n            int h = ((int) (Math.ceil(bounds.getHeight())));\n            BufferedImage renderedPaint = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n            Graphics2D g = ((Graphics2D) (renderedPaint.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setPaint(paint);\n            g.setRenderingHints(graphics.getRenderingHints());\n            g.fill(bounds);\n            g.dispose();\n            // draw the mask\n            BufferedImage mask = pdImage.getImage();\n            AffineTransform imageTransform = new AffineTransform(at);\n            imageTransform.scale(1.0 / mask.getWidth(), (-1.0) / mask.getHeight());\n            imageTransform.translate(0, -mask.getHeight());\n            AffineTransform full = new AffineTransform(g.getTransform());\n            full.concatenate(imageTransform);\n            Matrix m = new Matrix(full);\n            double scaleX = Math.abs(m.getScalingFactorX());\n            double scaleY = Math.abs(m.getScalingFactorY());\n            boolean smallMask = (mask.getWidth() <= 8) && (mask.getHeight() <= 8);\n            if ((mask.getWidth() == 1) && (mask.getHeight() == 1)) {\n                // PDFBOX-5802: force usage of the lookup table if it is only 1 pixel\n                // (See the comment for PDFBOX-5403 that it isn't done for some\n                // cases based purely on the rendering result of one file!)\n                smallMask = false;\n            }\n            if (!smallMask) {\n                // PDFBOX-5403:\n                // The mask is copied to RGB because this supports a smooth scaling, so we\n                // get a mask with 255 values instead of just 0 and 255.\n                // Inverting is done because when we don't do it, the getScaledInstance() call\n                // produces a black line in many masks. With the inversion we have a white line\n                // which is neutral. Because of the inversion we don't have to substract from 255\n                // in the \"apply the mask\" segment when rasterPixel[3] is assigned.\n                // The inversion is not done for very small ones, because of\n                // PDFBOX-2171-002-002710-p14.pdf where the \"New Harmony Consolidated\" and\n                // \"Sailor Springs\" patterns became almost invisible.\n                // (We may have to decide this differently in the future, e.g. on b/w relationship)\n                BufferedImage tmp = new BufferedImage(mask.getWidth(), mask.getHeight(), BufferedImage.TYPE_INT_RGB);\n                mask = new LookupOp(getInvLookupTable(), graphics.getRenderingHints()).filter(mask, tmp);\n            }\n            BufferedImage renderedMask = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n            g = ((Graphics2D) (renderedMask.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setRenderingHints(graphics.getRenderingHints());\n            if (smallMask) {\n                g.drawImage(mask, imageTransform, null);\n            } else if ((scaleX != 0) && (scaleY != 0)) {\n                while ((scaleX < 0.25) || (Math.round(mask.getWidth() * scaleX) < 1)) {\n                    scaleX *= 2.0;\n                } \n                while ((scaleY < 0.25) || (Math.round(mask.getHeight() * scaleY) < 1)) {\n                    scaleY *= 2.0;\n                } \n                int w2 = ((int) (Math.round(mask.getWidth() * scaleX)));\n                int h2 = ((int) (Math.round(mask.getHeight() * scaleY)));\n                Image scaledMask = mask.getScaledInstance(w2, h2, Image.SCALE_SMOOTH);\n                imageTransform.scale(1.0F / Math.abs(scaleX), 1.0F / Math.abs(scaleY));\n                g.drawImage(scaledMask, imageTransform, null);\n            }\n            g.dispose();\n            // apply the mask\n            int[] alphaPixel = null;\n            int[] rasterPixel = null;\n            WritableRaster raster = renderedPaint.getRaster();\n            WritableRaster alpha = renderedMask.getRaster();\n            for (int y = 0; y < h; y++) {\n                for (int x = 0; x < w; x++) {\n                    alphaPixel = alpha.getPixel(x, y, alphaPixel);\n                    rasterPixel = raster.getPixel(x, y, rasterPixel);\n                    rasterPixel[3] = alphaPixel[0];\n                    raster.setPixel(x, y, rasterPixel);\n                }\n            }\n            // draw the image\n            graphics.drawImage(renderedPaint, AffineTransform.getTranslateInstance(bounds.getMinX(), bounds.getMinY()), null);\n        } else {\n            // fill the image with stenciled paint\n            BufferedImage image = pdImage.getStencilImage(getNonStrokingPaint());\n            // draw the image\n            drawBufferedImage(pdImage, image, at);\n        }\n    } else if (subsamplingAllowed) {\n        int subsampling = getSubsampling(pdImage, at);\n        // draw the subsampled image\n        drawBufferedImage(pdImage, pdImage.getImage(null, subsampling), at);\n    } else {\n        // subsampling not allowed, draw the image\n        drawBufferedImage(pdImage, pdImage.getImage(), at);\n    }\n    if (!pdImage.getInterpolate()) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "/**\n * This will get the optional content group or optional content membership dictionary.\n *\n * @return The optional content group or optional content membership dictionary or null if there\nis none.\n */\npublic PDPropertyList getOptionalContent() {\n    COSDictionary optionalContent = getCOSObject().getCOSDictionary(COSName.OC);\n    return optionalContent != null ? PDPropertyList.create(optionalContent) : null;\n}", "/**\n * This is a convenience method that will get the dictionary object that is expected to be a COSDictionary. Null is\n * returned if the entry does not exist in the dictionary.\n *\n * @param key\n * \t\tThe key to the item in the dictionary.\n * @return The COSDictionary.\n */\npublic COSDictionary getCOSDictionary(COSName key) {\n    COSBase dictionary = getDictionaryObject(key);\n    if (dictionary instanceof COSDictionary) {\n        return ((COSDictionary) (dictionary));\n    }\n    return null;\n}", "/**\n * This will get an object from this dictionary. If the object is a reference then it will dereference it and get it\n * from the document. If the object is COSNull then null will be returned.\n *\n * @param key\n * \t\tThe key to the object that we are getting.\n * @return The object that matches the key.\n */\npublic COSBase getDictionaryObject(COSName key) {\n    COSBase retval = items.get(key);\n    if (retval instanceof COSObject) {\n        retval = ((COSObject) (retval)).getObject();\n    }\n    if (retval instanceof COSNull) {\n        retval = null;\n    }\n    return retval;\n}", "/**\n * This will get the object that this object encapsulates.\n *\n * @return The encapsulated object.\n */\npublic COSBase getObject() {\n    if ((!isDereferenced) && (parser != null)) {\n        try {\n            // mark as dereferenced to avoid endless recursions\n            isDereferenced = true;\n            baseObject = parser.dereferenceCOSObject(this);\n            getUpdateState().dereferenceChild(baseObject);\n        } catch (IOException e) {\n            LOG.error(\"Can't dereference \" + this, e);\n        } finally {\n            parser = null;\n        }\n    }\n    return baseObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<init>", "org.apache.pdfbox.pdmodel.font.PDSimpleFont.<init>", "org.apache.pdfbox.pdmodel.font.PDFont.<init>", "org.apache.pdfbox.pdmodel.font.PDFont.loadUnicodeCmap" ],
    "fullMethods" : [ "/**\n * Creates a new TrueType font from a Font dictionary.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @throws IOException\n * \t\tif the font could not be created\n */\npublic PDTrueTypeFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    TrueTypeFont ttfFont = null;\n    boolean fontIsDamaged = false;\n    if (getFontDescriptor() != null) {\n        PDFontDescriptor fd = super.getFontDescriptor();\n        PDStream ff2Stream = fd.getFontFile2();\n        if (ff2Stream != null) {\n            RandomAccessRead view = null;\n            try {\n                view = ff2Stream.getCOSObject().createView();\n                // embedded\n                TTFParser ttfParser = getParser(view, true);\n                ttfFont = ttfParser.parse(view);\n                ttfFont.close();\n            } catch (IOException e) {\n                LOG.warn(\"Could not read embedded TTF for font \" + getBaseFont(), e);\n                fontIsDamaged = true;\n                IOUtils.closeQuietly(view);\n            }\n        }\n    }\n    isEmbedded = ttfFont != null;\n    isDamaged = fontIsDamaged;\n    // substitute\n    if (ttfFont == null) {\n        FontMapping<TrueTypeFont> mapping = FontMappers.instance().getTrueTypeFont(getBaseFont(), getFontDescriptor());\n        ttfFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + ttfFont) + \" for \") + getBaseFont());\n        }\n    }\n    otf = ((ttfFont instanceof OpenTypeFont) && ((OpenTypeFont) (ttfFont)).isSupportedOTF()) ? ((OpenTypeFont) (ttfFont)) : null;\n    ttf = ttfFont;\n    readEncoding();\n}", "/**\n * Constructor for Standard 14.\n */\nPDSimpleFont(FontName baseFont) {\n    super(baseFont);\n    assignGlyphList(baseFont);\n}", "/**\n * Constructor for Standard 14.\n */\nPDFont(FontName baseFont) {\n    dict = new COSDictionary();\n    dict.setItem(COSName.TYPE, COSName.FONT);\n    toUnicodeCMap = null;\n    afmStandard14 = Standard14Fonts.getAFM(baseFont.getName());\n    if (afmStandard14 == null) {\n        throw new IllegalArgumentException(\"No AFM for font \" + baseFont);\n    }\n    fontDescriptor = PDType1FontEmbedder.buildFontDescriptor(afmStandard14);\n    // standard 14 fonts may be accessed concurrently, as they are singletons\n    codeToWidthMap = new ConcurrentHashMap<>();\n}", "private CMap loadUnicodeCmap() {\n    COSBase toUnicode = dict.getDictionaryObject(COSName.TO_UNICODE);\n    if (toUnicode == null) {\n        return null;\n    }\n    CMap cmap = null;\n    try {\n        cmap = readCMap(toUnicode);\n        if ((cmap != null) && (!cmap.hasUnicodeMappings())) {\n            String name = getName();\n            LOG.warn(\"Invalid ToUnicode CMap in font \" + name);\n            String cmapName = (cmap.getName() != null) ? cmap.getName() : \"\";\n            String ordering = (cmap.getOrdering() != null) ? cmap.getOrdering() : \"\";\n            COSName encoding = dict.getCOSName(COSName.ENCODING);\n            if (((cmapName.contains(\"Identity\")// \n             || ordering.contains(\"Identity\"))// \n             || COSName.IDENTITY_H.equals(encoding))// \n             || COSName.IDENTITY_V.equals(encoding)) {\n                COSDictionary encodingDict = dict.getCOSDictionary(COSName.ENCODING);\n                if ((encodingDict == null) || (!encodingDict.containsKey(COSName.DIFFERENCES))) {\n                    // assume that if encoding is identity, then the reverse is also true\n                    cmap = CMapManager.getPredefinedCMap(COSName.IDENTITY_H.getName());\n                    LOG.warn(\"Using predefined identity CMap instead\");\n                }\n            }\n        }\n    } catch (IOException ex) {\n        LOG.error(\"Could not read ToUnicode CMap in font \" + getName(), ex);\n    }\n    return cmap;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFParser.parse", "org.apache.pdfbox.pdfparser.PDFParser.initialParse", "org.apache.pdfbox.pdfparser.COSParser.retrieveTrailer", "org.apache.pdfbox.pdfparser.COSParser.parseXref" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the PDDocument object. This will close the keystore stream when it is\n * done parsing.\n *\n * @param lenient\n * \t\tactivate leniency if set to true\n * @return the populated PDDocument\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic PDDocument parse(boolean lenient) throws IOException {\n    setLenient(lenient);\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        // PDFBOX-1922 read the version header and rewind\n        if ((!parsePDFHeader()) && (!parseFDFHeader())) {\n            if (lenient) {\n                LOG.warn(\"Error: Header doesn't contain versioninfo\");\n            } else {\n                throw new IOException(\"Error: Header doesn't contain versioninfo\");\n            }\n        }\n        if (!initialParseDone) {\n            initialParse();\n        }\n        exceptionOccurred = false;\n        PDDocument pdDocument = createDocument();\n        pdDocument.setEncryptionDictionary(getEncryption());\n        return pdDocument;\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * The initial parse will first parse only the trailer, the xrefstart and all xref tables to have a pointer (offset)\n * to all the pdf's objects. It can handle linearized pdfs, which will have an xref at the end pointing to an xref\n * at the beginning of the file. Last the root object is parsed.\n *\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf something went wrong.\n */\nprotected void initialParse() throws IOException {\n    COSDictionary trailer = retrieveTrailer();\n    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);\n    if (root == null) {\n        throw new IOException(\"Missing root object specification in trailer.\");\n    }\n    // in some pdfs the type value \"Catalog\" is missing in the root object\n    if (isLenient() && (!root.containsKey(COSName.TYPE))) {\n        root.setItem(COSName.TYPE, COSName.CATALOG);\n    }\n    // check pages dictionaries\n    checkPages(root);\n    document.setDecrypted();\n    initialParseDone = true;\n}", "/**\n * Read the trailer information and provide a COSDictionary containing the trailer information.\n *\n * @return a COSDictionary containing the trailer information\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected COSDictionary retrieveTrailer() throws IOException {\n    COSDictionary trailer = null;\n    boolean rebuildTrailer = false;\n    try {\n        // parse startxref\n        // TODO FDF files don't have a startxref value, so that rebuildTrailer is triggered\n        long startXRefOffset = getStartxrefOffset();\n        if (startXRefOffset > (-1)) {\n            trailer = parseXref(startXRefOffset);\n        } else {\n            rebuildTrailer = isLenient();\n        }\n    } catch (IOException exception) {\n        if (isLenient()) {\n            rebuildTrailer = true;\n        } else {\n            throw exception;\n        }\n    }\n    // check if the trailer contains a Root object\n    if ((trailer != null) && (trailer.getItem(COSName.ROOT) == null)) {\n        rebuildTrailer = isLenient();\n    }\n    if (rebuildTrailer) {\n        trailer = getBruteForceParser().rebuildTrailer(xrefTrailerResolver, null);\n        trailerWasRebuild = true;\n        // transfer encryption information from BruteForceParser\n        encryption = getBruteForceParser().getEncryption();\n        if (encryption != null) {\n            securityHandler = encryption.getSecurityHandler();\n            accessPermission = securityHandler.getCurrentAccessPermission();\n        }\n    } else {\n        // prepare decryption if necessary\n        prepareDecryption();\n        // don't use the getter as it creates an instance of BruteForceParser\n        if ((bruteForceParser != null) && bruteForceParser.bfSearchTriggered()) {\n            getBruteForceParser().bfSearchForObjStreams(xrefTrailerResolver, securityHandler);\n        }\n    }\n    if (resetTrailerResolver()) {\n        xrefTrailerResolver.reset();\n        xrefTrailerResolver = null;\n    }\n    return trailer;\n}", "/**\n * Parses cross reference tables.\n *\n * @param startXRefOffset\n * \t\tstart offset of the first table\n * @return the trailer dictionary\n * @throws IOException\n * \t\tif something went wrong\n */\nprivate COSDictionary parseXref(long startXRefOffset) throws IOException {\n    source.seek(startXRefOffset);\n    long startXrefOffset = Math.max(0, parseStartXref());\n    // check the startxref offset\n    long fixedOffset = checkXRefOffset(startXrefOffset);\n    if (fixedOffset > (-1)) {\n        startXrefOffset = fixedOffset;\n    }\n    document.setStartXref(startXrefOffset);\n    long prev = startXrefOffset;\n    // ---- parse whole chain of xref tables/object streams using PREV reference\n    Set<Long> prevSet = new HashSet<>();\n    COSDictionary trailer = null;\n    while (prev > 0) {\n        // save expected position for loop detection\n        prevSet.add(prev);\n        // seek to xref table\n        source.seek(prev);\n        // skip white spaces\n        skipSpaces();\n        // save current position as well due to skipped spaces\n        prevSet.add(source.getPosition());\n        // -- parse xref\n        if (source.peek() == X) {\n            // xref table and trailer\n            // use existing parser to parse xref table\n            if ((!parseXrefTable(prev)) || (!parseTrailer())) {\n                throw new IOException(\"Expected trailer object at offset \" + source.getPosition());\n            }\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n            // check for a XRef stream, it may contain some object ids of compressed objects\n            if (trailer.containsKey(COSName.XREF_STM)) {\n                int streamOffset = trailer.getInt(COSName.XREF_STM);\n                // check the xref stream reference\n                fixedOffset = checkXRefOffset(streamOffset);\n                if ((fixedOffset > (-1)) && (fixedOffset != streamOffset)) {\n                    LOG.warn(((\"/XRefStm offset \" + streamOffset) + \" is incorrect, corrected to \") + fixedOffset);\n                    streamOffset = ((int) (fixedOffset));\n                    trailer.setInt(COSName.XREF_STM, streamOffset);\n                }\n                if (streamOffset > 0) {\n                    source.seek(streamOffset);\n                    skipSpaces();\n                    try {\n                        parseXrefObjStream(prev, false);\n                        document.setHasHybridXRef();\n                    } catch (IOException ex) {\n                        if (isLenient) {\n                            LOG.error(\"Failed to parse /XRefStm at offset \" + streamOffset, ex);\n                        } else {\n                            throw ex;\n                        }\n                    }\n                } else if (isLenient) {\n                    LOG.error(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                } else {\n                    throw new IOException(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                }\n            }\n            prev = trailer.getLong(COSName.PREV);\n        } else {\n            // parse xref stream\n            prev = parseXrefObjStream(prev, true);\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n        }\n        if (prev > 0) {\n            // check the xref table reference\n            fixedOffset = checkXRefOffset(prev);\n            if ((fixedOffset > (-1)) && (fixedOffset != prev)) {\n                prev = fixedOffset;\n                trailer.setLong(COSName.PREV, prev);\n            }\n        }\n        if (prevSet.contains(prev)) {\n            throw new IOException(\"/Prev loop at offset \" + prev);\n        }\n    } \n    // ---- build valid xrefs out of the xref chain\n    xrefTrailerResolver.setStartxref(startXrefOffset);\n    trailer = xrefTrailerResolver.getTrailer();\n    document.setTrailer(trailer);\n    document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());\n    // check the offsets of all referenced objects\n    if (isLenient) {\n        checkXrefOffsets();\n    }\n    // copy xref table\n    document.addXRefTable(xrefTrailerResolver.getXrefTable());\n    // remember the highest XRef object number to avoid it being reused in incremental saving\n    Optional<Long> maxValue = // \n    // \n    document.getXrefTable().keySet().stream().map(COSObjectKey::getNumber).reduce(Long::max);\n    document.setHighestXRefObjectNumber(maxValue.isPresent() ? maxValue.get() : 0);\n    return trailer;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.error",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingPaint.createContext" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type1ShadingContext(shading, cm, xform, matrix);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.trace",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<init>" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "/**\n * Constructor.\n */\nFileSystemFontProvider(FontCache cache) {\n    this.cache = cache;\n    try {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Will search the local system for fonts\");\n        }\n        // scan the local system for font files\n        FontFileFinder fontFileFinder = new FontFileFinder();\n        List<URI> fonts = fontFileFinder.find();\n        List<File> files = new ArrayList<>(fonts.size());\n        for (URI font : fonts) {\n            files.add(new File(font));\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace((\"Found \" + files.size()) + \" fonts on the local system\");\n        }\n        if (!files.isEmpty()) {\n            // load cached FontInfo objects\n            List<FSFontInfo> cachedInfos = loadDiskCache(files);\n            if ((cachedInfos != null) && (!cachedInfos.isEmpty())) {\n                fontInfoList.addAll(cachedInfos);\n            } else {\n                LOG.info(\"Building on-disk font cache, this may take a while\");\n                scanFonts(files);\n                saveDiskCache();\n                LOG.info((\"Finished building on-disk font cache, found \" + fontInfoList.size()) + \" fonts\");\n            }\n        }\n    } catch (AccessControlException e) {\n        LOG.error(\"Error accessing the file system\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.prepareDocumentForEncryption",
    "thirdPartyMethod" : "org.bouncycastle.asn1.ASN1InputStream.close",
    "thirdPartyPackage" : "org.bouncycastle.asn1",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.prepareDocumentForEncryption", "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.computeRecipientsField", "org.apache.pdfbox.pdmodel.encryption.PublicKeySecurityHandler.createDERForRecipient" ],
    "fullMethods" : [ "/**\n * Prepare the document for encryption.\n *\n * @param doc\n * \t\tThe document that will be encrypted.\n * @throws IOException\n * \t\tIf there is an error while encrypting.\n */\n@Override\npublic void prepareDocumentForEncryption(PDDocument doc) throws IOException {\n    try {\n        PDEncryption dictionary = doc.getEncryption();\n        if (dictionary == null) {\n            dictionary = new PDEncryption();\n        }\n        dictionary.setFilter(FILTER);\n        dictionary.setLength(getKeyLength());\n        int version = computeVersionNumber();\n        dictionary.setVersion(version);\n        // remove CF, StmF, and StrF entries that may be left from a previous encryption\n        dictionary.removeV45filters();\n        // create the 20 bytes seed\n        byte[] seed = new byte[20];\n        KeyGenerator key;\n        try {\n            key = KeyGenerator.getInstance(\"AES\");\n        } catch (NoSuchAlgorithmException e) {\n            // should never happen\n            throw new RuntimeException(e);\n        }\n        key.init(192, new SecureRandom());\n        SecretKey sk = key.generateKey();\n        // create the 20 bytes seed\n        System.arraycopy(sk.getEncoded(), 0, seed, 0, 20);\n        byte[][] recipientsFields = computeRecipientsField(seed);\n        int shaInputLength = seed.length;\n        for (byte[] field : recipientsFields) {\n            shaInputLength += field.length;\n        }\n        byte[] shaInput = new byte[shaInputLength];\n        System.arraycopy(seed, 0, shaInput, 0, 20);\n        int shaInputOffset = 20;\n        for (byte[] recipientsField : recipientsFields) {\n            System.arraycopy(recipientsField, 0, shaInput, shaInputOffset, recipientsField.length);\n            shaInputOffset += recipientsField.length;\n        }\n        byte[] mdResult;\n        switch (version) {\n            case 4 :\n                dictionary.setSubFilter(SUBFILTER5);\n                mdResult = MessageDigests.getSHA1().digest(shaInput);\n                prepareEncryptionDictAES(dictionary, COSName.AESV2, recipientsFields);\n                break;\n            case 5 :\n                dictionary.setSubFilter(SUBFILTER5);\n                mdResult = MessageDigests.getSHA256().digest(shaInput);\n                prepareEncryptionDictAES(dictionary, COSName.AESV3, recipientsFields);\n                break;\n            default :\n                dictionary.setSubFilter(SUBFILTER4);\n                mdResult = MessageDigests.getSHA1().digest(shaInput);\n                dictionary.setRecipients(recipientsFields);\n                break;\n        }\n        setEncryptionKey(new byte[getKeyLength() / 8]);\n        System.arraycopy(mdResult, 0, getEncryptionKey(), 0, getKeyLength() / 8);\n        doc.setEncryptionDictionary(dictionary);\n        doc.getDocument().setEncryptionDictionary(dictionary.getCOSObject());\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n}", "private byte[][] computeRecipientsField(byte[] seed) throws GeneralSecurityException, IOException {\n    PublicKeyProtectionPolicy protectionPolicy = getProtectionPolicy();\n    byte[][] recipientsField = new byte[protectionPolicy.getNumberOfRecipients()][];\n    Iterator<PublicKeyRecipient> it = protectionPolicy.getRecipientsIterator();\n    int i = 0;\n    while (it.hasNext()) {\n        PublicKeyRecipient recipient = it.next();\n        X509Certificate certificate = recipient.getX509();\n        int permission = recipient.getPermission().getPermissionBytesForPublicKey();\n        byte[] pkcs7input = new byte[24];\n        byte one = ((byte) (permission));\n        byte two = ((byte) (permission >>> 8));\n        byte three = ((byte) (permission >>> 16));\n        byte four = ((byte) (permission >>> 24));\n        // put this seed in the pkcs7 input\n        System.arraycopy(seed, 0, pkcs7input, 0, 20);\n        pkcs7input[20] = four;\n        pkcs7input[21] = three;\n        pkcs7input[22] = two;\n        pkcs7input[23] = one;\n        ASN1Primitive obj = createDERForRecipient(pkcs7input, certificate);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        obj.encodeTo(baos, ASN1Encoding.DER);\n        recipientsField[i] = baos.toByteArray();\n        i++;\n    } \n    return recipientsField;\n}", "private ASN1Primitive createDERForRecipient(byte[] in, X509Certificate cert) throws IOException, GeneralSecurityException {\n    String algorithm = PKCSObjectIdentifiers.RC2_CBC.getId();\n    AlgorithmParameterGenerator apg;\n    KeyGenerator keygen;\n    Cipher cipher;\n    try {\n        Provider provider = SecurityProvider.getProvider();\n        apg = AlgorithmParameterGenerator.getInstance(algorithm, provider);\n        keygen = KeyGenerator.getInstance(algorithm, provider);\n        cipher = Cipher.getInstance(algorithm, provider);\n    } catch (NoSuchAlgorithmException e) {\n        // happens when using the command line app .jar file\n        throw new IOException((\"Could not find a suitable javax.crypto provider for algorithm \" + algorithm) + \"; possible reason: using an unsigned .jar file\", e);\n    } catch (NoSuchPaddingException e) {\n        // should never happen, if this happens throw IOException instead\n        throw new RuntimeException(\"Could not find a suitable javax.crypto provider\", e);\n    }\n    AlgorithmParameters parameters = apg.generateParameters();\n    ASN1Primitive object;\n    try (ASN1InputStream input = new ASN1InputStream(parameters.getEncoded(\"ASN.1\"))) {\n        object = input.readObject();\n    }\n    keygen.init(128);\n    SecretKey secretkey = keygen.generateKey();\n    cipher.init(1, secretkey, parameters);\n    byte[] bytes = cipher.doFinal(in);\n    KeyTransRecipientInfo recipientInfo = computeRecipientInfo(cert, secretkey.getEncoded());\n    DERSet set = new DERSet(new RecipientInfo(recipientInfo));\n    AlgorithmIdentifier algorithmId = new AlgorithmIdentifier(new ASN1ObjectIdentifier(algorithm), object);\n    EncryptedContentInfo encryptedInfo = new EncryptedContentInfo(PKCSObjectIdentifiers.data, algorithmId, new DEROctetString(bytes));\n    EnvelopedData enveloped = new EnvelopedData(null, set, encryptedInfo, ((ASN1Set) (null)));\n    ContentInfo contentInfo = new ContentInfo(PKCSObjectIdentifiers.envelopedData, enveloped);\n    return contentInfo.toASN1Primitive();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationFreeText.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationFreeText.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationFreeText(COSDictionary a) {\n    super(a);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeHash2A", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeHash2B", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Check for owner password.\n *\n * @param ownerPassword\n * \t\tThe owner password.\n * @param user\n * \t\tThe u entry of the encryption dictionary.\n * @param owner\n * \t\tThe o entry of the encryption dictionary.\n * @param permissions\n * \t\tThe set of permissions on the document.\n * @param id\n * \t\tThe document id.\n * @param encRevision\n * \t\tThe encryption algorithm revision.\n * @param keyLengthInBytes\n * \t\tThe encryption key length in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata\n * @return True If the ownerPassword param is the owner password.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\npublic boolean isOwnerPassword(byte[] ownerPassword, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException {\n    switch (encRevision) {\n        case REVISION_2 :\n        case REVISION_3 :\n        case REVISION_4 :\n            return isOwnerPassword234(ownerPassword, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);\n        case REVISION_5 :\n        case REVISION_6 :\n            return isOwnerPassword56(ownerPassword, user, owner, encRevision);\n        default :\n            throw new IOException(\"Unknown Encryption Revision \" + encRevision);\n    }\n}", "private boolean isOwnerPassword56(byte[] ownerPassword, byte[] user, byte[] owner, int encRevision) throws IOException {\n    if (owner.length < 40) {\n        // PDFBOX-5104\n        throw new IOException(\"Owner password is too short\");\n    }\n    byte[] truncatedOwnerPassword = truncate127(ownerPassword);\n    byte[] oHash = new byte[32];\n    byte[] oValidationSalt = new byte[8];\n    System.arraycopy(owner, 0, oHash, 0, 32);\n    System.arraycopy(owner, 32, oValidationSalt, 0, 8);\n    if (encRevision == REVISION_5) {\n        return MessageDigest.isEqual(computeSHA256(truncatedOwnerPassword, oValidationSalt, user), oHash);\n    } else {\n        return MessageDigest.isEqual(computeHash2A(truncatedOwnerPassword, oValidationSalt, user), oHash);\n    }\n}", "// Algorithm 2.A from ISO 32000-1\nprivate byte[] computeHash2A(byte[] password, byte[] salt, byte[] u) throws IOException {\n    byte[] userKey = adjustUserKey(u);\n    byte[] truncatedPassword = truncate127(password);\n    byte[] input = concat(truncatedPassword, salt, userKey);\n    return computeHash2B(input, truncatedPassword, userKey);\n}", "// Algorithm 2.B from ISO 32000-2\nprivate static byte[] computeHash2B(byte[] input, byte[] password, byte[] userKey) throws IOException {\n    try {\n        MessageDigest md = MessageDigests.getSHA256();\n        byte[] k = md.digest(input);\n        byte[] e = null;\n        for (int round = 0; (round < 64) || ((e[e.length - 1] & 0xff) > (round - 32)); round++) {\n            byte[] k1;\n            if ((userKey != null) && (userKey.length >= 48)) {\n                k1 = new byte[64 * ((password.length + k.length) + 48)];\n            } else {\n                k1 = new byte[64 * (password.length + k.length)];\n            }\n            int pos = 0;\n            for (int i = 0; i < 64; i++) {\n                System.arraycopy(password, 0, k1, pos, password.length);\n                pos += password.length;\n                System.arraycopy(k, 0, k1, pos, k.length);\n                pos += k.length;\n                if ((userKey != null) && (userKey.length >= 48)) {\n                    System.arraycopy(userKey, 0, k1, pos, 48);\n                    pos += 48;\n                }\n            }\n            byte[] kFirst = new byte[16];\n            byte[] kSecond = new byte[16];\n            System.arraycopy(k, 0, kFirst, 0, 16);\n            System.arraycopy(k, 16, kSecond, 0, 16);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            SecretKeySpec keySpec = new SecretKeySpec(kFirst, \"AES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(kSecond);\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n            e = cipher.doFinal(k1);\n            byte[] eFirst = new byte[16];\n            System.arraycopy(e, 0, eFirst, 0, 16);\n            BigInteger bi = new BigInteger(1, eFirst);\n            BigInteger remainder = bi.mod(new BigInteger(\"3\"));\n            String nextHash = HASHES_2B[remainder.intValue()];\n            md = MessageDigest.getInstance(nextHash);\n            k = md.digest(e);\n        }\n        if (k.length > 32) {\n            byte[] kTrunc = new byte[32];\n            System.arraycopy(k, 0, kTrunc, 0, 32);\n            return kTrunc;\n        } else {\n            return k;\n        }\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.Version.getVersion",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.Version.getVersion" ],
    "fullMethods" : [ "/**\n * Returns the version of PDFBox.\n *\n * @return the version of PDFBox\n */\npublic static String getVersion() {\n    try (InputStream resourceAsStream = Version.class.getResourceAsStream(PDFBOX_VERSION_PROPERTIES);InputStream is = new BufferedInputStream(resourceAsStream)) {\n        Properties properties = new Properties();\n        properties.load(is);\n        return properties.getProperty(\"pdfbox.version\", null);\n    } catch (IOException io) {\n        LOG.debug(\"Unable to read version from properties - returning null\", io);\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFont.getSpaceWidth" ],
    "fullMethods" : [ "/**\n * Determines the width of the space character. This is very important for text extraction.\n *\n * @return the width of the space character\n */\npublic float getSpaceWidth() {\n    if (Float.compare(fontWidthOfSpace, -1.0F) == 0) {\n        try {\n            if ((toUnicodeCMap != null) && dict.containsKey(COSName.TO_UNICODE)) {\n                int spaceMapping = toUnicodeCMap.getSpaceMapping();\n                if (spaceMapping > (-1)) {\n                    fontWidthOfSpace = getWidth(spaceMapping);\n                }\n            } else {\n                try {\n                    // PDFBOX-5920: try with encoding, which gets the correct code\n                    fontWidthOfSpace = getStringWidth(\" \");\n                } catch (IllegalArgumentException | UnsupportedOperationException ex) {\n                    // Happens if space is not available in the font\n                    // or if encoding isn't implemented\n                    LOG.debug(ex.getMessage(), ex);\n                }\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getWidth(32);\n                }\n            }\n            // try to get it from the font itself\n            if (fontWidthOfSpace <= 0) {\n                fontWidthOfSpace = getWidthFromFont(32);\n                // use the average font width as fall back\n                if (fontWidthOfSpace <= 0) {\n                    fontWidthOfSpace = getAverageFontWidth();\n                }\n            }\n        } catch (Exception e) {\n            LOG.error((\"Can't determine the width of the space character for font \" + getName()) + \", assuming 250\", e);\n            fontWidthOfSpace = 250.0F;\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(((\"Space width for font \" + getName()) + \" is \") + fontWidthOfSpace);\n        }\n    }\n    return fontWidthOfSpace;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.toString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNAttributes.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(dictionary.getNameAsString(COSName.SUBTYPE));\n    sb.append('{');\n    PDDeviceNProcess process = getProcess();\n    if (process != null) {\n        sb.append(process);\n        sb.append(' ');\n    }\n    Map<String, PDSeparation> colorants;\n    try {\n        colorants = getColorants(null);\n        sb.append(\"Colorants{\");\n        for (Map.Entry<String, PDSeparation> col : colorants.entrySet()) {\n            sb.append('\\\"');\n            sb.append(col.getKey());\n            sb.append(\"\\\": \");\n            sb.append(col.getValue());\n            sb.append(' ');\n        }\n        sb.append('}');\n    } catch (IOException e) {\n        LOG.debug(\"Couldn't get the colorants information - returning 'ERROR' instead'\", e);\n        sb.append(\"ERROR\");\n    }\n    sb.append('}');\n    return sb.toString();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PatchMeshesShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.readPatch" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type7ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @throws IOException\n * \t\tif something went wrong\n */\nType7ShadingContext(PDShadingType7 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix, deviceBounds, 16);\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected PatchMeshesShadingContext(PDMeshBasedShadingType shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds, int controlPoints) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    patchList = shading.collectPatches(xform, matrix, controlPoints);\n    createPixelTable(deviceBounds);\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}", "/**\n * Read a single patch from a data stream, a patch contains information of its coordinates and color parameters.\n *\n * @param input\n * \t\tthe image source data stream\n * @param isFree\n * \t\twhether this is a free patch\n * @param implicitEdge\n * \t\timplicit edge when a patch is not free, otherwise it's not used\n * @param implicitCornerColor\n * \t\timplicit colors when a patch is not free, otherwise it's not used\n * @param maxSrcCoord\n * \t\tthe maximum coordinate value calculated from source data\n * @param maxSrcColor\n * \t\tthe maximum color value calculated from source data\n * @param rangeX\n * \t\trange for coordinate x\n * @param rangeY\n * \t\trange for coordinate y\n * @param colRange\n * \t\trange for color\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param xform\n * \t\ttransformation for user to device space\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return a single patch\n * @throws IOException\n * \t\twhen something went wrong\n */\nprotected Patch readPatch(ImageInputStream input, boolean isFree, Point2D[] implicitEdge, float[][] implicitCornerColor, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRange, Matrix matrix, AffineTransform xform, int controlPoints) throws IOException {\n    int numberOfColorComponents = getNumberOfColorComponents();\n    float[][] color = new float[4][numberOfColorComponents];\n    Point2D[] points = new Point2D[controlPoints];\n    int pStart = 4;\n    int cStart = 2;\n    if (isFree) {\n        pStart = 0;\n        cStart = 0;\n    } else {\n        points[0] = implicitEdge[0];\n        points[1] = implicitEdge[1];\n        points[2] = implicitEdge[2];\n        points[3] = implicitEdge[3];\n        for (int i = 0; i < numberOfColorComponents; i++) {\n            color[0][i] = implicitCornerColor[0][i];\n            color[1][i] = implicitCornerColor[1][i];\n        }\n    }\n    try {\n        int bitsPerCoordinate = getBitsPerCoordinate();\n        for (int i = pStart; i < controlPoints; i++) {\n            long x = input.readBits(bitsPerCoordinate);\n            long y = input.readBits(bitsPerCoordinate);\n            float px = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());\n            float py = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());\n            Point2D p = matrix.transformPoint(px, py);\n            xform.transform(p, p);\n            points[i] = p;\n        }\n        int bitsPerComponent = getBitsPerComponent();\n        for (int i = cStart; i < 4; i++) {\n            for (int j = 0; j < numberOfColorComponents; j++) {\n                long c = input.readBits(bitsPerComponent);\n                color[i][j] = interpolate(c, maxSrcColor, colRange[j].getMin(), colRange[j].getMax());\n            }\n        }\n    } catch (EOFException ex) {\n        LOG.debug(\"EOF\", ex);\n        return null;\n    }\n    return generatePatch(points, color);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.FDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.FDFParser.parse", "org.apache.pdfbox.pdfparser.COSParser.parseFDFHeader", "org.apache.pdfbox.pdfparser.COSParser.parseHeader" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the FDFDocument object.\n *\n * @return the parsed FDFDocument\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic FDFDocument parse() throws IOException {\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        if (!parseFDFHeader()) {\n            throw new IOException(\"Error: Header doesn't contain versioninfo\");\n        }\n        initialParse();\n        exceptionOccurred = false;\n        return new FDFDocument(document, source);\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * Parse the header of a fdf.\n *\n * @return true if a FDF header was found\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected boolean parseFDFHeader() throws IOException {\n    return parseHeader(FDF_HEADER, FDF_DEFAULT_VERSION);\n}", "private boolean parseHeader(String headerMarker, String defaultVersion) throws IOException {\n    // read first line\n    String header = readLine();\n    // some pdf-documents are broken and the pdf-version is in one of the following lines\n    if (!header.contains(headerMarker)) {\n        header = readLine();\n        while (!header.contains(headerMarker)) {\n            // if a line starts with a digit, it has to be the first one with data in it\n            if ((header.length() > 0) && Character.isDigit(header.charAt(0))) {\n                break;\n            }\n            header = readLine();\n        } \n    }\n    // nothing found\n    if (!header.contains(headerMarker)) {\n        source.seek(0);\n        return false;\n    }\n    // sometimes there is some garbage in the header before the header\n    // actually starts, so lets try to find the header first.\n    int headerStart = header.indexOf(headerMarker);\n    // greater than zero because if it is zero then there is no point of trimming\n    if (headerStart > 0) {\n        // trim off any leading characters\n        header = header.substring(headerStart);\n    }\n    // This is used if there is garbage after the header on the same line\n    if (header.startsWith(headerMarker) && (!header.matches(headerMarker + \"\\\\d.\\\\d\"))) {\n        if (header.length() < (headerMarker.length() + 3)) {\n            // No version number at all, set to 1.4 as default\n            header = headerMarker + defaultVersion;\n            LOG.debug((\"No version found, set to \" + defaultVersion) + \" as default.\");\n        } else {\n            String headerGarbage = header.substring(headerMarker.length() + 3) + \"\\n\";\n            header = header.substring(0, headerMarker.length() + 3);\n            source.rewind(headerGarbage.getBytes(StandardCharsets.ISO_8859_1).length);\n        }\n    }\n    float headerVersion = -1;\n    try {\n        String[] headerParts = header.split(\"-\");\n        if (headerParts.length == 2) {\n            headerVersion = Float.parseFloat(headerParts[1]);\n        }\n    } catch (NumberFormatException exception) {\n        LOG.debug(\"Can't parse the header version.\", exception);\n    }\n    if (headerVersion < 0) {\n        if (isLenient) {\n            headerVersion = 1.7F;\n        } else {\n            throw new IOException(\"Error getting header version: \" + header);\n        }\n    }\n    document.setVersion(headerVersion);\n    // rewind\n    source.seek(0);\n    return true;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.getFontMatrix",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.getFontMatrix" ],
    "fullMethods" : [ "@Override\npublic final Matrix getFontMatrix() {\n    if (fontMatrix == null) {\n        List<Number> numbers = null;\n        try {\n            numbers = genericFont.getFontMatrix();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font matrix - returning default value\", e);\n            fontMatrix = DEFAULT_FONT_MATRIX;\n        }\n        if ((numbers != null) && (numbers.size() == 6)) {\n            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());\n        } else {\n            return super.getFontMatrix();\n        }\n    }\n    return fontMatrix;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.setEndPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.setEndPage", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the last page to be extracted by this class.\n *\n * @param endPageValue\n * \t\tNew value of 1-based endPage property.\n */\npublic void setEndPage(int endPageValue) {\n    if (endPageValue <= 0) {\n        LOG.warn(\"Parameter must be 1-based, but is \" + endPageValue);\n    }\n    endPage = endPageValue;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.readPatch" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    return getBounds(xform, matrix, 12);\n}", "Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    Rectangle2D bounds = null;\n    for (Patch patch : collectPatches(xform, matrix, controlPoints)) {\n        for (ShadedTriangle shadedTriangle : patch.listOfTriangles) {\n            if (bounds == null) {\n                bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n            }\n            bounds.add(shadedTriangle.corner[0]);\n            bounds.add(shadedTriangle.corner[1]);\n            bounds.add(shadedTriangle.corner[2]);\n        }\n    }\n    return bounds;\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}", "/**\n * Read a single patch from a data stream, a patch contains information of its coordinates and color parameters.\n *\n * @param input\n * \t\tthe image source data stream\n * @param isFree\n * \t\twhether this is a free patch\n * @param implicitEdge\n * \t\timplicit edge when a patch is not free, otherwise it's not used\n * @param implicitCornerColor\n * \t\timplicit colors when a patch is not free, otherwise it's not used\n * @param maxSrcCoord\n * \t\tthe maximum coordinate value calculated from source data\n * @param maxSrcColor\n * \t\tthe maximum color value calculated from source data\n * @param rangeX\n * \t\trange for coordinate x\n * @param rangeY\n * \t\trange for coordinate y\n * @param colRange\n * \t\trange for color\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param xform\n * \t\ttransformation for user to device space\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return a single patch\n * @throws IOException\n * \t\twhen something went wrong\n */\nprotected Patch readPatch(ImageInputStream input, boolean isFree, Point2D[] implicitEdge, float[][] implicitCornerColor, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRange, Matrix matrix, AffineTransform xform, int controlPoints) throws IOException {\n    int numberOfColorComponents = getNumberOfColorComponents();\n    float[][] color = new float[4][numberOfColorComponents];\n    Point2D[] points = new Point2D[controlPoints];\n    int pStart = 4;\n    int cStart = 2;\n    if (isFree) {\n        pStart = 0;\n        cStart = 0;\n    } else {\n        points[0] = implicitEdge[0];\n        points[1] = implicitEdge[1];\n        points[2] = implicitEdge[2];\n        points[3] = implicitEdge[3];\n        for (int i = 0; i < numberOfColorComponents; i++) {\n            color[0][i] = implicitCornerColor[0][i];\n            color[1][i] = implicitCornerColor[1][i];\n        }\n    }\n    try {\n        int bitsPerCoordinate = getBitsPerCoordinate();\n        for (int i = pStart; i < controlPoints; i++) {\n            long x = input.readBits(bitsPerCoordinate);\n            long y = input.readBits(bitsPerCoordinate);\n            float px = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());\n            float py = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());\n            Point2D p = matrix.transformPoint(px, py);\n            xform.transform(p, p);\n            points[i] = p;\n        }\n        int bitsPerComponent = getBitsPerComponent();\n        for (int i = cStart; i < 4; i++) {\n            for (int j = 0; j < numberOfColorComponents; j++) {\n                long c = input.readBits(bitsPerComponent);\n                color[i][j] = interpolate(c, maxSrcColor, colRange[j].getMin(), colRange[j].getMax());\n            }\n        }\n    } catch (EOFException ex) {\n        LOG.debug(\"EOF\", ex);\n        return null;\n    }\n    return generatePatch(points, color);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decrypt",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decrypt", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptString", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptData", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptDataAES256" ],
    "fullMethods" : [ "/**\n * This will dispatch to the correct method.\n *\n * @param obj\n * \t\tThe object to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation Number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void decrypt(COSBase obj, long objNum, long genNum) throws IOException {\n    // PDFBOX-4477: only cache strings and streams, this improves speed and memory footprint\n    if (obj instanceof COSString) {\n        if (objects.contains(obj)) {\n            return;\n        }\n        objects.add(obj);\n        decryptString(((COSString) (obj)), objNum, genNum);\n    } else if (obj instanceof COSStream) {\n        if (objects.contains(obj)) {\n            return;\n        }\n        objects.add(obj);\n        decryptStream(((COSStream) (obj)), objNum, genNum);\n    } else if (obj instanceof COSDictionary) {\n        decryptDictionary(((COSDictionary) (obj)), objNum, genNum);\n    } else if (obj instanceof COSArray) {\n        decryptArray(((COSArray) (obj)), objNum, genNum);\n    }\n}", "/**\n * This will decrypt a string.\n *\n * @param string\n * \t\tthe string to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n */\nprivate void decryptString(COSString string, long objNum, long genNum) {\n    // String encrypted with identity filter\n    if (COSName.IDENTITY.equals(stringFilterName)) {\n        return;\n    }\n    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    try {\n        /* decrypt */\n        encryptData(objNum, genNum, data, outputStream, true);\n        string.setValue(outputStream.toByteArray());\n    } catch (IOException ex) {\n        LOG.error(((((\"Failed to decrypt COSString of length \" + string.getBytes().length) + \" in object \") + objNum) + \": \") + ex.getMessage(), ex);\n    }\n}", "/**\n * Encrypt or decrypt a set of data.\n *\n * @param objectNumber\n * \t\tThe data object number.\n * @param genNumber\n * \t\tThe data generation number.\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptData(long objectNumber, long genNumber, InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    // Determine whether we're using Algorithm 1 (for RC4 and AES-128), or 1.A (for AES-256)\n    if (useAES && (encryptionKey.length == 32)) {\n        encryptDataAES256(data, output, decrypt);\n    } else {\n        byte[] finalKey = calcFinalKey(objectNumber, genNumber);\n        if (useAES) {\n            encryptDataAESother(finalKey, data, output, decrypt);\n        } else {\n            encryptDataRC4(finalKey, data, output);\n        }\n    }\n    output.flush();\n}", "/**\n * Encrypt or decrypt data with AES256.\n *\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptDataAES256(InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    byte[] iv = new byte[16];\n    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {\n        return;\n    }\n    Cipher cipher;\n    try {\n        cipher = createCipher(this.encryptionKey, iv, decrypt);\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n    try (CipherInputStream cis = new CipherInputStream(data, cipher)) {\n        IOUtils.copy(cis, output);\n    } catch (IOException exception) {\n        // starting with java 8 the JVM wraps an IOException around a GeneralSecurityException\n        // it should be safe to swallow a GeneralSecurityException\n        if (!(exception.getCause() instanceof GeneralSecurityException)) {\n            throw exception;\n        }\n        LOG.debug(\"A GeneralSecurityException occurred when decrypting some stream data\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptData", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptDataAES256" ],
    "fullMethods" : [ "/**\n * This will decrypt a stream.\n *\n * @param stream\n * \t\tThe stream to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void decryptStream(COSStream stream, long objNum, long genNum) throws IOException {\n    // Stream encrypted with identity filter\n    if (COSName.IDENTITY.equals(streamFilterName)) {\n        return;\n    }\n    COSBase type = stream.getCOSName(COSName.TYPE);\n    if ((!decryptMetadata) && COSName.METADATA.equals(type)) {\n        return;\n    }\n    // \"The cross-reference stream shall not be encrypted\"\n    if (COSName.XREF.equals(type)) {\n        return;\n    }\n    if (COSName.METADATA.equals(type)) {\n        byte[] buf;\n        // PDFBOX-3229 check case where metadata is not encrypted despite /EncryptMetadata missing\n        try (InputStream is = stream.createRawInputStream()) {\n            buf = new byte[10];\n            long isResult = IOUtils.populateBuffer(is, buf);\n            if (Long.compare(isResult, buf.length) != 0) {\n                LOG.debug((((\"Tried reading \" + buf.length) + \" bytes but only \") + isResult) + \" bytes read\");\n            }\n        }\n        if (Arrays.equals(buf, \"<?xpacket \".getBytes(StandardCharsets.ISO_8859_1))) {\n            LOG.warn(\"Metadata is not encrypted, but was expected to be\");\n            LOG.warn(\"Read PDF specification about EncryptMetadata (default value: true)\");\n            return;\n        }\n    }\n    decryptDictionary(stream, objNum, genNum);\n    // the input and the output stream of a still encrypted COSStream aren't no longer based\n    // on the same object so that it is safe to omit the intermediate ByteArrayStream\n    // \n    try (InputStream encryptedStream = stream.createRawInputStream();OutputStream output = stream.createRawOutputStream()) {\n        /* decrypt */\n        encryptData(objNum, genNum, encryptedStream, output, true);\n    } catch (IOException ex) {\n        LOG.error(((((ex.getClass().getSimpleName() + \" thrown when decrypting object \") + objNum) + \" \") + genNum) + \" obj\");\n        throw ex;\n    }\n}", "/**\n * Encrypt or decrypt a set of data.\n *\n * @param objectNumber\n * \t\tThe data object number.\n * @param genNumber\n * \t\tThe data generation number.\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptData(long objectNumber, long genNumber, InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    // Determine whether we're using Algorithm 1 (for RC4 and AES-128), or 1.A (for AES-256)\n    if (useAES && (encryptionKey.length == 32)) {\n        encryptDataAES256(data, output, decrypt);\n    } else {\n        byte[] finalKey = calcFinalKey(objectNumber, genNumber);\n        if (useAES) {\n            encryptDataAESother(finalKey, data, output, decrypt);\n        } else {\n            encryptDataRC4(finalKey, data, output);\n        }\n    }\n    output.flush();\n}", "/**\n * Encrypt or decrypt data with AES256.\n *\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptDataAES256(InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    byte[] iv = new byte[16];\n    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {\n        return;\n    }\n    Cipher cipher;\n    try {\n        cipher = createCipher(this.encryptionKey, iv, decrypt);\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n    try (CipherInputStream cis = new CipherInputStream(data, cipher)) {\n        IOUtils.copy(cis, output);\n    } catch (IOException exception) {\n        // starting with java 8 the JVM wraps an IOException around a GeneralSecurityException\n        // it should be safe to swallow a GeneralSecurityException\n        if (!(exception.getCause() instanceof GeneralSecurityException)) {\n            throw exception;\n        }\n        LOG.debug(\"A GeneralSecurityException occurred when decrypting some stream data\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getWidth", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues" ],
    "fullMethods" : [ "@Override\npublic int getWidth() {\n    initJPXValues();\n    return getCOSObject().getInt(COSName.WIDTH);\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSStream.toTextString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSStream.toTextString" ],
    "fullMethods" : [ "/**\n * Returns the contents of the stream as a PDF \"text string\".\n *\n * @return the PDF string representation of the stream content\n */\npublic String toTextString() {\n    try (InputStream input = createInputStream()) {\n        byte[] array = IOUtils.toByteArray(input);\n        COSString string = new COSString(array);\n        return string.getString();\n    } catch (IOException e) {\n        LOG.debug(\"An exception occurred trying to get the content - returning empty string instead\", e);\n        return \"\";\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationPolyline.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationPolyline.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationPolyline(COSDictionary a) {\n    super(a);\n}", "/**\n * Constructor.\n *\n * @param a\n * \t\tThe FDF annotation.\n */\npublic FDFAnnotation(COSDictionary a) {\n    annot = a;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PatchMeshesShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.readPatch" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type6ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @throws IOException\n * \t\tif something went wrong\n */\nType6ShadingContext(PDShadingType6 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix, deviceBounds, 12);\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected PatchMeshesShadingContext(PDMeshBasedShadingType shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds, int controlPoints) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    patchList = shading.collectPatches(xform, matrix, controlPoints);\n    createPixelTable(deviceBounds);\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}", "/**\n * Read a single patch from a data stream, a patch contains information of its coordinates and color parameters.\n *\n * @param input\n * \t\tthe image source data stream\n * @param isFree\n * \t\twhether this is a free patch\n * @param implicitEdge\n * \t\timplicit edge when a patch is not free, otherwise it's not used\n * @param implicitCornerColor\n * \t\timplicit colors when a patch is not free, otherwise it's not used\n * @param maxSrcCoord\n * \t\tthe maximum coordinate value calculated from source data\n * @param maxSrcColor\n * \t\tthe maximum color value calculated from source data\n * @param rangeX\n * \t\trange for coordinate x\n * @param rangeY\n * \t\trange for coordinate y\n * @param colRange\n * \t\trange for color\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param xform\n * \t\ttransformation for user to device space\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return a single patch\n * @throws IOException\n * \t\twhen something went wrong\n */\nprotected Patch readPatch(ImageInputStream input, boolean isFree, Point2D[] implicitEdge, float[][] implicitCornerColor, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRange, Matrix matrix, AffineTransform xform, int controlPoints) throws IOException {\n    int numberOfColorComponents = getNumberOfColorComponents();\n    float[][] color = new float[4][numberOfColorComponents];\n    Point2D[] points = new Point2D[controlPoints];\n    int pStart = 4;\n    int cStart = 2;\n    if (isFree) {\n        pStart = 0;\n        cStart = 0;\n    } else {\n        points[0] = implicitEdge[0];\n        points[1] = implicitEdge[1];\n        points[2] = implicitEdge[2];\n        points[3] = implicitEdge[3];\n        for (int i = 0; i < numberOfColorComponents; i++) {\n            color[0][i] = implicitCornerColor[0][i];\n            color[1][i] = implicitCornerColor[1][i];\n        }\n    }\n    try {\n        int bitsPerCoordinate = getBitsPerCoordinate();\n        for (int i = pStart; i < controlPoints; i++) {\n            long x = input.readBits(bitsPerCoordinate);\n            long y = input.readBits(bitsPerCoordinate);\n            float px = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());\n            float py = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());\n            Point2D p = matrix.transformPoint(px, py);\n            xform.transform(p, p);\n            points[i] = p;\n        }\n        int bitsPerComponent = getBitsPerComponent();\n        for (int i = cStart; i < 4; i++) {\n            for (int j = 0; j < numberOfColorComponents; j++) {\n                long c = input.readBits(bitsPerComponent);\n                color[i][j] = interpolate(c, maxSrcColor, colRange[j].getMin(), colRange[j].getMax());\n            }\n        }\n    } catch (EOFException ex) {\n        LOG.debug(\"EOF\", ex);\n        return null;\n    }\n    return generatePatch(points, color);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.TilingPaintFactory.TilingPaintParameter.equals",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.TilingPaintFactory.TilingPaintParameter.equals" ],
    "fullMethods" : [ "// this may not catch all equals, but at least those related to one resource dictionary.\n// it isn't needed to investigate further because matrix or transform would be different anyway.\n@Override\npublic boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (!(obj instanceof TilingPaintParameter)) {\n        return false;\n    }\n    final TilingPaintParameter other = ((TilingPaintParameter) (obj));\n    if (!Objects.equals(this.matrix, other.matrix)) {\n        return false;\n    }\n    if (!Objects.equals(this.patternDict, other.patternDict)) {\n        return false;\n    }\n    if (!Objects.equals(this.colorSpace, other.colorSpace)) {\n        return false;\n    }\n    if ((this.color == null) && (other.color != null)) {\n        return false;\n    }\n    if ((this.color != null) && (other.color == null)) {\n        return false;\n    }\n    if ((this.color != null) && (this.color.getColorSpace() != other.color.getColorSpace())) {\n        return false;\n    }\n    try {\n        if ((((this.color != null) && (other.color != null)) && (this.color != other.color)) && (this.color.toRGB() != other.color.toRGB())) {\n            return false;\n        }\n    } catch (IOException ex) {\n        LOG.debug(\"Couldn't convert color to RGB - treating as not equal\", ex);\n        return false;\n    }\n    return Objects.equals(this.xform, other.xform);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFileByContent",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFileByContent" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image file. The file format is determined by the file\n * content. The following file types are supported: JPG, JPEG, TIF, TIFF, GIF, BMP and PNG. This\n * is a convenience method that calls {@link JPEGFactory#createFromStream},\n * {@link CCITTFactory#createFromFile} or {@link ImageIO#read} combined with\n * {@link LosslessFactory#createFromImage}. (The later can also be used to create a\n * PDImageXObject from a BufferedImage). Starting with 2.0.18, this call will create an image\n * directly from a PNG file without decoding it (when possible), which is faster. However the\n * result size depends on the compression skill of the software that created the PNG file. If\n * file size or bandwidth are important to you or to your clients, then create your PNG files\n * with a tool that has implemented the\n * <a href=\"https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/\">Zopfli\n * algorithm</a>, or use the two-step process mentioned above.\n *\n * @param file\n * \t\tthe image file.\n * @param doc\n * \t\tthe document that shall use this PDImageXObject.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromFileByContent(File file, PDDocument doc) throws IOException {\n    FileType fileType = null;\n    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(file))) {\n        fileType = FileTypeDetector.detectFileType(bufferedInputStream);\n    } catch (IOException e) {\n        throw new IOException(\"Could not determine file type: \" + file.getName(), e);\n    }\n    if (fileType == null) {\n        throw new IllegalArgumentException(\"Image type not supported: \" + file.getName());\n    }\n    if (fileType == FileType.JPEG) {\n        try (FileInputStream fis = new FileInputStream(file)) {\n            return JPEGFactory.createFromStream(doc, fis);\n        }\n    }\n    if (fileType == FileType.TIFF) {\n        try {\n            return CCITTFactory.createFromFile(doc, file);\n        } catch (IOException ex) {\n            LOG.debug(\"Reading as TIFF failed, setting fileType to PNG\", ex);\n            // Plan B: try reading with ImageIO\n            // common exception:\n            // First image in tiff is not CCITT T4 or T6 compressed\n            fileType = FileType.PNG;\n        }\n    }\n    if (((fileType == FileType.BMP) || (fileType == FileType.GIF)) || (fileType == FileType.PNG)) {\n        BufferedImage bim = ImageIO.read(file);\n        return LosslessFactory.createFromImage(doc, bim);\n    }\n    throw new IllegalArgumentException(((\"Image type \" + fileType) + \" not supported: \") + file.getName());\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.shadingFill",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.shadingFill", "org.apache.pdfbox.rendering.PageDrawer.applySoftMaskToPaint", "org.apache.pdfbox.rendering.SoftMask.<init>" ],
    "fullMethods" : [ "@Override\npublic void shadingFill(COSName shadingName) throws IOException {\n    if (!isContentRendered()) {\n        return;\n    }\n    PDShading shading = getResources().getShading(shadingName);\n    if (shading == null) {\n        LOG.error((\"shading \" + shadingName) + \" does not exist in resources dictionary\");\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    Shape savedClip = graphics.getClip();\n    graphics.setClip(null);\n    lastClips = null;\n    // get the transformed BBox and intersect with current clipping path\n    // need to do it here and not in shading getRaster() because it may have been rotated\n    PDRectangle bbox = shading.getBBox();\n    Area area;\n    if (bbox != null) {\n        area = new Area(bbox.transform(ctm));\n        area.intersect(getGraphicsState().getCurrentClippingPath());\n    } else {\n        Rectangle2D bounds = shading.getBounds(new AffineTransform(), ctm);\n        if (bounds != null) {\n            bounds.add(new Point2D.Double(Math.floor(bounds.getMinX() - 1), Math.floor(bounds.getMinY() - 1)));\n            bounds.add(new Point2D.Double(Math.ceil(bounds.getMaxX() + 1), Math.ceil(bounds.getMaxY() + 1)));\n            area = new Area(bounds);\n            area.intersect(getGraphicsState().getCurrentClippingPath());\n        } else {\n            area = getGraphicsState().getCurrentClippingPath();\n        }\n    }\n    if (!area.isEmpty()) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        Paint paint = shading.toPaint(ctm);\n        paint = applySoftMaskToPaint(paint, getGraphicsState().getSoftMask());\n        graphics.setPaint(paint);\n        graphics.fill(area);\n    }\n    graphics.setClip(savedClip);\n}", "private Paint applySoftMaskToPaint(Paint parentPaint, PDSoftMask softMask) throws IOException {\n    if ((softMask == null) || (softMask.getGroup() == null)) {\n        return parentPaint;\n    }\n    PDColor backdropColor = null;\n    if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        COSArray backdropColorArray = softMask.getBackdropColor();\n        if (backdropColorArray != null) {\n            PDTransparencyGroup form = softMask.getGroup();\n            PDColorSpace colorSpace = form.getGroup().getColorSpace(form.getResources());\n            // PDFBOX-5795\n            if ((colorSpace != null) && (colorSpace.getNumberOfComponents() == backdropColorArray.size())) {\n                backdropColor = new PDColor(backdropColorArray, colorSpace);\n            }\n        }\n    }\n    TransparencyGroup transparencyGroup = new TransparencyGroup(softMask.getGroup(), true, softMask.getInitialTransformationMatrix(), backdropColor);\n    BufferedImage image = transparencyGroup.getImage();\n    if (image == null) {\n        // Adobe Reader ignores empty softmasks instead of using bc color\n        // sample file: PDFJS-6967_reduced_outside_softmask.pdf\n        return parentPaint;\n    }\n    BufferedImage gray = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);\n    if (COSName.ALPHA.equals(softMask.getSubType())) {\n        gray.setData(image.getAlphaRaster());\n    } else if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        Graphics g = gray.getGraphics();\n        g.drawImage(image, 0, 0, null);\n        g.dispose();\n    } else {\n        throw new IOException(\"Invalid soft mask subtype.\");\n    }\n    gray = adjustImage(gray);\n    Rectangle2D tpgBounds = transparencyGroup.getBounds();\n    return new SoftMask(parentPaint, gray, tpgBounds, backdropColor, softMask.getTransferFunction());\n}", "/**\n * Creates a new soft mask paint.\n *\n * @param paint\n * \t\tunderlying paint.\n * @param mask\n * \t\tsoft mask\n * @param bboxDevice\n * \t\tbbox of the soft mask in the underlying Graphics2D device space\n * @param backdropColor\n * \t\tthe color to be used outside the transparency groupâs bounding box; if\n * \t\tnull, black will be used.\n * @param transferFunction\n * \t\tthe transfer function, may be null.\n */\nSoftMask(Paint paint, BufferedImage mask, Rectangle2D bboxDevice, PDColor backdropColor, PDFunction transferFunction) {\n    this.paint = paint;\n    this.mask = mask;\n    this.bboxDevice = bboxDevice;\n    if (transferFunction instanceof PDFunctionTypeIdentity) {\n        this.transferFunction = null;\n    } else {\n        this.transferFunction = transferFunction;\n    }\n    if (backdropColor != null) {\n        try {\n            Color color = new Color(backdropColor.toRGB());\n            // http://stackoverflow.com/a/25463098/535646\n            bc = (((299 * color.getRed()) + (587 * color.getGreen())) + (114 * color.getBlue())) / 1000;\n        } catch (IOException ex) {\n            // keep default\n            LOG.debug(\"Couldn't convert backdropColor to RGB - keeping default\", ex);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.setStartPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.setStartPage", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * This will set the first page to be extracted by this class.\n *\n * @param startPageValue\n * \t\tNew value of 1-based startPage property.\n */\npublic void setStartPage(int startPageValue) {\n    if (startPageValue <= 0) {\n        LOG.warn(\"Parameter must be 1-based, but is \" + startPageValue);\n    }\n    startPage = startPageValue;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    if (((region == null) && (subsampling == cachedImageSubsampling)) && (cachedImage != null)) {\n        BufferedImage cached = cachedImage.get();\n        if (cached != null) {\n            return cached;\n        }\n    }\n    initJPXValues();\n    // get RGB image w/o reference because applyMask might modify it, take long time and a lot of memory.\n    final BufferedImage image;\n    final PDImageXObject softMask = getSoftMask();\n    final PDImageXObject mask = getMask();\n    if (jpxSMask != null) {\n        // PDFBOX-5657: handle JPEG2000 SMaskInData\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), jpxSMask, false, true, null);\n    } else if (softMask != null) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), softMask.getOpaqueImage(region, subsampling), softMask.getInterpolate(), true, extractMatte(softMask));\n    } else if ((mask != null) && mask.isStencil()) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), mask.getOpaqueImage(region, subsampling), mask.getInterpolate(), false, null);\n    } else {\n        image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());\n    }\n    if ((region == null) && (subsampling <= cachedImageSubsampling)) {\n        // only cache full-image renders, and prefer lower subsampling frequency, as lower\n        // subsampling means higher quality and longer render times.\n        cachedImageSubsampling = subsampling;\n        cachedImage = new SoftReference<>(image);\n    }\n    return image;\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareDocumentForEncryption",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareDocumentForEncryption", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareEncryptionDictRev6", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Prepare document for encryption.\n *\n * @param document\n * \t\tThe document to encrypt.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\n@Override\npublic void prepareDocumentForEncryption(PDDocument document) throws IOException {\n    PDEncryption encryptionDictionary = document.getEncryption();\n    if (encryptionDictionary == null) {\n        encryptionDictionary = new PDEncryption();\n    }\n    int version = computeVersionNumber();\n    int revision = computeRevisionNumber(version);\n    encryptionDictionary.setFilter(FILTER);\n    encryptionDictionary.setVersion(version);\n    if ((version != REVISION_4) && (version != REVISION_5)) {\n        // remove CF, StmF, and StrF entries that may be left from a previous encryption\n        encryptionDictionary.removeV45filters();\n    }\n    encryptionDictionary.setRevision(revision);\n    encryptionDictionary.setLength(getKeyLength());\n    StandardProtectionPolicy protectionPolicy = getProtectionPolicy();\n    String ownerPassword = protectionPolicy.getOwnerPassword();\n    String userPassword = protectionPolicy.getUserPassword();\n    if (ownerPassword == null) {\n        ownerPassword = \"\";\n    }\n    if (userPassword == null) {\n        userPassword = \"\";\n    }\n    // If no owner password is set, use the user password instead.\n    if (ownerPassword.isEmpty()) {\n        ownerPassword = userPassword;\n    }\n    int permissionInt = protectionPolicy.getPermissions().getPermissionBytes();\n    encryptionDictionary.setPermissions(permissionInt);\n    int length = getKeyLength() / 8;\n    if (revision == REVISION_6) {\n        // PDFBOX-4155\n        ownerPassword = SaslPrep.saslPrepStored(ownerPassword);\n        userPassword = SaslPrep.saslPrepStored(userPassword);\n        prepareEncryptionDictRev6(ownerPassword, userPassword, encryptionDictionary, permissionInt);\n    } else {\n        prepareEncryptionDictRev234(ownerPassword, userPassword, encryptionDictionary, permissionInt, document, revision, length);\n    }\n    document.setEncryptionDictionary(encryptionDictionary);\n    document.getDocument().setEncryptionDictionary(encryptionDictionary.getCOSObject());\n}", "private void prepareEncryptionDictRev6(String ownerPassword, String userPassword, PDEncryption encryptionDictionary, int permissionInt) throws IOException {\n    try {\n        SecureRandom rnd = new SecureRandom();\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        // make a random 256-bit file encryption key\n        setEncryptionKey(new byte[32]);\n        rnd.nextBytes(getEncryptionKey());\n        // Algorithm 8a: Compute U\n        byte[] userPasswordBytes = truncate127(userPassword.getBytes(StandardCharsets.UTF_8));\n        byte[] userValidationSalt = new byte[8];\n        byte[] userKeySalt = new byte[8];\n        rnd.nextBytes(userValidationSalt);\n        rnd.nextBytes(userKeySalt);\n        byte[] hashU = computeHash2B(concat(userPasswordBytes, userValidationSalt), userPasswordBytes, null);\n        byte[] u = concat(hashU, userValidationSalt, userKeySalt);\n        // Algorithm 8b: Compute UE\n        byte[] hashUE = computeHash2B(concat(userPasswordBytes, userKeySalt), userPasswordBytes, null);\n        // \"an initialization vector of zero\"\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashUE, \"AES\"), new IvParameterSpec(new byte[16]));\n        byte[] ue = cipher.doFinal(getEncryptionKey());\n        // Algorithm 9a: Compute O\n        byte[] ownerPasswordBytes = truncate127(ownerPassword.getBytes(StandardCharsets.UTF_8));\n        byte[] ownerValidationSalt = new byte[8];\n        byte[] ownerKeySalt = new byte[8];\n        rnd.nextBytes(ownerValidationSalt);\n        rnd.nextBytes(ownerKeySalt);\n        byte[] hashO = computeHash2B(concat(ownerPasswordBytes, ownerValidationSalt, u), ownerPasswordBytes, u);\n        byte[] o = concat(hashO, ownerValidationSalt, ownerKeySalt);\n        // Algorithm 9b: Compute OE\n        byte[] hashOE = computeHash2B(concat(ownerPasswordBytes, ownerKeySalt, u), ownerPasswordBytes, u);\n        // \"an initialization vector of zero\"\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashOE, \"AES\"), new IvParameterSpec(new byte[16]));\n        byte[] oe = cipher.doFinal(getEncryptionKey());\n        // Set keys and other required constants in encryption dictionary\n        encryptionDictionary.setUserKey(u);\n        encryptionDictionary.setUserEncryptionKey(ue);\n        encryptionDictionary.setOwnerKey(o);\n        encryptionDictionary.setOwnerEncryptionKey(oe);\n        prepareEncryptionDictAES(encryptionDictionary, COSName.AESV3);\n        // Algorithm 10: compute \"Perms\" value\n        byte[] perms = new byte[16];\n        perms[0] = ((byte) (permissionInt));\n        perms[1] = ((byte) (permissionInt >>> 8));\n        perms[2] = ((byte) (permissionInt >>> 16));\n        perms[3] = ((byte) (permissionInt >>> 24));\n        perms[4] = ((byte) (0xff));\n        perms[5] = ((byte) (0xff));\n        perms[6] = ((byte) (0xff));\n        perms[7] = ((byte) (0xff));\n        perms[8] = 'T';// we always encrypt Metadata\n\n        perms[9] = 'a';\n        perms[10] = 'd';\n        perms[11] = 'b';\n        for (int i = 12; i <= 15; i++) {\n            perms[i] = ((byte) (rnd.nextInt()));\n        }\n        // \"an initialization vector of zero\"\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(getEncryptionKey(), \"AES\"), new IvParameterSpec(new byte[16]));\n        byte[] permsEnc = cipher.doFinal(perms);\n        encryptionDictionary.setPerms(permsEnc);\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.saveIncrementalForExternalSigning",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.saveIncrementalForExternalSigning", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Save PDF incrementally without closing for external signature creation scenario. The general sequence is:\n *\n * <pre>\n *    PDDocument pdDocument = ...;\n *    OutputStream outputStream = ...;\n *    SignatureOptions signatureOptions = ...; // options to specify fine tuned signature options or null for defaults\n *    PDSignature pdSignature = ...;\n *\n *    // add signature parameters to be used when creating signature dictionary\n *    pdDocument.addSignature(pdSignature, signatureOptions);\n *    // prepare PDF for signing and obtain helper class to be used\n *    ExternalSigningSupport externalSigningSupport = pdDocument.saveIncrementalForExternalSigning(outputStream);\n *    // get data to be signed\n *    InputStream dataToBeSigned = externalSigningSupport.getContent();\n *    // invoke signature service\n *    byte[] signature = sign(dataToBeSigned);\n *    // set resulted CMS signature\n *    externalSigningSupport.setSignature(signature);\n *\n *    // last step is to close the document\n *    pdDocument.close();\n * </pre>\n * <p>\n * Note that after calling this method, only {@code close()} method may invoked for {@code PDDocument} instance and\n * only AFTER {@link ExternalSigningSupport} instance is used.\n * </p>\n * <p>\n * Don't use the input file as target as this will produce a corrupted file.\n *\n * @param output\n * \t\tstream to write the final PDF. It will be closed when the document is closed. It <i><b>must\n * \t\tnever</b></i> point to the source file or that one will be harmed!\n * @return instance to be used for external signing and setting CMS signature\n * @throws IOException\n * \t\tif the output could not be written\n * @throws IllegalStateException\n * \t\tif the document was not loaded from a file or a stream or signature options were\n * \t\tnot set.\n */\npublic ExternalSigningSupport saveIncrementalForExternalSigning(OutputStream output) throws IOException {\n    subsetDesignatedFonts();\n    if (pdfSource == null) {\n        throw new IllegalStateException(\"document was not loaded from a file or a stream\");\n    }\n    // PDFBOX-3978: getLastSignatureDictionary() not helpful if signing into a template\n    // that is not the last signature. So give higher priority to signature with update flag.\n    PDSignature foundSignature = null;\n    for (PDSignature sig : getSignatureDictionaries()) {\n        foundSignature = sig;\n        if (sig.getCOSObject().isNeedToBeUpdated()) {\n            break;\n        }\n    }\n    if (foundSignature == null) {\n        throw new IllegalStateException(\"document does not contain signature fields\");\n    }\n    int[] byteRange = foundSignature.getByteRange();\n    if (!Arrays.equals(byteRange, RESERVE_BYTE_RANGE)) {\n        throw new IllegalStateException(\"signature reserve byte range has been changed \" + \"after addSignature(), please set the byte range that existed after addSignature()\");\n    }\n    COSWriter writer = new COSWriter(output, pdfSource);\n    writer.write(this);\n    signingSupport = new SigningSupport(writer);\n    return signingSupport;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.Splitter.split",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.Splitter.split", "org.apache.pdfbox.multipdf.Splitter.processPages", "org.apache.pdfbox.multipdf.Splitter.processPage", "org.apache.pdfbox.pdmodel.PDDocument.importPage", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will take a document and split into several other documents.\n *\n * @param document\n * \t\tThe document to split.\n * @return A list of all the split documents. These should all be saved before closing any\ndocuments, including the source document. Any further operations should be made after\nreloading them, to avoid problems due to resource sharing. For the same reason, they should\nnot be saved with encryption.\n * @throws IOException\n * \t\tIf there is an IOError\n */\npublic List<PDDocument> split(PDDocument document) throws IOException {\n    // reset the currentPageNumber for a case if the split method will be used several times\n    currentPageNumber = 0;\n    destinationDocuments = new ArrayList<>();\n    sourceDocument = document;\n    pageDictMaps = new ArrayList<>();\n    annotDictMaps = new ArrayList<>();\n    destToFixMap = new HashMap<>();\n    idSet = new HashSet<>();\n    roleSet = new HashSet<>();\n    processPages();\n    for (int i = 0; i < destinationDocuments.size(); ++i) {\n        PDDocument destinationDocument = destinationDocuments.get(i);\n        pageDictMap = pageDictMaps.get(i);\n        annotDictMap = annotDictMaps.get(i);\n        cloneStructureTree(destinationDocument);\n        fixDestinations(destinationDocument);\n    }\n    return destinationDocuments;\n}", "/**\n * Interface method to handle the start of the page processing.\n *\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprivate void processPages() throws IOException {\n    for (PDPage page : sourceDocument.getPages()) {\n        if (((currentPageNumber + 1) >= startPage) && ((currentPageNumber + 1) <= endPage)) {\n            processPage(page);\n            currentPageNumber++;\n        } else if (currentPageNumber > endPage) {\n            break;\n        } else {\n            currentPageNumber++;\n        }\n    }\n}", "/**\n * Interface to start processing a new page.\n *\n * @param page\n * \t\tThe page that is about to get processed.\n * @throws IOException\n * \t\tIf there is an error creating the new document.\n */\nprotected void processPage(PDPage page) throws IOException {\n    createNewDocumentIfNecessary();\n    PDPage imported = getDestinationDocument().importPage(page);\n    if ((page.getResources() != null) && (!page.getCOSObject().containsKey(COSName.RESOURCES))) {\n        imported.setResources(page.getResources());\n        LOG.info(\"Resources imported in Splitter\");// follow-up to warning in importPage\n\n    }\n    if (imported.getCOSObject().containsKey(COSName.B)) {\n        imported.getCOSObject().removeItem(COSName.B);\n        LOG.warn(\"/B entry (beads) removed by splitter\");\n    }\n    // remove page links to avoid copying not needed resources\n    processAnnotations(imported);\n    pageDictMap.put(page.getCOSObject(), imported.getCOSObject());\n}", "/**\n * This will import and copy the contents from another location. Currently the content stream is\n * stored in a scratch file. The scratch file is associated with the document. If you are adding\n * a page to this document from another document and want to copy the contents to this\n * document's scratch file then use this method otherwise just use the {@link #addPage addPage()}\n * method.\n * <p>\n * Unlike {@link #addPage addPage()}, this method creates a new PDPage object. If your page has\n * annotations, and if these link to pages not in the target document, then the target document\n * might become huge. What you need to do is to delete page references of such annotations. See\n * <a href=\"http://stackoverflow.com/a/35477351/535646\">here</a> for how to do this.\n * <p>\n * Inherited (global) resources are ignored because these can contain resources not needed for\n * this page which could bloat your document, see\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-28\">PDFBOX-28</a> and related issues.\n * If you need them, call <code>importedPage.setResources(page.getResources());</code>\n * <p>\n * This method should only be used to import a page from a loaded document, not from a generated\n * document because these can contain unfinished parts, e.g. font subsetting information.\n *\n * @param page\n * \t\tThe page to import.\n * @return The page that was imported.\n * @throws IOException\n * \t\tIf there is an error copying the page.\n */\npublic PDPage importPage(PDPage page) throws IOException {\n    PDPage importedPage = new PDPage(new COSDictionary(page.getCOSObject()), resourceCache);\n    importedPage.getCOSObject().removeItem(COSName.PARENT);\n    PDStream dest = new PDStream(this, page.getContents(), COSName.FLATE_DECODE);\n    importedPage.setContents(dest);\n    addPage(importedPage);\n    importedPage.setCropBox(new PDRectangle(page.getCropBox().getCOSArray()));\n    importedPage.setMediaBox(new PDRectangle(page.getMediaBox().getCOSArray()));\n    importedPage.setRotation(page.getRotation());\n    if ((page.getResources() != null) && (!page.getCOSObject().containsKey(COSName.RESOURCES))) {\n        LOG.warn(\"inherited resources of source document are not imported to destination page\");\n        LOG.warn(\"call importedPage.setResources(page.getResources()) to do this\");\n    }\n    return importedPage;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationPolygon.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationPolygon.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationPolygon(COSDictionary a) {\n    super(a);\n}", "/**\n * Constructor.\n *\n * @param a\n * \t\tThe FDF annotation.\n */\npublic FDFAnnotation(COSDictionary a) {\n    annot = a;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.importPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.importPage", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will import and copy the contents from another location. Currently the content stream is\n * stored in a scratch file. The scratch file is associated with the document. If you are adding\n * a page to this document from another document and want to copy the contents to this\n * document's scratch file then use this method otherwise just use the {@link #addPage addPage()}\n * method.\n * <p>\n * Unlike {@link #addPage addPage()}, this method creates a new PDPage object. If your page has\n * annotations, and if these link to pages not in the target document, then the target document\n * might become huge. What you need to do is to delete page references of such annotations. See\n * <a href=\"http://stackoverflow.com/a/35477351/535646\">here</a> for how to do this.\n * <p>\n * Inherited (global) resources are ignored because these can contain resources not needed for\n * this page which could bloat your document, see\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-28\">PDFBOX-28</a> and related issues.\n * If you need them, call <code>importedPage.setResources(page.getResources());</code>\n * <p>\n * This method should only be used to import a page from a loaded document, not from a generated\n * document because these can contain unfinished parts, e.g. font subsetting information.\n *\n * @param page\n * \t\tThe page to import.\n * @return The page that was imported.\n * @throws IOException\n * \t\tIf there is an error copying the page.\n */\npublic PDPage importPage(PDPage page) throws IOException {\n    PDPage importedPage = new PDPage(new COSDictionary(page.getCOSObject()), resourceCache);\n    importedPage.getCOSObject().removeItem(COSName.PARENT);\n    PDStream dest = new PDStream(this, page.getContents(), COSName.FLATE_DECODE);\n    importedPage.setContents(dest);\n    addPage(importedPage);\n    importedPage.setCropBox(new PDRectangle(page.getCropBox().getCOSArray()));\n    importedPage.setMediaBox(new PDRectangle(page.getMediaBox().getCOSArray()));\n    importedPage.setRotation(page.getRotation());\n    if ((page.getResources() != null) && (!page.getCOSObject().containsKey(COSName.RESOURCES))) {\n        LOG.warn(\"inherited resources of source document are not imported to destination page\");\n        LOG.warn(\"call importedPage.setResources(page.getResources()) to do this\");\n    }\n    return importedPage;\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.close",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.close", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will close the underlying COSDocument object.\n *\n * @throws IOException\n * \t\tIf there is an error releasing resources.\n */\n@Override\npublic void close() throws IOException {\n    if (!document.isClosed()) {\n        // Make sure that:\n        // - first Exception is kept\n        // - all IO resources are closed\n        // - there's a way to see which errors occurred\n        IOException firstException = null;\n        // close resources and COSWriter\n        if (signingSupport != null) {\n            firstException = IOUtils.closeAndLogException(signingSupport, LOG, \"SigningSupport\", firstException);\n        }\n        // close all intermediate I/O streams\n        firstException = IOUtils.closeAndLogException(document, LOG, \"COSDocument\", firstException);\n        // close the source PDF stream, if we read from one\n        if (pdfSource != null) {\n            firstException = IOUtils.closeAndLogException(pdfSource, LOG, \"RandomAccessRead pdfSource\", firstException);\n        }\n        // close fonts\n        for (TrueTypeFont ttf : fontsToClose) {\n            firstException = IOUtils.closeAndLogException(ttf, LOG, \"TrueTypeFont\", firstException);\n        }\n        // rethrow first exception to keep method contract\n        if (firstException != null) {\n            throw firstException;\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPopup.getParent",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationPopup.getParent" ],
    "fullMethods" : [ "/**\n * This will retrieve the markup annotation which this popup relates to.\n *\n * @return The parent markup annotation.\n */\npublic PDAnnotationMarkup getParent() {\n    try {\n        PDAnnotation ann = PDAnnotation.createAnnotation(getCOSObject().getDictionaryObject(COSName.PARENT, COSName.P));\n        if (!(ann instanceof PDAnnotationMarkup)) {\n            LOG.error((\"parent annotation is of type \" + ann.getClass().getSimpleName()) + \" but should be of type PDAnnotationMarkup\");\n            return null;\n        }\n        return ((PDAnnotationMarkup) (ann));\n    } catch (IOException ioe) {\n        LOG.debug(\"An exception while trying to get the parent markup - ignoring\", ioe);\n        // Couldn't construct the annotation, so return null i.e. do nothing\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getColorSpace",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getColorSpace", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues" ],
    "fullMethods" : [ "@Override\npublic PDColorSpace getColorSpace() throws IOException {\n    if (colorSpace == null) {\n        COSBase cosBase = getCOSObject().getItem(COSName.COLORSPACE, COSName.CS);\n        if (cosBase != null) {\n            COSObject indirect = null;\n            if (((cosBase instanceof COSObject) && (resources != null)) && (resources.getResourceCache() != null)) {\n                // PDFBOX-4022: use the resource cache because several images\n                // might have the same colorspace indirect object.\n                indirect = ((COSObject) (cosBase));\n                colorSpace = resources.getResourceCache().getColorSpace(indirect);\n                if (colorSpace != null) {\n                    return colorSpace;\n                }\n            }\n            colorSpace = PDColorSpace.create(cosBase, resources);\n            if (indirect != null) {\n                resources.getResourceCache().put(indirect, colorSpace);\n            }\n        } else if (isStencil()) {\n            // stencil mask color space must be gray, it is often missing\n            colorSpace = PDDeviceGray.INSTANCE;\n        } else {\n            initJPXValues();\n        }\n        if (colorSpace == null) {\n            // an image without a color space is always broken\n            throw new IOException(\"could not determine color space\");\n        }\n    }\n    return colorSpace;\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.util.DateConverter.toCalendar",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.util.DateConverter.toCalendar", "org.apache.pdfbox.util.DateConverter.parseDate", "org.apache.pdfbox.util.DateConverter.parseBigEndianDate" ],
    "fullMethods" : [ "/**\n * Returns the Calendar for a given string containing a date,\n * or {@code null} if it cannot be parsed.\n *\n * The returned value will have 0 for DST_OFFSET.\n *\n * @param text\n * \t\tA COS string containing a date.\n * @return The Calendar that the text string represents, or {@code null} if it cannot be parsed.\n */\npublic static Calendar toCalendar(String text) {\n    if ((text == null) || text.trim().isEmpty()) {\n        return null;\n    }\n    ParsePosition where = new ParsePosition(0);\n    skipOptionals(text, where, \" \");\n    skipString(text, \"D:\", where);\n    Calendar calendar = parseDate(text, where);\n    if ((calendar == null) || (where.getIndex() != text.length())) {\n        // the date string is invalid\n        return null;\n    }\n    return calendar;\n}", "/* Parses a String to see if it begins with a date, and if so, \nreturns that date. The date must be strictly correct--no \nfield may exceed the appropriate limit.\n(That is, the Calendar has setLenient(false).) \nSkips initial spaces, but does NOT check for \"D:\"\n\nThe scan first tries parseBigEndianDate and parseTZoffset\nand then tries parseSimpleDate with appropriate formats, \nagain followed by parseTZoffset. If at any stage the entire \ntext is consumed, that date value is returned immediately. \nOtherwise the date that consumes the longest initial part\nof the text is returned.\n\n- PDF format dates are among those recognized by parseBigEndianDate.\n- The formats tried are alphaStartFormats or digitStartFormat and\nany listed in the value of moreFmts.\n */\nprivate static Calendar parseDate(String text, ParsePosition initialWhere) {\n    if (((text == null) || text.isEmpty()) || \"D:\".equals(text.trim())) {\n        return null;\n    }\n    // remember longestr date string\n    int longestLen = -999999;\n    // theorem: the above value will never be used\n    // proof: longestLen is only used if longestDate is not null\n    GregorianCalendar longestDate = null;// null says no date found yet\n\n    int whereLen;// tempcopy of where.getIndex()\n\n    ParsePosition where = new ParsePosition(initialWhere.getIndex());\n    // check for null (throws exception) and trim off surrounding spaces\n    skipOptionals(text, where, \" \");\n    int startPosition = where.getIndex();\n    // try big-endian parse\n    GregorianCalendar retCal = parseBigEndianDate(text, where);\n    // check for success and a timezone\n    if ((retCal != null) && ((where.getIndex() == text.length()) || parseTZoffset(text, retCal, where))) {\n        // if text is fully consumed, return the date else remember it and its length\n        whereLen = where.getIndex();\n        if (whereLen == text.length()) {\n            initialWhere.setIndex(whereLen);\n            return retCal;\n        }\n        longestLen = whereLen;\n        longestDate = retCal;\n    }\n    // try one of the sets of standard formats\n    where.setIndex(startPosition);\n    String[] formats = (Character.isDigit(text.charAt(startPosition))) ? DIGIT_START_FORMATS : ALPHA_START_FORMATS;\n    retCal = parseSimpleDate(text, formats, where);\n    // check for success and a timezone\n    if ((retCal != null) && ((where.getIndex() == text.length()) || parseTZoffset(text, retCal, where))) {\n        // if text is fully consumed, return the date else remember it and its length\n        whereLen = where.getIndex();\n        if (whereLen == text.length()) {\n            initialWhere.setIndex(whereLen);\n            return retCal;\n        }\n        if (whereLen > longestLen) {\n            longestLen = whereLen;\n            longestDate = retCal;\n        }\n    }\n    if (longestDate != null) {\n        initialWhere.setIndex(longestLen);\n        return longestDate;\n    }\n    return retCal;\n}", "/* Parses a big-endian date: year month day hour min sec.\nThe year must be four digits. Other fields may be adjacent\nand delimited by length or they may follow appropriate delimiters.\n    year [ -/]* month [ -/]* dayofmonth [ T]* hour [:] min [:] sec [.secFraction]\nIf any numeric field is omitted, all following fields must also be omitted.\nNo time zone is processed.\n\nAmbiguous dates can produce unexpected results. For example:\n     1970 12 23:08 will parse as 1970 December 23 00:08:00 \n\nThe parse begins at `where, on return the index\nis advanced to just beyond the last character processed.\nThe error index is ignored and unchanged.\n */\nprivate static GregorianCalendar parseBigEndianDate(String text, ParsePosition initialWhere) {\n    ParsePosition where = new ParsePosition(initialWhere.getIndex());\n    int year = parseTimeField(text, where, 4, 0);\n    if (where.getIndex() != (4 + initialWhere.getIndex())) {\n        return null;\n    }\n    skipOptionals(text, where, \"/- \");\n    int month = parseTimeField(text, where, 2, 1) - 1;// Calendar months are 0...11\n\n    skipOptionals(text, where, \"/- \");\n    int day = parseTimeField(text, where, 2, 1);\n    skipOptionals(text, where, \" T\");\n    int hour = parseTimeField(text, where, 2, 0);\n    skipOptionals(text, where, \": \");\n    int minute = parseTimeField(text, where, 2, 0);\n    skipOptionals(text, where, \": \");\n    int second = parseTimeField(text, where, 2, 0);\n    char nextC = skipOptionals(text, where, \".\");\n    if (nextC == '.') {\n        // fractions of a second: skip up to 19 digits\n        parseTimeField(text, where, 19, 0);\n    }\n    GregorianCalendar dest = newGreg();\n    try {\n        dest.set(year, month, day, hour, minute, second);\n        // trigger limit tests\n        dest.getTimeInMillis();\n    } catch (IllegalArgumentException ill) {\n        LOG.debug(((\"Couldn't parse arguments text:\" + text) + \" initialWhere:\") + initialWhere, ill);\n        return null;\n    }\n    initialWhere.setIndex(where.getIndex());\n    skipOptionals(text, initialWhere, \" \");\n    // dest has at least a year value\n    return dest;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationLink.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationLink.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationLink(COSDictionary a) {\n    super(a);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationInk.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationInk.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationInk(COSDictionary a) {\n    super(a);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.<init>", "org.apache.pdfbox.text.PDFTextStripper.<clinit>" ],
    "fullMethods" : [ "/**\n * Instantiate a new PDFTextStripper object.\n */\npublic PDFTextStripper() {\n    addOperator(new BeginMarkedContentSequenceWithProperties(this));\n    addOperator(new BeginMarkedContentSequence(this));\n    addOperator(new EndMarkedContentSequence(this));\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptString", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptData", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptDataAES256" ],
    "fullMethods" : [ "/**\n * This will encrypt a string.\n *\n * @param string\n * \t\tthe string to encrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf an error occurs writing the new string.\n */\npublic void encryptString(COSString string, long objNum, int genNum) throws IOException {\n    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    /* encrypt */\n    encryptData(objNum, genNum, data, buffer, false);\n    string.setValue(buffer.toByteArray());\n}", "/**\n * Encrypt or decrypt a set of data.\n *\n * @param objectNumber\n * \t\tThe data object number.\n * @param genNumber\n * \t\tThe data generation number.\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptData(long objectNumber, long genNumber, InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    // Determine whether we're using Algorithm 1 (for RC4 and AES-128), or 1.A (for AES-256)\n    if (useAES && (encryptionKey.length == 32)) {\n        encryptDataAES256(data, output, decrypt);\n    } else {\n        byte[] finalKey = calcFinalKey(objectNumber, genNumber);\n        if (useAES) {\n            encryptDataAESother(finalKey, data, output, decrypt);\n        } else {\n            encryptDataRC4(finalKey, data, output);\n        }\n    }\n    output.flush();\n}", "/**\n * Encrypt or decrypt data with AES256.\n *\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptDataAES256(InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    byte[] iv = new byte[16];\n    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {\n        return;\n    }\n    Cipher cipher;\n    try {\n        cipher = createCipher(this.encryptionKey, iv, decrypt);\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n    try (CipherInputStream cis = new CipherInputStream(data, cipher)) {\n        IOUtils.copy(cis, output);\n    } catch (IOException exception) {\n        // starting with java 8 the JVM wraps an IOException around a GeneralSecurityException\n        // it should be safe to swallow a GeneralSecurityException\n        if (!(exception.getCause() instanceof GeneralSecurityException)) {\n            throw exception;\n        }\n        LOG.debug(\"A GeneralSecurityException occurred when decrypting some stream data\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tThe FDF annotation.\n */\npublic FDFAnnotation(COSDictionary a) {\n    annot = a;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.SoftMask.SoftPaintContext.getRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.SoftMask.SoftPaintContext.getRaster" ],
    "fullMethods" : [ "@Override\npublic Raster getRaster(int x1, int y1, int w, int h) {\n    Raster raster = context.getRaster(x1, y1, w, h);\n    ColorModel rasterCM = context.getColorModel();\n    float[] input = null;\n    Float[] map = null;\n    if (transferFunction != null) {\n        map = new Float[256];\n        input = new float[1];\n    }\n    // buffer\n    WritableRaster output = getColorModel().createCompatibleWritableRaster(w, h);\n    // the soft mask has its own bbox\n    x1 = x1 - ((int) (bboxDevice.getX()));\n    y1 = y1 - ((int) (bboxDevice.getY()));\n    int[] gray = new int[4];\n    Object pixelInput = null;\n    int[] pixelOutput = new int[4];\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            pixelInput = raster.getDataElements(x, y, pixelInput);\n            pixelOutput[0] = rasterCM.getRed(pixelInput);\n            pixelOutput[1] = rasterCM.getGreen(pixelInput);\n            pixelOutput[2] = rasterCM.getBlue(pixelInput);\n            pixelOutput[3] = rasterCM.getAlpha(pixelInput);\n            // get the alpha value from the gray mask, if within mask bounds\n            gray[0] = 0;\n            if (((((x1 + x) >= 0) && ((y1 + y) >= 0)) && ((x1 + x) < mask.getWidth())) && ((y1 + y) < mask.getHeight())) {\n                mask.getRaster().getPixel(x1 + x, y1 + y, gray);\n                int g = gray[0];\n                if (transferFunction != null) {\n                    // apply transfer function\n                    try {\n                        if (map[g] != null) {\n                            // was calculated before\n                            pixelOutput[3] = Math.round(pixelOutput[3] * map[g]);\n                        } else {\n                            // calculate and store in map\n                            input[0] = g / 255.0F;\n                            float f = transferFunction.eval(input)[0];\n                            map[g] = f;\n                            pixelOutput[3] = Math.round(pixelOutput[3] * f);\n                        }\n                    } catch (IOException ex) {\n                        // ignore exception, treat as outside\n                        LOG.debug(\"Couldn't apply transferFunction - treating as outside\", ex);\n                        pixelOutput[3] = Math.round(pixelOutput[3] * (bc / 255.0F));\n                    }\n                } else {\n                    pixelOutput[3] = Math.round(pixelOutput[3] * (g / 255.0F));\n                }\n            } else {\n                pixelOutput[3] = Math.round(pixelOutput[3] * (bc / 255.0F));\n            }\n            output.setPixel(x, y, pixelOutput);\n        }\n    }\n    return output;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfwriter.COSWriter.write",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfwriter.COSWriter.write", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will write the pdf document.\n *\n * @throws IOException\n * \t\tIf an error occurs while generating the data.\n * @param doc\n * \t\tThe document to write.\n */\npublic void write(COSDocument doc) throws IOException {\n    PDDocument pdDoc = new PDDocument(doc);\n    write(pdDoc);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getHeight",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getHeight", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues" ],
    "fullMethods" : [ "@Override\npublic int getHeight() {\n    initJPXValues();\n    return getCOSObject().getInt(COSName.HEIGHT);\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSDictionary.toString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSDictionary.toString" ],
    "fullMethods" : [ "/**\n * {@inheritDoc }\n */\n@Override\npublic String toString() {\n    try {\n        return getDictionaryString(this, new ArrayList<>());\n    } catch (IOException e) {\n        LOG.debug(\"An exception occurred trying - returning error message instead\", e);\n        return (\"COSDictionary{\" + e.getMessage()) + \"}\";\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromByteArray" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image byte array. This overloaded version allows providing\n * a custom factory to handle specific image formats, such as BMP and GIF, or to act as a\n * fallback strategy when the default converters (e.g., for PNG or TIFF) fail.\n *\n * @param document\n * \t\tthe document that shall use this PDImageXObject.\n * @param byteArray\n * \t\tbytes from an image file.\n * @param name\n * \t\tname of image file for exception messages, can be null.\n * @param customFactory\n * \t\toptional factory used to handle BMP, GIF, or fallback cases\n * \t\t(e.g., for PNG or TIFF). If {@code null}, this method delegates to\n * \t\t{@link #createFromByteArray(PDDocument, byte[], String)}.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray, String name, CustomFactory customFactory) throws IOException {\n    FileType fileType = FileTypeDetector.detectFileType(byteArray);\n    if (fileType == null) {\n        throw new IllegalArgumentException(\"Image type not supported: \" + name);\n    }\n    if (fileType == FileType.JPEG) {\n        return JPEGFactory.createFromByteArray(document, byteArray);\n    }\n    if (fileType == FileType.PNG) {\n        // Try to directly convert the image without recoding it.\n        PDImageXObject image = PNGConverter.convertPNGImage(document, byteArray);\n        if (image != null) {\n            return image;\n        }\n    }\n    if (fileType == FileType.TIFF) {\n        try {\n            return CCITTFactory.createFromByteArray(document, byteArray);\n        } catch (IOException ex) {\n            LOG.debug(\"Reading as TIFF failed, setting fileType to PNG\", ex);\n            // Plan B: try reading with ImageIO\n            // common exception:\n            // First image in tiff is not CCITT T4 or T6 compressed\n            fileType = FileType.PNG;\n        }\n    }\n    if (((fileType == FileType.BMP) || (fileType == FileType.GIF)) || (fileType == FileType.PNG)) {\n        if (customFactory != null) {\n            return customFactory.createFromByteArray(document, byteArray);\n        }\n        ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);\n        BufferedImage bim = ImageIO.read(bais);\n        return LosslessFactory.createFromImage(document, bim);\n    }\n    throw new IllegalArgumentException(((\"Image type \" + fileType) + \" not supported: \") + name);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>" ],
    "fullMethods" : [ "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getBitsPerComponent",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getBitsPerComponent", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues" ],
    "fullMethods" : [ "@Override\npublic int getBitsPerComponent() {\n    if (isStencil()) {\n        return 1;\n    } else {\n        initJPXValues();\n        return getCOSObject().getInt(COSName.BITS_PER_COMPONENT, COSName.BPC);\n    }\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.setVersion",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.setVersion", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Sets the PDF specification version for this document.\n *\n * @param newVersion\n * \t\tthe new PDF version (e.g. 1.4f)\n */\npublic void setVersion(float newVersion) {\n    float currentVersion = getVersion();\n    // nothing to do?\n    if (Float.compare(newVersion, currentVersion) == 0) {\n        return;\n    }\n    // the version can't be downgraded\n    if (newVersion < currentVersion) {\n        LOG.error(\"It's not allowed to downgrade the version of a pdf.\");\n        return;\n    }\n    // update the catalog version if the document version is >= 1.4\n    if (getDocument().getVersion() >= 1.4F) {\n        getDocumentCatalog().setVersion(Float.toString(newVersion));\n    } else {\n        // versions < 1.4f have a version header only\n        getDocument().setVersion(newVersion);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PageExtractor.extract",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PageExtractor.extract", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will take a document and extract the desired pages into a new\n * document.  Both startPage and endPage are included in the extracted\n * document.  If the endPage is greater than the number of pages in the\n * source document, it will go to the end of the document.  If startPage is\n * less than 1, it'll start with page 1.  If startPage is greater than\n * endPage or greater than the number of pages in the source document, a\n * blank document will be returned.\n *\n * @return The extracted document\n * @throws IOException\n * \t\tIf there is an IOError\n */\npublic PDDocument extract() throws IOException {\n    if (((endPage - startPage) + 1) <= 0) {\n        return new PDDocument();\n    }\n    Splitter splitter = new Splitter();\n    splitter.setStartPage(Math.max(startPage, 1));\n    splitter.setEndPage(Math.min(endPage, sourceDocument.getNumberOfPages()));\n    splitter.setSplitAtPage((getEndPage() - getStartPage()) + 1);\n    List<PDDocument> splitted = splitter.split(sourceDocument);\n    return splitted.get(0);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.getBoundingBox",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.getBoundingBox", "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.generateBoundingBox" ],
    "fullMethods" : [ "@Override\npublic BoundingBox getBoundingBox() {\n    if (fontBBox == null) {\n        fontBBox = generateBoundingBox();\n    }\n    return fontBBox;\n}", "private BoundingBox generateBoundingBox() {\n    if (getFontDescriptor() != null) {\n        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();\n        if ((bbox != null) && ((((Float.compare(bbox.getLowerLeftX(), 0) != 0) || (Float.compare(bbox.getLowerLeftY(), 0) != 0)) || (Float.compare(bbox.getUpperRightX(), 0) != 0)) || (Float.compare(bbox.getUpperRightY(), 0) != 0))) {\n            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());\n        }\n    }\n    try {\n        return cidFont != null ? cidFont.getFontBBox() : t1Font.getFontBBox();\n    } catch (IOException e) {\n        LOG.debug(\"Couldn't get font bounding box - returning default value\", e);\n        return new BoundingBox();\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3Font.getBoundingBox",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3Font.getBoundingBox", "org.apache.pdfbox.pdmodel.font.PDType3Font.generateBoundingBox" ],
    "fullMethods" : [ "@Override\npublic BoundingBox getBoundingBox() {\n    if (fontBBox == null) {\n        fontBBox = generateBoundingBox();\n    }\n    return fontBBox;\n}", "private BoundingBox generateBoundingBox() {\n    PDRectangle rect = getFontBBox();\n    if (rect == null) {\n        LOG.warn(\"FontBBox missing, returning empty rectangle\");\n        return new BoundingBox();\n    }\n    if (!isNonZeroBoundingBox(rect)) {\n        // Plan B: get the max bounding box of the glyphs\n        COSDictionary cp = getCharProcs();\n        if (cp != null) {\n            for (COSName name : cp.keySet()) {\n                COSStream typ3CharProcStream = cp.getCOSStream(name);\n                if (typ3CharProcStream != null) {\n                    PDType3CharProc charProc = new PDType3CharProc(this, typ3CharProcStream);\n                    try {\n                        PDRectangle glyphBBox = charProc.getGlyphBBox();\n                        if (glyphBBox == null) {\n                            continue;\n                        }\n                        rect.setLowerLeftX(Math.min(rect.getLowerLeftX(), glyphBBox.getLowerLeftX()));\n                        rect.setLowerLeftY(Math.min(rect.getLowerLeftY(), glyphBBox.getLowerLeftY()));\n                        rect.setUpperRightX(Math.max(rect.getUpperRightX(), glyphBBox.getUpperRightX()));\n                        rect.setUpperRightY(Math.max(rect.getUpperRightY(), glyphBBox.getUpperRightY()));\n                    } catch (IOException ex) {\n                        // ignore\n                        LOG.debug(\"error getting the glyph bounding box - font bounding box will be used\", ex);\n                    }\n                }\n            }\n        }\n    }\n    return new BoundingBox(rect.getLowerLeftX(), rect.getLowerLeftY(), rect.getUpperRightX(), rect.getUpperRightY());\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<init>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.loadDiskCache" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "/**\n * Constructor.\n */\nFileSystemFontProvider(FontCache cache) {\n    this.cache = cache;\n    try {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Will search the local system for fonts\");\n        }\n        // scan the local system for font files\n        FontFileFinder fontFileFinder = new FontFileFinder();\n        List<URI> fonts = fontFileFinder.find();\n        List<File> files = new ArrayList<>(fonts.size());\n        for (URI font : fonts) {\n            files.add(new File(font));\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace((\"Found \" + files.size()) + \" fonts on the local system\");\n        }\n        if (!files.isEmpty()) {\n            // load cached FontInfo objects\n            List<FSFontInfo> cachedInfos = loadDiskCache(files);\n            if ((cachedInfos != null) && (!cachedInfos.isEmpty())) {\n                fontInfoList.addAll(cachedInfos);\n            } else {\n                LOG.info(\"Building on-disk font cache, this may take a while\");\n                scanFonts(files);\n                saveDiskCache();\n                LOG.info((\"Finished building on-disk font cache, found \" + fontInfoList.size()) + \" fonts\");\n            }\n        }\n    } catch (AccessControlException e) {\n        LOG.error(\"Error accessing the file system\", e);\n    }\n}", "/**\n * Loads the font metadata cache from disk.\n */\nprivate List<FSFontInfo> loadDiskCache(List<File> files) {\n    Set<String> pending = new HashSet<>(files.size());\n    for (File file : files) {\n        pending.add(file.getAbsolutePath());\n    }\n    List<FSFontInfo> results = new ArrayList<>();\n    // Get the disk cache\n    File diskCacheFile = null;\n    boolean fileExists = false;\n    try {\n        diskCacheFile = getDiskCacheFile();\n        fileExists = diskCacheFile.exists();\n    } catch (SecurityException e) {\n        LOG.debug(\"Error checking for file existence\", e);\n    }\n    if (fileExists) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(diskCacheFile), StandardCharsets.UTF_8))) {\n            // consequent lines usually share the same font file (e.g. \"Courier\", \"Courier-Bold\", \"Courier-Oblique\").\n            // unused if SKIP_CHECKSUMS\n            File lastFile = null;\n            String lastHash = null;\n            // \n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\"\\\\|\", 12);\n                if (parts.length < 10) {\n                    LOG.warn((\"Incorrect line '\" + line) + \"' in font disk cache is skipped\");\n                    continue;\n                }\n                String postScriptName;\n                FontFormat format;\n                CIDSystemInfo cidSystemInfo = null;\n                int usWeightClass = -1;\n                int sFamilyClass = -1;\n                int ulCodePageRange1;\n                int ulCodePageRange2;\n                int macStyle = -1;\n                byte[] panose = null;\n                File fontFile;\n                String hash = \"\";\n                long lastModified = 0;\n                postScriptName = parts[0];\n                format = FontFormat.valueOf(parts[1]);\n                if (parts[2].length() > 0) {\n                    String[] ros = parts[2].split(\"-\");\n                    cidSystemInfo = new CIDSystemInfo(ros[0], ros[1], Integer.parseInt(ros[2]));\n                }\n                if (parts[3].length() > 0) {\n                    usWeightClass = ((int) (Long.parseLong(parts[3], 16)));\n                }\n                if (parts[4].length() > 0) {\n                    sFamilyClass = ((int) (Long.parseLong(parts[4], 16)));\n                }\n                ulCodePageRange1 = ((int) (Long.parseLong(parts[5], 16)));\n                ulCodePageRange2 = ((int) (Long.parseLong(parts[6], 16)));\n                if (parts[7].length() > 0) {\n                    macStyle = ((int) (Long.parseLong(parts[7], 16)));\n                }\n                if (parts[8].length() > 0) {\n                    panose = new byte[10];\n                    for (int i = 0; i < 10; i++) {\n                        String str = parts[8].substring(i * 2, (i * 2) + 2);\n                        int b = Integer.parseInt(str, 16);\n                        panose[i] = ((byte) (b & 0xff));\n                    }\n                }\n                fontFile = new File(parts[9]);\n                if (((parts.length >= 12) && (!parts[10].isEmpty())) && (!parts[11].isEmpty())) {\n                    hash = parts[10];\n                    lastModified = Long.parseLong(parts[11]);\n                }\n                if (fontFile.exists()) {\n                    // if the file exists, find out whether it's the same file.\n                    // first check whether time is different and if yes, whether hash is different\n                    boolean keep = fontFile.lastModified() == lastModified;\n                    if ((!keep) && (!SKIP_CHECKSUMS)) {\n                        String newHash;\n                        if (hash.equals(lastHash) && fontFile.equals(lastFile)) {\n                            newHash = lastHash;// already computed\n\n                        } else {\n                            try {\n                                newHash = computeHash(Files.newInputStream(fontFile.toPath()));\n                                lastFile = fontFile;\n                                lastHash = newHash;\n                            } catch (IOException ex) {\n                                LOG.debug(\"Error reading font file \" + fontFile.getAbsolutePath(), ex);\n                                newHash = \"<err>\";\n                            }\n                        }\n                        if (hash.equals(newHash)) {\n                            keep = true;\n                            lastModified = fontFile.lastModified();\n                        }\n                    }\n                    if (keep) {\n                        FSFontInfo info = new FSFontInfo(fontFile, format, postScriptName, cidSystemInfo, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this, hash, lastModified);\n                        results.add(info);\n                    } else {\n                        LOG.debug((\"Font file \" + fontFile.getAbsolutePath()) + \" is different\");\n                        continue;// don't remove from \"pending\"\n\n                    }\n                } else {\n                    LOG.debug((\"Font file \" + fontFile.getAbsolutePath()) + \" not found, skipped\");\n                }\n                pending.remove(fontFile.getAbsolutePath());\n            } \n        } catch (IOException e) {\n            LOG.warn(\"Error loading font cache, will be re-built\", e);\n            return null;\n        }\n    }\n    if (!pending.isEmpty()) {\n        // re-build the entire cache if we encounter un-cached fonts (could be optimised)\n        LOG.info(pending.size() + \" new font files found, font cache will be re-built\");\n        return null;\n    }\n    return results;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText", "org.apache.pdfbox.contentstream.PDFStreamEngine.getDefaultFont", "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>" ],
    "fullMethods" : [ "/**\n * Called when a string of text is to be shown.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextString(byte[] string) throws IOException {\n    showText(string);\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}", "/**\n * Provide standard 14 Helvetica font as default if there isn't any font available.\n *\n * @return the default font\n */\nprivate PDFont getDefaultFont() {\n    if (defaultFont == null) {\n        defaultFont = new PDType1Font(FontName.HELVETICA);\n    }\n    return defaultFont;\n}", "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.DCTFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.DCTFilter.decode" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException {\n    ImageReader reader = findRasterReader(\"JPEG\", \"a suitable JAI I/O image filter is not installed\");\n    try (ImageInputStream iis = ImageIO.createImageInputStream(encoded)) {\n        // skip one LF if there\n        if (iis.read() != 0xa) {\n            iis.seek(0);\n        }\n        reader.setInput(iis);\n        ImageReadParam irp = reader.getDefaultReadParam();\n        irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());\n        irp.setSourceRegion(options.getSourceRegion());\n        options.setFilterSubsampled(true);\n        Raster raster = readImageRaster(reader, irp);\n        // special handling for 4-component images\n        if (raster.getNumBands() == 4) {\n            // get APP14 marker\n            Integer transform;\n            try {\n                transform = getAdobeTransform(reader.getImageMetadata(0));\n            } catch (IIOException | NegativeArraySizeException e) {\n                // we really tried asking nicely, now we're using brute force.\n                LOG.debug(\"Couldn't read usÃ­ng getAdobeTransform() - using getAdobeTransformByBruteForce() as fallback\", e);\n                transform = getAdobeTransformByBruteForce(iis);\n            }\n            int colorTransform = (transform != null) ? transform : 0;\n            // 0 = Unknown (RGB or CMYK), 1 = YCbCr, 2 = YCCK\n            // https://exiftool.org/TagNames/JPEG.html#Adobe\n            switch (colorTransform) {\n                case 0 :\n                    // already CMYK\n                    break;\n                case 1 :\n                    LOG.warn(\"There is no 4 channel YCbCr, using YCCK\");\n                    // fallthrough\n                case 2 :\n                    raster = fromYCCKtoCMYK(raster);\n                    break;\n                default :\n                    throw new IllegalArgumentException(\"Unknown colorTransform\");\n            }\n        } else if (raster.getNumBands() == 3) {\n            // BGR to RGB\n            raster = fromBGRtoRGB(raster);\n        }\n        DataBufferByte dataBuffer = ((DataBufferByte) (raster.getDataBuffer()));\n        decoded.write(dataBuffer.getData());\n    } catch (CMMException ex) {\n        // PDFBOX-5732\n        throw new IOException(ex);\n    } finally {\n        reader.dispose();\n    }\n    return new DecodeResult(parameters);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.save",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.save", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Save the document using the given compression.\n * <p>\n * Don't use the input file as target as this will produce a corrupted file.\n * <p>\n * If encryption has been activated (with {@link #protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy)\n * protect(ProtectionPolicy)}), do not use the document after saving because the contents are now encrypted.\n * The same applies if your file was created from parts of another file and that\n * one is to be used after saving.\n *\n * @param file\n * \t\tThe file to save as.\n * @param compressParameters\n * \t\tThe parameters for the document's compression.\n * @throws IOException\n * \t\tif the output could not be written\n */\npublic void save(File file, CompressParameters compressParameters) throws IOException {\n    if (file.exists() && (file.length() > 0)) {\n        LOG.warn((\"You are overwriting the existing file \" + file.getName()) + \", this will produce a corrupted file if you're also reading from it\");\n    }\n    try (BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(file))) {\n        save(bufferedOutputStream, compressParameters);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createTemplate",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigBuilder.createTemplate", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Creates a PDDocument and adds the page parameter to it and keeps this as a template in the PDF template\n * Structure.\n *\n * @param page\n * \t\tthe page to be added\n * @throws IOException\n * \t\tif the document could not be created\n */\n@Override\npublic void createTemplate(PDPage page) throws IOException {\n    PDDocument template = new PDDocument();\n    template.addPage(page);\n    pdfStructure.setTemplate(template);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.parseCOSName", "org.apache.pdfbox.pdfparser.BaseParser.decodeBuffer" ],
    "fullMethods" : [ "/**\n * Search for/parse the object with the given object number. The stream is closed after parsing the object with the\n * given number.\n *\n * @param objectNumber\n * \t\tthe number of the object to b e parsed\n * @return the parsed object or null if the object with the given number can't be found\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic COSBase parseObject(long objectNumber) throws IOException {\n    COSBase streamObject = null;\n    try {\n        Integer objectOffset = privateReadObjectNumbers().get(objectNumber);\n        if (objectOffset != null) {\n            // jump to the offset of the first object\n            long currentPosition = source.getPosition();\n            if ((firstObject > 0) && (currentPosition < firstObject)) {\n                source.skip(firstObject - ((int) (currentPosition)));\n            }\n            // jump to the offset of the object to be parsed\n            source.skip(objectOffset);\n            streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return streamObject;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "/**\n * This will parse a PDF name from the stream.\n *\n * @return The parsed PDF name.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected COSName parseCOSName() throws IOException {\n    readExpectedChar('/');\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int c = source.read();\n    while (!isEndOfName(c)) {\n        final int ch = c;\n        if (ch == '#') {\n            int ch1 = source.read();\n            int ch2 = source.read();\n            // Prior to PDF v1.2, the # was not a special character.  Also,\n            // it has been observed that various PDF tools do not follow the\n            // spec with respect to the # escape, even though they report\n            // PDF versions of 1.2 or later.  The solution here is that we\n            // interpret the # as an escape only when it is followed by two\n            // valid hex digits.\n            if (isHexDigit(((char) (ch1))) && isHexDigit(((char) (ch2)))) {\n                String hex = Character.toString(((char) (ch1))) + ((char) (ch2));\n                try {\n                    buffer.write(Integer.parseInt(hex, 16));\n                } catch (NumberFormatException e) {\n                    throw new IOException((\"Error: expected hex digit, actual='\" + hex) + \"'\", e);\n                }\n                c = source.read();\n            } else {\n                // check for premature EOF\n                if ((ch2 == (-1)) || (ch1 == (-1))) {\n                    LOG.error(\"Premature EOF in BaseParser#parseCOSName\");\n                    c = -1;\n                    break;\n                }\n                source.rewind(1);\n                c = ch1;\n                buffer.write(ch);\n            }\n        } else {\n            buffer.write(ch);\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n    return COSName.getPDFName(decodeBuffer(buffer));\n}", "/**\n * Tries to decode the buffer cotent to an UTF-8 String.\n * If that fails, tries the alternative Encoding.\n *\n * @param buffer\n * \t\tthe {@link ByteArrayOutputStream} containing the bytes to decode\n * @return the decoded String\n */\nprivate String decodeBuffer(ByteArrayOutputStream buffer) throws UnsupportedEncodingException {\n    try {\n        return utf8Decoder.decode(ByteBuffer.wrap(buffer.toByteArray())).toString();\n    } catch (CharacterCodingException e) {\n        // some malformed PDFs don't use UTF-8 see PDFBOX-3347\n        LOG.debug((\"Buffer could not be decoded using StandardCharsets.UTF_8 - \" + \"trying \") + ALTERNATIVE_CHARSET.name(), e);\n        return buffer.toString(ALTERNATIVE_CHARSET.name());\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.readPatch" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    return getBounds(xform, matrix, 16);\n}", "Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    Rectangle2D bounds = null;\n    for (Patch patch : collectPatches(xform, matrix, controlPoints)) {\n        for (ShadedTriangle shadedTriangle : patch.listOfTriangles) {\n            if (bounds == null) {\n                bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n            }\n            bounds.add(shadedTriangle.corner[0]);\n            bounds.add(shadedTriangle.corner[1]);\n            bounds.add(shadedTriangle.corner[2]);\n        }\n    }\n    return bounds;\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}", "/**\n * Read a single patch from a data stream, a patch contains information of its coordinates and color parameters.\n *\n * @param input\n * \t\tthe image source data stream\n * @param isFree\n * \t\twhether this is a free patch\n * @param implicitEdge\n * \t\timplicit edge when a patch is not free, otherwise it's not used\n * @param implicitCornerColor\n * \t\timplicit colors when a patch is not free, otherwise it's not used\n * @param maxSrcCoord\n * \t\tthe maximum coordinate value calculated from source data\n * @param maxSrcColor\n * \t\tthe maximum color value calculated from source data\n * @param rangeX\n * \t\trange for coordinate x\n * @param rangeY\n * \t\trange for coordinate y\n * @param colRange\n * \t\trange for color\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param xform\n * \t\ttransformation for user to device space\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return a single patch\n * @throws IOException\n * \t\twhen something went wrong\n */\nprotected Patch readPatch(ImageInputStream input, boolean isFree, Point2D[] implicitEdge, float[][] implicitCornerColor, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRange, Matrix matrix, AffineTransform xform, int controlPoints) throws IOException {\n    int numberOfColorComponents = getNumberOfColorComponents();\n    float[][] color = new float[4][numberOfColorComponents];\n    Point2D[] points = new Point2D[controlPoints];\n    int pStart = 4;\n    int cStart = 2;\n    if (isFree) {\n        pStart = 0;\n        cStart = 0;\n    } else {\n        points[0] = implicitEdge[0];\n        points[1] = implicitEdge[1];\n        points[2] = implicitEdge[2];\n        points[3] = implicitEdge[3];\n        for (int i = 0; i < numberOfColorComponents; i++) {\n            color[0][i] = implicitCornerColor[0][i];\n            color[1][i] = implicitCornerColor[1][i];\n        }\n    }\n    try {\n        int bitsPerCoordinate = getBitsPerCoordinate();\n        for (int i = pStart; i < controlPoints; i++) {\n            long x = input.readBits(bitsPerCoordinate);\n            long y = input.readBits(bitsPerCoordinate);\n            float px = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());\n            float py = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());\n            Point2D p = matrix.transformPoint(px, py);\n            xform.transform(p, p);\n            points[i] = p;\n        }\n        int bitsPerComponent = getBitsPerComponent();\n        for (int i = cStart; i < 4; i++) {\n            for (int j = 0; j < numberOfColorComponents; j++) {\n                long c = input.readBits(bitsPerComponent);\n                color[i][j] = interpolate(c, maxSrcColor, colRange[j].getMin(), colRange[j].getMax());\n            }\n        }\n    } catch (EOFException ex) {\n        LOG.debug(\"EOF\", ex);\n        return null;\n    }\n    return generatePatch(points, color);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeHash2A", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeHash2B", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Check if a plaintext password is the user password.\n *\n * @param password\n * \t\tThe plaintext password.\n * @param user\n * \t\tThe u entry of the encryption dictionary.\n * @param owner\n * \t\tThe o entry of the encryption dictionary.\n * @param permissions\n * \t\tThe permissions set in the PDF.\n * @param id\n * \t\tThe document id used for encryption.\n * @param encRevision\n * \t\tThe revision of the encryption algorithm.\n * @param keyLengthInBytes\n * \t\tThe length of the encryption key in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata.\n * @return true If the plaintext password is the user password.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\npublic boolean isUserPassword(byte[] password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException {\n    switch (encRevision) {\n        case REVISION_2 :\n        case REVISION_3 :\n        case REVISION_4 :\n            return isUserPassword234(password, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);\n        case REVISION_5 :\n        case REVISION_6 :\n            return isUserPassword56(password, user, encRevision);\n        default :\n            throw new IOException(\"Unknown Encryption Revision \" + encRevision);\n    }\n}", "private boolean isUserPassword56(byte[] password, byte[] user, int encRevision) throws IOException {\n    byte[] truncatedPassword = truncate127(password);\n    byte[] uHash = new byte[32];\n    byte[] uValidationSalt = new byte[8];\n    System.arraycopy(user, 0, uHash, 0, 32);\n    System.arraycopy(user, 32, uValidationSalt, 0, 8);\n    byte[] hash;\n    if (encRevision == REVISION_5) {\n        hash = computeSHA256(truncatedPassword, uValidationSalt, null);\n    } else {\n        hash = computeHash2A(truncatedPassword, uValidationSalt, null);\n    }\n    return MessageDigest.isEqual(hash, uHash);\n}", "// Algorithm 2.A from ISO 32000-1\nprivate byte[] computeHash2A(byte[] password, byte[] salt, byte[] u) throws IOException {\n    byte[] userKey = adjustUserKey(u);\n    byte[] truncatedPassword = truncate127(password);\n    byte[] input = concat(truncatedPassword, salt, userKey);\n    return computeHash2B(input, truncatedPassword, userKey);\n}", "// Algorithm 2.B from ISO 32000-2\nprivate static byte[] computeHash2B(byte[] input, byte[] password, byte[] userKey) throws IOException {\n    try {\n        MessageDigest md = MessageDigests.getSHA256();\n        byte[] k = md.digest(input);\n        byte[] e = null;\n        for (int round = 0; (round < 64) || ((e[e.length - 1] & 0xff) > (round - 32)); round++) {\n            byte[] k1;\n            if ((userKey != null) && (userKey.length >= 48)) {\n                k1 = new byte[64 * ((password.length + k.length) + 48)];\n            } else {\n                k1 = new byte[64 * (password.length + k.length)];\n            }\n            int pos = 0;\n            for (int i = 0; i < 64; i++) {\n                System.arraycopy(password, 0, k1, pos, password.length);\n                pos += password.length;\n                System.arraycopy(k, 0, k1, pos, k.length);\n                pos += k.length;\n                if ((userKey != null) && (userKey.length >= 48)) {\n                    System.arraycopy(userKey, 0, k1, pos, 48);\n                    pos += 48;\n                }\n            }\n            byte[] kFirst = new byte[16];\n            byte[] kSecond = new byte[16];\n            System.arraycopy(k, 0, kFirst, 0, 16);\n            System.arraycopy(k, 16, kSecond, 0, 16);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            SecretKeySpec keySpec = new SecretKeySpec(kFirst, \"AES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(kSecond);\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n            e = cipher.doFinal(k1);\n            byte[] eFirst = new byte[16];\n            System.arraycopy(e, 0, eFirst, 0, 16);\n            BigInteger bi = new BigInteger(1, eFirst);\n            BigInteger remainder = bi.mod(new BigInteger(\"3\"));\n            String nextHash = HASHES_2B[remainder.intValue()];\n            md = MessageDigest.getInstance(nextHash);\n            k = md.digest(e);\n        }\n        if (k.length > 32) {\n            byte[] kTrunc = new byte[32];\n            System.arraycopy(k, 0, kTrunc, 0, 32);\n            return kTrunc;\n        } else {\n            return k;\n        }\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNProcess.toString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDDeviceNProcess.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder(\"Process{\");\n    try {\n        sb.append(getColorSpace());\n        for (String component : getComponents()) {\n            sb.append(\" \\\"\");\n            sb.append(component);\n            sb.append('\\\"');\n        }\n    } catch (IOException e) {\n        LOG.debug(\"Couldn't get the colorants information - returning 'ERROR' instead'\", e);\n        sb.append(\"ERROR\");\n    }\n    sb.append('}');\n    return sb.toString();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject", "org.apache.pdfbox.pdfparser.BaseParser.parseCOSName", "org.apache.pdfbox.pdfparser.BaseParser.decodeBuffer" ],
    "fullMethods" : [ "/**\n * Parse all compressed objects. The stream is closed after parsing.\n *\n * @return a map containing all parsed objects using the object number as key\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic Map<COSObjectKey, COSBase> parseAllObjects() throws IOException {\n    Map<COSObjectKey, COSBase> allObjects = new HashMap<>();\n    try {\n        Map<Integer, Long> objectNumbers = privateReadObjectOffsets();\n        // count the number of object numbers eliminating double entries\n        long numberOfObjNumbers = objectNumbers.values().stream().distinct().count();\n        // the usage of the index should be restricted to cases where more than one\n        // object use the same object number.\n        // there are malformed pdfs in the wild which would lead to false results if\n        // pdfbox always relies on the index if available. In most cases the object number\n        // is sufficient to choose the correct object\n        boolean indexNeeded = objectNumbers.size() > numberOfObjNumbers;\n        long currentPosition = source.getPosition();\n        if ((firstObject > 0) && (currentPosition < firstObject)) {\n            source.skip(firstObject - ((int) (currentPosition)));\n        }\n        int index = 0;\n        for (Entry<Integer, Long> entry : objectNumbers.entrySet()) {\n            COSObjectKey objectKey = getObjectKey(entry.getValue(), 0);\n            // skip object if the index doesn't match\n            if ((indexNeeded && (objectKey.getStreamIndex() > (-1))) && (objectKey.getStreamIndex() != index)) {\n                index++;\n                continue;\n            }\n            int finalPosition = firstObject + entry.getKey();\n            currentPosition = source.getPosition();\n            if ((finalPosition > 0) && (currentPosition < finalPosition)) {\n                // jump to the offset of the object to be parsed\n                source.skip(finalPosition - ((int) (currentPosition)));\n            }\n            COSBase streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n            allObjects.put(objectKey, streamObject);\n            index++;\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return allObjects;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}", "/**\n * This will parse a PDF name from the stream.\n *\n * @return The parsed PDF name.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected COSName parseCOSName() throws IOException {\n    readExpectedChar('/');\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int c = source.read();\n    while (!isEndOfName(c)) {\n        final int ch = c;\n        if (ch == '#') {\n            int ch1 = source.read();\n            int ch2 = source.read();\n            // Prior to PDF v1.2, the # was not a special character.  Also,\n            // it has been observed that various PDF tools do not follow the\n            // spec with respect to the # escape, even though they report\n            // PDF versions of 1.2 or later.  The solution here is that we\n            // interpret the # as an escape only when it is followed by two\n            // valid hex digits.\n            if (isHexDigit(((char) (ch1))) && isHexDigit(((char) (ch2)))) {\n                String hex = Character.toString(((char) (ch1))) + ((char) (ch2));\n                try {\n                    buffer.write(Integer.parseInt(hex, 16));\n                } catch (NumberFormatException e) {\n                    throw new IOException((\"Error: expected hex digit, actual='\" + hex) + \"'\", e);\n                }\n                c = source.read();\n            } else {\n                // check for premature EOF\n                if ((ch2 == (-1)) || (ch1 == (-1))) {\n                    LOG.error(\"Premature EOF in BaseParser#parseCOSName\");\n                    c = -1;\n                    break;\n                }\n                source.rewind(1);\n                c = ch1;\n                buffer.write(ch);\n            }\n        } else {\n            buffer.write(ch);\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n    return COSName.getPDFName(decodeBuffer(buffer));\n}", "/**\n * Tries to decode the buffer cotent to an UTF-8 String.\n * If that fails, tries the alternative Encoding.\n *\n * @param buffer\n * \t\tthe {@link ByteArrayOutputStream} containing the bytes to decode\n * @return the decoded String\n */\nprivate String decodeBuffer(ByteArrayOutputStream buffer) throws UnsupportedEncodingException {\n    try {\n        return utf8Decoder.decode(ByteBuffer.wrap(buffer.toByteArray())).toString();\n    } catch (CharacterCodingException e) {\n        // some malformed PDFs don't use UTF-8 see PDFBOX-3347\n        LOG.debug((\"Buffer could not be decoded using StandardCharsets.UTF_8 - \" + \"trying \") + ALTERNATIVE_CHARSET.name(), e);\n        return buffer.toString(ALTERNATIVE_CHARSET.name());\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptStream", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptData", "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.encryptDataAES256" ],
    "fullMethods" : [ "/**\n * This will encrypt a stream, but not the dictionary as the dictionary is\n * encrypted by visitFromString() in COSWriter and we don't want to encrypt\n * it twice.\n *\n * @param stream\n * \t\tThe stream to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void encryptStream(COSStream stream, long objNum, int genNum) throws IOException {\n    // empty streams don't need to be encrypted\n    if (!stream.hasData()) {\n        return;\n    }\n    byte[] rawData;\n    try (InputStream is = stream.createRawInputStream()) {\n        rawData = IOUtils.toByteArray(is);\n    }\n    ByteArrayInputStream encryptedStream = new ByteArrayInputStream(rawData);\n    try (OutputStream output = stream.createRawOutputStream()) {\n        /* encrypt */\n        encryptData(objNum, genNum, encryptedStream, output, false);\n    }\n}", "/**\n * Encrypt or decrypt a set of data.\n *\n * @param objectNumber\n * \t\tThe data object number.\n * @param genNumber\n * \t\tThe data generation number.\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptData(long objectNumber, long genNumber, InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    // Determine whether we're using Algorithm 1 (for RC4 and AES-128), or 1.A (for AES-256)\n    if (useAES && (encryptionKey.length == 32)) {\n        encryptDataAES256(data, output, decrypt);\n    } else {\n        byte[] finalKey = calcFinalKey(objectNumber, genNumber);\n        if (useAES) {\n            encryptDataAESother(finalKey, data, output, decrypt);\n        } else {\n            encryptDataRC4(finalKey, data, output);\n        }\n    }\n    output.flush();\n}", "/**\n * Encrypt or decrypt data with AES256.\n *\n * @param data\n * \t\tThe data to encrypt.\n * @param output\n * \t\tThe output to write the encrypted data to.\n * @param decrypt\n * \t\ttrue to decrypt the data, false to encrypt it.\n * @throws IOException\n * \t\tIf there is an error reading the data.\n */\nprivate void encryptDataAES256(InputStream data, OutputStream output, boolean decrypt) throws IOException {\n    byte[] iv = new byte[16];\n    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {\n        return;\n    }\n    Cipher cipher;\n    try {\n        cipher = createCipher(this.encryptionKey, iv, decrypt);\n    } catch (GeneralSecurityException e) {\n        throw new IOException(e);\n    }\n    try (CipherInputStream cis = new CipherInputStream(data, cipher)) {\n        IOUtils.copy(cis, output);\n    } catch (IOException exception) {\n        // starting with java 8 the JVM wraps an IOException around a GeneralSecurityException\n        // it should be safe to swallow a GeneralSecurityException\n        if (!(exception.getCause() instanceof GeneralSecurityException)) {\n            throw exception;\n        }\n        LOG.debug(\"A GeneralSecurityException occurred when decrypting some stream data\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKey",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKey", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKeyRev56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Compute the encryption key.\n *\n * @param password\n * \t\tThe password to compute the encrypted key.\n * @param o\n * \t\tThe O entry of the encryption dictionary.\n * @param u\n * \t\tThe U entry of the encryption dictionary.\n * @param oe\n * \t\tThe OE entry of the encryption dictionary.\n * @param ue\n * \t\tThe UE entry of the encryption dictionary.\n * @param permissions\n * \t\tThe permissions for the document.\n * @param id\n * \t\tThe document id.\n * @param encRevision\n * \t\tThe revision of the encryption algorithm.\n * @param keyLengthInBytes\n * \t\tThe length of the encryption key in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata\n * @param isOwnerPassword\n * \t\twhether the password given is the owner password (for revision 6)\n * @return The encrypted key bytes.\n * @throws IOException\n * \t\tIf there is an error with encryption.\n */\npublic byte[] computeEncryptedKey(byte[] password, byte[] o, byte[] u, byte[] oe, byte[] ue, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata, boolean isOwnerPassword) throws IOException {\n    if ((encRevision == REVISION_5) || (encRevision == REVISION_6)) {\n        return computeEncryptedKeyRev56(password, isOwnerPassword, o, u, oe, ue, encRevision);\n    } else {\n        return computeEncryptedKeyRev234(password, o, permissions, id, encryptMetadata, keyLengthInBytes, encRevision);\n    }\n}", "private byte[] computeEncryptedKeyRev56(byte[] password, boolean isOwnerPassword, byte[] o, byte[] u, byte[] oe, byte[] ue, int encRevision) throws IOException {\n    byte[] hash;\n    byte[] fileKeyEnc;\n    if (isOwnerPassword) {\n        if (oe == null) {\n            throw new IOException(\"/Encrypt/OE entry is missing\");\n        }\n        byte[] oKeySalt = new byte[8];\n        System.arraycopy(o, 40, oKeySalt, 0, 8);\n        if (encRevision == REVISION_5) {\n            hash = computeSHA256(password, oKeySalt, u);\n        } else {\n            hash = computeHash2A(password, oKeySalt, u);\n        }\n        fileKeyEnc = oe;\n    } else {\n        if (ue == null) {\n            throw new IOException(\"/Encrypt/UE entry is missing\");\n        }\n        byte[] uKeySalt = new byte[8];\n        System.arraycopy(u, 40, uKeySalt, 0, 8);\n        if (encRevision == REVISION_5) {\n            hash = computeSHA256(password, uKeySalt, null);\n        } else {\n            hash = computeHash2A(password, uKeySalt, null);\n        }\n        fileKeyEnc = ue;\n    }\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(hash, \"AES\"), new IvParameterSpec(new byte[16]));\n        return cipher.doFinal(fileKeyEnc);\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.addSignature",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.addSignature", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * This will add a signature to the document. If the 0-based page number in the options\n * parameter is smaller than 0 or larger than max, the nearest valid page number will be used\n * (i.e. 0 or max) and no exception will be thrown.\n * <p>\n * Only one signature may be added in a document. To sign several times,\n * load document, add signature, save incremental and close again.\n *\n * @param sigObject\n * \t\tis the PDSignatureField model\n * @param signatureInterface\n * \t\tis an interface whose implementation provides\n * \t\tsigning capabilities. Can be null if external signing if used.\n * @param options\n * \t\tsignature options\n * @throws IOException\n * \t\tif there is an error creating required fields\n * @throws IllegalStateException\n * \t\tif one attempts to add several signature\n * \t\tfields.\n */\npublic void addSignature(PDSignature sigObject, SignatureInterface signatureInterface, SignatureOptions options) throws IOException {\n    if (signatureAdded) {\n        throw new IllegalStateException(\"Only one signature may be added in a document\");\n    }\n    signatureAdded = true;\n    // Reserve content\n    // We need to reserve some space for the signature. Some signatures including\n    // big certificate chain and we need enough space to store it.\n    int preferredSignatureSize = options.getPreferredSignatureSize();\n    if (preferredSignatureSize > 0) {\n        sigObject.setContents(new byte[preferredSignatureSize]);\n    } else {\n        sigObject.setContents(new byte[SignatureOptions.DEFAULT_SIGNATURE_SIZE]);\n    }\n    // Reserve ByteRange, will be overwritten in COSWriter\n    sigObject.setByteRange(RESERVE_BYTE_RANGE);\n    signInterface = signatureInterface;\n    // Create SignatureForm for signature and append it to the document\n    // Get the first valid page\n    PDPageTree pageTree = getPages();\n    int pageCount = pageTree.getCount();\n    if (pageCount == 0) {\n        throw new IllegalStateException(\"Cannot sign an empty document\");\n    }\n    // Get the AcroForm from the Root-Dictionary and append the annotation\n    PDDocumentCatalog catalog = getDocumentCatalog();\n    PDAcroForm acroForm = catalog.getAcroForm(null);\n    catalog.getCOSObject().setNeedToBeUpdated(true);\n    if (acroForm == null) {\n        acroForm = new PDAcroForm(this);\n        catalog.setAcroForm(acroForm);\n    } else {\n        acroForm.getCOSObject().setNeedToBeUpdated(true);\n    }\n    PDSignatureField signatureField = null;\n    COSArray fieldArray = acroForm.getCOSObject().getCOSArray(COSName.FIELDS);\n    if (fieldArray != null) {\n        fieldArray.setNeedToBeUpdated(true);\n        signatureField = findSignatureField(acroForm.getFieldIterator(), sigObject);\n    } else {\n        acroForm.getCOSObject().setItem(COSName.FIELDS, new COSArray());\n    }\n    PDAnnotationWidget firstWidget;\n    PDPage page;\n    if (signatureField == null) {\n        signatureField = new PDSignatureField(acroForm);\n        // append the signature object\n        signatureField.setValue(sigObject);\n        firstWidget = signatureField.getWidgets().get(0);\n        int startIndex = Math.min(Math.max(options.getPage(), 0), pageCount - 1);\n        page = pageTree.get(startIndex);\n        // backward linking\n        firstWidget.setPage(page);\n    } else {\n        firstWidget = signatureField.getWidgets().get(0);\n        sigObject.getCOSObject().setNeedToBeUpdated(true);\n        page = null;\n    }\n    // TODO This \"overwrites\" the settings of the original signature field which might not be intended by the user\n    // better make it configurable (not all users need/want PDF/A but their own setting):\n    // to conform PDF/A-1 requirement:\n    // The /F key's Print flag bit shall be set to 1 and\n    // its Hidden, Invisible and NoView flag bits shall be set to 0\n    firstWidget.setPrinted(true);\n    // This may be troublesome if several form fields are signed,\n    // see thread from PDFBox users mailing list 17.2.2021 - 19.2.2021\n    // https://mail-archives.apache.org/mod_mbox/pdfbox-users/202102.mbox/thread\n    // better set the printed flag in advance\n    // Set the AcroForm Fields\n    List<PDField> acroFormFields = acroForm.getFields();\n    acroForm.getCOSObject().setDirect(true);\n    acroForm.setSignaturesExist(true);\n    acroForm.setAppendOnly(true);\n    boolean checkFields = checkSignatureField(acroForm.getFieldIterator(), signatureField);\n    if (checkFields) {\n        signatureField.getCOSObject().setNeedToBeUpdated(true);\n    } else {\n        acroFormFields.add(signatureField);\n    }\n    // Get the object from the visual signature\n    COSDocument visualSignature = options.getVisualSignature();\n    // Distinction of case for visual and non-visual signature\n    if (visualSignature == null) {\n        prepareNonVisibleSignature(firstWidget);\n    } else {\n        prepareVisibleSignature(firstWidget, acroForm, visualSignature);\n    }\n    if (page != null) {\n        // Create Annotation / Field for signature\n        List<PDAnnotation> annotations = page.getAnnotations();\n        // Get the annotations of the page and append the signature-annotation to it\n        // take care that page and acroforms do not share the same array (if so, we don't need to add it twice)\n        if (!(((checkFields && (annotations instanceof COSArrayList)) && (acroFormFields instanceof COSArrayList)) && ((COSArrayList) (annotations)).toList().equals(((COSArrayList) (acroFormFields)).toList()))) {\n            // use check to prevent the annotation widget from appearing twice\n            if (checkSignatureAnnotation(annotations, firstWidget)) {\n                firstWidget.getCOSObject().setNeedToBeUpdated(true);\n            } else {\n                annotations.add(firstWidget);\n            }\n        }\n        // Make /Annots a direct object by reassigning it,\n        // to avoid problem if it is an existing indirect object:\n        // it would not be updated in incremental save, and if we'd set the /Annots array \"to be updated\"\n        // while keeping it indirect, Adobe Reader would claim that the document had been modified.\n        page.setAnnotations(annotations);\n        page.getCOSObject().setNeedToBeUpdated(true);\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup", "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroupOnGraphics", "org.apache.pdfbox.rendering.PageDrawer.applySoftMaskToPaint", "org.apache.pdfbox.rendering.SoftMask.<init>" ],
    "fullMethods" : [ "@Override\npublic void showTransparencyGroup(PDTransparencyGroup form) throws IOException {\n    showTransparencyGroupOnGraphics(form, graphics);\n}", "/**\n * For advanced users, to extract the transparency group into a separate graphics device.\n *\n * @param form\n * \t\tthe transparency group to be extracted\n * @param graphics\n * \t\tthe target graphics device\n * @throws IOException\n * \t\tif the transparency group could not be extracted\n */\nprotected void showTransparencyGroupOnGraphics(PDTransparencyGroup form, Graphics2D graphics) throws IOException {\n    if (isHiddenOCG(form.getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    TransparencyGroup group = new TransparencyGroup(form, false, getGraphicsState().getCurrentTransformationMatrix(), null);\n    BufferedImage image = group.getImage();\n    if (image == null) {\n        // image is empty, don't bother\n        return;\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    // both the DPI xform and the CTM were already applied to the group, so all we do\n    // here is draw it directly onto the Graphics2D device at the appropriate position\n    AffineTransform savedTransform = graphics.getTransform();\n    AffineTransform transform = new AffineTransform(xform);\n    transform.scale(1.0 / xformScalingFactorX, 1.0 / xformScalingFactorY);\n    graphics.setTransform(transform);\n    // adjust bbox (x,y) position at the initial scale + cropbox\n    PDRectangle bbox = group.getBBox();\n    float x = bbox.getLowerLeftX() - pageSize.getLowerLeftX();\n    float y = pageSize.getUpperRightY() - bbox.getUpperRightY();\n    if (flipTG) {\n        graphics.translate(0, image.getHeight());\n        graphics.scale(1, -1);\n    } else {\n        graphics.translate(x * xformScalingFactorX, y * xformScalingFactorY);\n    }\n    PDSoftMask softMask = getGraphicsState().getSoftMask();\n    if (softMask != null) {\n        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Float(0, 0, image.getWidth(), image.getHeight()));\n        awtPaint = applySoftMaskToPaint(awtPaint, softMask);\n        graphics.setPaint(awtPaint);\n        graphics.fill(new Rectangle2D.Float(0, 0, bbox.getWidth() * xformScalingFactorX, bbox.getHeight() * xformScalingFactorY));\n    } else {\n        try {\n            graphics.drawImage(image, null, null);\n        } catch (InternalError ie) {\n            LOG.error(\"Exception drawing image, see JDK-6689349, \" + \"try rendering into a BufferedImage instead\", ie);\n        }\n    }\n    graphics.setTransform(savedTransform);\n}", "private Paint applySoftMaskToPaint(Paint parentPaint, PDSoftMask softMask) throws IOException {\n    if ((softMask == null) || (softMask.getGroup() == null)) {\n        return parentPaint;\n    }\n    PDColor backdropColor = null;\n    if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        COSArray backdropColorArray = softMask.getBackdropColor();\n        if (backdropColorArray != null) {\n            PDTransparencyGroup form = softMask.getGroup();\n            PDColorSpace colorSpace = form.getGroup().getColorSpace(form.getResources());\n            // PDFBOX-5795\n            if ((colorSpace != null) && (colorSpace.getNumberOfComponents() == backdropColorArray.size())) {\n                backdropColor = new PDColor(backdropColorArray, colorSpace);\n            }\n        }\n    }\n    TransparencyGroup transparencyGroup = new TransparencyGroup(softMask.getGroup(), true, softMask.getInitialTransformationMatrix(), backdropColor);\n    BufferedImage image = transparencyGroup.getImage();\n    if (image == null) {\n        // Adobe Reader ignores empty softmasks instead of using bc color\n        // sample file: PDFJS-6967_reduced_outside_softmask.pdf\n        return parentPaint;\n    }\n    BufferedImage gray = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);\n    if (COSName.ALPHA.equals(softMask.getSubType())) {\n        gray.setData(image.getAlphaRaster());\n    } else if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        Graphics g = gray.getGraphics();\n        g.drawImage(image, 0, 0, null);\n        g.dispose();\n    } else {\n        throw new IOException(\"Invalid soft mask subtype.\");\n    }\n    gray = adjustImage(gray);\n    Rectangle2D tpgBounds = transparencyGroup.getBounds();\n    return new SoftMask(parentPaint, gray, tpgBounds, backdropColor, softMask.getTransferFunction());\n}", "/**\n * Creates a new soft mask paint.\n *\n * @param paint\n * \t\tunderlying paint.\n * @param mask\n * \t\tsoft mask\n * @param bboxDevice\n * \t\tbbox of the soft mask in the underlying Graphics2D device space\n * @param backdropColor\n * \t\tthe color to be used outside the transparency groupâs bounding box; if\n * \t\tnull, black will be used.\n * @param transferFunction\n * \t\tthe transfer function, may be null.\n */\nSoftMask(Paint paint, BufferedImage mask, Rectangle2D bboxDevice, PDColor backdropColor, PDFunction transferFunction) {\n    this.paint = paint;\n    this.mask = mask;\n    this.bboxDevice = bboxDevice;\n    if (transferFunction instanceof PDFunctionTypeIdentity) {\n        this.transferFunction = null;\n    } else {\n        this.transferFunction = transferFunction;\n    }\n    if (backdropColor != null) {\n        try {\n            Color color = new Color(backdropColor.toRGB());\n            // http://stackoverflow.com/a/25463098/535646\n            bc = (((299 * color.getRed()) + (587 * color.getGreen())) + (114 * color.getBlue())) / 1000;\n        } catch (IOException ex) {\n            // keep default\n            LOG.debug(\"Couldn't convert backdropColor to RGB - keeping default\", ex);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.protect",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.protect", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Protects the document with a protection policy. The document content will be really\n * encrypted when it will be saved. This method only marks the document for encryption. It also\n * calls {@link #setAllSecurityToBeRemoved(boolean)} with a false argument if it was set to true\n * previously and logs a warning.\n * <p>\n * Do not use the document after saving, because the structures are encrypted.\n * The same applies if your file was created from parts of another file and that\n * one is to be used after saving.\n *\n * @see org.apache.pdfbox.pdmodel.encryption.StandardProtectionPolicy\n * @see org.apache.pdfbox.pdmodel.encryption.PublicKeyProtectionPolicy\n * @param policy\n * \t\tThe protection policy.\n * @throws IOException\n * \t\tif there isn't any suitable security handler.\n */\npublic void protect(ProtectionPolicy policy) throws IOException {\n    if (isAllSecurityToBeRemoved()) {\n        LOG.warn(\"do not call setAllSecurityToBeRemoved(true) before calling protect(), \" + \"as protect() implies setAllSecurityToBeRemoved(false)\");\n        setAllSecurityToBeRemoved(false);\n    }\n    if (!isEncrypted()) {\n        encryption = new PDEncryption();\n    }\n    SecurityHandler<ProtectionPolicy> securityHandler = SecurityHandlerFactory.INSTANCE.newSecurityHandlerForPolicy(policy);\n    if (securityHandler == null) {\n        throw new IOException(\"No security handler for policy \" + policy);\n    }\n    getEncryption().setSecurityHandler(securityHandler);\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPageMode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocumentCatalog.getPageMode" ],
    "fullMethods" : [ "/**\n * Returns the page display mode.\n *\n * @return the PageMode of the document, if not present PageMode.USE_NONE is returned\n */\npublic PageMode getPageMode() {\n    String mode = root.getNameAsString(COSName.PAGE_MODE);\n    if (mode != null) {\n        try {\n            return PageMode.fromString(mode);\n        } catch (IllegalArgumentException e) {\n            LOG.debug((\"Invalid PageMode used '\" + mode) + \"' - setting to PageMode.USE_NONE\", e);\n            return PageMode.USE_NONE;\n        }\n    } else {\n        return PageMode.USE_NONE;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.fillPath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.fillPath", "org.apache.pdfbox.rendering.PageDrawer.getNonStrokingPaint", "org.apache.pdfbox.rendering.PageDrawer.applySoftMaskToPaint", "org.apache.pdfbox.rendering.SoftMask.<init>" ],
    "fullMethods" : [ "@Override\npublic void fillPath(int windingRule) throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    graphics.setComposite(graphicsState.getNonStrokingJavaComposite());\n    setClip();\n    linePath.setWindingRule(windingRule);\n    // disable anti-aliasing for rectangular paths, this is a workaround to avoid small stripes\n    // which occur when solid fills are used to simulate piecewise gradients, see PDFBOX-2302\n    // note that we ignore paths with a width/height under 1 as these are fills used as strokes,\n    // see PDFBOX-1658 for an example\n    Rectangle2D bounds = linePath.getBounds2D();\n    boolean noAntiAlias = (isRectangular(linePath) && (bounds.getWidth() > 1)) && (bounds.getHeight() > 1);\n    if (noAntiAlias) {\n        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n    }\n    Shape shape;\n    if (graphicsState.getNonStrokingColorSpace() instanceof PDPattern) {\n        // apply clip to path to avoid oversized device bounds in shading contexts (PDFBOX-2901)\n        Area area = new Area(linePath);\n        Shape clip = graphics.getClip();\n        if (clip != null) {\n            area.intersect(new Area(clip));\n        }\n        intersectShadingBBox(graphicsState.getNonStrokingColor(), area);\n        shape = area;\n    } else {\n        shape = linePath;\n    }\n    if (isContentRendered() && (!shape.getPathIterator(null).isDone())) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        graphics.setPaint(getNonStrokingPaint());\n        graphics.fill(shape);\n    }\n    linePath.reset();\n    if (noAntiAlias) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "/**\n * Returns the non-stroking AWT Paint. You may need to call this if you override\n * {@link #showGlyph(Matrix, PDFont, int, Vector) showGlyph()}. See\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-5093\">PDFBOX-5093</a> for more.\n *\n * @return The non-stroking AWT Paint.\n * @throws IOException\n * \t\tif the non-stroking AWT Paint could not be created\n */\nprotected final Paint getNonStrokingPaint() throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    return applySoftMaskToPaint(getPaint(graphicsState.getNonStrokingColor()), graphicsState.getSoftMask());\n}", "private Paint applySoftMaskToPaint(Paint parentPaint, PDSoftMask softMask) throws IOException {\n    if ((softMask == null) || (softMask.getGroup() == null)) {\n        return parentPaint;\n    }\n    PDColor backdropColor = null;\n    if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        COSArray backdropColorArray = softMask.getBackdropColor();\n        if (backdropColorArray != null) {\n            PDTransparencyGroup form = softMask.getGroup();\n            PDColorSpace colorSpace = form.getGroup().getColorSpace(form.getResources());\n            // PDFBOX-5795\n            if ((colorSpace != null) && (colorSpace.getNumberOfComponents() == backdropColorArray.size())) {\n                backdropColor = new PDColor(backdropColorArray, colorSpace);\n            }\n        }\n    }\n    TransparencyGroup transparencyGroup = new TransparencyGroup(softMask.getGroup(), true, softMask.getInitialTransformationMatrix(), backdropColor);\n    BufferedImage image = transparencyGroup.getImage();\n    if (image == null) {\n        // Adobe Reader ignores empty softmasks instead of using bc color\n        // sample file: PDFJS-6967_reduced_outside_softmask.pdf\n        return parentPaint;\n    }\n    BufferedImage gray = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);\n    if (COSName.ALPHA.equals(softMask.getSubType())) {\n        gray.setData(image.getAlphaRaster());\n    } else if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        Graphics g = gray.getGraphics();\n        g.drawImage(image, 0, 0, null);\n        g.dispose();\n    } else {\n        throw new IOException(\"Invalid soft mask subtype.\");\n    }\n    gray = adjustImage(gray);\n    Rectangle2D tpgBounds = transparencyGroup.getBounds();\n    return new SoftMask(parentPaint, gray, tpgBounds, backdropColor, softMask.getTransferFunction());\n}", "/**\n * Creates a new soft mask paint.\n *\n * @param paint\n * \t\tunderlying paint.\n * @param mask\n * \t\tsoft mask\n * @param bboxDevice\n * \t\tbbox of the soft mask in the underlying Graphics2D device space\n * @param backdropColor\n * \t\tthe color to be used outside the transparency groupâs bounding box; if\n * \t\tnull, black will be used.\n * @param transferFunction\n * \t\tthe transfer function, may be null.\n */\nSoftMask(Paint paint, BufferedImage mask, Rectangle2D bboxDevice, PDColor backdropColor, PDFunction transferFunction) {\n    this.paint = paint;\n    this.mask = mask;\n    this.bboxDevice = bboxDevice;\n    if (transferFunction instanceof PDFunctionTypeIdentity) {\n        this.transferFunction = null;\n    } else {\n        this.transferFunction = transferFunction;\n    }\n    if (backdropColor != null) {\n        try {\n            Color color = new Color(backdropColor.toRGB());\n            // http://stackoverflow.com/a/25463098/535646\n            bc = (((299 * color.getRed()) + (587 * color.getGreen())) + (114 * color.getBlue())) / 1000;\n        } catch (IOException ex) {\n            // keep default\n            LOG.debug(\"Couldn't convert backdropColor to RGB - keeping default\", ex);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFileByExtension",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.createFromFileByExtension" ],
    "fullMethods" : [ "/**\n * Create a PDImageXObject from an image file. The file format is determined by the file name\n * suffix. The following suffixes are supported: JPG, JPEG, TIF, TIFF, GIF, BMP and PNG. This is\n * a convenience method that calls {@link JPEGFactory#createFromStream},\n * {@link CCITTFactory#createFromFile} or {@link ImageIO#read} combined with\n * {@link LosslessFactory#createFromImage}. (The later can also be used to create a\n * PDImageXObject from a BufferedImage). Starting with 2.0.18, this call will create an image\n * directly from a PNG file without decoding it (when possible), which is faster. However the\n * result size depends on the compression skill of the software that created the PNG file. If\n * file size or bandwidth are important to you or to your clients, then create your PNG files\n * with a tool that has implemented the\n * <a href=\"https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/\">Zopfli\n * algorithm</a>, or use the two-step process mentioned above.\n *\n * @param file\n * \t\tthe image file.\n * @param doc\n * \t\tthe document that shall use this PDImageXObject.\n * @return a PDImageXObject.\n * @throws IOException\n * \t\tif there is an error when reading the file or creating the\n * \t\tPDImageXObject.\n * @throws IllegalArgumentException\n * \t\tif the image type is not supported.\n */\npublic static PDImageXObject createFromFileByExtension(File file, PDDocument doc) throws IOException {\n    String name = file.getName();\n    int dot = name.lastIndexOf('.');\n    if (dot == (-1)) {\n        throw new IllegalArgumentException(\"Image type not supported: \" + name);\n    }\n    String ext = name.substring(dot + 1).toLowerCase();\n    if (\"jpg\".equals(ext) || \"jpeg\".equals(ext)) {\n        try (FileInputStream fis = new FileInputStream(file)) {\n            return JPEGFactory.createFromStream(doc, fis);\n        }\n    }\n    if (\"tif\".equals(ext) || \"tiff\".equals(ext)) {\n        try {\n            return CCITTFactory.createFromFile(doc, file);\n        } catch (IOException ex) {\n            LOG.debug(\"Reading as TIFF failed, setting fileType to PNG\", ex);\n            // Plan B: try reading with ImageIO\n            // common exception:\n            // First image in tiff is not CCITT T4 or T6 compressed\n            ext = \"png\";\n        }\n    }\n    if ((\"gif\".equals(ext) || \"bmp\".equals(ext)) || \"png\".equals(ext)) {\n        BufferedImage bim = ImageIO.read(file);\n        return LosslessFactory.createFromImage(doc, bim);\n    }\n    throw new IllegalArgumentException(\"Image type not supported: \" + name);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.strokePath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.strokePath", "org.apache.pdfbox.rendering.PageDrawer.getStrokingPaint", "org.apache.pdfbox.rendering.PageDrawer.applySoftMaskToPaint", "org.apache.pdfbox.rendering.SoftMask.<init>" ],
    "fullMethods" : [ "@Override\npublic void strokePath() throws IOException {\n    if (isContentRendered()) {\n        graphics.setComposite(getGraphicsState().getStrokingJavaComposite());\n        graphics.setPaint(getStrokingPaint());\n        graphics.setStroke(getStroke());\n        setClip();\n        graphics.draw(linePath);\n    }\n    linePath.reset();\n}", "// returns the stroking AWT Paint\nprivate Paint getStrokingPaint() throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    return applySoftMaskToPaint(getPaint(graphicsState.getStrokingColor()), graphicsState.getSoftMask());\n}", "private Paint applySoftMaskToPaint(Paint parentPaint, PDSoftMask softMask) throws IOException {\n    if ((softMask == null) || (softMask.getGroup() == null)) {\n        return parentPaint;\n    }\n    PDColor backdropColor = null;\n    if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        COSArray backdropColorArray = softMask.getBackdropColor();\n        if (backdropColorArray != null) {\n            PDTransparencyGroup form = softMask.getGroup();\n            PDColorSpace colorSpace = form.getGroup().getColorSpace(form.getResources());\n            // PDFBOX-5795\n            if ((colorSpace != null) && (colorSpace.getNumberOfComponents() == backdropColorArray.size())) {\n                backdropColor = new PDColor(backdropColorArray, colorSpace);\n            }\n        }\n    }\n    TransparencyGroup transparencyGroup = new TransparencyGroup(softMask.getGroup(), true, softMask.getInitialTransformationMatrix(), backdropColor);\n    BufferedImage image = transparencyGroup.getImage();\n    if (image == null) {\n        // Adobe Reader ignores empty softmasks instead of using bc color\n        // sample file: PDFJS-6967_reduced_outside_softmask.pdf\n        return parentPaint;\n    }\n    BufferedImage gray = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);\n    if (COSName.ALPHA.equals(softMask.getSubType())) {\n        gray.setData(image.getAlphaRaster());\n    } else if (COSName.LUMINOSITY.equals(softMask.getSubType())) {\n        Graphics g = gray.getGraphics();\n        g.drawImage(image, 0, 0, null);\n        g.dispose();\n    } else {\n        throw new IOException(\"Invalid soft mask subtype.\");\n    }\n    gray = adjustImage(gray);\n    Rectangle2D tpgBounds = transparencyGroup.getBounds();\n    return new SoftMask(parentPaint, gray, tpgBounds, backdropColor, softMask.getTransferFunction());\n}", "/**\n * Creates a new soft mask paint.\n *\n * @param paint\n * \t\tunderlying paint.\n * @param mask\n * \t\tsoft mask\n * @param bboxDevice\n * \t\tbbox of the soft mask in the underlying Graphics2D device space\n * @param backdropColor\n * \t\tthe color to be used outside the transparency groupâs bounding box; if\n * \t\tnull, black will be used.\n * @param transferFunction\n * \t\tthe transfer function, may be null.\n */\nSoftMask(Paint paint, BufferedImage mask, Rectangle2D bboxDevice, PDColor backdropColor, PDFunction transferFunction) {\n    this.paint = paint;\n    this.mask = mask;\n    this.bboxDevice = bboxDevice;\n    if (transferFunction instanceof PDFunctionTypeIdentity) {\n        this.transferFunction = null;\n    } else {\n        this.transferFunction = transferFunction;\n    }\n    if (backdropColor != null) {\n        try {\n            Color color = new Color(backdropColor.toRGB());\n            // http://stackoverflow.com/a/25463098/535646\n            bc = (((299 * color.getRed()) + (587 * color.getGreen())) + (114 * color.getBlue())) / 1000;\n        } catch (IOException ex) {\n            // keep default\n            LOG.debug(\"Couldn't convert backdropColor to RGB - keeping default\", ex);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareForDecryption",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareForDecryption", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.validatePerms", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Prepares everything to decrypt the document.\n *\n * Only if decryption of single objects is needed this should be called.\n *\n * @param encryption\n * \t\tencryption dictionary\n * @param documentIDArray\n * \t\tdocument id\n * @param decryptionMaterial\n * \t\tInformation used to decrypt the document.\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\n@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException {\n    if (!(decryptionMaterial instanceof StandardDecryptionMaterial)) {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    // This is only used with security version 4 and 5.\n    if (encryption.getVersion() >= REVISION_4) {\n        setStreamFilterName(encryption.getStreamFilterName());\n        setStringFilterName(encryption.getStringFilterName());\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = ((StandardDecryptionMaterial) (decryptionMaterial));\n    String password = material.getPassword();\n    if (password == null) {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = (encryption.getVersion() == 1) ? 5 : encryption.getLength() / 8;\n    if ((encryption.getVersion() == REVISION_4) || (encryption.getVersion() == REVISION_5)) {\n        // detect whether AES encryption is used. This assumes that the encryption algo is\n        // stored in the PDCryptFilterDictionary\n        // However, crypt filters are used only when V is 4 or 5.\n        PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n        if (stdCryptFilterDictionary != null) {\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            if (COSName.AESV2.equals(cryptFilterMethod)) {\n                dicLength = 128 / 8;\n                setAES(true);\n                if (encryption.getCOSObject().containsKey(COSName.LENGTH)) {\n                    // PDFBOX-5345\n                    int newLength = encryption.getLength() / 8;\n                    if (newLength < dicLength) {\n                        LOG.warn((((\"Using \" + newLength) + \" bytes key length instead of \") + dicLength) + \" in AESV2 encryption?!\");\n                        dicLength = newLength;\n                    }\n                }\n            }\n            if (COSName.AESV3.equals(cryptFilterMethod)) {\n                dicLength = 256 / 8;\n                setAES(true);\n                if (encryption.getCOSObject().containsKey(COSName.LENGTH)) {\n                    // PDFBOX-5345\n                    int newLength = encryption.getLength() / 8;\n                    if (newLength < dicLength) {\n                        LOG.warn((((\"Using \" + newLength) + \" bytes key length instead of \") + dicLength) + \" in AESV3 encryption?!\");\n                        dicLength = newLength;\n                    }\n                }\n            }\n        }\n    }\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    // we need to know whether the meta data was encrypted for password calculation\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null;\n    byte[] oe = null;\n    Charset passwordCharset = StandardCharsets.ISO_8859_1;\n    if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n        passwordCharset = StandardCharsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    if (dicRevision == REVISION_6) {\n        password = SaslPrep.saslPrepQuery(password);// PDFBOX-4155\n\n    }\n    AccessPermission currentAccessPermission;\n    byte[] encryptedKey;\n    byte[] passwordBytes;\n    boolean isOwnerPassword;\n    if (isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n            passwordBytes = password.getBytes(passwordCharset);\n        } else {\n            passwordBytes = getUserPassword234(password.getBytes(passwordCharset), ownerKey, dicRevision, dicLength);\n        }\n        isOwnerPassword = true;\n    } else if (isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {\n        currentAccessPermission = new AccessPermission(dicPermissions);\n        currentAccessPermission.setReadOnly();\n        setCurrentAccessPermission(currentAccessPermission);\n        passwordBytes = password.getBytes(passwordCharset);\n        isOwnerPassword = false;\n    } else {\n        throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n    }\n    encryptedKey = computeEncryptedKey(passwordBytes, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, isOwnerPassword);\n    if ((dicRevision == REVISION_4) && (encryptedKey.length < 16)) {\n        LOG.info(\"PDFBOX-5955: padding RC4 key to length 16\");\n        encryptedKey = Arrays.copyOf(encryptedKey, 16);\n    }\n    setEncryptionKey(encryptedKey);\n    if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n        validatePerms(encryption, dicPermissions, encryptMetadata);\n    }\n}", "// Algorithm 13: validate permissions (\"Perms\" field). Relaxed to accommodate buggy encoders\n// https://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/adobe_supplement_iso32000.pdf\nprivate void validatePerms(PDEncryption encryption, int dicPermissions, boolean encryptMetadata) throws IOException {\n    try {\n        // \"Decrypt the 16-byte Perms string using AES-256 in ECB mode with an\n        // initialization vector of zero and the file encryption key as the key.\"\n        @SuppressWarnings({ \"squid:S5542\", \"lgtm [java/weak-cryptographic-algorithm]\" })\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(getEncryptionKey(), \"AES\"));\n        byte[] perms = cipher.doFinal(encryption.getPerms());\n        // \"Verify that bytes 9-11 of the result are the characters âaâ, âdâ, âbâ.\"\n        if (((perms[9] != 'a') || (perms[10] != 'd')) || (perms[11] != 'b')) {\n            LOG.warn(\"Verification of permissions failed (constant)\");\n        }\n        // \"Bytes 0-3 of the decrypted Perms entry, treated as a little-endian integer,\n        // are the user permissions. They should match the value in the P key.\"\n        int permsP = (((perms[0] & 0xff) | ((perms[1] & 0xff) << 8)) | ((perms[2] & 0xff) << 16)) | ((perms[3] & 0xff) << 24);\n        if (permsP != dicPermissions) {\n            LOG.warn((((\"Verification of permissions failed (\" + String.format(\"%08X\", permsP)) + \" != \") + String.format(\"%08X\", dicPermissions)) + \")\");\n        }\n        if ((encryptMetadata && (perms[8] != 'T')) || ((!encryptMetadata) && (perms[8] != 'F'))) {\n            LOG.warn(\"Verification of permissions failed (EncryptMetadata)\");\n        }\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject", "org.apache.pdfbox.pdfparser.COSParser.parseObjectDynamically", "org.apache.pdfbox.pdfparser.COSParser.getObjectOffset", "org.apache.pdfbox.pdfparser.BruteForceParser.getBFCOSObjectOffsets", "org.apache.pdfbox.pdfparser.BruteForceParser.bfSearchForObjects", "org.apache.pdfbox.pdfparser.BruteForceParser.bfSearchForLastEOFMarker" ],
    "fullMethods" : [ "@Override\npublic COSBase dereferenceCOSObject(COSObject obj) throws IOException {\n    long currentPos = source.getPosition();\n    COSObjectKey key = obj.getKey();\n    COSBase parsedObj = parseObjectDynamically(key, false);\n    if (parsedObj != null) {\n        parsedObj.setDirect(false);\n        parsedObj.setKey(key);\n    }\n    if (currentPos > 0) {\n        source.seek(currentPos);\n    }\n    return parsedObj;\n}", "/**\n * Parse the object for the given object key.\n *\n * @param objKey\n * \t\tkey of object to be parsed\n * @param requireExistingNotCompressedObj\n * \t\tif <code>true</code> the object to be parsed must be defined in xref\n * \t\t(comment: null objects may be missing from xref) and it must not be a compressed object within object stream\n * \t\t(this is used to circumvent being stuck in a loop in a malicious PDF)\n * @return the parsed object (which is also added to document object)\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprotected synchronized COSBase parseObjectDynamically(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    COSObject pdfObject = document.getObjectFromPool(objKey);\n    if (!pdfObject.isObjectNull()) {\n        return pdfObject.getObject();\n    }\n    Long offsetOrObjstmObNr = getObjectOffset(objKey, requireExistingNotCompressedObj);\n    COSBase referencedObject = null;\n    if (offsetOrObjstmObNr != null) {\n        if (offsetOrObjstmObNr > 0) {\n            referencedObject = parseFileObject(offsetOrObjstmObNr, objKey);\n        } else {\n            // xref value is object nr of object stream containing object to be parsed\n            // since our object was not found it means object stream was not parsed so far\n            referencedObject = parseObjectStreamObject(-offsetOrObjstmObNr, objKey);\n        }\n    }\n    if ((referencedObject == null) || (referencedObject instanceof COSNull)) {\n        // not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)\n        // or some other issue with dereferencing\n        // remove parser to avoid endless recursion\n        pdfObject.setToNull();\n    }\n    return referencedObject;\n}", "private Long getObjectOffset(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    // read offset or object stream object number from xref table\n    Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);\n    // maybe something is wrong with the xref table -> perform brute force search for all objects\n    if ((offsetOrObjstmObNr == null) && isLenient) {\n        offsetOrObjstmObNr = getBruteForceParser().getBFCOSObjectOffsets().get(objKey);\n        if (offsetOrObjstmObNr != null) {\n            LOG.debug(((\"Set missing offset \" + offsetOrObjstmObNr) + \" for object \") + objKey);\n            document.getXrefTable().put(objKey, offsetOrObjstmObNr);\n        }\n    }\n    // test to circumvent loops with broken documents\n    if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null) || (offsetOrObjstmObNr <= 0))) {\n        throw new IOException(((\"Object must be defined and must not be compressed object: \" + objKey.getNumber()) + \":\") + objKey.getGeneration());\n    }\n    return offsetOrObjstmObNr;\n}", "/**\n * Returns all found objects of a brute force search.\n *\n * @return map containing all found objects of a brute force search\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected Map<COSObjectKey, Long> getBFCOSObjectOffsets() throws IOException {\n    if (!bfSearchTriggered) {\n        bfSearchTriggered = true;\n        bfSearchForObjects();\n    }\n    return bfSearchCOSObjectKeyOffsets;\n}", "/**\n * Brute force search for every object in the pdf.\n *\n * @throws IOException\n * \t\tif something went wrong\n */\nprivate void bfSearchForObjects() throws IOException {\n    long lastEOFMarker = bfSearchForLastEOFMarker();\n    long originOffset = source.getPosition();\n    long currentOffset = MINIMUM_SEARCH_OFFSET;\n    long lastObjectId = Long.MIN_VALUE;\n    int lastGenID = Integer.MIN_VALUE;\n    long lastObjOffset = Long.MIN_VALUE;\n    char[] endobjString = \"ndo\".toCharArray();\n    char[] endobjRemainingString = \"bj\".toCharArray();\n    boolean endOfObjFound = false;\n    do {\n        source.seek(currentOffset);\n        int nextChar = source.read();\n        currentOffset++;\n        if (isWhitespace(nextChar) && isString(OBJ_MARKER)) {\n            long tempOffset = currentOffset - 2;\n            source.seek(tempOffset);\n            int genID = source.peek();\n            // is the next char a digit?\n            if (isDigit(genID)) {\n                genID -= 48;\n                tempOffset--;\n                source.seek(tempOffset);\n                if (isWhitespace()) {\n                    while ((tempOffset > MINIMUM_SEARCH_OFFSET) && isWhitespace()) {\n                        source.seek(--tempOffset);\n                    } \n                    boolean objectIDFound = false;\n                    while ((tempOffset > MINIMUM_SEARCH_OFFSET) && isDigit()) {\n                        source.seek(--tempOffset);\n                        objectIDFound = true;\n                    } \n                    if (objectIDFound) {\n                        source.read();\n                        long objectId = readObjectNumber();\n                        if (lastObjOffset > 0) {\n                            // add the former object ID only if there was a subsequent object ID\n                            bfSearchCOSObjectKeyOffsets.put(new COSObjectKey(lastObjectId, lastGenID), lastObjOffset);\n                        }\n                        lastObjectId = objectId;\n                        lastGenID = genID;\n                        lastObjOffset = tempOffset + 1;\n                        currentOffset += OBJ_MARKER.length - 1;\n                        endOfObjFound = false;\n                    }\n                }\n            }\n        } else if ((nextChar == 'e') && isString(endobjString)) {\n            currentOffset += endobjString.length;\n            source.seek(currentOffset);\n            if (source.isEOF()) {\n                endOfObjFound = true;\n            } else if (isString(endobjRemainingString)) {\n                currentOffset += endobjRemainingString.length;\n                endOfObjFound = true;\n            }\n        }\n    } while ((currentOffset < lastEOFMarker) && (!source.isEOF()) );\n    if (((lastEOFMarker < Long.MAX_VALUE) || endOfObjFound) && (lastObjOffset > 0)) {\n        // if the pdf wasn't cut off in the middle or if the last object ends with a \"endobj\" marker\n        // the last object id has to be added here so that it can't get lost as there isn't any subsequent object id\n        bfSearchCOSObjectKeyOffsets.put(new COSObjectKey(lastObjectId, lastGenID), lastObjOffset);\n    }\n    // reestablish origin position\n    source.seek(originOffset);\n}", "/**\n * Brute force search for the last EOF marker.\n *\n * @throws IOException\n * \t\tif something went wrong\n */\nprivate long bfSearchForLastEOFMarker() throws IOException {\n    long lastEOFMarker = -1;\n    long originOffset = source.getPosition();\n    source.seek(MINIMUM_SEARCH_OFFSET);\n    long tempMarker = findString(EOF_MARKER);\n    while (tempMarker != (-1)) {\n        try {\n            // check if the following data is some valid pdf content\n            // which most likely indicates that the pdf is linearized,\n            // updated or just cut off somewhere in the middle\n            skipSpaces();\n            if (!isString(XREF_TABLE)) {\n                readObjectNumber();\n                readGenerationNumber();\n            }\n        } catch (IOException exception) {\n            // save the EOF marker as the following data is most likely some garbage\n            LOG.debug(\"An exception occurred during brute force for last EOF - ignoring\", exception);\n            lastEOFMarker = tempMarker;\n        }\n        tempMarker = findString(EOF_MARKER);\n    } \n    source.seek(originOffset);\n    // no EOF marker found\n    if (lastEOFMarker == (-1)) {\n        lastEOFMarker = Long.MAX_VALUE;\n    }\n    return lastEOFMarker;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.getVersion",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.getVersion", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Returns the PDF specification version this document conforms to.\n *\n * @return the PDF version (e.g. 1.4f)\n */\npublic float getVersion() {\n    float headerVersionFloat = getDocument().getVersion();\n    // there may be a second version information in the document catalog starting with 1.4\n    if (headerVersionFloat >= 1.4F) {\n        String catalogVersion = getDocumentCatalog().getVersion();\n        float catalogVersionFloat = -1;\n        if (catalogVersion != null) {\n            try {\n                catalogVersionFloat = Float.parseFloat(catalogVersion);\n            } catch (NumberFormatException exception) {\n                LOG.error(\"Can't extract the version number of the document catalog.\", exception);\n            }\n        }\n        // the most recent version is the correct one\n        return Math.max(catalogVersionFloat, headerVersionFloat);\n    } else {\n        return headerVersionFloat;\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.getReferencedObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDObjectReference.getReferencedObject" ],
    "fullMethods" : [ "/**\n * Gets a higher-level object for the referenced object.\n * Currently this method may return a {@link PDAnnotation},\n * a {@link PDXObject} or <code>null</code>.\n *\n * @return a higher-level object for the referenced object\n */\npublic COSObjectable getReferencedObject() {\n    COSDictionary objDictionary = getCOSObject().getCOSDictionary(COSName.OBJ);\n    if (objDictionary == null) {\n        return null;\n    }\n    try {\n        if (objDictionary instanceof COSStream) {\n            PDXObject xobject = PDXObject.createXObject(objDictionary, null);// <-- TODO: valid?\n\n            if (xobject != null) {\n                return xobject;\n            }\n        }\n        PDAnnotation annotation = PDAnnotation.createAnnotation(objDictionary);\n        /* COSName.TYPE is optional, so if annotation is of type unknown and\n        COSName.TYPE is not COSName.ANNOT it still may be an annotation.\n        TODO shall we return the annotation object instead of null?\n        what else can be the target of the object reference?\n         */\n        if ((!(annotation instanceof PDAnnotationUnknown)) || COSName.ANNOT.equals(objDictionary.getCOSName(COSName.TYPE))) {\n            return annotation;\n        }\n    } catch (IOException exception) {\n        LOG.debug(\"Couldn't get the referenced object - returning null instead\", exception);\n        // this can only happen if the target is an XObject.\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.getFontMatrix",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.getFontMatrix" ],
    "fullMethods" : [ "@Override\npublic final Matrix getFontMatrix() {\n    if (fontMatrix == null) {\n        // PDF specified that Type 1 fonts use a 1000upem matrix, but some fonts specify\n        // their own custom matrix anyway, for example PDFBOX-2298\n        List<Number> numbers = null;\n        try {\n            numbers = genericFont.getFontMatrix();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font matrix box - returning default value\", e);\n            fontMatrix = DEFAULT_FONT_MATRIX;\n        }\n        if ((numbers != null) && (numbers.size() == 6)) {\n            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());\n        } else {\n            return super.getFontMatrix();\n        }\n    }\n    return fontMatrix;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText", "org.apache.pdfbox.contentstream.PDFStreamEngine.getDefaultFont", "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>" ],
    "fullMethods" : [ "/**\n * Called when a string of text with spacing adjustments is to be shown.\n *\n * @param array\n * \t\tarray of encoded text strings and adjustments\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextStrings(COSArray array) throws IOException {\n    PDTextState textState = getGraphicsState().getTextState();\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    PDFont font = textState.getFont();\n    boolean isVertical = false;\n    if (font != null) {\n        isVertical = font.isVertical();\n    }\n    for (COSBase obj : array) {\n        if (obj instanceof COSNumber) {\n            float tj = ((COSNumber) (obj)).floatValue();\n            // calculate the combined displacements\n            float tx;\n            float ty;\n            if (isVertical) {\n                tx = 0;\n                ty = ((-tj) / 1000) * fontSize;\n            } else {\n                tx = (((-tj) / 1000) * fontSize) * horizontalScaling;\n                ty = 0;\n            }\n            applyTextAdjustment(tx, ty);\n        } else if (obj instanceof COSString) {\n            byte[] string = ((COSString) (obj)).getBytes();\n            showText(string);\n        } else if (obj instanceof COSArray) {\n            LOG.error(\"Nested arrays are not allowed in an array for TJ operation: \" + obj);\n        } else {\n            LOG.error(((\"Unknown type \" + obj.getClass().getSimpleName()) + \" in array for TJ operation: \") + obj);\n        }\n    }\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}", "/**\n * Provide standard 14 Helvetica font as default if there isn't any font available.\n *\n * @return the default font\n */\nprivate PDFont getDefaultFont() {\n    if (defaultFont == null) {\n        defaultFont = new PDType1Font(FontName.HELVETICA);\n    }\n    return defaultFont;\n}", "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.drawImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.drawImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getImage", "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.initJPXValues" ],
    "fullMethods" : [ "@Override\npublic void drawImage(PDImage pdImage) throws IOException {\n    if ((pdImage instanceof PDImageXObject) && isHiddenOCG(((PDImageXObject) (pdImage)).getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    AffineTransform at = ctm.createAffineTransform();\n    if (!pdImage.getInterpolate()) {\n        // if the image is scaled down, we use smooth interpolation, eg PDFBOX-2364\n        // only when scaled up do we use nearest neighbour, eg PDFBOX-2302 / mori-cvpr01.pdf\n        // PDFBOX-4930: we use the sizes of the ARGB image. These can be different\n        // than the original sizes of the base image, when the mask is bigger.\n        // PDFBOX-5091: also consider subsampling, the sizes are different too.\n        BufferedImage bim;\n        if (subsamplingAllowed) {\n            bim = pdImage.getImage(null, getSubsampling(pdImage, at));\n        } else {\n            bim = pdImage.getImage();\n        }\n        boolean isScaledUp = (bim.getWidth() <= Math.abs(Math.round(ctm.getScalingFactorX() * xformScalingFactorX))) || (bim.getHeight() <= Math.abs(Math.round(ctm.getScalingFactorY() * xformScalingFactorY)));\n        if (isScaledUp) {\n            graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        }\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    if (pdImage.isStencil()) {\n        if (getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDPattern) {\n            // The earlier code for stencils (see \"else\") doesn't work with patterns because the\n            // CTM is not taken into consideration.\n            // this code is based on the fact that it is easily possible to draw the mask and\n            // the paint at the correct place with the existing code, but not in one step.\n            // Thus what we do is to draw both in separate images, then combine the two and draw\n            // the result.\n            // Note that the device scale is not used. In theory, some patterns can get better\n            // at higher resolutions but the stencil would become more and more \"blocky\".\n            // If anybody wants to do this, have a look at the code in showTransparencyGroup().\n            // draw the paint\n            Paint paint = getNonStrokingPaint();\n            Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);\n            Rectangle2D bounds = at.createTransformedShape(unitRect).getBounds2D();\n            int w = ((int) (Math.ceil(bounds.getWidth())));\n            int h = ((int) (Math.ceil(bounds.getHeight())));\n            BufferedImage renderedPaint = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n            Graphics2D g = ((Graphics2D) (renderedPaint.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setPaint(paint);\n            g.setRenderingHints(graphics.getRenderingHints());\n            g.fill(bounds);\n            g.dispose();\n            // draw the mask\n            BufferedImage mask = pdImage.getImage();\n            AffineTransform imageTransform = new AffineTransform(at);\n            imageTransform.scale(1.0 / mask.getWidth(), (-1.0) / mask.getHeight());\n            imageTransform.translate(0, -mask.getHeight());\n            AffineTransform full = new AffineTransform(g.getTransform());\n            full.concatenate(imageTransform);\n            Matrix m = new Matrix(full);\n            double scaleX = Math.abs(m.getScalingFactorX());\n            double scaleY = Math.abs(m.getScalingFactorY());\n            boolean smallMask = (mask.getWidth() <= 8) && (mask.getHeight() <= 8);\n            if ((mask.getWidth() == 1) && (mask.getHeight() == 1)) {\n                // PDFBOX-5802: force usage of the lookup table if it is only 1 pixel\n                // (See the comment for PDFBOX-5403 that it isn't done for some\n                // cases based purely on the rendering result of one file!)\n                smallMask = false;\n            }\n            if (!smallMask) {\n                // PDFBOX-5403:\n                // The mask is copied to RGB because this supports a smooth scaling, so we\n                // get a mask with 255 values instead of just 0 and 255.\n                // Inverting is done because when we don't do it, the getScaledInstance() call\n                // produces a black line in many masks. With the inversion we have a white line\n                // which is neutral. Because of the inversion we don't have to substract from 255\n                // in the \"apply the mask\" segment when rasterPixel[3] is assigned.\n                // The inversion is not done for very small ones, because of\n                // PDFBOX-2171-002-002710-p14.pdf where the \"New Harmony Consolidated\" and\n                // \"Sailor Springs\" patterns became almost invisible.\n                // (We may have to decide this differently in the future, e.g. on b/w relationship)\n                BufferedImage tmp = new BufferedImage(mask.getWidth(), mask.getHeight(), BufferedImage.TYPE_INT_RGB);\n                mask = new LookupOp(getInvLookupTable(), graphics.getRenderingHints()).filter(mask, tmp);\n            }\n            BufferedImage renderedMask = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n            g = ((Graphics2D) (renderedMask.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setRenderingHints(graphics.getRenderingHints());\n            if (smallMask) {\n                g.drawImage(mask, imageTransform, null);\n            } else if ((scaleX != 0) && (scaleY != 0)) {\n                while ((scaleX < 0.25) || (Math.round(mask.getWidth() * scaleX) < 1)) {\n                    scaleX *= 2.0;\n                } \n                while ((scaleY < 0.25) || (Math.round(mask.getHeight() * scaleY) < 1)) {\n                    scaleY *= 2.0;\n                } \n                int w2 = ((int) (Math.round(mask.getWidth() * scaleX)));\n                int h2 = ((int) (Math.round(mask.getHeight() * scaleY)));\n                Image scaledMask = mask.getScaledInstance(w2, h2, Image.SCALE_SMOOTH);\n                imageTransform.scale(1.0F / Math.abs(scaleX), 1.0F / Math.abs(scaleY));\n                g.drawImage(scaledMask, imageTransform, null);\n            }\n            g.dispose();\n            // apply the mask\n            int[] alphaPixel = null;\n            int[] rasterPixel = null;\n            WritableRaster raster = renderedPaint.getRaster();\n            WritableRaster alpha = renderedMask.getRaster();\n            for (int y = 0; y < h; y++) {\n                for (int x = 0; x < w; x++) {\n                    alphaPixel = alpha.getPixel(x, y, alphaPixel);\n                    rasterPixel = raster.getPixel(x, y, rasterPixel);\n                    rasterPixel[3] = alphaPixel[0];\n                    raster.setPixel(x, y, rasterPixel);\n                }\n            }\n            // draw the image\n            graphics.drawImage(renderedPaint, AffineTransform.getTranslateInstance(bounds.getMinX(), bounds.getMinY()), null);\n        } else {\n            // fill the image with stenciled paint\n            BufferedImage image = pdImage.getStencilImage(getNonStrokingPaint());\n            // draw the image\n            drawBufferedImage(pdImage, image, at);\n        }\n    } else if (subsamplingAllowed) {\n        int subsampling = getSubsampling(pdImage, at);\n        // draw the subsampled image\n        drawBufferedImage(pdImage, pdImage.getImage(null, subsampling), at);\n    } else {\n        // subsampling not allowed, draw the image\n        drawBufferedImage(pdImage, pdImage.getImage(), at);\n    }\n    if (!pdImage.getInterpolate()) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "/**\n * {@inheritDoc }\n */\n@Override\npublic BufferedImage getImage(Rectangle region, int subsampling) throws IOException {\n    if (((region == null) && (subsampling == cachedImageSubsampling)) && (cachedImage != null)) {\n        BufferedImage cached = cachedImage.get();\n        if (cached != null) {\n            return cached;\n        }\n    }\n    initJPXValues();\n    // get RGB image w/o reference because applyMask might modify it, take long time and a lot of memory.\n    final BufferedImage image;\n    final PDImageXObject softMask = getSoftMask();\n    final PDImageXObject mask = getMask();\n    if (jpxSMask != null) {\n        // PDFBOX-5657: handle JPEG2000 SMaskInData\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), jpxSMask, false, true, null);\n    } else if (softMask != null) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), softMask.getOpaqueImage(region, subsampling), softMask.getInterpolate(), true, extractMatte(softMask));\n    } else if ((mask != null) && mask.isStencil()) {\n        image = applyMask(SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask()), mask.getOpaqueImage(region, subsampling), mask.getInterpolate(), false, null);\n    } else {\n        image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());\n    }\n    if ((region == null) && (subsampling <= cachedImageSubsampling)) {\n        // only cache full-image renders, and prefer lower subsampling frequency, as lower\n        // subsampling means higher quality and longer render times.\n        cachedImageSubsampling = subsampling;\n        cachedImage = new SoftReference<>(image);\n    }\n    return image;\n}", "private void initJPXValues() {\n    if ((!hasJPXFilter) || jpxValuesInitialized) {\n        return;\n    }\n    // some of the dictionary values of the COSStream may be overwritten by values which are extracted from the\n    // image itself, such as\n    // width and height of the image\n    // bits per component\n    // the colorspace of the image is used if the dictionary doesn't provide any value\n    PDStream stream = getStream();\n    try (COSInputStream is = stream.createInputStream()) {\n        DecodeResult decodeResult = is.getDecodeResult();\n        stream.getCOSObject().addAll(decodeResult.getParameters());\n        if (colorSpace == null) {\n            colorSpace = decodeResult.getJPXColorSpace();\n        }\n        jpxSMask = decodeResult.getJPXSMask();\n        jpxValuesInitialized = true;\n    } catch (IOException exception) {\n        LOG.debug(\"Can't initialize JPX based values\", exception);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFMergerUtility.mergeDocuments",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFMergerUtility.mergeDocuments", "org.apache.pdfbox.multipdf.PDFMergerUtility.legacyMergeDocuments", "org.apache.pdfbox.pdmodel.PDDocument.<clinit>" ],
    "fullMethods" : [ "/**\n * Merge the list of source documents, saving the result in the destination file. The source\n * list is not reset after merge. If you want to merge one document at a time, then it's better\n * to use\n * {@link #appendDocument(org.apache.pdfbox.pdmodel.PDDocument, org.apache.pdfbox.pdmodel.PDDocument)}.\n *\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache; in case of <code>null</code>\n * \t\tunrestricted main memory is used\n * @param compressParameters\n * \t\tdefines if compressed object streams are enabled\n * @throws IOException\n * \t\tIf there is an error saving the document.\n */\npublic void mergeDocuments(StreamCacheCreateFunction streamCacheCreateFunction, CompressParameters compressParameters) throws IOException {\n    if (documentMergeMode == DocumentMergeMode.PDFBOX_LEGACY_MODE) {\n        legacyMergeDocuments(streamCacheCreateFunction, compressParameters);\n    } else if (documentMergeMode == DocumentMergeMode.OPTIMIZE_RESOURCES_MODE) {\n        optimizedMergeDocuments(streamCacheCreateFunction, compressParameters);\n    }\n}", "/**\n * Merge the list of source documents, saving the result in the destination file.\n *\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of a stream cache; in case of <code>null</code>\n * \t\tunrestricted main memory is used\n * @throws IOException\n * \t\tIf there is an error saving the document.\n */\nprivate void legacyMergeDocuments(StreamCacheCreateFunction streamCacheCreateFunction, CompressParameters compressParameters) throws IOException {\n    if (!sources.isEmpty()) {\n        // Make sure that:\n        // - first Exception is kept\n        // - all PDDocuments are closed\n        // - all FileInputStreams are closed\n        // - there's a way to see which errors occurred\n        StreamCacheCreateFunction strmCacheFunc = (streamCacheCreateFunction != null) ? streamCacheCreateFunction : IOUtils.createMemoryOnlyStreamCache();\n        try (PDDocument destination = new PDDocument(strmCacheFunc)) {\n            for (Object sourceObject : sources) {\n                PDDocument sourceDoc;\n                if (sourceObject instanceof File) {\n                    sourceDoc = Loader.loadPDF(((File) (sourceObject)));\n                } else {\n                    sourceDoc = Loader.loadPDF(((RandomAccessRead) (sourceObject)));\n                }\n                try {\n                    appendDocument(destination, sourceDoc);\n                } finally {\n                    IOUtils.closeAndLogException(sourceDoc, LOG, \"PDDocument\", null);\n                }\n            }\n            // optionally set meta data\n            if (destinationDocumentInformation != null) {\n                destination.setDocumentInformation(destinationDocumentInformation);\n            }\n            if (destinationMetadata != null) {\n                destination.getDocumentCatalog().setMetadata(destinationMetadata);\n            }\n            if (destinationStream == null) {\n                destination.save(destinationFileName, compressParameters);\n            } else {\n                destination.save(destinationStream, compressParameters);\n            }\n        }\n    }\n}", "" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.getFontMatrix",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.getFontMatrix" ],
    "fullMethods" : [ "@Override\npublic final Matrix getFontMatrix() {\n    if (fontMatrix == null) {\n        List<Number> numbers;\n        if (cidFont != null) {\n            numbers = cidFont.getFontMatrix();\n        } else {\n            try {\n                numbers = t1Font.getFontMatrix();\n            } catch (IOException e) {\n                LOG.debug(\"Couldn't get font matrix - returning default value\", e);\n                return new Matrix(0.001F, 0, 0, 0.001F, 0, 0);\n            }\n        }\n        if ((numbers != null) && (numbers.size() == 6)) {\n            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());\n        } else {\n            fontMatrix = new Matrix(0.001F, 0, 0, 0.001F, 0, 0);\n        }\n    }\n    return fontMatrix;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFParser.parse", "org.apache.pdfbox.pdfparser.COSParser.parsePDFHeader", "org.apache.pdfbox.pdfparser.COSParser.parseHeader" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the PDDocument object. This will close the keystore stream when it is\n * done parsing.\n *\n * @param lenient\n * \t\tactivate leniency if set to true\n * @return the populated PDDocument\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic PDDocument parse(boolean lenient) throws IOException {\n    setLenient(lenient);\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        // PDFBOX-1922 read the version header and rewind\n        if ((!parsePDFHeader()) && (!parseFDFHeader())) {\n            if (lenient) {\n                LOG.warn(\"Error: Header doesn't contain versioninfo\");\n            } else {\n                throw new IOException(\"Error: Header doesn't contain versioninfo\");\n            }\n        }\n        if (!initialParseDone) {\n            initialParse();\n        }\n        exceptionOccurred = false;\n        PDDocument pdDocument = createDocument();\n        pdDocument.setEncryptionDictionary(getEncryption());\n        return pdDocument;\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * Parse the header of a pdf.\n *\n * @return true if a PDF header was found\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected boolean parsePDFHeader() throws IOException {\n    return parseHeader(PDF_HEADER, PDF_DEFAULT_VERSION);\n}", "private boolean parseHeader(String headerMarker, String defaultVersion) throws IOException {\n    // read first line\n    String header = readLine();\n    // some pdf-documents are broken and the pdf-version is in one of the following lines\n    if (!header.contains(headerMarker)) {\n        header = readLine();\n        while (!header.contains(headerMarker)) {\n            // if a line starts with a digit, it has to be the first one with data in it\n            if ((header.length() > 0) && Character.isDigit(header.charAt(0))) {\n                break;\n            }\n            header = readLine();\n        } \n    }\n    // nothing found\n    if (!header.contains(headerMarker)) {\n        source.seek(0);\n        return false;\n    }\n    // sometimes there is some garbage in the header before the header\n    // actually starts, so lets try to find the header first.\n    int headerStart = header.indexOf(headerMarker);\n    // greater than zero because if it is zero then there is no point of trimming\n    if (headerStart > 0) {\n        // trim off any leading characters\n        header = header.substring(headerStart);\n    }\n    // This is used if there is garbage after the header on the same line\n    if (header.startsWith(headerMarker) && (!header.matches(headerMarker + \"\\\\d.\\\\d\"))) {\n        if (header.length() < (headerMarker.length() + 3)) {\n            // No version number at all, set to 1.4 as default\n            header = headerMarker + defaultVersion;\n            LOG.debug((\"No version found, set to \" + defaultVersion) + \" as default.\");\n        } else {\n            String headerGarbage = header.substring(headerMarker.length() + 3) + \"\\n\";\n            header = header.substring(0, headerMarker.length() + 3);\n            source.rewind(headerGarbage.getBytes(StandardCharsets.ISO_8859_1).length);\n        }\n    }\n    float headerVersion = -1;\n    try {\n        String[] headerParts = header.split(\"-\");\n        if (headerParts.length == 2) {\n            headerVersion = Float.parseFloat(headerParts[1]);\n        }\n    } catch (NumberFormatException exception) {\n        LOG.debug(\"Can't parse the header version.\", exception);\n    }\n    if (headerVersion < 0) {\n        if (isLenient) {\n            headerVersion = 1.7F;\n        } else {\n            throw new IOException(\"Error getting header version: \" + header);\n        }\n    }\n    document.setVersion(headerVersion);\n    // rewind\n    source.seek(0);\n    return true;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.debug",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken", "org.apache.pdfbox.pdfparser.BaseParser.parseCOSName", "org.apache.pdfbox.pdfparser.BaseParser.decodeBuffer" ],
    "fullMethods" : [ "/**\n * This will parse the next token in the stream.\n *\n * @return The next token in the stream or null if there are no more tokens in the stream.\n * @throws IOException\n * \t\tIf an io error occurs while parsing the stream.\n */\npublic Object parseNextToken() throws IOException {\n    if (source.isClosed()) {\n        return null;\n    }\n    skipSpaces();\n    if (source.isEOF()) {\n        close();\n        return null;\n    }\n    char c = ((char) (source.peek()));\n    switch (c) {\n        case '<' :\n            // pull off first left bracket\n            source.read();\n            // check for second left bracket\n            c = ((char) (source.peek()));\n            // put back first bracket\n            source.rewind(1);\n            if (c == '<') {\n                try {\n                    return parseCOSDictionary(true);\n                } catch (IOException exception) {\n                    LOG.warn(\"Stop reading invalid dictionary from content stream at offset \" + source.getPosition());\n                    close();\n                    return null;\n                }\n            } else {\n                return parseCOSString();\n            }\n        case '[' :\n            // array\n            try {\n                return parseCOSArray();\n            } catch (IOException exception) {\n                LOG.warn(\"Stop reading invalid array from content stream at offset \" + source.getPosition());\n                close();\n                return null;\n            }\n        case '(' :\n            // string\n            return parseCOSString();\n        case '/' :\n            // name\n            return parseCOSName();\n        case 'n' :\n            // null\n            String nullString = readString();\n            if (nullString.equals(\"null\")) {\n                return COSNull.NULL;\n            } else {\n                return Operator.getOperator(nullString);\n            }\n        case 't' :\n        case 'f' :\n            String next = readString();\n            if (next.equals(\"true\")) {\n                return COSBoolean.TRUE;\n            } else if (next.equals(\"false\")) {\n                return COSBoolean.FALSE;\n            } else {\n                return Operator.getOperator(next);\n            }\n        case '0' :\n        case '1' :\n        case '2' :\n        case '3' :\n        case '4' :\n        case '5' :\n        case '6' :\n        case '7' :\n        case '8' :\n        case '9' :\n        case '-' :\n        case '+' :\n        case '.' :\n            /* We will be filling buf with the rest of the number.  Only\n            allow 1 \".\" and \"-\" and \"+\" at start of number.\n             */\n            StringBuilder buf = new StringBuilder();\n            buf.append(c);\n            source.read();\n            // Ignore double negative (this is consistent with Adobe Reader)\n            if ((c == '-') && (source.peek() == c)) {\n                source.read();\n            }\n            boolean dotNotRead = c != '.';\n            while ((Character.isDigit(c = ((char) (source.peek()))) || (dotNotRead && (c == '.'))) || (c == '-')) {\n                if (c != '-') {\n                    // PDFBOX-4064: ignore \"-\" in the middle of a number\n                    buf.append(c);\n                }\n                source.read();\n                if (dotNotRead && (c == '.')) {\n                    dotNotRead = false;\n                }\n            } \n            String s = buf.toString();\n            if (\"+\".equals(s)) {\n                // PDFBOX-5906\n                LOG.warn(\"isolated '+' is ignored\");\n                return COSNull.NULL;\n            }\n            return COSNumber.get(s);\n        case 'B' :\n            String nextOperator = readString();\n            Operator beginImageOP = Operator.getOperator(nextOperator);\n            if (nextOperator.equals(OperatorName.BEGIN_INLINE_IMAGE)) {\n                inlineImageDepth++;\n                if (inlineImageDepth > 1) {\n                    // PDFBOX-6038\n                    throw new IOException(((((\"Nested '\" + OperatorName.BEGIN_INLINE_IMAGE) + \"' operator not allowed at offset \") + source.getPosition()) + \", first: \") + inlineOffset);\n                } else {\n                    inlineOffset = source.getPosition();\n                }\n                COSDictionary imageParams = new COSDictionary();\n                beginImageOP.setImageParameters(imageParams);\n                Object nextToken = null;\n                while ((nextToken = parseNextToken()) instanceof COSName) {\n                    Object value = parseNextToken();\n                    if (!(value instanceof COSBase)) {\n                        LOG.warn(\"Unexpected token in inline image dictionary at offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                        break;\n                    }\n                    imageParams.setItem(((COSName) (nextToken)), ((COSBase) (value)));\n                } \n                // final token will be the image data, maybe??\n                if (nextToken instanceof Operator) {\n                    Operator imageData = ((Operator) (nextToken));\n                    if ((imageData.getImageData() == null) || (imageData.getImageData().length == 0)) {\n                        LOG.warn(\"empty inline image at stream offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                    }\n                    beginImageOP.setImageData(imageData.getImageData());\n                    inlineImageDepth--;\n                } else {\n                    LOG.warn((((((\"nextToken \" + nextToken) + \" at position \") + (source.isClosed() ? \"EOF\" : source.getPosition())) + \", expected \") + OperatorName.BEGIN_INLINE_IMAGE_DATA) + \"?!\");\n                }\n            }\n            return beginImageOP;\n        case 'I' :\n            // Special case for ID operator\n            String id = Character.toString(((char) (source.read()))) + ((char) (source.read()));\n            if (!id.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA)) {\n                long currentPosition = source.getPosition();\n                close();\n                throw new IOException(((\"Error: Expected operator 'ID' actual='\" + id) + \"' at stream offset \") + currentPosition);\n            }\n            ByteArrayOutputStream imageData = new ByteArrayOutputStream();\n            // skip one line break (CR, LF or CRLF) or any one-byte whitespace\n            if ((!skipLinebreak()) && isWhitespace()) {\n                // pull off the whitespace character\n                source.read();\n            }\n            int lastByte = source.read();\n            int currentByte = source.read();\n            // PDF spec is kinda unclear about this. Should a whitespace\n            // always appear before EI? Not sure, so that we just read\n            // until EI<whitespace>.\n            // Be aware not all kind of whitespaces are allowed here. see PDFBOX-1561\n            while ((!((((lastByte == 'E') && (currentByte == 'I')) && hasNextSpaceOrReturn()) && hasNoFollowingBinData())) && (!isEOF())) {\n                imageData.write(lastByte);\n                lastByte = currentByte;\n                currentByte = source.read();\n            } \n            // the EI operator isn't unread, as it won't be processed anyway\n            Operator beginImageDataOP = Operator.getOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);\n            // save the image data to the operator, so that it can be accessed later\n            beginImageDataOP.setImageData(imageData.toByteArray());\n            return beginImageDataOP;\n        case ']' :\n            // some ']' around without its previous '['\n            // this means a PDF is somewhat corrupt but we will continue to parse.\n            source.read();\n            // must be a better solution than null...\n            return COSNull.NULL;\n        default :\n            // we must be an operator\n            String operator = readOperator().trim();\n            if (operator.length() > 0) {\n                return Operator.getOperator(operator);\n            }\n    }\n    return null;\n}", "/**\n * This will parse a PDF name from the stream.\n *\n * @return The parsed PDF name.\n * @throws IOException\n * \t\tIf there is an error reading from the stream.\n */\nprotected COSName parseCOSName() throws IOException {\n    readExpectedChar('/');\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int c = source.read();\n    while (!isEndOfName(c)) {\n        final int ch = c;\n        if (ch == '#') {\n            int ch1 = source.read();\n            int ch2 = source.read();\n            // Prior to PDF v1.2, the # was not a special character.  Also,\n            // it has been observed that various PDF tools do not follow the\n            // spec with respect to the # escape, even though they report\n            // PDF versions of 1.2 or later.  The solution here is that we\n            // interpret the # as an escape only when it is followed by two\n            // valid hex digits.\n            if (isHexDigit(((char) (ch1))) && isHexDigit(((char) (ch2)))) {\n                String hex = Character.toString(((char) (ch1))) + ((char) (ch2));\n                try {\n                    buffer.write(Integer.parseInt(hex, 16));\n                } catch (NumberFormatException e) {\n                    throw new IOException((\"Error: expected hex digit, actual='\" + hex) + \"'\", e);\n                }\n                c = source.read();\n            } else {\n                // check for premature EOF\n                if ((ch2 == (-1)) || (ch1 == (-1))) {\n                    LOG.error(\"Premature EOF in BaseParser#parseCOSName\");\n                    c = -1;\n                    break;\n                }\n                source.rewind(1);\n                c = ch1;\n                buffer.write(ch);\n            }\n        } else {\n            buffer.write(ch);\n            c = source.read();\n        }\n    } \n    if (c != (-1)) {\n        source.rewind(1);\n    }\n    return COSName.getPDFName(decodeBuffer(buffer));\n}", "/**\n * Tries to decode the buffer cotent to an UTF-8 String.\n * If that fails, tries the alternative Encoding.\n *\n * @param buffer\n * \t\tthe {@link ByteArrayOutputStream} containing the bytes to decode\n * @return the decoded String\n */\nprivate String decodeBuffer(ByteArrayOutputStream buffer) throws UnsupportedEncodingException {\n    try {\n        return utf8Decoder.decode(ByteBuffer.wrap(buffer.toByteArray())).toString();\n    } catch (CharacterCodingException e) {\n        // some malformed PDFs don't use UTF-8 see PDFBOX-3347\n        LOG.debug((\"Buffer could not be decoded using StandardCharsets.UTF_8 - \" + \"trying \") + ALTERNATIVE_CHARSET.name(), e);\n        return buffer.toString(ALTERNATIVE_CHARSET.name());\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isOwnerPassword56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeHash2A", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeHash2B", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Check for owner password.\n *\n * @param ownerPassword\n * \t\tThe owner password.\n * @param user\n * \t\tThe u entry of the encryption dictionary.\n * @param owner\n * \t\tThe o entry of the encryption dictionary.\n * @param permissions\n * \t\tThe set of permissions on the document.\n * @param id\n * \t\tThe document id.\n * @param encRevision\n * \t\tThe encryption algorithm revision.\n * @param keyLengthInBytes\n * \t\tThe encryption key length in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata\n * @return True If the ownerPassword param is the owner password.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\npublic boolean isOwnerPassword(byte[] ownerPassword, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException {\n    switch (encRevision) {\n        case REVISION_2 :\n        case REVISION_3 :\n        case REVISION_4 :\n            return isOwnerPassword234(ownerPassword, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);\n        case REVISION_5 :\n        case REVISION_6 :\n            return isOwnerPassword56(ownerPassword, user, owner, encRevision);\n        default :\n            throw new IOException(\"Unknown Encryption Revision \" + encRevision);\n    }\n}", "private boolean isOwnerPassword56(byte[] ownerPassword, byte[] user, byte[] owner, int encRevision) throws IOException {\n    if (owner.length < 40) {\n        // PDFBOX-5104\n        throw new IOException(\"Owner password is too short\");\n    }\n    byte[] truncatedOwnerPassword = truncate127(ownerPassword);\n    byte[] oHash = new byte[32];\n    byte[] oValidationSalt = new byte[8];\n    System.arraycopy(owner, 0, oHash, 0, 32);\n    System.arraycopy(owner, 32, oValidationSalt, 0, 8);\n    if (encRevision == REVISION_5) {\n        return MessageDigest.isEqual(computeSHA256(truncatedOwnerPassword, oValidationSalt, user), oHash);\n    } else {\n        return MessageDigest.isEqual(computeHash2A(truncatedOwnerPassword, oValidationSalt, user), oHash);\n    }\n}", "// Algorithm 2.A from ISO 32000-1\nprivate byte[] computeHash2A(byte[] password, byte[] salt, byte[] u) throws IOException {\n    byte[] userKey = adjustUserKey(u);\n    byte[] truncatedPassword = truncate127(password);\n    byte[] input = concat(truncatedPassword, salt, userKey);\n    return computeHash2B(input, truncatedPassword, userKey);\n}", "// Algorithm 2.B from ISO 32000-2\nprivate static byte[] computeHash2B(byte[] input, byte[] password, byte[] userKey) throws IOException {\n    try {\n        MessageDigest md = MessageDigests.getSHA256();\n        byte[] k = md.digest(input);\n        byte[] e = null;\n        for (int round = 0; (round < 64) || ((e[e.length - 1] & 0xff) > (round - 32)); round++) {\n            byte[] k1;\n            if ((userKey != null) && (userKey.length >= 48)) {\n                k1 = new byte[64 * ((password.length + k.length) + 48)];\n            } else {\n                k1 = new byte[64 * (password.length + k.length)];\n            }\n            int pos = 0;\n            for (int i = 0; i < 64; i++) {\n                System.arraycopy(password, 0, k1, pos, password.length);\n                pos += password.length;\n                System.arraycopy(k, 0, k1, pos, k.length);\n                pos += k.length;\n                if ((userKey != null) && (userKey.length >= 48)) {\n                    System.arraycopy(userKey, 0, k1, pos, 48);\n                    pos += 48;\n                }\n            }\n            byte[] kFirst = new byte[16];\n            byte[] kSecond = new byte[16];\n            System.arraycopy(k, 0, kFirst, 0, 16);\n            System.arraycopy(k, 16, kSecond, 0, 16);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            SecretKeySpec keySpec = new SecretKeySpec(kFirst, \"AES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(kSecond);\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n            e = cipher.doFinal(k1);\n            byte[] eFirst = new byte[16];\n            System.arraycopy(e, 0, eFirst, 0, 16);\n            BigInteger bi = new BigInteger(1, eFirst);\n            BigInteger remainder = bi.mod(new BigInteger(\"3\"));\n            String nextHash = HASHES_2B[remainder.intValue()];\n            md = MessageDigest.getInstance(nextHash);\n            k = md.digest(e);\n        }\n        if (k.length > 32) {\n            byte[] kTrunc = new byte[32];\n            System.arraycopy(k, 0, kTrunc, 0, 32);\n            return kTrunc;\n        } else {\n            return k;\n        }\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getRectangle",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.getRectangle" ],
    "fullMethods" : [ "/**\n * The annotation rectangle, defining the location of the annotation on the page in default user space units. This\n * is usually required and should not return null on valid PDF documents. But where this is a parent form field with\n * children, such as radio button collections then the rectangle will be null.\n *\n * @return The Rect value of this annotation.\n */\npublic PDRectangle getRectangle() {\n    COSArray rectArray = dictionary.getCOSArray(COSName.RECT);\n    PDRectangle rectangle = null;\n    if (rectArray != null) {\n        if (((((rectArray.size() == 4) && (rectArray.getObject(0) instanceof COSNumber)) && (rectArray.getObject(1) instanceof COSNumber)) && (rectArray.getObject(2) instanceof COSNumber)) && (rectArray.getObject(3) instanceof COSNumber)) {\n            rectangle = new PDRectangle(rectArray);\n        } else {\n            LOG.warn(rectArray + \" is not a rectangle array, returning null\");\n        }\n    }\n    return rectangle;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.FlateFilterDecoderStream.read",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.FlateFilterDecoderStream.read", "org.apache.pdfbox.filter.FlateFilterDecoderStream.fetch" ],
    "fullMethods" : [ "/**\n * This will read a chunk of data.\n *\n * @param data\n * \t\tThe buffer to write data to.\n * @param offset\n * \t\tThe offset into the data stream.\n * @param length\n * \t\tThe number of byte to attempt to read.\n * @return The number of bytes actually read.\n * @throws IOException\n * \t\tIf there is an error reading data from the underlying stream.\n */\n@Override\npublic int read(byte[] data, int offset, int length) throws IOException {\n    if (isEOF) {\n        return -1;\n    }\n    int numberOfBytesRead = 0;\n    while (numberOfBytesRead < length) {\n        int available = bytesDecoded - currentDataIndex;\n        if (available > 0) {\n            int bytes2Copy = Math.min(length - numberOfBytesRead, available);\n            System.arraycopy(decodedData, currentDataIndex, data, numberOfBytesRead + offset, bytes2Copy);\n            currentDataIndex += bytes2Copy;\n            numberOfBytesRead += bytes2Copy;\n        } else if (!fetch()) {\n            break;\n        }\n    } \n    return numberOfBytesRead;\n}", "private boolean fetch() throws IOException {\n    currentDataIndex = 0;\n    if (isEOF || inflater.finished()) {\n        isEOF = true;\n        bytesDecoded = 0;\n        return false;\n    }\n    if (inflater.needsInput()) {\n        int bytesRead = in.read(buffer);\n        if (bytesRead > (-1)) {\n            inflater.setInput(buffer, 0, bytesRead);\n        } else {\n            isEOF = true;\n            return false;\n        }\n    }\n    try {\n        // overwrite formerly read bytes\n        if (bytesDecoded > 0) {\n            Arrays.fill(decodedData, 0, bytesDecoded, ((byte) (0)));\n        }\n        bytesDecoded = inflater.inflate(decodedData);\n    } catch (DataFormatException exception) {\n        isEOF = true;\n        // check if some bytes could be read at all\n        int countZeros = 0;\n        for (int i = 0; i < decodedData.length; i++) {\n            if (decodedData[i] == 0) {\n                countZeros++;\n            } else {\n                countZeros = 0;\n            }\n        }\n        bytesDecoded = decodedData.length - countZeros;\n        // don't throw an exception, use the already read data or an empty stream\n        LOG.warn(\"FlateFilter: premature end of stream due to a DataFormatException = \" + exception.getMessage());\n        return bytesDecoded > 0;\n    }\n    return true;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>" ],
    "fullMethods" : [ "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type7ShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PatchMeshesShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type7ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @throws IOException\n * \t\tif something went wrong\n */\nType7ShadingContext(PDShadingType7 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix, deviceBounds, 16);\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected PatchMeshesShadingContext(PDMeshBasedShadingType shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds, int controlPoints) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    patchList = shading.collectPatches(xform, matrix, controlPoints);\n    createPixelTable(deviceBounds);\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances" ],
    "fullMethods" : [ "/**\n * Set the selected value of this field, and try to update the visual appearance.\n *\n * @param value\n * \t\tThe name of the selected item.\n * @throws IOException\n * \t\tif the value could not be set\n */\n@Override\npublic void setValue(String value) throws IOException {\n    getCOSObject().setString(COSName.V, value);\n    // remove I key for single valued choice field\n    setSelectedOptionsIndex(null);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.FDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.FDFParser.parse", "org.apache.pdfbox.pdfparser.FDFParser.initialParse", "org.apache.pdfbox.pdfparser.COSParser.retrieveTrailer", "org.apache.pdfbox.pdfparser.COSParser.parseXref" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the FDFDocument object.\n *\n * @return the parsed FDFDocument\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic FDFDocument parse() throws IOException {\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        if (!parseFDFHeader()) {\n            throw new IOException(\"Error: Header doesn't contain versioninfo\");\n        }\n        initialParse();\n        exceptionOccurred = false;\n        return new FDFDocument(document, source);\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}", "/**\n * The initial parse will first parse only the trailer, the xrefstart and all xref tables to have a pointer (offset)\n * to all the pdf's objects. It can handle linearized pdfs, which will have an xref at the end pointing to an xref\n * at the beginning of the file. Last the root object is parsed.\n *\n * @throws IOException\n * \t\tIf something went wrong.\n */\nprivate void initialParse() throws IOException {\n    COSDictionary trailer = retrieveTrailer();\n    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);\n    if (root == null) {\n        throw new IOException(\"Missing root object specification in trailer.\");\n    }\n    initialParseDone = true;\n}", "/**\n * Read the trailer information and provide a COSDictionary containing the trailer information.\n *\n * @return a COSDictionary containing the trailer information\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected COSDictionary retrieveTrailer() throws IOException {\n    COSDictionary trailer = null;\n    boolean rebuildTrailer = false;\n    try {\n        // parse startxref\n        // TODO FDF files don't have a startxref value, so that rebuildTrailer is triggered\n        long startXRefOffset = getStartxrefOffset();\n        if (startXRefOffset > (-1)) {\n            trailer = parseXref(startXRefOffset);\n        } else {\n            rebuildTrailer = isLenient();\n        }\n    } catch (IOException exception) {\n        if (isLenient()) {\n            rebuildTrailer = true;\n        } else {\n            throw exception;\n        }\n    }\n    // check if the trailer contains a Root object\n    if ((trailer != null) && (trailer.getItem(COSName.ROOT) == null)) {\n        rebuildTrailer = isLenient();\n    }\n    if (rebuildTrailer) {\n        trailer = getBruteForceParser().rebuildTrailer(xrefTrailerResolver, null);\n        trailerWasRebuild = true;\n        // transfer encryption information from BruteForceParser\n        encryption = getBruteForceParser().getEncryption();\n        if (encryption != null) {\n            securityHandler = encryption.getSecurityHandler();\n            accessPermission = securityHandler.getCurrentAccessPermission();\n        }\n    } else {\n        // prepare decryption if necessary\n        prepareDecryption();\n        // don't use the getter as it creates an instance of BruteForceParser\n        if ((bruteForceParser != null) && bruteForceParser.bfSearchTriggered()) {\n            getBruteForceParser().bfSearchForObjStreams(xrefTrailerResolver, securityHandler);\n        }\n    }\n    if (resetTrailerResolver()) {\n        xrefTrailerResolver.reset();\n        xrefTrailerResolver = null;\n    }\n    return trailer;\n}", "/**\n * Parses cross reference tables.\n *\n * @param startXRefOffset\n * \t\tstart offset of the first table\n * @return the trailer dictionary\n * @throws IOException\n * \t\tif something went wrong\n */\nprivate COSDictionary parseXref(long startXRefOffset) throws IOException {\n    source.seek(startXRefOffset);\n    long startXrefOffset = Math.max(0, parseStartXref());\n    // check the startxref offset\n    long fixedOffset = checkXRefOffset(startXrefOffset);\n    if (fixedOffset > (-1)) {\n        startXrefOffset = fixedOffset;\n    }\n    document.setStartXref(startXrefOffset);\n    long prev = startXrefOffset;\n    // ---- parse whole chain of xref tables/object streams using PREV reference\n    Set<Long> prevSet = new HashSet<>();\n    COSDictionary trailer = null;\n    while (prev > 0) {\n        // save expected position for loop detection\n        prevSet.add(prev);\n        // seek to xref table\n        source.seek(prev);\n        // skip white spaces\n        skipSpaces();\n        // save current position as well due to skipped spaces\n        prevSet.add(source.getPosition());\n        // -- parse xref\n        if (source.peek() == X) {\n            // xref table and trailer\n            // use existing parser to parse xref table\n            if ((!parseXrefTable(prev)) || (!parseTrailer())) {\n                throw new IOException(\"Expected trailer object at offset \" + source.getPosition());\n            }\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n            // check for a XRef stream, it may contain some object ids of compressed objects\n            if (trailer.containsKey(COSName.XREF_STM)) {\n                int streamOffset = trailer.getInt(COSName.XREF_STM);\n                // check the xref stream reference\n                fixedOffset = checkXRefOffset(streamOffset);\n                if ((fixedOffset > (-1)) && (fixedOffset != streamOffset)) {\n                    LOG.warn(((\"/XRefStm offset \" + streamOffset) + \" is incorrect, corrected to \") + fixedOffset);\n                    streamOffset = ((int) (fixedOffset));\n                    trailer.setInt(COSName.XREF_STM, streamOffset);\n                }\n                if (streamOffset > 0) {\n                    source.seek(streamOffset);\n                    skipSpaces();\n                    try {\n                        parseXrefObjStream(prev, false);\n                        document.setHasHybridXRef();\n                    } catch (IOException ex) {\n                        if (isLenient) {\n                            LOG.error(\"Failed to parse /XRefStm at offset \" + streamOffset, ex);\n                        } else {\n                            throw ex;\n                        }\n                    }\n                } else if (isLenient) {\n                    LOG.error(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                } else {\n                    throw new IOException(\"Skipped XRef stream due to a corrupt offset:\" + streamOffset);\n                }\n            }\n            prev = trailer.getLong(COSName.PREV);\n        } else {\n            // parse xref stream\n            prev = parseXrefObjStream(prev, true);\n            trailer = xrefTrailerResolver.getCurrentTrailer();\n        }\n        if (prev > 0) {\n            // check the xref table reference\n            fixedOffset = checkXRefOffset(prev);\n            if ((fixedOffset > (-1)) && (fixedOffset != prev)) {\n                prev = fixedOffset;\n                trailer.setLong(COSName.PREV, prev);\n            }\n        }\n        if (prevSet.contains(prev)) {\n            throw new IOException(\"/Prev loop at offset \" + prev);\n        }\n    } \n    // ---- build valid xrefs out of the xref chain\n    xrefTrailerResolver.setStartxref(startXrefOffset);\n    trailer = xrefTrailerResolver.getTrailer();\n    document.setTrailer(trailer);\n    document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());\n    // check the offsets of all referenced objects\n    if (isLenient) {\n        checkXrefOffsets();\n    }\n    // copy xref table\n    document.addXRefTable(xrefTrailerResolver.getXrefTable());\n    // remember the highest XRef object number to avoid it being reused in incremental saving\n    Optional<Long> maxValue = // \n    // \n    document.getXrefTable().keySet().stream().map(COSObjectKey::getNumber).reduce(Long::max);\n    document.setHighestXRefObjectNumber(maxValue.isPresent() ? maxValue.get() : 0);\n    return trailer;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.FlateFilterDecoderStream.read",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.FlateFilterDecoderStream.read", "org.apache.pdfbox.filter.FlateFilterDecoderStream.fetch" ],
    "fullMethods" : [ "/**\n * This will read the next byte from the stream.\n *\n * @return The next byte read from the stream.\n * @throws IOException\n * \t\tIf there is an error reading from the wrapped stream.\n */\n@Override\npublic int read() throws IOException {\n    if (isEOF) {\n        return -1;\n    }\n    if ((currentDataIndex == bytesDecoded) && (!fetch())) {\n        return -1;\n    }\n    return decodedData[currentDataIndex++] & 0xff;\n}", "private boolean fetch() throws IOException {\n    currentDataIndex = 0;\n    if (isEOF || inflater.finished()) {\n        isEOF = true;\n        bytesDecoded = 0;\n        return false;\n    }\n    if (inflater.needsInput()) {\n        int bytesRead = in.read(buffer);\n        if (bytesRead > (-1)) {\n            inflater.setInput(buffer, 0, bytesRead);\n        } else {\n            isEOF = true;\n            return false;\n        }\n    }\n    try {\n        // overwrite formerly read bytes\n        if (bytesDecoded > 0) {\n            Arrays.fill(decodedData, 0, bytesDecoded, ((byte) (0)));\n        }\n        bytesDecoded = inflater.inflate(decodedData);\n    } catch (DataFormatException exception) {\n        isEOF = true;\n        // check if some bytes could be read at all\n        int countZeros = 0;\n        for (int i = 0; i < decodedData.length; i++) {\n            if (decodedData[i] == 0) {\n                countZeros++;\n            } else {\n                countZeros = 0;\n            }\n        }\n        bytesDecoded = decodedData.length - countZeros;\n        // don't throw an exception, use the already read data or an empty stream\n        LOG.warn(\"FlateFilter: premature end of stream due to a DataFormatException = \" + exception.getMessage());\n        return bytesDecoded > 0;\n    }\n    return true;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.TrueTypeEmbedder.subset",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.TrueTypeEmbedder.subset", "org.apache.pdfbox.pdmodel.font.PDCIDFontType2Embedder.buildSubset", "org.apache.pdfbox.pdmodel.font.PDCIDFontType2Embedder.buildVerticalMetrics", "org.apache.pdfbox.pdmodel.font.PDCIDFontType2Embedder.buildVerticalHeader" ],
    "fullMethods" : [ "@Override\npublic void subset() throws IOException {\n    if (!isSubsettingPermitted(ttf)) {\n        throw new IOException(\"This font does not permit subsetting\");\n    }\n    if (!embedSubset) {\n        throw new IllegalStateException(\"Subsetting is disabled\");\n    }\n    // set the GIDs to subset\n    TTFSubsetter subsetter = new TTFSubsetter(ttf, TABLES);\n    subsetter.addAll(subsetCodePoints);\n    subsetter.forceInvisible('â');// ZWSP\n\n    subsetter.forceInvisible('â');// ZWNJ\n\n    subsetter.forceInvisible('â ');// WJ\n\n    subsetter.forceInvisible('ï»¿');// ZWNBSP\n\n    if (!allGlyphIds.isEmpty()) {\n        subsetter.addGlyphIds(allGlyphIds);\n    }\n    // calculate deterministic tag based on the chosen subset\n    Map<Integer, Integer> gidToCid = subsetter.getGIDMap();\n    String tag = getTag(gidToCid);\n    subsetter.setPrefix(tag);\n    // save the subset font\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    subsetter.writeToStream(out);\n    // re-build the embedded font\n    buildSubset(new ByteArrayInputStream(out.toByteArray()), tag, gidToCid);\n    ttf.close();\n}", "/**\n * Rebuild a font subset.\n */\n@Override\nprotected void buildSubset(InputStream ttfSubset, String tag, Map<Integer, Integer> gidToCid) throws IOException {\n    // build CID2GIDMap, because the content stream has been written with the old GIDs\n    TreeMap<Integer, Integer> cidToGid = new TreeMap<>();\n    gidToCid.forEach((newGID, oldGID) -> cidToGid.put(oldGID, newGID));\n    // build unicode mapping before subsetting as the subsetted font won't have a cmap\n    buildToUnicodeCMap(gidToCid);\n    // build vertical metrics before subsetting as the subsetted font won't have vhea, vmtx\n    if (vertical) {\n        buildVerticalMetrics(cidToGid);\n    }\n    // rebuild the relevant part of the font\n    buildFontFile2(ttfSubset);\n    addNameTag(tag);\n    buildWidths(cidToGid);\n    buildCIDToGIDMap(cidToGid);\n    buildCIDSet(cidToGid);\n}", "/**\n * Builds vertical metrics with a custom CIDToGIDMap (for embedding font subset).\n */\nprivate void buildVerticalMetrics(TreeMap<Integer, Integer> cidToGid) throws IOException {\n    // The \"vhea\" and \"vmtx\" tables that specify vertical metrics shall never be used by a conforming\n    // reader. The only way to specify vertical metrics in PDF shall be by means of the DW2 and W2\n    // entries in a CIDFont dictionary.\n    if (!buildVerticalHeader(cidFont)) {\n        return;\n    }\n    float scaling = 1000.0F / ttf.getHeader().getUnitsPerEm();\n    VerticalHeaderTable vhea = ttf.getVerticalHeader();\n    VerticalMetricsTable vmtx = ttf.getVerticalMetrics();\n    GlyphTable glyf = ttf.getGlyph();\n    HorizontalMetricsTable hmtx = ttf.getHorizontalMetrics();\n    long v_y = Math.round(vhea.getAscender() * scaling);\n    long w1 = Math.round((-vhea.getAdvanceHeightMax()) * scaling);\n    COSArray heights = new COSArray();\n    COSArray w2 = new COSArray();\n    int prev = Integer.MIN_VALUE;\n    // Use a sorted list to get an optimal width array\n    Set<Integer> keys = cidToGid.keySet();\n    for (int cid : keys) {\n        // Unlike buildWidths, we look up with cid (not gid) here because this is\n        // the original TTF, not the rebuilt one.\n        GlyphData glyph = glyf.getGlyph(cid);\n        if (glyph == null) {\n            continue;\n        }\n        long height = Math.round((glyph.getYMaximum() + vmtx.getTopSideBearing(cid)) * scaling);\n        long advance = Math.round((-vmtx.getAdvanceHeight(cid)) * scaling);\n        if ((height == v_y) && (advance == w1)) {\n            // skip default metrics\n            continue;\n        }\n        // c [w1_1y v_1x v_1y w1_2y v_2x v_2y ... w1_ny v_nx v_ny]\n        if (prev != (cid - 1)) {\n            w2 = new COSArray();\n            heights.add(COSInteger.get(cid));// c\n\n            heights.add(w2);\n        }\n        w2.add(COSInteger.get(advance));// w1_iy\n\n        long width = Math.round(hmtx.getAdvanceWidth(cid) * scaling);\n        w2.add(COSInteger.get(width / 2));// v_ix\n\n        w2.add(COSInteger.get(height));// v_iy\n\n        prev = cid;\n    }\n    cidFont.setItem(COSName.W2, heights);\n}", "private boolean buildVerticalHeader(COSDictionary cidFont) throws IOException {\n    VerticalHeaderTable vhea = ttf.getVerticalHeader();\n    if (vhea == null) {\n        LOG.warn(\"Font to be subset is set to vertical, but has no 'vhea' table\");\n        return false;\n    }\n    float scaling = 1000.0F / ttf.getHeader().getUnitsPerEm();\n    long v = Math.round(vhea.getAscender() * scaling);\n    long w1 = Math.round((-vhea.getAdvanceHeightMax()) * scaling);\n    if ((v != 880) || (w1 != (-1000))) {\n        COSArray cosDw2 = new COSArray();\n        cosDw2.add(COSInteger.get(v));\n        cosDw2.add(COSInteger.get(w1));\n        cidFont.setItem(COSName.DW2, cosDw2);\n    }\n    return true;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType6.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    return getBounds(xform, matrix, 12);\n}", "Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    Rectangle2D bounds = null;\n    for (Patch patch : collectPatches(xform, matrix, controlPoints)) {\n        for (ShadedTriangle shadedTriangle : patch.listOfTriangles) {\n            if (bounds == null) {\n                bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n            }\n            bounds.add(shadedTriangle.corner[0]);\n            bounds.add(shadedTriangle.corner[1]);\n            bounds.add(shadedTriangle.corner[2]);\n        }\n    }\n    return bounds;\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances" ],
    "fullMethods" : [ "/**\n * Refreshes the appearance streams and appearance dictionaries for the widget annotations of the specified fields.\n *\n * @param fields\n * \t\ta list of fields to be refreshed\n * @throws IOException\n * \t\tif the appearance streams could not be refreshed\n */\npublic void refreshAppearances(List<PDField> fields) throws IOException {\n    for (PDField field : fields) {\n        if (field instanceof PDTerminalField) {\n            ((PDTerminalField) (field)).constructAppearances();\n        }\n    }\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.text.SetFontAndSize.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.text.SetFontAndSize.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws IOException {\n    if (arguments.size() < 2) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    COSBase base1 = arguments.get(1);\n    if (!(base0 instanceof COSName)) {\n        return;\n    }\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    COSName fontName = ((COSName) (base0));\n    float fontSize = ((COSNumber) (base1)).floatValue();\n    PDFStreamEngine context = getContext();\n    context.getGraphicsState().getTextState().setFontSize(fontSize);\n    PDFont font = context.getResources().getFont(fontName);\n    if (font == null) {\n        LOG.warn((\"font '\" + fontName.getName()) + \"' not found in resources\");\n    }\n    context.getGraphicsState().getTextState().setFont(font);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.refreshAppearances", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances" ],
    "fullMethods" : [ "/**\n * Refreshes the appearance streams and appearance dictionaries for the widget annotations of all fields.\n *\n * @throws IOException\n * \t\tif the appearance streams could not be refreshed\n */\npublic void refreshAppearances() throws IOException {\n    for (PDField field : getFieldTree()) {\n        if (field instanceof PDTerminalField) {\n            ((PDTerminalField) (field)).constructAppearances();\n        }\n    }\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.SecurityHandler.decryptStream" ],
    "fullMethods" : [ "/**\n * This will decrypt a stream.\n *\n * @param stream\n * \t\tThe stream to decrypt.\n * @param objNum\n * \t\tThe object number.\n * @param genNum\n * \t\tThe object generation number.\n * @throws IOException\n * \t\tIf there is an error getting the stream data.\n */\npublic void decryptStream(COSStream stream, long objNum, long genNum) throws IOException {\n    // Stream encrypted with identity filter\n    if (COSName.IDENTITY.equals(streamFilterName)) {\n        return;\n    }\n    COSBase type = stream.getCOSName(COSName.TYPE);\n    if ((!decryptMetadata) && COSName.METADATA.equals(type)) {\n        return;\n    }\n    // \"The cross-reference stream shall not be encrypted\"\n    if (COSName.XREF.equals(type)) {\n        return;\n    }\n    if (COSName.METADATA.equals(type)) {\n        byte[] buf;\n        // PDFBOX-3229 check case where metadata is not encrypted despite /EncryptMetadata missing\n        try (InputStream is = stream.createRawInputStream()) {\n            buf = new byte[10];\n            long isResult = IOUtils.populateBuffer(is, buf);\n            if (Long.compare(isResult, buf.length) != 0) {\n                LOG.debug((((\"Tried reading \" + buf.length) + \" bytes but only \") + isResult) + \" bytes read\");\n            }\n        }\n        if (Arrays.equals(buf, \"<?xpacket \".getBytes(StandardCharsets.ISO_8859_1))) {\n            LOG.warn(\"Metadata is not encrypted, but was expected to be\");\n            LOG.warn(\"Read PDF specification about EncryptMetadata (default value: true)\");\n            return;\n        }\n    }\n    decryptDictionary(stream, objNum, genNum);\n    // the input and the output stream of a still encrypted COSStream aren't no longer based\n    // on the same object so that it is safe to omit the intermediate ByteArrayStream\n    // \n    try (InputStream encryptedStream = stream.createRawInputStream();OutputStream output = stream.createRawOutputStream()) {\n        /* decrypt */\n        encryptData(objNum, genNum, encryptedStream, output, true);\n    } catch (IOException ex) {\n        LOG.error(((((ex.getClass().getSimpleName() + \" thrown when decrypting object \") + objNum) + \" \") + genNum) + \" obj\");\n        throw ex;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFMergerUtility.appendDocument" ],
    "fullMethods" : [ "/**\n * append all pages from source to destination.\n *\n * @param destination\n * \t\tthe document to receive the pages\n * @param source\n * \t\tthe document originating the new pages\n * @throws IOException\n * \t\tIf there is an error accessing data from either\n * \t\tdocument.\n */\npublic void appendDocument(PDDocument destination, PDDocument source) throws IOException {\n    PDFCloneUtility cloner = new PDFCloneUtility(destination);\n    if (source.getDocument().isClosed()) {\n        throw new IOException(\"Error: source PDF is closed.\");\n    }\n    if (destination.getDocument().isClosed()) {\n        throw new IOException(\"Error: destination PDF is closed.\");\n    }\n    PDDocumentCatalog srcCatalog = source.getDocumentCatalog();\n    if (isDynamicXfa(srcCatalog.getAcroForm())) {\n        throw new IOException(\"Error: can't merge source document containing dynamic XFA form content.\");\n    }\n    PDDocumentInformation destInfo = destination.getDocumentInformation();\n    PDDocumentInformation srcInfo = source.getDocumentInformation();\n    mergeInto(srcInfo.getCOSObject(), destInfo.getCOSObject(), cloner, Collections.emptySet());\n    // use the highest version number for the resulting pdf\n    float destVersion = destination.getVersion();\n    float srcVersion = source.getVersion();\n    if (destVersion < srcVersion) {\n        destination.setVersion(srcVersion);\n    }\n    PDDocumentCatalog destCatalog = destination.getDocumentCatalog();\n    mergeAcroForm(cloner, destCatalog, srcCatalog);\n    COSArray destThreads = destCatalog.getCOSObject().getCOSArray(COSName.THREADS);\n    COSArray srcThreads = cloner.cloneForNewDocument(destCatalog.getCOSObject().getCOSArray(COSName.THREADS));\n    if (destThreads == null) {\n        destCatalog.getCOSObject().setItem(COSName.THREADS, srcThreads);\n    } else {\n        destThreads.addAll(srcThreads);\n    }\n    PDDocumentNameDictionary destNames = destCatalog.getNames();\n    PDDocumentNameDictionary srcNames = srcCatalog.getNames();\n    if (srcNames != null) {\n        if (destNames == null) {\n            destCatalog.getCOSObject().setItem(COSName.NAMES, cloner.cloneForNewDocument(srcNames.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcNames, destNames);\n        }\n    }\n    if ((destNames != null) && destNames.getCOSObject().containsKey(COSName.ID_TREE)) {\n        // found in 001031.pdf from PDFBOX-4417 and doesn't belong there\n        destNames.getCOSObject().removeItem(COSName.ID_TREE);\n        LOG.warn(\"Removed /IDTree from /Names dictionary, doesn't belong there\");\n    }\n    PDDocumentNameDestinationDictionary srcDests = srcCatalog.getDests();\n    if (srcDests != null) {\n        PDDocumentNameDestinationDictionary destDests = destCatalog.getDests();\n        if (destDests == null) {\n            destCatalog.getCOSObject().setItem(COSName.DESTS, cloner.cloneForNewDocument(srcDests.getCOSObject()));\n        } else {\n            cloner.cloneMerge(srcDests, destDests);\n        }\n    }\n    PDDocumentOutline srcOutline = srcCatalog.getDocumentOutline();\n    if (srcOutline != null) {\n        PDDocumentOutline destOutline = destCatalog.getDocumentOutline();\n        if ((destOutline == null) || (destOutline.getFirstChild() == null)) {\n            PDDocumentOutline cloned = new PDDocumentOutline(cloner.cloneForNewDocument(srcOutline.getCOSObject()));\n            destCatalog.setDocumentOutline(cloned);\n        } else {\n            // search last sibling for dest, because /Last entry is sometimes wrong\n            PDOutlineItem destLastOutlineItem = destOutline.getFirstChild();\n            while (true) {\n                PDOutlineItem outlineItem = destLastOutlineItem.getNextSibling();\n                if (outlineItem == null) {\n                    break;\n                }\n                destLastOutlineItem = outlineItem;\n            } \n            for (PDOutlineItem item : srcOutline.children()) {\n                // get each child, clone its dictionary, remove siblings info,\n                // append outline item created from there\n                COSDictionary clonedDict = cloner.cloneForNewDocument(item.getCOSObject());\n                clonedDict.removeItem(COSName.PREV);\n                clonedDict.removeItem(COSName.NEXT);\n                PDOutlineItem clonedItem = new PDOutlineItem(clonedDict);\n                destLastOutlineItem.insertSiblingAfter(clonedItem);\n                destLastOutlineItem = destLastOutlineItem.getNextSibling();\n            }\n        }\n    }\n    PageMode destPageMode = destCatalog.getPageMode();\n    if (destPageMode == null) {\n        PageMode srcPageMode = srcCatalog.getPageMode();\n        destCatalog.setPageMode(srcPageMode);\n    }\n    COSDictionary srcLabels = srcCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n    if (srcLabels != null) {\n        int destPageCount = destination.getNumberOfPages();\n        COSArray destNums;\n        COSDictionary destLabels = destCatalog.getCOSObject().getCOSDictionary(COSName.PAGE_LABELS);\n        if (destLabels == null) {\n            destLabels = new COSDictionary();\n            destNums = new COSArray();\n            destLabels.setItem(COSName.NUMS, destNums);\n            destCatalog.getCOSObject().setItem(COSName.PAGE_LABELS, destLabels);\n        } else {\n            destNums = destLabels.getCOSArray(COSName.NUMS);\n        }\n        COSArray srcNums = srcLabels.getCOSArray(COSName.NUMS);\n        if (srcNums != null) {\n            int startSize = destNums.size();\n            for (int i = 0; i < srcNums.size(); i += 2) {\n                COSBase base = srcNums.getObject(i);\n                if (!(base instanceof COSNumber)) {\n                    LOG.error(((\"page labels ignored, index \" + i) + \" should be a number, but is \") + base);\n                    // remove what we added\n                    while (destNums.size() > startSize) {\n                        destNums.remove(startSize);\n                    } \n                    break;\n                }\n                COSNumber labelIndex = ((COSNumber) (base));\n                long labelIndexValue = labelIndex.intValue();\n                destNums.add(COSInteger.get(labelIndexValue + destPageCount));\n                destNums.add(cloner.cloneForNewDocument(srcNums.getObject(i + 1)));\n            }\n        }\n    }\n    COSStream destMetadata = destCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    COSStream srcMetadata = srcCatalog.getCOSObject().getCOSStream(COSName.METADATA);\n    if ((destMetadata == null) && (srcMetadata != null)) {\n        try {\n            PDStream newStream = new PDStream(destination, srcMetadata.createInputStream(), ((COSName) (null)));\n            mergeInto(srcMetadata, newStream.getCOSObject(), cloner, new HashSet<>(Arrays.asList(COSName.FILTER, COSName.LENGTH)));\n            destCatalog.getCOSObject().setItem(COSName.METADATA, newStream);\n        } catch (IOException ex) {\n            // PDFBOX-4227 cleartext XMP stream with /Flate\n            LOG.error(\"Metadata skipped because it could not be read\", ex);\n        }\n    }\n    COSDictionary destOCP = destCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    COSDictionary srcOCP = srcCatalog.getCOSObject().getCOSDictionary(COSName.OCPROPERTIES);\n    if ((destOCP == null) && (srcOCP != null)) {\n        destCatalog.getCOSObject().setItem(COSName.OCPROPERTIES, cloner.cloneForNewDocument(srcOCP));\n    } else if ((destOCP != null) && (srcOCP != null)) {\n        cloner.cloneMerge(srcOCP, destOCP);\n    }\n    mergeOutputIntents(srcCatalog, destCatalog, cloner);\n    // merge logical structure hierarchy\n    boolean mergeStructTree = false;\n    int destParentTreeNextKey = -1;\n    Map<Integer, COSObjectable> srcNumberTreeAsMap = null;\n    Map<Integer, COSObjectable> destNumberTreeAsMap = null;\n    PDStructureTreeRoot srcStructTree = srcCatalog.getStructureTreeRoot();\n    PDStructureTreeRoot destStructTree = destCatalog.getStructureTreeRoot();\n    if ((destStructTree == null) && (srcStructTree != null)) {\n        // create a dummy structure tree in the destination, so that the source\n        // tree is cloned. (We can't just copy the tree reference due to PDFBOX-3999)\n        destStructTree = new PDStructureTreeRoot();\n        destCatalog.setStructureTreeRoot(destStructTree);\n        destStructTree.setParentTree(new PDNumberTreeNode(PDParentTreeValue.class));\n        // PDFBOX-4429: remove bogus StructParent(s)\n        for (PDPage page : destCatalog.getPages()) {\n            page.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : page.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n    }\n    if (destStructTree != null) {\n        PDNumberTreeNode destParentTree = destStructTree.getParentTree();\n        destParentTreeNextKey = destStructTree.getParentTreeNextKey();\n        if (destParentTree != null) {\n            destNumberTreeAsMap = getNumberTreeAsMap(destParentTree);\n            if (destParentTreeNextKey < 0) {\n                if (destNumberTreeAsMap.isEmpty()) {\n                    destParentTreeNextKey = 0;\n                } else {\n                    destParentTreeNextKey = Collections.max(destNumberTreeAsMap.keySet()) + 1;\n                }\n            }\n            if ((destParentTreeNextKey >= 0) && (srcStructTree != null)) {\n                PDNumberTreeNode srcParentTree = srcStructTree.getParentTree();\n                if (srcParentTree != null) {\n                    srcNumberTreeAsMap = getNumberTreeAsMap(srcParentTree);\n                    if (!srcNumberTreeAsMap.isEmpty()) {\n                        mergeStructTree = true;\n                    }\n                }\n            }\n        }\n    }\n    Map<COSDictionary, COSDictionary> objMapping = new HashMap<>();\n    PDPageTree destinationPageTree = destination.getPages();// cache PageTree\n\n    for (PDPage page : srcCatalog.getPages()) {\n        PDPage newPage = new PDPage(cloner.cloneForNewDocument(page.getCOSObject()));\n        if (!mergeStructTree) {\n            // PDFBOX-4429: remove bogus StructParent(s)\n            newPage.getCOSObject().removeItem(COSName.STRUCT_PARENTS);\n            for (PDAnnotation ann : newPage.getAnnotations()) {\n                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);\n            }\n        }\n        newPage.setCropBox(page.getCropBox());\n        newPage.setMediaBox(page.getMediaBox());\n        newPage.setRotation(page.getRotation());\n        PDResources resources = page.getResources();\n        if (resources != null) {\n            // this is smart enough to just create references for resources that are used on multiple pages\n            newPage.setResources(new PDResources(cloner.cloneForNewDocument(resources.getCOSObject())));\n        } else {\n            newPage.setResources(new PDResources());\n        }\n        if (mergeStructTree) {\n            // add the value of the destination ParentTreeNextKey to every source element\n            // StructParent(s) value so that these don't overlap with the existing values\n            updateStructParentEntries(newPage, destParentTreeNextKey);\n            objMapping.put(page.getCOSObject(), newPage.getCOSObject());\n            List<PDAnnotation> oldAnnots = page.getAnnotations();\n            List<PDAnnotation> newAnnots = newPage.getAnnotations();\n            for (int i = 0; i < oldAnnots.size(); i++) {\n                objMapping.put(oldAnnots.get(i).getCOSObject(), newAnnots.get(i).getCOSObject());\n            }\n            // TODO update mapping for XObjects\n        }\n        destinationPageTree.add(newPage);\n    }\n    mergeOpenAction(srcCatalog, destCatalog, cloner);\n    if (mergeStructTree) {\n        updatePageReferences(cloner, srcNumberTreeAsMap, objMapping);\n        int maxSrcKey = -1;\n        for (Map.Entry<Integer, COSObjectable> entry : srcNumberTreeAsMap.entrySet()) {\n            int srcKey = entry.getKey();\n            maxSrcKey = Math.max(srcKey, maxSrcKey);\n            COSObjectable value = entry.getValue();\n            if (value != null) {\n                value = cloner.cloneForNewDocument(value.getCOSObject());\n                destNumberTreeAsMap.put(destParentTreeNextKey + srcKey, value);\n            }\n        }\n        destParentTreeNextKey += maxSrcKey + 1;\n        PDNumberTreeNode newParentTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);\n        // Note that all elements are stored flatly. This could become a problem for large files\n        // when these are opened in a viewer that uses the tagging information.\n        // If this happens, then PDNumberTreeNode should be improved with a convenience method that\n        // stores the map into a B+Tree, see https://en.wikipedia.org/wiki/B+_tree\n        newParentTreeNode.setNumbers(destNumberTreeAsMap);\n        destStructTree.setParentTree(newParentTreeNode);\n        destStructTree.setParentTreeNextKey(destParentTreeNextKey);\n        mergeKEntries(cloner, srcStructTree, destStructTree);\n        mergeRoleMap(srcStructTree, destStructTree, cloner);\n        mergeIDTree(cloner, srcStructTree, destStructTree);\n        mergeMarkInfo(destCatalog, srcCatalog);\n        mergeLanguage(destCatalog, srcCatalog);\n        mergeViewerPreferences(destCatalog, srcCatalog, cloner);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType0.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param parent\n * \t\tThe parent font.\n * @throws IOException\n * \t\tif the font could not be read\n */\npublic PDCIDFontType0(COSDictionary fontDictionary, PDType0Font parent) throws IOException {\n    super(fontDictionary, parent);\n    boolean fontIsDamaged = false;\n    CFFFont cffFont = null;\n    PDFontDescriptor fd = getFontDescriptor();\n    if (fd != null) {\n        PDStream ff3Stream = fd.getFontFile3();\n        if (ff3Stream != null) {\n            try (RandomAccessRead randomAccessRead = ff3Stream.getCOSObject().createView()) {\n                if ((randomAccessRead.length() > 0) && (randomAccessRead.peek() == '%')) {\n                    // PDFBOX-2642 contains a corrupt PFB font instead of a CFF\n                    LOG.warn(\"Found PFB but expected embedded CFF font \" + fd.getFontName());\n                    fontIsDamaged = true;\n                } else {\n                    CFFParser cffParser = new CFFParser();\n                    cffFont = cffParser.parse(randomAccessRead).get(0);\n                }\n            } catch (IOException e) {\n                LOG.error(\"Can't read the embedded CFF font \" + fd.getFontName(), e);\n                fontIsDamaged = true;\n            }\n        }\n    }\n    if (cffFont != null) {\n        // embedded\n        if (cffFont instanceof CFFCIDFont) {\n            cidFont = ((CFFCIDFont) (cffFont));\n            t1Font = null;\n        } else {\n            cidFont = null;\n            t1Font = cffFont;\n        }\n        cid2gid = readCIDToGIDMap();\n        isEmbedded = true;\n        isDamaged = false;\n    } else {\n        // find font or substitute\n        CIDFontMapping mapping = FontMappers.instance().getCIDFont(getBaseFont(), getFontDescriptor(), getCIDSystemInfo());\n        FontBoxFont font;\n        if (mapping.isCIDFont()) {\n            cffFont = mapping.getFont().getCFF().getFont();\n            if (cffFont instanceof CFFCIDFont) {\n                cidFont = ((CFFCIDFont) (cffFont));\n                t1Font = null;\n                font = cidFont;\n            } else {\n                // PDFBOX-3515: OpenType fonts are loaded as CFFType1Font\n                CFFType1Font f = ((CFFType1Font) (cffFont));\n                cidFont = null;\n                t1Font = f;\n                font = f;\n            }\n        } else {\n            cidFont = null;\n            t1Font = mapping.getTrueTypeFont();\n            font = t1Font;\n        }\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback \" + font.getName()) + \" for CID-keyed font \") + getBaseFont());\n        }\n        isEmbedded = false;\n        isDamaged = fontIsDamaged;\n    }\n    fontMatrixTransform = getFontMatrix().createAffineTransform();\n    fontMatrixTransform.scale(1000, 1000);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRGBImage", "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.getNumberOfComponents" ],
    "fullMethods" : [ "/**\n * Returns the content of the given image as an AWT buffered image with an RGB color space.\n * If a color key mask is provided then an ARGB image is returned instead.\n * This method never returns null.\n *\n * @param pdImage\n * \t\tthe image to read\n * @param region\n * \t\tThe region of the source image to get, or null if the entire image is needed.\n * \t\tThe actual region will be clipped to the dimensions of the source image.\n * @param subsampling\n * \t\tThe amount of rows and columns to advance for every output pixel, a value\n * \t\tof 1 meaning every pixel will be read. It must not be larger than the image width or height.\n * @param colorKey\n * \t\tan optional color key mask\n * @return content of this image as an (A)RGB buffered image\n * @throws IOException\n * \t\tif the image cannot be read\n */\npublic static BufferedImage getRGBImage(PDImage pdImage, Rectangle region, int subsampling, COSArray colorKey) throws IOException {\n    if (pdImage.isEmpty()) {\n        throw new IOException(\"Image stream is empty\");\n    }\n    Rectangle clipped = clipRegion(pdImage, region);\n    // get parameters, they must be valid or have been repaired\n    final PDColorSpace colorSpace = pdImage.getColorSpace();\n    final int numComponents = colorSpace.getNumberOfComponents();\n    final int width = ((int) (Math.ceil(clipped.getWidth() / subsampling)));\n    final int height = ((int) (Math.ceil(clipped.getHeight() / subsampling)));\n    final int bitsPerComponent = pdImage.getBitsPerComponent();\n    if ((((width <= 0) || (height <= 0)) || (pdImage.getWidth() <= 0)) || (pdImage.getHeight() <= 0)) {\n        throw new IOException(\"image width and height must be positive\");\n    }\n    try {\n        if (((bitsPerComponent == 1) && (colorKey == null)) && (numComponents == 1)) {\n            return from1Bit(pdImage, clipped, subsampling, width, height);\n        }\n        // An AWT raster must use 8/16/32 bits per component. Images with < 8bpc\n        // will be unpacked into a byte-backed raster. Images with 16bpc will be reduced\n        // in depth to 8bpc as they will be drawn to TYPE_INT_RGB images anyway. All code\n        // in PDColorSpace#toRGBImage expects an 8-bit range, i.e. 0-255.\n        // Interleaved raster allows chunk-copying for 8-bit images.\n        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, width, height, numComponents, new Point(0, 0));\n        final float[] defaultDecode = pdImage.getColorSpace().getDefaultDecode(8);\n        final float[] decode = getDecodeArray(pdImage);\n        if (((bitsPerComponent == 8) && (colorKey == null)) && Arrays.equals(decode, defaultDecode)) {\n            // convert image, faster path for non-decoded, non-colormasked 8-bit images\n            return from8bit(pdImage, raster, clipped, subsampling, width, height);\n        }\n        return fromAny(pdImage, raster, colorKey, clipped, subsampling, width, height);\n    } catch (NegativeArraySizeException | IllegalArgumentException ex) {\n        throw new IOException(ex);\n    }\n}", "@Override\npublic int getNumberOfComponents() {\n    if (numberOfComponents < 0) {\n        numberOfComponents = stream.getCOSObject().getInt(COSName.N);\n        // PDFBOX-4801 correct wrong /N values\n        if (iccProfile != null) {\n            int numIccComponents = iccProfile.getNumComponents();\n            if (numIccComponents != numberOfComponents) {\n                LOG.warn((((\"Using \" + numIccComponents) + \" components from ICC profile info instead of \") + numberOfComponents) + \" components from /N entry\");\n                numberOfComponents = numIccComponents;\n            }\n        }\n    }\n    return numberOfComponents;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.insertSiblingBefore",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.insertSiblingBefore", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCountForAddedChild", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount" ],
    "fullMethods" : [ "/**\n * Insert a single sibling before this node.\n *\n * @param newSibling\n * \t\tThe item to insert.\n * @throws IllegalArgumentException\n * \t\tif the given sibling node is part of a list\n * \t\t(i.e. if it has a previous or a next sibling)\n */\npublic void insertSiblingBefore(PDOutlineItem newSibling) {\n    requireSingleNode(newSibling);\n    PDOutlineNode parent = getParent();\n    newSibling.setParent(parent);\n    PDOutlineItem previous = getPreviousSibling();\n    setPreviousSibling(newSibling);\n    newSibling.setNextSibling(this);\n    if (previous != null) {\n        previous.setNextSibling(newSibling);\n        newSibling.setPreviousSibling(previous);\n    } else if (parent != null) {\n        getParent().setFirstChild(newSibling);\n    }\n    updateParentOpenCountForAddedChild(newSibling);\n}", "void updateParentOpenCountForAddedChild(PDOutlineItem newChild) {\n    int delta = 1;\n    if (newChild.isNodeOpen()) {\n        delta += newChild.getOpenCount();\n    }\n    newChild.updateParentOpenCount(delta);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getKids",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getKids" ],
    "fullMethods" : [ "/**\n * Return the children of this node.  This list will contain PDNameTreeNode objects.\n *\n * @return The list of children or null if there are no children.\n */\npublic List<PDNameTreeNode<T>> getKids() {\n    List<PDNameTreeNode<T>> retval = null;\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids != null) {\n        List<PDNameTreeNode<T>> pdObjects = new ArrayList<>(kids.size());\n        for (int i = 0; i < kids.size(); i++) {\n            COSBase base = kids.getObject(i);\n            PDNameTreeNode<T> childNode;\n            if (base instanceof COSDictionary) {\n                childNode = createChildNode(((COSDictionary) (base)));\n            } else {\n                LOG.warn(\"Bad child node at position \" + i);\n                childNode = createChildNode(new COSDictionary());\n            }\n            pdObjects.add(childNode);\n        }\n        retval = new COSArrayList<>(pdObjects, kids);\n    }\n    return retval;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType0Font.readEncoding" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param ttf\n * \t\tA TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding. Set this to false when creating a font for\n * \t\tAcroForm.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font load(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException {\n    return new PDType0Font(doc, ttf, embedSubset, false, false);\n}", "/**\n * Private. Creates a new PDType0Font font for embedding.\n *\n * @param document\n * @param ttf\n * @param embedSubset\n * @param closeTTF\n * \t\twhether to close the ttf parameter after embedding. Must be true when the ttf\n * \t\tparameter was created in the load() method, false when the ttf parameter was passed to the\n * \t\tload() method.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @throws IOException\n */\nprivate PDType0Font(PDDocument document, TrueTypeFont ttf, boolean embedSubset, boolean closeTTF, boolean vertical) throws IOException {\n    if (vertical) {\n        ttf.enableVerticalSubstitutions();\n    }\n    gsubData = ttf.getGsubData();\n    cmapLookup = ttf.getUnicodeCmapLookup();\n    embedder = new PDCIDFontType2Embedder(document, dict, ttf, embedSubset, this, vertical);\n    descendantFont = embedder.getCIDFont();\n    readEncoding();\n    fetchCMapUCS2();\n    if (closeTTF) {\n        if (embedSubset) {\n            this.ttf = ttf;\n            document.registerTrueTypeFontForClosing(ttf);\n        } else {\n            // the TTF is fully loaded and it is safe to close the underlying data source\n            ttf.close();\n        }\n    }\n}", "/**\n * Reads the font's Encoding entry, which should be a CMap name/stream.\n */\nprivate void readEncoding() throws IOException {\n    COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);\n    if (encoding instanceof COSName) {\n        // predefined CMap\n        COSName encodingName = ((COSName) (encoding));\n        cMap = CMapManager.getPredefinedCMap(encodingName.getName());\n        isCMapPredefined = true;\n    } else if (encoding != null) {\n        cMap = readCMap(encoding);\n        if (cMap == null) {\n            throw new IOException(\"Missing required CMap\");\n        } else if (!cMap.hasCIDMappings()) {\n            LOG.warn(\"Invalid Encoding CMap in font \" + getName());\n        }\n    }\n    // check if the descendant font is CJK\n    PDCIDSystemInfo ros = descendantFont.getCIDSystemInfo();\n    if (ros != null) {\n        String ordering = ros.getOrdering();\n        isDescendantCJK = \"Adobe\".equals(ros.getRegistry()) && (((\"GB1\".equals(ordering) || \"CNS1\".equals(ordering)) || \"Japan1\".equals(ordering)) || \"Korea1\".equals(ordering));\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.get",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.get", "org.apache.pdfbox.pdmodel.PDPageTree.get", "org.apache.pdfbox.pdmodel.PDPageTree.getKids" ],
    "fullMethods" : [ "/**\n * Returns the page at the given index.\n *\n * @param index\n * \t\tzero-based index\n * @return the page at the given index\n * @throws IllegalStateException\n * \t\tif the requested index isn't found or doesn't point to a valid page dictionary\n * @throws IndexOutOfBoundsException\n * \t\tif the requested index is higher than the page count\n */\npublic PDPage get(int index) {\n    COSDictionary dict = get(index + 1, root, 0);\n    sanitizeType(dict);\n    ResourceCache resourceCache = (document != null) ? document.getResourceCache() : null;\n    return new PDPage(dict, resourceCache);\n}", "/**\n * Returns the given COS page using a depth-first search.\n *\n * @param pageNum\n * \t\t1-based page number\n * @param node\n * \t\tpage tree node to search\n * @param encountered\n * \t\tnumber of pages encountered so far\n * @return COS dictionary of the Page object\n * @throws IllegalStateException\n * \t\tif the requested page number isn't found\n * @throws IndexOutOfBoundsException\n * \t\tif the requested page number is higher than the page count\n */\nprivate COSDictionary get(int pageNum, COSDictionary node, int encountered) {\n    if (pageNum < 1) {\n        throw new IndexOutOfBoundsException(\"Index out of bounds: \" + pageNum);\n    }\n    if (pageSet.contains(node)) {\n        pageSet.clear();\n        throw new IllegalStateException(\"Possible recursion found when searching for page \" + pageNum);\n    } else {\n        // collect already processed pages to detect possible recursions\n        // to avoid a StackOverflowError\n        pageSet.add(node);\n    }\n    if (isPageTreeNode(node)) {\n        int count = node.getInt(COSName.COUNT, 0);\n        if (pageNum <= (encountered + count)) {\n            // it's a kid of this node\n            for (COSDictionary kid : getKids(node)) {\n                // which kid?\n                if (isPageTreeNode(kid)) {\n                    int kidCount = kid.getInt(COSName.COUNT, 0);\n                    if (pageNum <= (encountered + kidCount)) {\n                        // it's this kid\n                        return get(pageNum, kid, encountered);\n                    } else {\n                        encountered += kidCount;\n                    }\n                } else {\n                    // single page\n                    encountered++;\n                    if (pageNum == encountered) {\n                        // it's this page\n                        return get(pageNum, kid, encountered);\n                    }\n                }\n            }\n            throw new IllegalStateException(\"1-based index not found: \" + pageNum);\n        } else {\n            throw new IndexOutOfBoundsException(\"1-based index out of bounds: \" + pageNum);\n        }\n    } else if (encountered == pageNum) {\n        pageSet.clear();\n        return node;\n    } else {\n        throw new IllegalStateException(\"1-based index not found: \" + pageNum);\n    }\n}", "/**\n * Helper to get kids from malformed PDFs.\n *\n * @param node\n * \t\tpage tree node\n * @return list of kids\n */\nprivate List<COSDictionary> getKids(COSDictionary node) {\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // probably a malformed PDF\n        return Collections.emptyList();\n    }\n    int size = kids.size();\n    List<COSDictionary> result = new ArrayList<>(size);\n    for (int i = 0; i < size; i++) {\n        COSBase base = kids.getObject(i);\n        if (base instanceof COSDictionary) {\n            result.add(((COSDictionary) (base)));\n        } else if (base == null) {\n            LOG.warn(\"replaced null entry with an empty page\");\n            COSDictionary emptyPage = new COSDictionary();\n            emptyPage.setItem(COSName.TYPE, COSName.PAGE);\n            kids.set(i, emptyPage);\n            result.add(emptyPage);\n        } else {\n            LOG.warn(\"COSDictionary expected, but got \" + base.getClass().getSimpleName());\n        }\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.addLast",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.addLast", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCountForAddedChild", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount" ],
    "fullMethods" : [ "/**\n * Adds the given node to the bottom of the children list.\n *\n * @param newChild\n * \t\tThe node to add.\n * @throws IllegalArgumentException\n * \t\tif the given node is part of a list (i.e. if it has a previous or a next\n * \t\tsibling)\n */\npublic void addLast(PDOutlineItem newChild) {\n    requireSingleNode(newChild);\n    append(newChild);\n    updateParentOpenCountForAddedChild(newChild);\n}", "void updateParentOpenCountForAddedChild(PDOutlineItem newChild) {\n    int delta = 1;\n    if (newChild.isNodeOpen()) {\n        delta += newChild.getOpenCount();\n    }\n    newChild.updateParentOpenCount(delta);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.flatten",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.flatten" ],
    "fullMethods" : [ "/**\n * This will flatten the specified form fields.\n *\n * <p>\n * Flattening a form field will take the current appearance and make that part of the pages content stream. All form\n * fields and annotations associated are removed.\n * </p>\n *\n * <p>\n * Invisible and hidden fields will be skipped and will not become part of the page content stream\n * </p>\n *\n * @param fields\n * \t\ta list of fields to be flattened\n * @param refreshAppearances\n * \t\tif set to true the appearances for the form field widgets will be updated\n * @throws IOException\n * \t\tif something went wrong flattening the fields\n */\npublic void flatten(List<PDField> fields, boolean refreshAppearances) throws IOException {\n    // Nothing to flatten if there are no fields provided\n    if (fields.isEmpty()) {\n        return;\n    }\n    if ((!refreshAppearances) && getNeedAppearances()) {\n        LOG.warn(\"acroForm.getNeedAppearances() returns true, \" + \"visual field appearances may not have been set\");\n        LOG.warn(\"call acroForm.refreshAppearances() or \" + \"use the flatten() method with refreshAppearances parameter\");\n    }\n    // for dynamic XFA forms there is no flatten as this would mean to do a rendering\n    // from the XFA content into a static PDF.\n    if (xfaIsDynamic()) {\n        LOG.warn(\"Flatten for a dynamix XFA form is not supported\");\n        return;\n    }\n    // refresh the appearances if set\n    if (refreshAppearances) {\n        refreshAppearances(fields);\n    }\n    PDPageTree pages = document.getPages();\n    Map<COSDictionary, Set<COSDictionary>> pagesWidgetsMap = buildPagesWidgetsMap(fields, pages);\n    // preserve all non widget annotations\n    for (PDPage page : pages) {\n        Set<COSDictionary> widgetsForPageMap = pagesWidgetsMap.get(page.getCOSObject());\n        // indicates if the original content stream\n        // has been wrapped in a q...Q pair.\n        boolean isContentStreamWrapped = false;\n        List<PDAnnotation> annotations = new ArrayList<>();\n        for (PDAnnotation annotation : page.getAnnotations()) {\n            if ((widgetsForPageMap == null) || (!widgetsForPageMap.contains(annotation.getCOSObject()))) {\n                annotations.add(annotation);\n            } else if (isVisibleAnnotation(annotation)) {\n                try (PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, true, !isContentStreamWrapped)) {\n                    isContentStreamWrapped = true;\n                    PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();\n                    PDFormXObject fieldObject = new PDFormXObject(appearanceStream.getCOSObject());\n                    contentStream.saveGraphicsState();\n                    // see https://stackoverflow.com/a/54091766/1729265 for an explanation\n                    // of the steps required\n                    // this will transform the appearance stream form object into the rectangle of the\n                    // annotation bbox and map the coordinate systems\n                    Matrix transformationMatrix = resolveTransformationMatrix(annotation, appearanceStream);\n                    contentStream.transform(transformationMatrix);\n                    contentStream.drawForm(fieldObject);\n                    contentStream.restoreGraphicsState();\n                }\n            }\n        }\n        page.setAnnotations(annotations);\n    }\n    // remove the fields\n    removeFields(fields);\n    // remove XFA for hybrid forms\n    dictionary.removeItem(COSName.XFA);\n    // remove SigFlags if no signature left\n    if (this.document.getSignatureDictionaries().isEmpty()) {\n        this.getCOSObject().removeItem(COSName.SIG_FLAGS);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRawRaster",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getRawRaster", "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.getNumberOfComponents" ],
    "fullMethods" : [ "/**\n * Extract the raw unconverted raster of the given image\n *\n * @param pdImage\n * \t\tThe image to get the raw raster data from\n * @return the raw raster of this image\n * @throws IOException\n */\npublic static WritableRaster getRawRaster(PDImage pdImage) throws IOException {\n    if (pdImage.isEmpty()) {\n        throw new IOException(\"Image stream is empty\");\n    }\n    // get parameters, they must be valid or have been repaired\n    final PDColorSpace colorSpace = pdImage.getColorSpace();\n    final int numComponents = colorSpace.getNumberOfComponents();\n    final int width = pdImage.getWidth();\n    final int height = pdImage.getHeight();\n    final int bitsPerComponent = pdImage.getBitsPerComponent();\n    if ((width <= 0) || (height <= 0)) {\n        throw new IOException(\"image width and height must be positive\");\n    }\n    try {\n        int dataBufferType = DataBuffer.TYPE_BYTE;\n        if (bitsPerComponent > 8) {\n            dataBufferType = DataBuffer.TYPE_USHORT;\n        }\n        WritableRaster raster = Raster.createInterleavedRaster(dataBufferType, width, height, numComponents, new Point(0, 0));\n        readRasterFromAny(pdImage, raster);\n        return raster;\n    } catch (NegativeArraySizeException | IllegalArgumentException ex) {\n        throw new IOException(ex);\n    }\n}", "@Override\npublic int getNumberOfComponents() {\n    if (numberOfComponents < 0) {\n        numberOfComponents = stream.getCOSObject().getInt(COSName.N);\n        // PDFBOX-4801 correct wrong /N values\n        if (iccProfile != null) {\n            int numIccComponents = iccProfile.getNumComponents();\n            if (numIccComponents != numberOfComponents) {\n                LOG.warn((((\"Using \" + numIccComponents) + \" components from ICC profile info instead of \") + numberOfComponents) + \" components from /N entry\");\n                numberOfComponents = numIccComponents;\n            }\n        }\n    }\n    return numberOfComponents;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.setStartPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.setStartPage" ],
    "fullMethods" : [ "/**\n * This will set the first page to be extracted by this class.\n *\n * @param startPageValue\n * \t\tNew value of 1-based startPage property.\n */\npublic void setStartPage(int startPageValue) {\n    if (startPageValue <= 0) {\n        LOG.warn(\"Parameter must be 1-based, but is \" + startPageValue);\n    }\n    startPage = startPageValue;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.setFont" ],
    "fullMethods" : [ "/**\n * Set the font and font size to draw text with.\n *\n * @param font\n * \t\tThe font to use.\n * @param fontSize\n * \t\tThe font size to draw the text.\n * @throws IOException\n * \t\tIf there is an error writing the font information.\n */\npublic void setFont(PDFont font, float fontSize) throws IOException {\n    if (fontStack.isEmpty()) {\n        fontStack.add(font);\n    } else {\n        fontStack.pop();\n        fontStack.push(font);\n    }\n    // keep track of fonts which are configured for subsetting\n    if (font.willBeSubset()) {\n        if (document != null) {\n            document.getFontsToSubset().add(font);\n        } else {\n            LOG.warn((\"Using the subsetted font '\" + font.getName()) + \"' without a PDDocument context; call subset() before saving\");\n        }\n    } else if ((!font.isEmbedded()) && (!font.isStandard14())) {\n        LOG.warn((\"attempting to use font '\" + font.getName()) + \"' that isn't embedded\");\n    }\n    // complex text layout\n    if (font instanceof PDType0Font) {\n        PDType0Font type0Font = ((PDType0Font) (font));\n        GsubData gsubData = type0Font.getGsubData();\n        if (gsubData != GsubData.NO_DATA_FOUND) {\n            GsubWorker gsubWorker = gsubWorkerFactory.getGsubWorker(type0Font.getCmapLookup(), gsubData);\n            gsubWorkers.put(((PDType0Font) (font)), gsubWorker);\n        } else if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No GSUB data found in font\" + font.getName());\n        }\n    }\n    writeOperand(resources.add(font));\n    writeOperand(fontSize);\n    writeOperator(OperatorName.SET_FONT_AND_SIZE);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.codeToGID",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.codeToGID" ],
    "fullMethods" : [ "/**\n * Returns the GID for the given character code.\n *\n * @param code\n * \t\tcharacter code\n * @return GID\n * @throws IOException\n * \t\tif the mapping could not be read\n */\n@Override\npublic int codeToGID(int code) throws IOException {\n    if (!isEmbedded) {\n        // The conforming reader shall select glyphs by translating characters from the\n        // encoding specified by the predefined CMap to one of the encodings in the TrueType\n        // font's 'cmap' table. The means by which this is accomplished are implementation-\n        // dependent.\n        // omit the CID2GID mapping if the embedded font is replaced by an external font\n        String name = getName();\n        if ((((cid2gid != null) && (!isDamaged)) && (name != null)) && name.equals(ttf.getName())) {\n            // Acrobat allows non-embedded GIDs - todo: can we find a test PDF for this?\n            // PDFBOX-5612: should happen only if it's really the same font\n            // this is not perfect, we may have to improve this because some identical fonts\n            // have different names\n            LOG.warn(\"Using non-embedded GIDs in font \" + getName());\n            int cid = codeToCID(code);\n            if (cid < cid2gid.length) {\n                return cid2gid[cid];\n            } else {\n                return 0;\n            }\n        } else {\n            // fallback to the ToUnicode CMap, test with PDFBOX-1422 and PDFBOX-2560\n            String unicode = parent.toUnicode(code);\n            if (unicode == null) {\n                if (!noMapping.contains(code)) {\n                    // we keep track of which warnings have been issued, so we don't log multiple times\n                    noMapping.add(code);\n                    LOG.warn(((\"Failed to find a character mapping for \" + code) + \" in \") + getName());\n                }\n                // Acrobat is willing to use the CID as a GID, even when the font isn't embedded\n                // see PDFBOX-2599\n                return codeToCID(code);\n            } else if (unicode.length() > 1) {\n                LOG.warn(\"Trying to map multi-byte character using 'cmap', result will be poor\");\n            }\n            // a non-embedded font always has a cmap (otherwise FontMapper won't load it)\n            return cmap.getGlyphId(unicode.codePointAt(0));\n        }\n    } else {\n        // If the TrueType font program is embedded, the Type 2 CIDFont dictionary shall contain\n        // a CIDToGIDMap entry that maps CIDs to the glyph indices for the appropriate glyph\n        // descriptions in that font program.\n        int cid = codeToCID(code);\n        if (cid2gid != null) {\n            // use CIDToGIDMap\n            if (cid < cid2gid.length) {\n                return cid2gid[cid];\n            } else {\n                return 0;\n            }\n        } else {\n            // \"Identity\" is the default for CFF-based OpenTypeFonts\n            if ((otf != null) && otf.isPostScript()) {\n                return cid;\n            }\n            // \"Identity\" is the default for TrueTypeFonts if the CID is within the range\n            return cid < ttf.getNumberOfGlyphs() ? cid : 0;\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareDocumentForEncryption",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareDocumentForEncryption", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareEncryptionDictRev6", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Prepare document for encryption.\n *\n * @param document\n * \t\tThe document to encrypt.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\n@Override\npublic void prepareDocumentForEncryption(PDDocument document) throws IOException {\n    PDEncryption encryptionDictionary = document.getEncryption();\n    if (encryptionDictionary == null) {\n        encryptionDictionary = new PDEncryption();\n    }\n    int version = computeVersionNumber();\n    int revision = computeRevisionNumber(version);\n    encryptionDictionary.setFilter(FILTER);\n    encryptionDictionary.setVersion(version);\n    if ((version != REVISION_4) && (version != REVISION_5)) {\n        // remove CF, StmF, and StrF entries that may be left from a previous encryption\n        encryptionDictionary.removeV45filters();\n    }\n    encryptionDictionary.setRevision(revision);\n    encryptionDictionary.setLength(getKeyLength());\n    StandardProtectionPolicy protectionPolicy = getProtectionPolicy();\n    String ownerPassword = protectionPolicy.getOwnerPassword();\n    String userPassword = protectionPolicy.getUserPassword();\n    if (ownerPassword == null) {\n        ownerPassword = \"\";\n    }\n    if (userPassword == null) {\n        userPassword = \"\";\n    }\n    // If no owner password is set, use the user password instead.\n    if (ownerPassword.isEmpty()) {\n        ownerPassword = userPassword;\n    }\n    int permissionInt = protectionPolicy.getPermissions().getPermissionBytes();\n    encryptionDictionary.setPermissions(permissionInt);\n    int length = getKeyLength() / 8;\n    if (revision == REVISION_6) {\n        // PDFBOX-4155\n        ownerPassword = SaslPrep.saslPrepStored(ownerPassword);\n        userPassword = SaslPrep.saslPrepStored(userPassword);\n        prepareEncryptionDictRev6(ownerPassword, userPassword, encryptionDictionary, permissionInt);\n    } else {\n        prepareEncryptionDictRev234(ownerPassword, userPassword, encryptionDictionary, permissionInt, document, revision, length);\n    }\n    document.setEncryptionDictionary(encryptionDictionary);\n    document.getDocument().setEncryptionDictionary(encryptionDictionary.getCOSObject());\n}", "private void prepareEncryptionDictRev6(String ownerPassword, String userPassword, PDEncryption encryptionDictionary, int permissionInt) throws IOException {\n    try {\n        SecureRandom rnd = new SecureRandom();\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        // make a random 256-bit file encryption key\n        setEncryptionKey(new byte[32]);\n        rnd.nextBytes(getEncryptionKey());\n        // Algorithm 8a: Compute U\n        byte[] userPasswordBytes = truncate127(userPassword.getBytes(StandardCharsets.UTF_8));\n        byte[] userValidationSalt = new byte[8];\n        byte[] userKeySalt = new byte[8];\n        rnd.nextBytes(userValidationSalt);\n        rnd.nextBytes(userKeySalt);\n        byte[] hashU = computeHash2B(concat(userPasswordBytes, userValidationSalt), userPasswordBytes, null);\n        byte[] u = concat(hashU, userValidationSalt, userKeySalt);\n        // Algorithm 8b: Compute UE\n        byte[] hashUE = computeHash2B(concat(userPasswordBytes, userKeySalt), userPasswordBytes, null);\n        // \"an initialization vector of zero\"\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashUE, \"AES\"), new IvParameterSpec(new byte[16]));\n        byte[] ue = cipher.doFinal(getEncryptionKey());\n        // Algorithm 9a: Compute O\n        byte[] ownerPasswordBytes = truncate127(ownerPassword.getBytes(StandardCharsets.UTF_8));\n        byte[] ownerValidationSalt = new byte[8];\n        byte[] ownerKeySalt = new byte[8];\n        rnd.nextBytes(ownerValidationSalt);\n        rnd.nextBytes(ownerKeySalt);\n        byte[] hashO = computeHash2B(concat(ownerPasswordBytes, ownerValidationSalt, u), ownerPasswordBytes, u);\n        byte[] o = concat(hashO, ownerValidationSalt, ownerKeySalt);\n        // Algorithm 9b: Compute OE\n        byte[] hashOE = computeHash2B(concat(ownerPasswordBytes, ownerKeySalt, u), ownerPasswordBytes, u);\n        // \"an initialization vector of zero\"\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashOE, \"AES\"), new IvParameterSpec(new byte[16]));\n        byte[] oe = cipher.doFinal(getEncryptionKey());\n        // Set keys and other required constants in encryption dictionary\n        encryptionDictionary.setUserKey(u);\n        encryptionDictionary.setUserEncryptionKey(ue);\n        encryptionDictionary.setOwnerKey(o);\n        encryptionDictionary.setOwnerEncryptionKey(oe);\n        prepareEncryptionDictAES(encryptionDictionary, COSName.AESV3);\n        // Algorithm 10: compute \"Perms\" value\n        byte[] perms = new byte[16];\n        perms[0] = ((byte) (permissionInt));\n        perms[1] = ((byte) (permissionInt >>> 8));\n        perms[2] = ((byte) (permissionInt >>> 16));\n        perms[3] = ((byte) (permissionInt >>> 24));\n        perms[4] = ((byte) (0xff));\n        perms[5] = ((byte) (0xff));\n        perms[6] = ((byte) (0xff));\n        perms[7] = ((byte) (0xff));\n        perms[8] = 'T';// we always encrypt Metadata\n\n        perms[9] = 'a';\n        perms[10] = 'd';\n        perms[11] = 'b';\n        for (int i = 12; i <= 15; i++) {\n            perms[i] = ((byte) (rnd.nextInt()));\n        }\n        // \"an initialization vector of zero\"\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(getEncryptionKey(), \"AES\"), new IvParameterSpec(new byte[16]));\n        byte[] permsEnc = cipher.doFinal(perms);\n        encryptionDictionary.setPerms(permsEnc);\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDStream.getFileDecodeParams",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDStream.getFileDecodeParams", "org.apache.pdfbox.pdmodel.common.PDStream.internalGetDecodeParams" ],
    "fullMethods" : [ "/**\n * Get the list of decode parameters. Each entry in the list will refer to\n * an entry in the filters list.\n *\n * @return The list of decode parameters.\n * @throws IOException\n * \t\tif there is an error retrieving the parameters.\n */\npublic List<Object> getFileDecodeParams() throws IOException {\n    return internalGetDecodeParams(COSName.F_DECODE_PARMS, null);\n}", "private List<Object> internalGetDecodeParams(COSName name1, COSName name2) throws IOException {\n    COSBase dp = stream.getDictionaryObject(name1, name2);\n    if (dp instanceof COSDictionary) {\n        Map<?, ?> map = COSDictionaryMap.convertBasicTypesToMap(((COSDictionary) (dp)));\n        return new COSArrayList<>(map, dp, stream, name1);\n    }\n    if (dp instanceof COSArray) {\n        COSArray array = ((COSArray) (dp));\n        List<Object> actuals = new ArrayList<>(array.size());\n        for (int i = 0; i < array.size(); i++) {\n            COSBase base = array.getObject(i);\n            if (base instanceof COSDictionary) {\n                actuals.add(COSDictionaryMap.convertBasicTypesToMap(((COSDictionary) (base))));\n            } else {\n                LOG.warn((\"Expected COSDictionary, got \" + base) + \", ignored\");\n            }\n        }\n        return new COSArrayList<>(actuals, array);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.create",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask.create" ],
    "fullMethods" : [ "/**\n * Creates a new soft mask.\n *\n * @param dictionary\n * \t\tSMask\n * @param resourceCache\n * \t\tResource cache, may be null.\n * @return the newly created instance of PDSoftMask\n */\npublic static PDSoftMask create(COSBase dictionary, ResourceCache resourceCache) {\n    if (dictionary instanceof COSName) {\n        if (COSName.NONE.equals(dictionary)) {\n            return null;\n        } else {\n            LOG.warn(\"Invalid SMask \" + dictionary);\n            return null;\n        }\n    } else if (dictionary instanceof COSDictionary) {\n        return new PDSoftMask(((COSDictionary) (dictionary)), resourceCache);\n    } else {\n        LOG.warn(\"Invalid SMask \" + dictionary);\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.Splitter.split",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.Splitter.split", "org.apache.pdfbox.multipdf.Splitter.processPages", "org.apache.pdfbox.multipdf.Splitter.processPage" ],
    "fullMethods" : [ "/**\n * This will take a document and split into several other documents.\n *\n * @param document\n * \t\tThe document to split.\n * @return A list of all the split documents. These should all be saved before closing any\ndocuments, including the source document. Any further operations should be made after\nreloading them, to avoid problems due to resource sharing. For the same reason, they should\nnot be saved with encryption.\n * @throws IOException\n * \t\tIf there is an IOError\n */\npublic List<PDDocument> split(PDDocument document) throws IOException {\n    // reset the currentPageNumber for a case if the split method will be used several times\n    currentPageNumber = 0;\n    destinationDocuments = new ArrayList<>();\n    sourceDocument = document;\n    pageDictMaps = new ArrayList<>();\n    annotDictMaps = new ArrayList<>();\n    destToFixMap = new HashMap<>();\n    idSet = new HashSet<>();\n    roleSet = new HashSet<>();\n    processPages();\n    for (int i = 0; i < destinationDocuments.size(); ++i) {\n        PDDocument destinationDocument = destinationDocuments.get(i);\n        pageDictMap = pageDictMaps.get(i);\n        annotDictMap = annotDictMaps.get(i);\n        cloneStructureTree(destinationDocument);\n        fixDestinations(destinationDocument);\n    }\n    return destinationDocuments;\n}", "/**\n * Interface method to handle the start of the page processing.\n *\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprivate void processPages() throws IOException {\n    for (PDPage page : sourceDocument.getPages()) {\n        if (((currentPageNumber + 1) >= startPage) && ((currentPageNumber + 1) <= endPage)) {\n            processPage(page);\n            currentPageNumber++;\n        } else if (currentPageNumber > endPage) {\n            break;\n        } else {\n            currentPageNumber++;\n        }\n    }\n}", "/**\n * Interface to start processing a new page.\n *\n * @param page\n * \t\tThe page that is about to get processed.\n * @throws IOException\n * \t\tIf there is an error creating the new document.\n */\nprotected void processPage(PDPage page) throws IOException {\n    createNewDocumentIfNecessary();\n    PDPage imported = getDestinationDocument().importPage(page);\n    if ((page.getResources() != null) && (!page.getCOSObject().containsKey(COSName.RESOURCES))) {\n        imported.setResources(page.getResources());\n        LOG.info(\"Resources imported in Splitter\");// follow-up to warning in importPage\n\n    }\n    if (imported.getCOSObject().containsKey(COSName.B)) {\n        imported.getCOSObject().removeItem(COSName.B);\n        LOG.warn(\"/B entry (beads) removed by splitter\");\n    }\n    // remove page links to avoid copying not needed resources\n    processAnnotations(imported);\n    pageDictMap.put(page.getCOSObject(), imported.getCOSObject());\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.importPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.importPage" ],
    "fullMethods" : [ "/**\n * This will import and copy the contents from another location. Currently the content stream is\n * stored in a scratch file. The scratch file is associated with the document. If you are adding\n * a page to this document from another document and want to copy the contents to this\n * document's scratch file then use this method otherwise just use the {@link #addPage addPage()}\n * method.\n * <p>\n * Unlike {@link #addPage addPage()}, this method creates a new PDPage object. If your page has\n * annotations, and if these link to pages not in the target document, then the target document\n * might become huge. What you need to do is to delete page references of such annotations. See\n * <a href=\"http://stackoverflow.com/a/35477351/535646\">here</a> for how to do this.\n * <p>\n * Inherited (global) resources are ignored because these can contain resources not needed for\n * this page which could bloat your document, see\n * <a href=\"https://issues.apache.org/jira/browse/PDFBOX-28\">PDFBOX-28</a> and related issues.\n * If you need them, call <code>importedPage.setResources(page.getResources());</code>\n * <p>\n * This method should only be used to import a page from a loaded document, not from a generated\n * document because these can contain unfinished parts, e.g. font subsetting information.\n *\n * @param page\n * \t\tThe page to import.\n * @return The page that was imported.\n * @throws IOException\n * \t\tIf there is an error copying the page.\n */\npublic PDPage importPage(PDPage page) throws IOException {\n    PDPage importedPage = new PDPage(new COSDictionary(page.getCOSObject()), resourceCache);\n    importedPage.getCOSObject().removeItem(COSName.PARENT);\n    PDStream dest = new PDStream(this, page.getContents(), COSName.FLATE_DECODE);\n    importedPage.setContents(dest);\n    addPage(importedPage);\n    importedPage.setCropBox(new PDRectangle(page.getCropBox().getCOSArray()));\n    importedPage.setMediaBox(new PDRectangle(page.getMediaBox().getCOSArray()));\n    importedPage.setRotation(page.getRotation());\n    if ((page.getResources() != null) && (!page.getCOSObject().containsKey(COSName.RESOURCES))) {\n        LOG.warn(\"inherited resources of source document are not imported to destination page\");\n        LOG.warn(\"call importedPage.setResources(page.getResources()) to do this\");\n    }\n    return importedPage;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>" ],
    "fullMethods" : [ "/**\n * Creates a PDColor containing the given color value.\n *\n * @param array\n * \t\ta COS array containing the color value\n * @param colorSpace\n * \t\tcolor space in which the color value is defined\n */\npublic PDColor(COSArray array, PDColorSpace colorSpace) {\n    if ((array.size() > 0) && (array.get(array.size() - 1) instanceof COSName)) {\n        // color components (optional), for the color of an uncoloured tiling pattern\n        components = new float[array.size() - 1];\n        initComponents(array);\n        // pattern name (required)\n        COSBase base = array.get(array.size() - 1);\n        if (base instanceof COSName) {\n            patternName = ((COSName) (base));\n        } else {\n            LOG.warn((\"pattern name in \" + array) + \" isn't a name, ignored\");\n            patternName = COSName.getPDFName(\"Unknown\");\n        }\n    } else {\n        // color components only\n        components = new float[array.size()];\n        initComponents(array);\n        patternName = null;\n    }\n    this.colorSpace = colorSpace;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.CurveTo.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.CurveTo.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.size() < 6) {\n        throw new MissingOperandException(operator, operands);\n    }\n    if (!checkArrayTypesClass(operands, COSNumber.class)) {\n        return;\n    }\n    COSNumber x1 = ((COSNumber) (operands.get(0)));\n    COSNumber y1 = ((COSNumber) (operands.get(1)));\n    COSNumber x2 = ((COSNumber) (operands.get(2)));\n    COSNumber y2 = ((COSNumber) (operands.get(3)));\n    COSNumber x3 = ((COSNumber) (operands.get(4)));\n    COSNumber y3 = ((COSNumber) (operands.get(5)));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    Point2D.Float point1 = context.transformedPoint(x1.floatValue(), y1.floatValue());\n    Point2D.Float point2 = context.transformedPoint(x2.floatValue(), y2.floatValue());\n    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());\n    if (context.getCurrentPoint() == null) {\n        LOG.warn((((\"curveTo (\" + point3.x) + \",\") + point3.y) + \") without initial MoveTo\");\n        context.moveTo(point3.x, point3.y);\n    } else {\n        context.curveTo(point1.x, point1.y, point2.x, point2.y, point3.x, point3.y);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.create",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotation.create" ],
    "fullMethods" : [ "/**\n * Create the correct FDFAnnotation.\n *\n * @param fdfDic\n * \t\tThe FDF dictionary.\n * @return A newly created FDFAnnotation\n */\npublic static FDFAnnotation create(COSDictionary fdfDic) {\n    FDFAnnotation retval = null;\n    if (fdfDic != null) {\n        String fdfDicName = fdfDic.getNameAsString(COSName.SUBTYPE);\n        if (FDFAnnotationText.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationText(fdfDic);\n        } else if (FDFAnnotationCaret.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationCaret(fdfDic);\n        } else if (FDFAnnotationFreeText.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationFreeText(fdfDic);\n        } else if (FDFAnnotationFileAttachment.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationFileAttachment(fdfDic);\n        } else if (FDFAnnotationHighlight.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationHighlight(fdfDic);\n        } else if (FDFAnnotationInk.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationInk(fdfDic);\n        } else if (FDFAnnotationLine.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationLine(fdfDic);\n        } else if (FDFAnnotationLink.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationLink(fdfDic);\n        } else if (FDFAnnotationCircle.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationCircle(fdfDic);\n        } else if (FDFAnnotationSquare.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationSquare(fdfDic);\n        } else if (FDFAnnotationPolygon.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationPolygon(fdfDic);\n        } else if (FDFAnnotationPolyline.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationPolyline(fdfDic);\n        } else if (FDFAnnotationSound.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationSound(fdfDic);\n        } else if (FDFAnnotationSquiggly.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationSquiggly(fdfDic);\n        } else if (FDFAnnotationStamp.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationStamp(fdfDic);\n        } else if (FDFAnnotationStrikeOut.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationStrikeOut(fdfDic);\n        } else if (FDFAnnotationUnderline.SUBTYPE.equals(fdfDicName)) {\n            retval = new FDFAnnotationUnderline(fdfDic);\n        } else {\n            LOG.warn((\"Unknown or unsupported annotation type '\" + fdfDicName) + \"'\");\n        }\n    }\n    return retval;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>" ],
    "fullMethods" : [ "/**\n * Creates a PDColor containing the given color component values and pattern name.\n *\n * @param components\n * \t\tarray of color component values\n * @param patternName\n * \t\tthe name of a pattern in a pattern dictionary\n * @param colorSpace\n * \t\tcolor space in which the pattern/components are defined\n */\npublic PDColor(float[] components, COSName patternName, PDColorSpace colorSpace) {\n    this.components = components.clone();\n    this.patternName = patternName;\n    this.colorSpace = colorSpace;\n    if (colorSpace instanceof PDPattern) {\n        PDColorSpace ucs = ((PDPattern) (colorSpace)).getUnderlyingColorSpace();\n        if ((ucs != null) && (ucs.getNumberOfComponents() != components.length)) {\n            // PDFBOX-5882\n            LOG.warn(((\"Pattern colorspace component count \" + ucs.getNumberOfComponents()) + \" doesn't match components length \") + components.length);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromByteArray",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.createFromByteArray", "org.apache.pdfbox.pdmodel.graphics.image.JPEGFactory.retrieveDimensions" ],
    "fullMethods" : [ "/**\n * Creates a new JPEG Image XObject from a byte array containing JPEG data.\n *\n * @param document\n * \t\tthe document where the image will be created\n * @param byteArray\n * \t\tbytes of JPEG image\n * @return a new Image XObject\n * @throws IOException\n * \t\tif the input stream cannot be read\n */\npublic static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray) throws IOException {\n    // copy stream\n    ByteArrayInputStream byteStream = new ByteArrayInputStream(byteArray);\n    Dimensions meta = retrieveDimensions(byteStream);\n    PDColorSpace colorSpace;\n    switch (meta.numComponents) {\n        case 1 :\n            colorSpace = PDDeviceGray.INSTANCE;\n            break;\n        case 3 :\n            colorSpace = PDDeviceRGB.INSTANCE;\n            break;\n        case 4 :\n            colorSpace = PDDeviceCMYK.INSTANCE;\n            break;\n        default :\n            throw new UnsupportedOperationException(\"number of data elements not supported: \" + meta.numComponents);\n    }\n    // create PDImageXObject from stream\n    PDImageXObject pdImage = new PDImageXObject(document, byteStream, COSName.DCT_DECODE, meta.width, meta.height, 8, colorSpace);\n    if (colorSpace instanceof PDDeviceCMYK) {\n        COSArray decode = new COSArray();\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        decode.add(COSInteger.ONE);\n        decode.add(COSInteger.ZERO);\n        pdImage.setDecode(decode);\n    }\n    return pdImage;\n}", "private static Dimensions retrieveDimensions(ByteArrayInputStream stream) throws IOException {\n    ImageReader reader = Filter.findRasterReader(\"JPEG\", \"a suitable JAI I/O image filter is not installed\");\n    try (ImageInputStream iis = ImageIO.createImageInputStream(stream)) {\n        reader.setInput(iis);\n        Dimensions meta = new Dimensions();\n        meta.width = reader.getWidth(0);\n        meta.height = reader.getHeight(0);\n        // PDFBOX-4691: get from image metadata (faster because no decoding)\n        try {\n            meta.numComponents = getNumComponentsFromImageMetadata(reader);\n            if (meta.numComponents != 0) {\n                return meta;\n            }\n            LOG.info(\"No image metadata, will decode image and use raster size\");\n        } catch (IOException ex) {\n            LOG.warn(\"Error reading image metadata, will decode image and use raster size\");\n        }\n        // Old method: get from raster (slower)\n        ImageIO.setUseCache(false);\n        Raster raster = reader.readRaster(0, null);\n        meta.numComponents = raster.getNumDataElements();\n        return meta;\n    } finally {\n        stream.reset();\n        reader.dispose();\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.Filter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.Filter.decode" ],
    "fullMethods" : [ "/**\n * Decodes data, with optional DecodeOptions. Not all filters support all options, and so callers should check the\n * options' <code>honored</code> flag to test if they were applied.\n *\n * @param encoded\n * \t\tthe input stream holding the encoded data\n * @param filterList\n * \t\tlist of filters to be used for decoding\n * @param parameters\n * \t\tthe parameters used for decoding\n * @param options\n * \t\tadditional options for decoding\n * @param results\n * \t\tlist of optional decoding results for each filter\n * @return the decoded stream data\n * @throws IOException\n * \t\tif the stream cannot be decoded\n * @throws IllegalArgumentException\n * \t\tif filterList is empty\n */\npublic static RandomAccessRead decode(InputStream encoded, List<Filter> filterList, COSDictionary parameters, DecodeOptions options, List<DecodeResult> results) throws IOException {\n    long length = parameters.getLong(COSName.LENGTH, RandomAccessReadBuffer.DEFAULT_CHUNK_SIZE_4KB);\n    if (filterList.isEmpty()) {\n        throw new IllegalArgumentException(\"Empty filterList\");\n    }\n    if (filterList.size() > 1) {\n        Set<Filter> filterSet = new HashSet<>(filterList);\n        if (filterSet.size() != filterList.size()) {\n            List<Filter> reducedFilterList = new ArrayList<>();\n            for (Filter filter : filterList) {\n                if (!reducedFilterList.contains(filter)) {\n                    reducedFilterList.add(filter);\n                }\n            }\n            // replace origin list with the reduced one\n            filterList = reducedFilterList;\n            LOG.warn(\"Removed duplicated filter entries\");\n        }\n    }\n    InputStream input = encoded;\n    RandomAccessReadWriteBuffer randomAccessWriteBuffer = null;\n    OutputStream output = null;\n    // apply filters\n    for (int i = 0; i < filterList.size(); i++) {\n        if (i > 0) {\n            randomAccessWriteBuffer.seek(0);\n            input = new RandomAccessInputStream(randomAccessWriteBuffer);\n            length = randomAccessWriteBuffer.length();\n        }\n        // we don't know the size of the decoded stream, just estimate a 4 times bigger size than the encoded stream\n        // use the estimated stream size as chunk size, use the default chunk size as limit to avoid to big values\n        if ((length <= 0) || (length >= (RandomAccessReadBuffer.DEFAULT_CHUNK_SIZE_4KB / 4))) {\n            length = RandomAccessReadBuffer.DEFAULT_CHUNK_SIZE_4KB;\n        } else {\n            length = length * 4;\n        }\n        randomAccessWriteBuffer = new RandomAccessReadWriteBuffer(((int) (length)));\n        output = new RandomAccessOutputStream(randomAccessWriteBuffer);\n        try {\n            DecodeResult result = filterList.get(i).decode(input, output, parameters, i, options);\n            if (results != null) {\n                results.add(result);\n            }\n        } finally {\n            IOUtils.closeQuietly(input);\n        }\n    }\n    randomAccessWriteBuffer.seek(0);\n    return randomAccessWriteBuffer;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setStartxref",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setStartxref" ],
    "fullMethods" : [ "/**\n * Sets the byte position of the first XRef\n * (has to be called after very last startxref was read).\n * This is used to resolve chain of active XRef/trailer.\n *\n * In case startxref position is not found we output a\n * warning and use all XRef/trailer objects combined\n * in byte position order.\n * Thus for incomplete PDF documents with missing\n * startxref one could call this method with parameter value -1.\n *\n * @param startxrefBytePosValue\n * \t\tstarting position of the first XRef\n */\npublic void setStartxref(long startxrefBytePosValue) {\n    if (resolvedXrefTrailer != null) {\n        LOG.warn(\"Method must be called only ones with last startxref value.\");\n        return;\n    }\n    resolvedXrefTrailer = new XrefTrailerObj();\n    resolvedXrefTrailer.trailer = new COSDictionary();\n    XrefTrailerObj curObj = bytePosToXrefMap.get(startxrefBytePosValue);\n    List<Long> xrefSeqBytePos = new ArrayList<>();\n    if (curObj == null) {\n        // no XRef at given position\n        LOG.warn(\"Did not found XRef object at specified startxref position \" + startxrefBytePosValue);\n        // use all objects in byte position order (last entries overwrite previous ones)\n        xrefSeqBytePos.addAll(bytePosToXrefMap.keySet());\n        Collections.sort(xrefSeqBytePos);\n    } else {\n        // copy xref type\n        resolvedXrefTrailer.xrefType = curObj.xrefType;\n        // found starting Xref object\n        // add this and follow chain defined by 'Prev' keys\n        xrefSeqBytePos.add(startxrefBytePosValue);\n        while (curObj.trailer != null) {\n            long prevBytePos = curObj.trailer.getLong(COSName.PREV, -1L);\n            if (prevBytePos == (-1)) {\n                break;\n            }\n            curObj = bytePosToXrefMap.get(prevBytePos);\n            if (curObj == null) {\n                LOG.warn(\"Did not found XRef object pointed to by 'Prev' key at position \" + prevBytePos);\n                break;\n            }\n            xrefSeqBytePos.add(prevBytePos);\n            // prevent infinite loops\n            if (xrefSeqBytePos.size() >= bytePosToXrefMap.size()) {\n                break;\n            }\n        } \n        // have to reverse order so that later XRefs will overwrite previous ones\n        Collections.reverse(xrefSeqBytePos);\n    }\n    // merge used and sorted XRef/trailer\n    for (Long bPos : xrefSeqBytePos) {\n        curObj = bytePosToXrefMap.get(bPos);\n        if (curObj.trailer != null) {\n            resolvedXrefTrailer.trailer.addAll(curObj.trailer);\n        }\n        resolvedXrefTrailer.xrefTable.putAll(curObj.xrefTable);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.FontMapperImpl.getProvider", "org.apache.pdfbox.pdmodel.font.FontMapperImpl.DefaultFontProvider.<clinit>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.<init>", "org.apache.pdfbox.pdmodel.font.FileSystemFontProvider.loadDiskCache" ],
    "fullMethods" : [ "/**\n * Returns the font service provider. Defaults to using FileSystemFontProvider.\n */\npublic synchronized FontProvider getProvider() {\n    if (fontProvider == null) {\n        setProvider(DefaultFontProvider.INSTANCE);\n    }\n    return fontProvider;\n}", "", "/**\n * Constructor.\n */\nFileSystemFontProvider(FontCache cache) {\n    this.cache = cache;\n    try {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Will search the local system for fonts\");\n        }\n        // scan the local system for font files\n        FontFileFinder fontFileFinder = new FontFileFinder();\n        List<URI> fonts = fontFileFinder.find();\n        List<File> files = new ArrayList<>(fonts.size());\n        for (URI font : fonts) {\n            files.add(new File(font));\n        }\n        if (LOG.isTraceEnabled()) {\n            LOG.trace((\"Found \" + files.size()) + \" fonts on the local system\");\n        }\n        if (!files.isEmpty()) {\n            // load cached FontInfo objects\n            List<FSFontInfo> cachedInfos = loadDiskCache(files);\n            if ((cachedInfos != null) && (!cachedInfos.isEmpty())) {\n                fontInfoList.addAll(cachedInfos);\n            } else {\n                LOG.info(\"Building on-disk font cache, this may take a while\");\n                scanFonts(files);\n                saveDiskCache();\n                LOG.info((\"Finished building on-disk font cache, found \" + fontInfoList.size()) + \" fonts\");\n            }\n        }\n    } catch (AccessControlException e) {\n        LOG.error(\"Error accessing the file system\", e);\n    }\n}", "/**\n * Loads the font metadata cache from disk.\n */\nprivate List<FSFontInfo> loadDiskCache(List<File> files) {\n    Set<String> pending = new HashSet<>(files.size());\n    for (File file : files) {\n        pending.add(file.getAbsolutePath());\n    }\n    List<FSFontInfo> results = new ArrayList<>();\n    // Get the disk cache\n    File diskCacheFile = null;\n    boolean fileExists = false;\n    try {\n        diskCacheFile = getDiskCacheFile();\n        fileExists = diskCacheFile.exists();\n    } catch (SecurityException e) {\n        LOG.debug(\"Error checking for file existence\", e);\n    }\n    if (fileExists) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(diskCacheFile), StandardCharsets.UTF_8))) {\n            // consequent lines usually share the same font file (e.g. \"Courier\", \"Courier-Bold\", \"Courier-Oblique\").\n            // unused if SKIP_CHECKSUMS\n            File lastFile = null;\n            String lastHash = null;\n            // \n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\"\\\\|\", 12);\n                if (parts.length < 10) {\n                    LOG.warn((\"Incorrect line '\" + line) + \"' in font disk cache is skipped\");\n                    continue;\n                }\n                String postScriptName;\n                FontFormat format;\n                CIDSystemInfo cidSystemInfo = null;\n                int usWeightClass = -1;\n                int sFamilyClass = -1;\n                int ulCodePageRange1;\n                int ulCodePageRange2;\n                int macStyle = -1;\n                byte[] panose = null;\n                File fontFile;\n                String hash = \"\";\n                long lastModified = 0;\n                postScriptName = parts[0];\n                format = FontFormat.valueOf(parts[1]);\n                if (parts[2].length() > 0) {\n                    String[] ros = parts[2].split(\"-\");\n                    cidSystemInfo = new CIDSystemInfo(ros[0], ros[1], Integer.parseInt(ros[2]));\n                }\n                if (parts[3].length() > 0) {\n                    usWeightClass = ((int) (Long.parseLong(parts[3], 16)));\n                }\n                if (parts[4].length() > 0) {\n                    sFamilyClass = ((int) (Long.parseLong(parts[4], 16)));\n                }\n                ulCodePageRange1 = ((int) (Long.parseLong(parts[5], 16)));\n                ulCodePageRange2 = ((int) (Long.parseLong(parts[6], 16)));\n                if (parts[7].length() > 0) {\n                    macStyle = ((int) (Long.parseLong(parts[7], 16)));\n                }\n                if (parts[8].length() > 0) {\n                    panose = new byte[10];\n                    for (int i = 0; i < 10; i++) {\n                        String str = parts[8].substring(i * 2, (i * 2) + 2);\n                        int b = Integer.parseInt(str, 16);\n                        panose[i] = ((byte) (b & 0xff));\n                    }\n                }\n                fontFile = new File(parts[9]);\n                if (((parts.length >= 12) && (!parts[10].isEmpty())) && (!parts[11].isEmpty())) {\n                    hash = parts[10];\n                    lastModified = Long.parseLong(parts[11]);\n                }\n                if (fontFile.exists()) {\n                    // if the file exists, find out whether it's the same file.\n                    // first check whether time is different and if yes, whether hash is different\n                    boolean keep = fontFile.lastModified() == lastModified;\n                    if ((!keep) && (!SKIP_CHECKSUMS)) {\n                        String newHash;\n                        if (hash.equals(lastHash) && fontFile.equals(lastFile)) {\n                            newHash = lastHash;// already computed\n\n                        } else {\n                            try {\n                                newHash = computeHash(Files.newInputStream(fontFile.toPath()));\n                                lastFile = fontFile;\n                                lastHash = newHash;\n                            } catch (IOException ex) {\n                                LOG.debug(\"Error reading font file \" + fontFile.getAbsolutePath(), ex);\n                                newHash = \"<err>\";\n                            }\n                        }\n                        if (hash.equals(newHash)) {\n                            keep = true;\n                            lastModified = fontFile.lastModified();\n                        }\n                    }\n                    if (keep) {\n                        FSFontInfo info = new FSFontInfo(fontFile, format, postScriptName, cidSystemInfo, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this, hash, lastModified);\n                        results.add(info);\n                    } else {\n                        LOG.debug((\"Font file \" + fontFile.getAbsolutePath()) + \" is different\");\n                        continue;// don't remove from \"pending\"\n\n                    }\n                } else {\n                    LOG.debug((\"Font file \" + fontFile.getAbsolutePath()) + \" not found, skipped\");\n                }\n                pending.remove(fontFile.getAbsolutePath());\n            } \n        } catch (IOException e) {\n            LOG.warn(\"Error loading font cache, will be re-built\", e);\n            return null;\n        }\n    }\n    if (!pending.isEmpty()) {\n        // re-build the entire cache if we encounter un-cached fonts (could be optimised)\n        LOG.info(pending.size() + \" new font files found, font cache will be re-built\");\n        return null;\n    }\n    return results;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getSuffix",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.getSuffix" ],
    "fullMethods" : [ "/**\n * This will get the suffix for this image type, e.g. jpg/png.\n *\n * @return The image suffix or null if not available.\n */\n@Override\npublic String getSuffix() {\n    List<COSName> filters = getStream().getFilters();\n    if (filters.isEmpty()) {\n        return \"png\";\n    } else if (filters.contains(COSName.DCT_DECODE)) {\n        return \"jpg\";\n    } else if (filters.contains(COSName.JPX_DECODE)) {\n        return \"jpx\";\n    } else if (filters.contains(COSName.CCITTFAX_DECODE)) {\n        return \"tiff\";\n    } else if ((filters.contains(COSName.FLATE_DECODE) || filters.contains(COSName.LZW_DECODE)) || filters.contains(COSName.RUN_LENGTH_DECODE)) {\n        return \"png\";\n    } else if (filters.contains(COSName.JBIG2_DECODE)) {\n        return \"jb2\";\n    } else {\n        LOG.warn(\"getSuffix() returns null, filters: \" + filters);\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.GlyphCache.getPathForCharacterCode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.GlyphCache.getPathForCharacterCode" ],
    "fullMethods" : [ "public GeneralPath getPathForCharacterCode(int code) {\n    GeneralPath path = cache.get(code);\n    if (path != null) {\n        return path;\n    }\n    try {\n        if (!font.hasGlyph(code)) {\n            String fontName = ((PDFontLike) (font)).getName();\n            if (font instanceof PDType0Font) {\n                int cid = ((PDType0Font) (font)).codeToCID(code);\n                String cidHex = String.format(\"%04x\", cid);\n                LOG.warn(((((\"No glyph for code \" + code) + \" (CID \") + cidHex) + \") in font \") + fontName);\n            } else if (font instanceof PDSimpleFont) {\n                PDSimpleFont simpleFont = ((PDSimpleFont) (font));\n                LOG.warn((((((((\"No glyph for code \" + code) + \" in \") + font.getClass().getSimpleName()) + \" \") + fontName) + \" (embedded or system font used: \") + simpleFont.getFontBoxFont().getName()) + \")\");\n                if ((code == 10) && simpleFont.isStandard14()) {\n                    // PDFBOX-4001 return empty path for line feed on std14\n                    path = new GeneralPath();\n                    cache.put(code, path);\n                    return path;\n                }\n            } else {\n                LOG.warn(((\"No glyph for code \" + code) + \" in font \") + fontName);\n            }\n        }\n        path = font.getNormalizedPath(code);\n        cache.put(code, path);\n        return path;\n    } catch (IOException e) {\n        // todo: escalate this error?\n        String fontName = ((PDFontLike) (font)).getName();\n        LOG.error(((\"Glyph rendering failed for code \" + code) + \" in font \") + fontName, e);\n        return new GeneralPath();\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.getBounds",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType7.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.getBounds", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches" ],
    "fullMethods" : [ "@Override\npublic Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException {\n    return getBounds(xform, matrix, 16);\n}", "Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    Rectangle2D bounds = null;\n    for (Patch patch : collectPatches(xform, matrix, controlPoints)) {\n        for (ShadedTriangle shadedTriangle : patch.listOfTriangles) {\n            if (bounds == null) {\n                bounds = new Rectangle2D.Double(shadedTriangle.corner[0].getX(), shadedTriangle.corner[0].getY(), 0, 0);\n            }\n            bounds.add(shadedTriangle.corner[0]);\n            bounds.add(shadedTriangle.corner[1]);\n            bounds.add(shadedTriangle.corner[2]);\n        }\n    }\n    return bounds;\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDChoice.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances" ],
    "fullMethods" : [ "/**\n * Sets the entry \"V\" to the given values. Requires {@link #isMultiSelect()} to be true.\n *\n * @param values\n * \t\tthe list of values\n * @throws IOException\n * \t\tif the appearance couldn't be generated.\n */\npublic void setValue(List<String> values) throws IOException {\n    if ((values != null) && (!values.isEmpty())) {\n        if (!isMultiSelect()) {\n            throw new IllegalArgumentException(\"The list box does not allow multiple selections.\");\n        }\n        List<String> options = getOptions();\n        if (!options.containsAll(values)) {\n            throw new IllegalArgumentException(\"The values are not contained in the selectable options.\");\n        }\n        getCOSObject().setItem(COSName.V, COSArray.ofCOSStrings(values));\n        updateSelectedOptionsIndex(values, options);\n    } else {\n        getCOSObject().removeItem(COSName.V);\n        getCOSObject().removeItem(COSName.I);\n    }\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDAbstractContentStream.close",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDAbstractContentStream.close" ],
    "fullMethods" : [ "/**\n * Close the content stream.  This must be called when you are done with this object.\n *\n * @throws IOException\n * \t\tIf the underlying stream has a problem being written to.\n */\n@Override\npublic void close() throws IOException {\n    if (inTextMode) {\n        LOG.warn(\"You did not call endText(), some viewers won't display your text\");\n    }\n    outputStream.close();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseAllObjects", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject" ],
    "fullMethods" : [ "/**\n * Parse all compressed objects. The stream is closed after parsing.\n *\n * @return a map containing all parsed objects using the object number as key\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic Map<COSObjectKey, COSBase> parseAllObjects() throws IOException {\n    Map<COSObjectKey, COSBase> allObjects = new HashMap<>();\n    try {\n        Map<Integer, Long> objectNumbers = privateReadObjectOffsets();\n        // count the number of object numbers eliminating double entries\n        long numberOfObjNumbers = objectNumbers.values().stream().distinct().count();\n        // the usage of the index should be restricted to cases where more than one\n        // object use the same object number.\n        // there are malformed pdfs in the wild which would lead to false results if\n        // pdfbox always relies on the index if available. In most cases the object number\n        // is sufficient to choose the correct object\n        boolean indexNeeded = objectNumbers.size() > numberOfObjNumbers;\n        long currentPosition = source.getPosition();\n        if ((firstObject > 0) && (currentPosition < firstObject)) {\n            source.skip(firstObject - ((int) (currentPosition)));\n        }\n        int index = 0;\n        for (Entry<Integer, Long> entry : objectNumbers.entrySet()) {\n            COSObjectKey objectKey = getObjectKey(entry.getValue(), 0);\n            // skip object if the index doesn't match\n            if ((indexNeeded && (objectKey.getStreamIndex() > (-1))) && (objectKey.getStreamIndex() != index)) {\n                index++;\n                continue;\n            }\n            int finalPosition = firstObject + entry.getKey();\n            currentPosition = source.getPosition();\n            if ((finalPosition > 0) && (currentPosition < finalPosition)) {\n                // jump to the offset of the object to be parsed\n                source.skip(finalPosition - ((int) (currentPosition)));\n            }\n            COSBase streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n            allObjects.put(objectKey, streamObject);\n            index++;\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return allObjects;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.toUnicode" ],
    "fullMethods" : [ "@Override\npublic String toUnicode(int code) {\n    // try to use a ToUnicode CMap\n    String unicode = super.toUnicode(code);\n    if (unicode != null) {\n        return unicode;\n    }\n    // Use identity mapping if the given ToUnicode CMap doesn't provide any valid mapping\n    // a predefined map shall only be used if there isn't any ToUnicode CMap\n    // PDFBOX-6022: not when there's a predefined cmap\n    if ((getToUnicodeCMap() != null) && (!isCMapPredefined)) {\n        return Character.toString(((char) (code)));\n    }\n    if ((isCMapPredefined || isDescendantCJK) && (cMapUCS2 != null)) {\n        // if the font is composite and uses a predefined cmap (excluding Identity-H/V) then\n        // or if its descendant font uses Adobe-GB1/CNS1/Japan1/Korea1\n        // a) Map the character code to a character identifier (CID) according to the font?s CMap\n        int cid = codeToCID(code);\n        // e) Map the CID according to the CMap from step d), producing a Unicode value\n        return cMapUCS2.toUnicode(cid);\n    }\n    // PDFBOX-5324: try to get unicode from font cmap\n    if (descendantFont instanceof PDCIDFontType2) {\n        TrueTypeFont font = ((PDCIDFontType2) (descendantFont)).getTrueTypeFont();\n        if (font != null) {\n            try {\n                CmapLookup cmap = font.getUnicodeCmapLookup(false);\n                if (cmap != null) {\n                    int gid;\n                    if (descendantFont.isEmbedded()) {\n                        // original PDFBOX-5324 supported only embedded fonts\n                        gid = descendantFont.codeToGID(code);\n                    } else {\n                        // PDFBOX-5331: this bypasses the fallback attempt in\n                        // PDCIDFontType2.codeToGID() which would bring a stackoverflow\n                        gid = descendantFont.codeToCID(code);\n                    }\n                    List<Integer> codes = cmap.getCharCodes(gid);\n                    if ((codes != null) && (!codes.isEmpty())) {\n                        return Character.toString(((char) (int) (codes.get(0))));\n                    }\n                }\n            } catch (IOException e) {\n                LOG.warn(\"get unicode from font cmap fail\", e);\n            }\n        }\n    }\n    if (LOG.isWarnEnabled() && (!noUnicode.contains(code))) {\n        // if no value has been produced, there is no way to obtain Unicode for the character.\n        String cid = \"CID+\" + codeToCID(code);\n        LOG.warn(((((\"No Unicode mapping for \" + cid) + \" (\") + code) + \") in font \") + getName());\n        // we keep track of which warnings have been issued, so we don't log multiple times\n        noUnicode.add(code);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDSimpleFont.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDSimpleFont.toUnicode" ],
    "fullMethods" : [ "@Override\npublic String toUnicode(int code, GlyphList customGlyphList) {\n    // allow the glyph list to be overridden for the purpose of extracting Unicode\n    // we only do this when the font's glyph list is the AGL, to avoid breaking Zapf Dingbats\n    GlyphList unicodeGlyphList;\n    if (this.glyphList == GlyphList.getAdobeGlyphList()) {\n        unicodeGlyphList = customGlyphList;\n    } else {\n        unicodeGlyphList = this.glyphList;\n    }\n    // first try to use a ToUnicode CMap\n    String unicode = super.toUnicode(code);\n    if (unicode != null) {\n        return unicode;\n    }\n    // if the font is a \"simple font\" and uses MacRoman/MacExpert/WinAnsi[Encoding]\n    // or has Differences with names from only Adobe Standard and/or Symbol, then:\n    // \n    // a) Map the character codes to names\n    // b) Look up the name in the Adobe Glyph List to obtain the Unicode value\n    String name = null;\n    if (encoding != null) {\n        name = encoding.getName(code);\n        unicode = unicodeGlyphList.toUnicode(name);\n        if (unicode != null) {\n            return unicode;\n        }\n    }\n    // if no value has been produced, there is no way to obtain Unicode for the character.\n    if (LOG.isWarnEnabled() && (!noUnicode.contains(code))) {\n        // we keep track of which warnings have been issued, so we don't log multiple times\n        noUnicode.add(code);\n        if (name != null) {\n            LOG.warn(((((\"No Unicode mapping for \" + name) + \" (\") + code) + \") in font \") + getName());\n        } else {\n            LOG.warn(((\"No Unicode mapping for character code \" + code) + \" in font \") + getName());\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFDictionary.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fdfDictionary\n * \t\tThe FDF documents catalog.\n */\npublic FDFDictionary(COSDictionary fdfDictionary) {\n    fdf = fdfDictionary;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.remove",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.remove", "org.apache.pdfbox.pdmodel.PDPageTree.get", "org.apache.pdfbox.pdmodel.PDPageTree.getKids" ],
    "fullMethods" : [ "/**\n * Removes the page with the given index from the page tree.\n *\n * @param index\n * \t\tzero-based page index\n */\npublic void remove(int index) {\n    COSDictionary node = get(index + 1, root, 0);\n    remove(node);\n}", "/**\n * Returns the given COS page using a depth-first search.\n *\n * @param pageNum\n * \t\t1-based page number\n * @param node\n * \t\tpage tree node to search\n * @param encountered\n * \t\tnumber of pages encountered so far\n * @return COS dictionary of the Page object\n * @throws IllegalStateException\n * \t\tif the requested page number isn't found\n * @throws IndexOutOfBoundsException\n * \t\tif the requested page number is higher than the page count\n */\nprivate COSDictionary get(int pageNum, COSDictionary node, int encountered) {\n    if (pageNum < 1) {\n        throw new IndexOutOfBoundsException(\"Index out of bounds: \" + pageNum);\n    }\n    if (pageSet.contains(node)) {\n        pageSet.clear();\n        throw new IllegalStateException(\"Possible recursion found when searching for page \" + pageNum);\n    } else {\n        // collect already processed pages to detect possible recursions\n        // to avoid a StackOverflowError\n        pageSet.add(node);\n    }\n    if (isPageTreeNode(node)) {\n        int count = node.getInt(COSName.COUNT, 0);\n        if (pageNum <= (encountered + count)) {\n            // it's a kid of this node\n            for (COSDictionary kid : getKids(node)) {\n                // which kid?\n                if (isPageTreeNode(kid)) {\n                    int kidCount = kid.getInt(COSName.COUNT, 0);\n                    if (pageNum <= (encountered + kidCount)) {\n                        // it's this kid\n                        return get(pageNum, kid, encountered);\n                    } else {\n                        encountered += kidCount;\n                    }\n                } else {\n                    // single page\n                    encountered++;\n                    if (pageNum == encountered) {\n                        // it's this page\n                        return get(pageNum, kid, encountered);\n                    }\n                }\n            }\n            throw new IllegalStateException(\"1-based index not found: \" + pageNum);\n        } else {\n            throw new IndexOutOfBoundsException(\"1-based index out of bounds: \" + pageNum);\n        }\n    } else if (encountered == pageNum) {\n        pageSet.clear();\n        return node;\n    } else {\n        throw new IllegalStateException(\"1-based index not found: \" + pageNum);\n    }\n}", "/**\n * Helper to get kids from malformed PDFs.\n *\n * @param node\n * \t\tpage tree node\n * @return list of kids\n */\nprivate List<COSDictionary> getKids(COSDictionary node) {\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // probably a malformed PDF\n        return Collections.emptyList();\n    }\n    int size = kids.size();\n    List<COSDictionary> result = new ArrayList<>(size);\n    for (int i = 0; i < size; i++) {\n        COSBase base = kids.getObject(i);\n        if (base instanceof COSDictionary) {\n            result.add(((COSDictionary) (base)));\n        } else if (base == null) {\n            LOG.warn(\"replaced null entry with an empty page\");\n            COSDictionary emptyPage = new COSDictionary();\n            emptyPage.setItem(COSName.TYPE, COSName.PAGE);\n            kids.set(i, emptyPage);\n            result.add(emptyPage);\n        } else {\n            LOG.warn(\"COSDictionary expected, but got \" + base.getClass().getSimpleName());\n        }\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances" ],
    "fullMethods" : [ "/**\n * Set the selected option given its name, and try to update the visual appearance.\n *\n * @param value\n * \t\tName of option to select\n * @throws IOException\n * \t\tif the value could not be set\n * @throws IllegalArgumentException\n * \t\tif the value is not a valid option.\n */\n@Override\npublic void setValue(String value) throws IOException {\n    checkValue(value);\n    // if there are export values/an Opt entry there is a different\n    // approach to setting the value\n    if (!getExportValues().isEmpty()) {\n        updateByOption(value);\n    } else {\n        updateByValue(value);\n    }\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.fillPath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.fillPath", "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getNonStrokingJavaComposite", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.getInstance" ],
    "fullMethods" : [ "@Override\npublic void fillPath(int windingRule) throws IOException {\n    PDGraphicsState graphicsState = getGraphicsState();\n    graphics.setComposite(graphicsState.getNonStrokingJavaComposite());\n    setClip();\n    linePath.setWindingRule(windingRule);\n    // disable anti-aliasing for rectangular paths, this is a workaround to avoid small stripes\n    // which occur when solid fills are used to simulate piecewise gradients, see PDFBOX-2302\n    // note that we ignore paths with a width/height under 1 as these are fills used as strokes,\n    // see PDFBOX-1658 for an example\n    Rectangle2D bounds = linePath.getBounds2D();\n    boolean noAntiAlias = (isRectangular(linePath) && (bounds.getWidth() > 1)) && (bounds.getHeight() > 1);\n    if (noAntiAlias) {\n        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n    }\n    Shape shape;\n    if (graphicsState.getNonStrokingColorSpace() instanceof PDPattern) {\n        // apply clip to path to avoid oversized device bounds in shading contexts (PDFBOX-2901)\n        Area area = new Area(linePath);\n        Shape clip = graphics.getClip();\n        if (clip != null) {\n            area.intersect(new Area(clip));\n        }\n        intersectShadingBBox(graphicsState.getNonStrokingColor(), area);\n        shape = area;\n    } else {\n        shape = linePath;\n    }\n    if (isContentRendered() && (!shape.getPathIterator(null).isDone())) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        graphics.setPaint(getNonStrokingPaint());\n        graphics.fill(shape);\n    }\n    linePath.reset();\n    if (noAntiAlias) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "public Composite getNonStrokingJavaComposite() {\n    return BlendComposite.getInstance(blendMode, ((float) (nonStrokingAlphaConstant)));\n}", "/**\n * Creates a blend composite\n *\n * @param blendMode\n * \t\tDesired blend mode\n * @param constantAlpha\n * \t\tConstant alpha, must be in the inclusive range\n * \t\t[0.0...1.0] or it will be clipped.\n * @return a blend composite.\n * @throws IllegalArgumentException\n * \t\tif blendMode is null.\n */\npublic static Composite getInstance(BlendMode blendMode, float constantAlpha) {\n    if (constantAlpha < 0) {\n        LOG.warn(\"using 0 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 0;\n    } else if (constantAlpha > 1) {\n        LOG.warn(\"using 1 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 1;\n    }\n    if (blendMode == null) {\n        throw new IllegalArgumentException(\"blendMode parameter cannot be null\");\n    }\n    if (blendMode == BlendMode.NORMAL) {\n        return AlphaComposite.getInstance(AlphaComposite.SRC_OVER, constantAlpha);\n    } else {\n        return new BlendComposite(blendMode, constantAlpha);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.dereferenceCOSObject", "org.apache.pdfbox.pdfparser.COSParser.parseObjectDynamically", "org.apache.pdfbox.pdfparser.COSParser.parseFileObject" ],
    "fullMethods" : [ "@Override\npublic COSBase dereferenceCOSObject(COSObject obj) throws IOException {\n    long currentPos = source.getPosition();\n    COSObjectKey key = obj.getKey();\n    COSBase parsedObj = parseObjectDynamically(key, false);\n    if (parsedObj != null) {\n        parsedObj.setDirect(false);\n        parsedObj.setKey(key);\n    }\n    if (currentPos > 0) {\n        source.seek(currentPos);\n    }\n    return parsedObj;\n}", "/**\n * Parse the object for the given object key.\n *\n * @param objKey\n * \t\tkey of object to be parsed\n * @param requireExistingNotCompressedObj\n * \t\tif <code>true</code> the object to be parsed must be defined in xref\n * \t\t(comment: null objects may be missing from xref) and it must not be a compressed object within object stream\n * \t\t(this is used to circumvent being stuck in a loop in a malicious PDF)\n * @return the parsed object (which is also added to document object)\n * @throws IOException\n * \t\tIf an IO error occurs.\n */\nprotected synchronized COSBase parseObjectDynamically(COSObjectKey objKey, boolean requireExistingNotCompressedObj) throws IOException {\n    COSObject pdfObject = document.getObjectFromPool(objKey);\n    if (!pdfObject.isObjectNull()) {\n        return pdfObject.getObject();\n    }\n    Long offsetOrObjstmObNr = getObjectOffset(objKey, requireExistingNotCompressedObj);\n    COSBase referencedObject = null;\n    if (offsetOrObjstmObNr != null) {\n        if (offsetOrObjstmObNr > 0) {\n            referencedObject = parseFileObject(offsetOrObjstmObNr, objKey);\n        } else {\n            // xref value is object nr of object stream containing object to be parsed\n            // since our object was not found it means object stream was not parsed so far\n            referencedObject = parseObjectStreamObject(-offsetOrObjstmObNr, objKey);\n        }\n    }\n    if ((referencedObject == null) || (referencedObject instanceof COSNull)) {\n        // not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)\n        // or some other issue with dereferencing\n        // remove parser to avoid endless recursion\n        pdfObject.setToNull();\n    }\n    return referencedObject;\n}", "private COSBase parseFileObject(Long objOffset, final COSObjectKey objKey) throws IOException {\n    // jump to the object start\n    source.seek(objOffset);\n    // an indirect object starts with the object number/generation number\n    final long readObjNr = readObjectNumber();\n    final int readObjGen = readGenerationNumber();\n    readExpectedString(OBJ_MARKER, true);\n    // consistency check\n    if ((readObjNr != objKey.getNumber()) || (readObjGen != objKey.getGeneration())) {\n        throw new IOException(((((((((\"XREF for \" + objKey.getNumber()) + \":\") + objKey.getGeneration()) + \" points to wrong object: \") + readObjNr) + \":\") + readObjGen) + \" at offset \") + objOffset);\n    }\n    skipSpaces();\n    COSBase parsedObject = parseDirObject();\n    if (parsedObject != null) {\n        parsedObject.setDirect(false);\n        parsedObject.setKey(objKey);\n    }\n    String endObjectKey = readString();\n    if (endObjectKey.equals(STREAM_STRING)) {\n        source.rewind(endObjectKey.getBytes(StandardCharsets.ISO_8859_1).length);\n        if (parsedObject instanceof COSDictionary) {\n            COSStream stream = parseCOSStream(((COSDictionary) (parsedObject)));\n            if (securityHandler != null) {\n                securityHandler.decryptStream(stream, objKey.getNumber(), objKey.getGeneration());\n            }\n            parsedObject = stream;\n        } else {\n            // this is not legal\n            // the combination of a dict and the stream/endstream\n            // forms a complete stream object\n            throw new IOException((\"Stream not preceded by dictionary (offset: \" + objOffset) + \").\");\n        }\n        skipSpaces();\n        endObjectKey = readLine();\n        // we have case with a second 'endstream' before endobj\n        if ((!endObjectKey.startsWith(ENDOBJ_STRING)) && endObjectKey.startsWith(ENDSTREAM_STRING)) {\n            endObjectKey = endObjectKey.substring(9).trim();\n            if (endObjectKey.length() == 0) {\n                // no other characters in extra endstream line\n                // read next line\n                endObjectKey = readLine();\n            }\n        }\n    } else if (securityHandler != null) {\n        securityHandler.decrypt(parsedObject, objKey.getNumber(), objKey.getGeneration());\n    }\n    if (!endObjectKey.startsWith(ENDOBJ_STRING)) {\n        if (isLenient) {\n            LOG.warn((((((((\"Object (\" + readObjNr) + \":\") + readObjGen) + \") at offset \") + objOffset) + \" does not end with 'endobj' but with '\") + endObjectKey) + \"'\");\n        } else {\n            throw new IOException((((((((\"Object (\" + readObjNr) + \":\") + readObjGen) + \") at offset \") + objOffset) + \" does not end with 'endobj' but with '\") + endObjectKey) + \"'\");\n        }\n    }\n    return parsedObject;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getViewports",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getViewports" ],
    "fullMethods" : [ "/**\n * Get the viewports.\n *\n * @return a list of viewports or null if there is no /VP entry.\n */\npublic List<PDViewportDictionary> getViewports() {\n    COSArray array = page.getCOSArray(COSName.VP);\n    if (array == null) {\n        return null;\n    }\n    List<PDViewportDictionary> viewports = new ArrayList<>();\n    for (int i = 0; i < array.size(); ++i) {\n        COSBase base2 = array.getObject(i);\n        if (base2 instanceof COSDictionary) {\n            viewports.add(new PDViewportDictionary(((COSDictionary) (base2))));\n        } else {\n            LOG.warn((\"Array element \" + base2) + \" is skipped, must be a (viewport) dictionary\");\n        }\n    }\n    return viewports;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.closeNode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.closeNode", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.switchNodeCount", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount" ],
    "fullMethods" : [ "/**\n * Close this node.\n */\npublic void closeNode() {\n    if (isNodeOpen()) {\n        switchNodeCount();\n    }\n}", "private void switchNodeCount() {\n    int openCount = getOpenCount();\n    setOpenCount(-openCount);\n    updateParentOpenCount(-openCount);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<init>", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.loadList" ],
    "fullMethods" : [ "/**\n * Creates a new GlyphList from a glyph list file.\n *\n * @param numberOfEntries\n * \t\tnumber of expected values used to preallocate the correct amount of memory\n * @param input\n * \t\tglyph list in Adobe format\n * @throws IOException\n * \t\tif the glyph list could not be read\n */\npublic GlyphList(InputStream input, int numberOfEntries) throws IOException {\n    nameToUnicode = new HashMap<>(numberOfEntries);\n    unicodeToName = new HashMap<>(numberOfEntries);\n    loadList(input);\n}", "private void loadList(InputStream input) throws IOException {\n    try (BufferedReader in = new BufferedReader(new InputStreamReader(input, StandardCharsets.ISO_8859_1))) {\n        while (in.ready()) {\n            String line = in.readLine();\n            if ((line != null) && (!line.startsWith(\"#\"))) {\n                String[] parts = line.split(\";\");\n                if (parts.length < 2) {\n                    throw new IOException(\"Invalid glyph list entry: \" + line);\n                }\n                String name = parts[0];\n                String[] unicodeList = parts[1].split(\" \");\n                int[] codePoints = new int[unicodeList.length];\n                int index = 0;\n                for (String hex : unicodeList) {\n                    codePoints[index++] = Integer.parseInt(hex, 16);\n                }\n                String string = new String(codePoints, 0, codePoints.length);\n                // forward mapping\n                String oldMapping = nameToUnicode.put(name, string);\n                if (oldMapping != null) {\n                    LOG.warn(((((\"duplicate value for \" + name) + \" -> \") + parts[1]) + \" \") + nameToUnicode.get(name));\n                }\n                // reverse mapping\n                // PDFBOX-3884: take the various standard encodings as canonical,\n                // e.g. tilde over ilde\n                final boolean forceOverride = (((WinAnsiEncoding.INSTANCE.contains(name) || MacRomanEncoding.INSTANCE.contains(name)) || MacExpertEncoding.INSTANCE.contains(name)) || SymbolEncoding.INSTANCE.contains(name)) || ZapfDingbatsEncoding.INSTANCE.contains(name);\n                if (forceOverride) {\n                    unicodeToName.put(string, name);\n                } else {\n                    unicodeToName.putIfAbsent(string, name);\n                }\n            }\n        } \n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.drawImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.drawImage", "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getNonStrokingJavaComposite", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.getInstance" ],
    "fullMethods" : [ "@Override\npublic void drawImage(PDImage pdImage) throws IOException {\n    if ((pdImage instanceof PDImageXObject) && isHiddenOCG(((PDImageXObject) (pdImage)).getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    AffineTransform at = ctm.createAffineTransform();\n    if (!pdImage.getInterpolate()) {\n        // if the image is scaled down, we use smooth interpolation, eg PDFBOX-2364\n        // only when scaled up do we use nearest neighbour, eg PDFBOX-2302 / mori-cvpr01.pdf\n        // PDFBOX-4930: we use the sizes of the ARGB image. These can be different\n        // than the original sizes of the base image, when the mask is bigger.\n        // PDFBOX-5091: also consider subsampling, the sizes are different too.\n        BufferedImage bim;\n        if (subsamplingAllowed) {\n            bim = pdImage.getImage(null, getSubsampling(pdImage, at));\n        } else {\n            bim = pdImage.getImage();\n        }\n        boolean isScaledUp = (bim.getWidth() <= Math.abs(Math.round(ctm.getScalingFactorX() * xformScalingFactorX))) || (bim.getHeight() <= Math.abs(Math.round(ctm.getScalingFactorY() * xformScalingFactorY)));\n        if (isScaledUp) {\n            graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        }\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    if (pdImage.isStencil()) {\n        if (getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDPattern) {\n            // The earlier code for stencils (see \"else\") doesn't work with patterns because the\n            // CTM is not taken into consideration.\n            // this code is based on the fact that it is easily possible to draw the mask and\n            // the paint at the correct place with the existing code, but not in one step.\n            // Thus what we do is to draw both in separate images, then combine the two and draw\n            // the result.\n            // Note that the device scale is not used. In theory, some patterns can get better\n            // at higher resolutions but the stencil would become more and more \"blocky\".\n            // If anybody wants to do this, have a look at the code in showTransparencyGroup().\n            // draw the paint\n            Paint paint = getNonStrokingPaint();\n            Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);\n            Rectangle2D bounds = at.createTransformedShape(unitRect).getBounds2D();\n            int w = ((int) (Math.ceil(bounds.getWidth())));\n            int h = ((int) (Math.ceil(bounds.getHeight())));\n            BufferedImage renderedPaint = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n            Graphics2D g = ((Graphics2D) (renderedPaint.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setPaint(paint);\n            g.setRenderingHints(graphics.getRenderingHints());\n            g.fill(bounds);\n            g.dispose();\n            // draw the mask\n            BufferedImage mask = pdImage.getImage();\n            AffineTransform imageTransform = new AffineTransform(at);\n            imageTransform.scale(1.0 / mask.getWidth(), (-1.0) / mask.getHeight());\n            imageTransform.translate(0, -mask.getHeight());\n            AffineTransform full = new AffineTransform(g.getTransform());\n            full.concatenate(imageTransform);\n            Matrix m = new Matrix(full);\n            double scaleX = Math.abs(m.getScalingFactorX());\n            double scaleY = Math.abs(m.getScalingFactorY());\n            boolean smallMask = (mask.getWidth() <= 8) && (mask.getHeight() <= 8);\n            if ((mask.getWidth() == 1) && (mask.getHeight() == 1)) {\n                // PDFBOX-5802: force usage of the lookup table if it is only 1 pixel\n                // (See the comment for PDFBOX-5403 that it isn't done for some\n                // cases based purely on the rendering result of one file!)\n                smallMask = false;\n            }\n            if (!smallMask) {\n                // PDFBOX-5403:\n                // The mask is copied to RGB because this supports a smooth scaling, so we\n                // get a mask with 255 values instead of just 0 and 255.\n                // Inverting is done because when we don't do it, the getScaledInstance() call\n                // produces a black line in many masks. With the inversion we have a white line\n                // which is neutral. Because of the inversion we don't have to substract from 255\n                // in the \"apply the mask\" segment when rasterPixel[3] is assigned.\n                // The inversion is not done for very small ones, because of\n                // PDFBOX-2171-002-002710-p14.pdf where the \"New Harmony Consolidated\" and\n                // \"Sailor Springs\" patterns became almost invisible.\n                // (We may have to decide this differently in the future, e.g. on b/w relationship)\n                BufferedImage tmp = new BufferedImage(mask.getWidth(), mask.getHeight(), BufferedImage.TYPE_INT_RGB);\n                mask = new LookupOp(getInvLookupTable(), graphics.getRenderingHints()).filter(mask, tmp);\n            }\n            BufferedImage renderedMask = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n            g = ((Graphics2D) (renderedMask.getGraphics()));\n            g.translate(-bounds.getMinX(), -bounds.getMinY());\n            g.setRenderingHints(graphics.getRenderingHints());\n            if (smallMask) {\n                g.drawImage(mask, imageTransform, null);\n            } else if ((scaleX != 0) && (scaleY != 0)) {\n                while ((scaleX < 0.25) || (Math.round(mask.getWidth() * scaleX) < 1)) {\n                    scaleX *= 2.0;\n                } \n                while ((scaleY < 0.25) || (Math.round(mask.getHeight() * scaleY) < 1)) {\n                    scaleY *= 2.0;\n                } \n                int w2 = ((int) (Math.round(mask.getWidth() * scaleX)));\n                int h2 = ((int) (Math.round(mask.getHeight() * scaleY)));\n                Image scaledMask = mask.getScaledInstance(w2, h2, Image.SCALE_SMOOTH);\n                imageTransform.scale(1.0F / Math.abs(scaleX), 1.0F / Math.abs(scaleY));\n                g.drawImage(scaledMask, imageTransform, null);\n            }\n            g.dispose();\n            // apply the mask\n            int[] alphaPixel = null;\n            int[] rasterPixel = null;\n            WritableRaster raster = renderedPaint.getRaster();\n            WritableRaster alpha = renderedMask.getRaster();\n            for (int y = 0; y < h; y++) {\n                for (int x = 0; x < w; x++) {\n                    alphaPixel = alpha.getPixel(x, y, alphaPixel);\n                    rasterPixel = raster.getPixel(x, y, rasterPixel);\n                    rasterPixel[3] = alphaPixel[0];\n                    raster.setPixel(x, y, rasterPixel);\n                }\n            }\n            // draw the image\n            graphics.drawImage(renderedPaint, AffineTransform.getTranslateInstance(bounds.getMinX(), bounds.getMinY()), null);\n        } else {\n            // fill the image with stenciled paint\n            BufferedImage image = pdImage.getStencilImage(getNonStrokingPaint());\n            // draw the image\n            drawBufferedImage(pdImage, image, at);\n        }\n    } else if (subsamplingAllowed) {\n        int subsampling = getSubsampling(pdImage, at);\n        // draw the subsampled image\n        drawBufferedImage(pdImage, pdImage.getImage(null, subsampling), at);\n    } else {\n        // subsampling not allowed, draw the image\n        drawBufferedImage(pdImage, pdImage.getImage(), at);\n    }\n    if (!pdImage.getInterpolate()) {\n        // JDK 1.7 has a bug where rendering hints are reset by the above call to\n        // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n        setRenderingHints();\n    }\n}", "public Composite getNonStrokingJavaComposite() {\n    return BlendComposite.getInstance(blendMode, ((float) (nonStrokingAlphaConstant)));\n}", "/**\n * Creates a blend composite\n *\n * @param blendMode\n * \t\tDesired blend mode\n * @param constantAlpha\n * \t\tConstant alpha, must be in the inclusive range\n * \t\t[0.0...1.0] or it will be clipped.\n * @return a blend composite.\n * @throws IllegalArgumentException\n * \t\tif blendMode is null.\n */\npublic static Composite getInstance(BlendMode blendMode, float constantAlpha) {\n    if (constantAlpha < 0) {\n        LOG.warn(\"using 0 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 0;\n    } else if (constantAlpha > 1) {\n        LOG.warn(\"using 1 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 1;\n    }\n    if (blendMode == null) {\n        throw new IllegalArgumentException(\"blendMode parameter cannot be null\");\n    }\n    if (blendMode == BlendMode.NORMAL) {\n        return AlphaComposite.getInstance(AlphaComposite.SRC_OVER, constantAlpha);\n    } else {\n        return new BlendComposite(blendMode, constantAlpha);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.AppearanceGeneratorHelper.setAppearanceValue" ],
    "fullMethods" : [ "/**\n * This is the public method for setting the appearance stream.\n *\n * @param apValue\n * \t\tthe String value which the appearance should represent\n * @throws IOException\n * \t\tIf there is an error creating the stream.\n */\npublic void setAppearanceValue(String apValue) throws IOException {\n    value = getFormattedValue(apValue);\n    // Treat multiline field values in single lines as single lime values.\n    // This is in line with how Adobe Reader behaves when entering text\n    // interactively but NOT how it behaves when the field value has been\n    // set programmatically and Reader is forced to generate the appearance\n    // using PDAcroForm.setNeedAppearances\n    // see PDFBOX-3911\n    if ((field instanceof PDTextField) && (!((PDTextField) (field)).isMultiline())) {\n        value = value.replaceAll(\"\\\\u000D\\\\u000A|[\\\\u000A\\\\u000B\\\\u000C\\\\u000D\\\\u0085\\\\u2028\\\\u2029]\", \" \");\n    }\n    for (PDAnnotationWidget widget : field.getWidgets()) {\n        if (widget.getCOSObject().containsKey(\"PMD\")) {\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" is a PaperMetaData widget, no appearance stream created\");\n            continue;\n        }\n        // some fields have the /Da at the widget level if the\n        // widgets differ in layout.\n        PDDefaultAppearanceString acroFormAppearance = defaultAppearance;\n        if (widget.getCOSObject().getDictionaryObject(COSName.DA) != null) {\n            defaultAppearance = getWidgetDefaultAppearanceString(widget);\n        }\n        PDRectangle rect = widget.getRectangle();\n        if (rect == null) {\n            widget.getCOSObject().removeItem(COSName.AP);\n            LOG.warn((\"widget of field \" + field.getFullyQualifiedName()) + \" has no rectangle, no appearance stream created\");\n            continue;\n        }\n        PDAppearanceDictionary appearanceDict = widget.getAppearance();\n        if (appearanceDict == null) {\n            appearanceDict = new PDAppearanceDictionary();\n            widget.setAppearance(appearanceDict);\n        }\n        PDAppearanceEntry appearance = appearanceDict.getNormalAppearance();\n        // TODO support appearances other than \"normal\"\n        PDAppearanceStream appearanceStream;\n        if (isValidAppearanceStream(appearance)) {\n            appearanceStream = appearance.getAppearanceStream();\n        } else {\n            appearanceStream = prepareNormalAppearanceStream(widget);\n            appearanceDict.setNormalAppearance(appearanceStream);\n            // TODO support appearances other than \"normal\"\n        }\n        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();\n        /* Adobe Acrobat always recreates the complete appearance stream if there is an appearance characteristics\n        entry (the widget dictionaries MK entry). In addition if there is no content yet also create the appearance\n        stream from the entries.\n         */\n        if ((appearanceCharacteristics != null) || (appearanceStream.getContentStream().getLength() == 0)) {\n            initializeAppearanceContent(widget, appearanceCharacteristics, appearanceStream);\n        }\n        setAppearanceContent(widget, appearanceStream);\n        // restore the field level appearance\n        defaultAppearance = acroFormAppearance;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.PDFCloneUtility.cloneForNewDocument",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.PDFCloneUtility.cloneForNewDocument", "org.apache.pdfbox.multipdf.PDFCloneUtility.cloneCOSBaseForNewDocument", "org.apache.pdfbox.multipdf.PDFCloneUtility.cloneCOSArray", "org.apache.pdfbox.multipdf.PDFCloneUtility.hasSelfReference" ],
    "fullMethods" : [ "/**\n * Deep-clones the given object for inclusion into a different PDF document identified by the destination parameter.\n *\n * Expert use only, donât use it if you donât know exactly what you are doing.\n *\n * @param <TCOSBase>\n * \t\tThe type to be returned.\n * @param base\n * \t\tthe initial object as the root of the deep-clone operation\n * @return the cloned instance of the base object\n * @throws IOException\n * \t\tif an I/O error occurs\n */\n@SuppressWarnings(\"unchecked\")\npublic <TCOSBase extends COSBase> TCOSBase cloneForNewDocument(TCOSBase base) throws IOException {\n    if (base == null) {\n        return null;\n    }\n    COSBase retval = clonedVersion.get(base);\n    if (retval != null) {\n        // we are done, it has already been converted.\n        return ((TCOSBase) (retval));\n    }\n    if (clonedValues.contains(base)) {\n        // Don't clone a clone\n        return base;\n    }\n    retval = cloneCOSBaseForNewDocument(base);\n    clonedVersion.put(base, retval);\n    clonedValues.add(retval);\n    return ((TCOSBase) (retval));\n}", "private COSBase cloneCOSBaseForNewDocument(COSBase base) throws IOException {\n    if (base instanceof COSObject) {\n        return cloneForNewDocument(((COSObject) (base)).getObject());\n    }\n    if (base instanceof COSArray) {\n        return cloneCOSArray(((COSArray) (base)));\n    }\n    if (base instanceof COSStream) {\n        return cloneCOSStream(((COSStream) (base)));\n    }\n    if (base instanceof COSDictionary) {\n        return cloneCOSDictionary(((COSDictionary) (base)));\n    }\n    return base;\n}", "private COSArray cloneCOSArray(COSArray array) throws IOException {\n    COSArray newArray = new COSArray();\n    for (int i = 0; i < array.size(); i++) {\n        COSBase value = array.get(i);\n        if (hasSelfReference(array, value)) {\n            newArray.add(newArray);\n        } else {\n            newArray.add(cloneForNewDocument(value));\n        }\n    }\n    return newArray;\n}", "/**\n * Check whether an element (of an array or a dictionary) points to its parent.\n *\n * @param parent\n * \t\tCOSArray or COSDictionary\n * @param value\n * \t\tan element\n */\nprivate boolean hasSelfReference(COSBase parent, COSBase value) {\n    if (value instanceof COSObject) {\n        COSBase actual = ((COSObject) (value)).getObject();\n        if (actual == parent) {\n            COSObject cosObj = ((COSObject) (value));\n            LOG.warn((parent.getClass().getSimpleName() + \" object has a reference to itself: \") + cosObj.getKey());\n            return true;\n        }\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFParser.parse",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFParser.parse" ],
    "fullMethods" : [ "/**\n * This will parse the stream and populate the PDDocument object. This will close the keystore stream when it is\n * done parsing.\n *\n * @param lenient\n * \t\tactivate leniency if set to true\n * @return the populated PDDocument\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error reading from the stream or corrupt data is found.\n */\npublic PDDocument parse(boolean lenient) throws IOException {\n    setLenient(lenient);\n    // set to false if all is processed\n    boolean exceptionOccurred = true;\n    try {\n        // PDFBOX-1922 read the version header and rewind\n        if ((!parsePDFHeader()) && (!parseFDFHeader())) {\n            if (lenient) {\n                LOG.warn(\"Error: Header doesn't contain versioninfo\");\n            } else {\n                throw new IOException(\"Error: Header doesn't contain versioninfo\");\n            }\n        }\n        if (!initialParseDone) {\n            initialParse();\n        }\n        exceptionOccurred = false;\n        PDDocument pdDocument = createDocument();\n        pdDocument.setEncryptionDictionary(getEncryption());\n        return pdDocument;\n    } finally {\n        if (exceptionOccurred && (document != null)) {\n            IOUtils.closeQuietly(document);\n            document = null;\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getKids",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getKids" ],
    "fullMethods" : [ "/**\n * Return the children of this node.  This list will contain PDNumberTreeNode objects.\n *\n * @return The list of children or null if there are no children.\n */\npublic List<PDNumberTreeNode> getKids() {\n    List<PDNumberTreeNode> retval = null;\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids != null) {\n        List<PDNumberTreeNode> pdObjects = new ArrayList<>(kids.size());\n        for (int i = 0; i < kids.size(); i++) {\n            COSBase base = kids.getObject(i);\n            PDNumberTreeNode childNode;\n            if (base instanceof COSDictionary) {\n                childNode = createChildNode(((COSDictionary) (base)));\n            } else {\n                LOG.warn(\"Bad child node at position \" + i);\n                childNode = new PDNumberTreeNode(valueType);\n            }\n            pdObjects.add(childNode);\n        }\n        retval = new COSArrayList<>(pdObjects, kids);\n    }\n    return retval;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.iterator",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.iterator", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.<init>", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.<init>", "org.apache.pdfbox.pdmodel.PDPageTree.PageIterator.enqueueKids", "org.apache.pdfbox.pdmodel.PDPageTree.access", "org.apache.pdfbox.pdmodel.PDPageTree.getKids" ],
    "fullMethods" : [ "/**\n * Returns an iterator which walks all pages in the tree, in order.\n */\n@Override\npublic Iterator<PDPage> iterator() {\n    return new PageIterator(root);\n}", "private PageIterator(COSDictionary node) {\n    enqueueKids(node);\n    set = null;// release memory, we don't use this anymore\n\n}", "private PageIterator(COSDictionary node) {\n    enqueueKids(node);\n    set = null;// release memory, we don't use this anymore\n\n}", "private void enqueueKids(COSDictionary node) {\n    if (isPageTreeNode(node)) {\n        List<COSDictionary> kids = getKids(node);\n        for (COSDictionary kid : kids) {\n            if (set.contains(kid)) {\n                // PDFBOX-5009, PDFBOX-3953: prevent stack overflow with malformed PDFs\n                LOG.error(\"This page tree node has already been visited\");\n                continue;\n            } else if (kid.containsKey(COSName.KIDS)) {\n                set.add(kid);\n            }\n            enqueueKids(kid);\n        }\n    } else if ((node != null) && COSName.PAGE.equals(node.getCOSName(COSName.TYPE))) {\n        queue.add(node);\n    } else {\n        LOG.error(\"Page skipped due to an invalid or missing type \" + (node == null ? \"(null)\" : node.getCOSName(COSName.TYPE)));\n    }\n}", "{\n    java.util.List $stack2;\n    org.apache.pdfbox.cos.COSDictionary x1;\n    org.apache.pdfbox.pdmodel.PDPageTree x0;\n\n\n    x0 := @parameter0: org.apache.pdfbox.pdmodel.PDPageTree;\n    x1 := @parameter1: org.apache.pdfbox.cos.COSDictionary;\n    $stack2 = specialinvoke x0.<org.apache.pdfbox.pdmodel.PDPageTree: java.util.List getKids(org.apache.pdfbox.cos.COSDictionary)>(x1);\n\n    return $stack2;\n}\n", "/**\n * Helper to get kids from malformed PDFs.\n *\n * @param node\n * \t\tpage tree node\n * @return list of kids\n */\nprivate List<COSDictionary> getKids(COSDictionary node) {\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // probably a malformed PDF\n        return Collections.emptyList();\n    }\n    int size = kids.size();\n    List<COSDictionary> result = new ArrayList<>(size);\n    for (int i = 0; i < size; i++) {\n        COSBase base = kids.getObject(i);\n        if (base instanceof COSDictionary) {\n            result.add(((COSDictionary) (base)));\n        } else if (base == null) {\n            LOG.warn(\"replaced null entry with an empty page\");\n            COSDictionary emptyPage = new COSDictionary();\n            emptyPage.setItem(COSName.TYPE, COSName.PAGE);\n            kids.set(i, emptyPage);\n            result.add(emptyPage);\n        } else {\n            LOG.warn(\"COSDictionary expected, but got \" + base.getClass().getSimpleName());\n        }\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getNames",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getNames" ],
    "fullMethods" : [ "/**\n * This will return a map of names on this level. The key will be a string,\n * and the value will depend on where this class is being used.\n *\n * @return ordered map of COS objects or <code>null</code> if the dictionary\ncontains no 'Names' entry on this level.\n * @throws IOException\n * \t\tIf there is an error while creating the sub types.\n * @see #getKids()\n */\npublic Map<String, T> getNames() throws IOException {\n    COSArray namesArray = node.getCOSArray(COSName.NAMES);\n    if (namesArray != null) {\n        int size = namesArray.size();\n        Map<String, T> names = new LinkedHashMap<>(size);\n        if ((namesArray.size() % 2) != 0) {\n            LOG.warn(\"Names array has odd size: \" + size);\n        }\n        for (int i = 0; (i + 1) < size; i += 2) {\n            COSBase base = namesArray.getObject(i);\n            if (!(base instanceof COSString)) {\n                throw new IOException(((\"Expected string, found \" + base) + \" in name tree at index \") + i);\n            }\n            COSString key = ((COSString) (base));\n            COSBase cosValue = namesArray.getObject(i + 1);\n            names.put(key.getString(), convertCOSToPD(cosValue));\n        }\n        return Collections.unmodifiableMap(names);\n    } else {\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType3Font.readEncoding" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param resourceCache\n * \t\tResource cache, can be null.\n * @throws IOException\n * \t\tif the font could not be created\n */\npublic PDType3Font(COSDictionary fontDictionary, ResourceCache resourceCache) throws IOException {\n    super(fontDictionary);\n    this.resourceCache = resourceCache;\n    readEncoding();\n}", "@Override\nprotected final void readEncoding() throws IOException {\n    COSBase encodingBase = dict.getDictionaryObject(COSName.ENCODING);\n    if (encodingBase instanceof COSName) {\n        COSName encodingName = ((COSName) (encodingBase));\n        encoding = Encoding.getInstance(encodingName);\n        if (encoding == null) {\n            LOG.warn(\"Unknown encoding: \" + encodingName.getName());\n        }\n    } else if (encodingBase instanceof COSDictionary) {\n        encoding = new DictionaryEncoding(((COSDictionary) (encodingBase)));\n    }\n    glyphList = GlyphList.getAdobeGlyphList();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.getHeight",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.getHeight" ],
    "fullMethods" : [ "@Override\npublic float getHeight(int code) throws IOException {\n    String name = codeToName(code);\n    float height;\n    if (!glyphHeights.containsKey(name)) {\n        if (cffFont == null) {\n            LOG.warn(\"No embedded CFF font, returning 0\");\n            return 0;\n        }\n        height = ((float) (cffFont.getType1CharString(name).getBounds().getHeight()));\n        glyphHeights.put(name, height);\n    } else {\n        height = glyphHeights.get(name);\n    }\n    return height;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDCIDFontType2.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @param parent\n * \t\tThe parent font.\n * @param trueTypeFont\n * \t\tThe true type font used to create the parent font\n * @throws IOException\n * \t\tif the font could not be read\n */\npublic PDCIDFontType2(COSDictionary fontDictionary, PDType0Font parent, TrueTypeFont trueTypeFont) throws IOException {\n    super(fontDictionary, parent);\n    PDFontDescriptor fd = getFontDescriptor();\n    if (trueTypeFont != null) {\n        ttf = trueTypeFont;\n        otf = ((trueTypeFont instanceof OpenTypeFont) && ((OpenTypeFont) (trueTypeFont)).isSupportedOTF()) ? ((OpenTypeFont) (trueTypeFont)) : null;\n        isEmbedded = true;\n        isDamaged = false;\n    } else {\n        boolean fontIsDamaged = false;\n        TrueTypeFont ttfFont = null;\n        PDStream stream = null;\n        if (fd != null) {\n            stream = fd.getFontFile2();\n            if (stream == null) {\n                stream = fd.getFontFile3();\n            }\n            if (stream == null) {\n                // Acrobat looks in FontFile too, even though it is not in the spec, see PDFBOX-2599\n                stream = fd.getFontFile();\n            }\n        }\n        if (stream != null) {\n            try {\n                // embedded OTF or TTF\n                RandomAccessRead view = stream.getCOSObject().createView();\n                TTFParser ttfParser = getParser(view, true);\n                ttfFont = ttfParser.parse(view);\n                ttfFont.close();\n            } catch (IOException e) {\n                fontIsDamaged = true;\n                LOG.warn(\"Could not read embedded OTF for font \" + getBaseFont(), e);\n            }\n            if ((ttfFont instanceof OpenTypeFont) && (!((OpenTypeFont) (ttfFont)).isSupportedOTF())) {\n                // the OpenType font contains CFF2 outlines which are not supported yet\n                ttfFont = null;\n                fontIsDamaged = true;\n                LOG.warn(\"Found an OpenType font using CFF2 outlines which are not supported \" + fd.getFontName());\n            }\n        }\n        isEmbedded = ttfFont != null;\n        isDamaged = fontIsDamaged;\n        if (ttfFont == null) {\n            ttfFont = findFontOrSubstitute();\n        }\n        otf = ((ttfFont instanceof OpenTypeFont) && ((OpenTypeFont) (ttfFont)).isSupportedOTF()) ? ((OpenTypeFont) (ttfFont)) : null;\n        ttf = ttfFont;\n    }\n    cmap = ttf.getUnicodeCmapLookup(false);\n    cid2gid = readCIDToGIDMap();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.openNode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.openNode", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.switchNodeCount", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount" ],
    "fullMethods" : [ "/**\n * This will set this node to be open when it is shown in the viewer. By default, when a new node is created it will\n * be closed. This will do nothing if the node is already open.\n */\npublic void openNode() {\n    // if the node is already open then do nothing.\n    if (!isNodeOpen()) {\n        switchNodeCount();\n    }\n}", "private void switchNodeCount() {\n    int openCount = getOpenCount();\n    setOpenCount(-openCount);\n    updateParentOpenCount(-openCount);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setTrailer",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setTrailer" ],
    "fullMethods" : [ "/**\n * Adds trailer information for current XRef object.\n *\n * @param trailer\n * \t\tthe current document trailer dictionary\n */\npublic void setTrailer(COSDictionary trailer) {\n    if (curXrefTrailerObj == null) {\n        // should not happen...\n        LOG.warn(\"Cannot add trailer because XRef start was not signalled.\");\n        return;\n    }\n    curXrefTrailerObj.trailer = trailer;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.LineTo.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.LineTo.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.size() < 2) {\n        throw new MissingOperandException(operator, operands);\n    }\n    COSBase base0 = operands.get(0);\n    if (!(base0 instanceof COSNumber)) {\n        return;\n    }\n    COSBase base1 = operands.get(1);\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    // append straight line segment from the current point to the point\n    COSNumber x = ((COSNumber) (base0));\n    COSNumber y = ((COSNumber) (base1));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    Point2D.Float pos = context.transformedPoint(x.floatValue(), y.floatValue());\n    if (context.getCurrentPoint() == null) {\n        LOG.warn((((\"LineTo (\" + pos.x) + \",\") + pos.y) + \") without initial MoveTo\");\n        context.moveTo(pos.x, pos.y);\n    } else {\n        context.lineTo(pos.x, pos.y);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param dict\n * \t\tThe annotations dictionary.\n */\npublic PDAnnotation(COSDictionary dict) {\n    dictionary = dict;\n    COSBase type = dict.getDictionaryObject(COSName.TYPE);\n    if (type == null) {\n        dictionary.setItem(COSName.TYPE, COSName.ANNOT);\n    } else if (!COSName.ANNOT.equals(type)) {\n        LOG.warn((\"Annotation has type \" + type) + \", further mayhem may follow\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.text.PDFTextStripper.setEndPage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.text.PDFTextStripper.setEndPage" ],
    "fullMethods" : [ "/**\n * This will set the last page to be extracted by this class.\n *\n * @param endPageValue\n * \t\tNew value of 1-based endPage property.\n */\npublic void setEndPage(int endPageValue) {\n    if (endPageValue <= 0) {\n        LOG.warn(\"Parameter must be 1-based, but is \" + endPageValue);\n    }\n    endPage = endPageValue;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.<init>", "org.apache.pdfbox.pdmodel.fdf.FDFAnnotationStamp.parseStampAnnotationAppearanceXML" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param a\n * \t\tAn existing FDF Annotation.\n */\npublic FDFAnnotationStamp(COSDictionary a) {\n    super(a);\n}", "/**\n * This will create an Appearance dictionary from an appearance XML element.\n *\n * @param appearanceXML\n * \t\tThe XML element that contains the appearance data.\n */\nprivate COSDictionary parseStampAnnotationAppearanceXML(Element appearanceXML) throws IOException {\n    COSDictionary dictionary = new COSDictionary();\n    // the N entry is required.\n    dictionary.setItem(COSName.N, new COSStream());\n    LOG.debug(\"Build dictionary for Appearance based on the appearanceXML\");\n    NodeList nodeList = appearanceXML.getChildNodes();\n    String parentAttrKey = appearanceXML.getAttribute(\"KEY\");\n    LOG.debug(((((((\"Appearance Root - tag: \" + appearanceXML.getTagName()) + \", name: \") + appearanceXML.getNodeName()) + \", key: \") + parentAttrKey) + \", children: \") + nodeList.getLength());\n    // Currently only handles Appearance dictionary (AP key on the root)\n    if (!\"AP\".equals(appearanceXML.getAttribute(\"KEY\"))) {\n        LOG.warn((((parentAttrKey + \" => Not handling element: \") + appearanceXML.getTagName()) + \" with key: \") + appearanceXML.getAttribute(\"KEY\"));\n        return dictionary;\n    }\n    for (int i = 0; i < nodeList.getLength(); i++) {\n        Node node = nodeList.item(i);\n        if (node instanceof Element) {\n            Element child = ((Element) (node));\n            String childTagName = child.getTagName();\n            if (\"STREAM\".equalsIgnoreCase(childTagName)) {\n                LOG.debug((((parentAttrKey + \" => Process \") + child.getAttribute(\"KEY\")) + \" item in the dictionary after processing the \") + childTagName);\n                dictionary.setItem(child.getAttribute(\"KEY\"), parseStreamElement(child));\n                LOG.debug((parentAttrKey + \" => Set \") + child.getAttribute(\"KEY\"));\n            } else {\n                LOG.warn((parentAttrKey + \" => Not handling element: \") + childTagName);\n            }\n        }\n    }\n    return dictionary;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateFinalPoint.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateFinalPoint.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.size() < 4) {\n        throw new MissingOperandException(operator, operands);\n    }\n    if (!checkArrayTypesClass(operands, COSNumber.class)) {\n        return;\n    }\n    COSNumber x1 = ((COSNumber) (operands.get(0)));\n    COSNumber y1 = ((COSNumber) (operands.get(1)));\n    COSNumber x3 = ((COSNumber) (operands.get(2)));\n    COSNumber y3 = ((COSNumber) (operands.get(3)));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    Point2D currentPoint = context.getCurrentPoint();\n    Point2D.Float point1 = context.transformedPoint(x1.floatValue(), y1.floatValue());\n    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());\n    if (currentPoint == null) {\n        LOG.warn((((\"curveTo (\" + point3.x) + \",\") + point3.y) + \") without initial MoveTo\");\n        context.moveTo(point3.x, point3.y);\n    } else {\n        context.curveTo(point1.x, point1.y, point3.x, point3.y, point3.x, point3.y);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.flatten",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm.flatten" ],
    "fullMethods" : [ "/**\n * This will flatten all form fields.\n *\n * <p>\n * Flattening a form field will take the current appearance and make that part of the pages content stream. All form\n * fields and annotations associated are removed.\n * </p>\n *\n * <p>\n * Invisible and hidden fields will be skipped and will not become part of the page content stream\n * </p>\n *\n * <p>\n * The appearances for the form fields widgets will <strong>not</strong> be generated\n * </p>\n *\n * @throws IOException\n * \t\tif something went wrong flattening the fields\n */\npublic void flatten() throws IOException {\n    // for dynamic XFA forms there is no flatten as this would mean to do a rendering\n    // from the XFA content into a static PDF.\n    if (xfaIsDynamic()) {\n        LOG.warn(\"Flatten for a dynamix XFA form is not supported\");\n        return;\n    }\n    List<PDField> fields = new ArrayList<>();\n    for (PDField field : getFieldTree()) {\n        fields.add(field);\n    }\n    flatten(fields, false);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.load",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.load", "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType0Font.readEncoding" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param randomAccessRead\n * \t\tsource of a TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding. Set this to false when creating a font for\n * \t\tAcroForm.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font load(PDDocument doc, RandomAccessRead randomAccessRead, boolean embedSubset, boolean vertical) throws IOException {\n    return new PDType0Font(doc, new TTFParser().parse(randomAccessRead), embedSubset, true, vertical);\n}", "/**\n * Private. Creates a new PDType0Font font for embedding.\n *\n * @param document\n * @param ttf\n * @param embedSubset\n * @param closeTTF\n * \t\twhether to close the ttf parameter after embedding. Must be true when the ttf\n * \t\tparameter was created in the load() method, false when the ttf parameter was passed to the\n * \t\tload() method.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @throws IOException\n */\nprivate PDType0Font(PDDocument document, TrueTypeFont ttf, boolean embedSubset, boolean closeTTF, boolean vertical) throws IOException {\n    if (vertical) {\n        ttf.enableVerticalSubstitutions();\n    }\n    gsubData = ttf.getGsubData();\n    cmapLookup = ttf.getUnicodeCmapLookup();\n    embedder = new PDCIDFontType2Embedder(document, dict, ttf, embedSubset, this, vertical);\n    descendantFont = embedder.getCIDFont();\n    readEncoding();\n    fetchCMapUCS2();\n    if (closeTTF) {\n        if (embedSubset) {\n            this.ttf = ttf;\n            document.registerTrueTypeFontForClosing(ttf);\n        } else {\n            // the TTF is fully loaded and it is safe to close the underlying data source\n            ttf.close();\n        }\n    }\n}", "/**\n * Reads the font's Encoding entry, which should be a CMap name/stream.\n */\nprivate void readEncoding() throws IOException {\n    COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);\n    if (encoding instanceof COSName) {\n        // predefined CMap\n        COSName encodingName = ((COSName) (encoding));\n        cMap = CMapManager.getPredefinedCMap(encodingName.getName());\n        isCMapPredefined = true;\n    } else if (encoding != null) {\n        cMap = readCMap(encoding);\n        if (cMap == null) {\n            throw new IOException(\"Missing required CMap\");\n        } else if (!cMap.hasCIDMappings()) {\n            LOG.warn(\"Invalid Encoding CMap in font \" + getName());\n        }\n    }\n    // check if the descendant font is CJK\n    PDCIDSystemInfo ros = descendantFont.getCIDSystemInfo();\n    if (ros != null) {\n        String ordering = ros.getOrdering();\n        isDescendantCJK = \"Adobe\".equals(ros.getRegistry()) && (((\"GB1\".equals(ordering) || \"CNS1\".equals(ordering)) || \"Japan1\".equals(ordering)) || \"Korea1\".equals(ordering));\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageTree.indexOf",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageTree.indexOf", "org.apache.pdfbox.pdmodel.PDPageTree.findPage", "org.apache.pdfbox.pdmodel.PDPageTree.getKids" ],
    "fullMethods" : [ "/**\n * Returns the index of the given page, or -1 if it does not exist.\n *\n * @param page\n * \t\tThe page to search for.\n * @return the zero-based index of the given page, or -1 if the page is not found.\n */\npublic int indexOf(PDPage page) {\n    SearchContext context = new SearchContext(page);\n    if (findPage(context, root)) {\n        return context.index;\n    }\n    return -1;\n}", "private boolean findPage(SearchContext context, COSDictionary node) {\n    for (COSDictionary kid : getKids(node)) {\n        if (context.found) {\n            break;\n        }\n        if (isPageTreeNode(kid)) {\n            findPage(context, kid);\n        } else {\n            context.visitPage(kid);\n        }\n    }\n    return context.found;\n}", "/**\n * Helper to get kids from malformed PDFs.\n *\n * @param node\n * \t\tpage tree node\n * @return list of kids\n */\nprivate List<COSDictionary> getKids(COSDictionary node) {\n    COSArray kids = node.getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        // probably a malformed PDF\n        return Collections.emptyList();\n    }\n    int size = kids.size();\n    List<COSDictionary> result = new ArrayList<>(size);\n    for (int i = 0; i < size; i++) {\n        COSBase base = kids.getObject(i);\n        if (base instanceof COSDictionary) {\n            result.add(((COSDictionary) (base)));\n        } else if (base == null) {\n            LOG.warn(\"replaced null entry with an empty page\");\n            COSDictionary emptyPage = new COSDictionary();\n            emptyPage.setItem(COSName.TYPE, COSName.PAGE);\n            kids.set(i, emptyPage);\n            result.add(emptyPage);\n        } else {\n            LOG.warn(\"COSDictionary expected, but got \" + base.getClass().getSimpleName());\n        }\n    }\n    return result;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.ClosePath.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.ClosePath.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    if (context.getCurrentPoint() == null) {\n        LOG.warn(\"ClosePath without initial MoveTo\");\n        return;\n    }\n    context.closePath();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.create",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.create", "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.<init>", "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.loadICCProfile" ],
    "fullMethods" : [ "/**\n * Creates a new ICC color space using the PDF array, optionally using a resource cache.\n *\n * @param iccArray\n * \t\tthe ICC stream object.\n * @param resources\n * \t\tresources to use as cache, or null for no caching.\n * @return an ICC color space.\n * @throws IOException\n * \t\tif there is an error reading the ICC profile or if the parameter is\n * \t\tinvalid.\n */\npublic static PDICCBased create(COSArray iccArray, PDResources resources) throws IOException {\n    checkArray(iccArray);\n    COSBase base = iccArray.get(1);\n    if ((base instanceof COSObject) && (resources != null)) {\n        ResourceCache resourceCache = resources.getResourceCache();\n        if (resourceCache != null) {\n            COSObject indirect = ((COSObject) (base));\n            PDColorSpace space = resourceCache.getColorSpace(indirect);\n            if (space instanceof PDICCBased) {\n                return ((PDICCBased) (space));\n            } else {\n                PDICCBased newSpace = new PDICCBased(iccArray);\n                resourceCache.put(indirect, newSpace);\n                return newSpace;\n            }\n        }\n    }\n    return new PDICCBased(iccArray);\n}", "/**\n * Creates a new ICC color space with an empty stream.\n *\n * @param doc\n * \t\tthe document to store the ICC data\n */\npublic PDICCBased(PDDocument doc) {\n    array = new COSArray();\n    array.add(COSName.ICCBASED);\n    stream = new PDStream(doc);\n    array.add(stream);\n}", "/**\n * Load the ICC profile, or init alternateColorSpace color space.\n */\nprivate void loadICCProfile() throws IOException {\n    if (useOnlyAlternateColorSpace) {\n        try {\n            fallbackToAlternateColorSpace(null);\n            return;\n        } catch (IOException e) {\n            LOG.warn(\"Error initializing alternate color space: \" + e.getLocalizedMessage());\n        }\n    }\n    try (InputStream input = this.stream.createInputStream()) {\n        // if the embedded profile is sRGB then we can use Java's built-in profile, which\n        // results in a large performance gain as it's our native color space, see PDFBOX-2587\n        ICC_Profile profile;\n        synchronized(LOG) {\n            profile = ICC_Profile.getInstance(input);\n            if (is_sRGB(profile)) {\n                isRGB = true;\n                awtColorSpace = ((ICC_ColorSpace) (ColorSpace.getInstance(ColorSpace.CS_sRGB)));\n                iccProfile = awtColorSpace.getProfile();\n            } else {\n                profile = ensureDisplayProfile(profile);\n                awtColorSpace = new ICC_ColorSpace(profile);\n                iccProfile = profile;\n            }\n            // set initial colour\n            int numOfComponents = getNumberOfComponents();\n            float[] initial = new float[numOfComponents];\n            for (int c = 0; c < initial.length; c++) {\n                initial[c] = Math.max(0, getRangeForComponent(c).getMin());\n            }\n            initialColor = new PDColor(initial, this);\n            // do things that trigger a ProfileDataException\n            // or CMMException due to invalid profiles, see PDFBOX-1295 and PDFBOX-1740 (Ã¼-file)\n            // or ArrayIndexOutOfBoundsException, see PDFBOX-3610\n            // also triggers \"CMMException: LCMS error 13\" for PDFBOX-5563 with LCMS, but\n            // calling \"new ComponentColorModel\" doesn't\n            awtColorSpace.toRGB(new float[numOfComponents]);\n            // PDFBOX-4015: this one triggers \"CMMException: LCMS error 13\" with LCMS\n            new ComponentColorModel(awtColorSpace, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n        }\n    } catch (ProfileDataException | CMMException | IllegalArgumentException | ArrayIndexOutOfBoundsException | IOException e) {\n        fallbackToAlternateColorSpace(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateInitialPoint.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.graphics.CurveToReplicateInitialPoint.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> operands) throws IOException {\n    if (operands.size() < 4) {\n        throw new MissingOperandException(operator, operands);\n    }\n    if (!checkArrayTypesClass(operands, COSNumber.class)) {\n        return;\n    }\n    COSNumber x2 = ((COSNumber) (operands.get(0)));\n    COSNumber y2 = ((COSNumber) (operands.get(1)));\n    COSNumber x3 = ((COSNumber) (operands.get(2)));\n    COSNumber y3 = ((COSNumber) (operands.get(3)));\n    PDFGraphicsStreamEngine context = getGraphicsContext();\n    Point2D currentPoint = context.getCurrentPoint();\n    Point2D.Float point2 = context.transformedPoint(x2.floatValue(), y2.floatValue());\n    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());\n    if (currentPoint == null) {\n        LOG.warn((((\"curveTo (\" + point3.x) + \",\") + point3.y) + \") without initial MoveTo\");\n        context.moveTo(point3.x, point3.y);\n    } else {\n        context.curveTo(((float) (currentPoint.getX())), ((float) (currentPoint.getY())), point2.x, point2.y, point3.x, point3.y);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.addFirst",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.addFirst", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCountForAddedChild", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount" ],
    "fullMethods" : [ "/**\n * Adds the given node to the top of the children list.\n *\n * @param newChild\n * \t\tThe node to add.\n * @throws IllegalArgumentException\n * \t\tif the given node is part of a list (i.e. if it has a previous or a next\n * \t\tsibling)\n */\npublic void addFirst(PDOutlineItem newChild) {\n    requireSingleNode(newChild);\n    prepend(newChild);\n    updateParentOpenCountForAddedChild(newChild);\n}", "void updateParentOpenCountForAddedChild(PDOutlineItem newChild) {\n    int delta = 1;\n    if (newChild.isNodeOpen()) {\n        delta += newChild.getOpenCount();\n    }\n    newChild.updateParentOpenCount(delta);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingPaint.createContext", "org.apache.pdfbox.pdmodel.graphics.shading.Type6ShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PatchMeshesShadingContext.<init>", "org.apache.pdfbox.pdmodel.graphics.shading.PDMeshBasedShadingType.collectPatches" ],
    "fullMethods" : [ "@Override\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    try {\n        return new Type6ShadingContext(shading, cm, xform, matrix, deviceBounds);\n    } catch (IOException e) {\n        LOG.error(\"An error occurred while painting\", e);\n        return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);\n    }\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @throws IOException\n * \t\tif something went wrong\n */\nType6ShadingContext(PDShadingType6 shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds) throws IOException {\n    super(shading, colorModel, xform, matrix, deviceBounds, 12);\n}", "/**\n * Constructor creates an instance to be used for fill operations.\n *\n * @param shading\n * \t\tthe shading type to be used\n * @param colorModel\n * \t\tthe color model to be used\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param deviceBounds\n * \t\tdevice bounds\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @throws IOException\n * \t\tif something went wrong\n */\nprotected PatchMeshesShadingContext(PDMeshBasedShadingType shading, ColorModel colorModel, AffineTransform xform, Matrix matrix, Rectangle deviceBounds, int controlPoints) throws IOException {\n    super(shading, colorModel, xform, matrix);\n    patchList = shading.collectPatches(xform, matrix, controlPoints);\n    createPixelTable(deviceBounds);\n}", "/**\n * Create a patch list from a data stream, the returned list contains all the patches contained in the data stream.\n *\n * @param xform\n * \t\ttransformation for user to device space\n * @param matrix\n * \t\tthe pattern matrix concatenated with that of the parent content stream\n * @param controlPoints\n * \t\tnumber of control points, 12 for type 6 shading and 16 for type 7 shading\n * @return the obtained patch list\n * @throws IOException\n * \t\twhen something went wrong\n */\n@SuppressWarnings({ \"squid:S2583\", \"squid:S1166\" })\nfinal List<Patch> collectPatches(AffineTransform xform, Matrix matrix, int controlPoints) throws IOException {\n    COSDictionary dict = getCOSObject();\n    if (!(dict instanceof COSStream)) {\n        return Collections.emptyList();\n    }\n    PDRange rangeX = getDecodeForParameter(0);\n    PDRange rangeY = getDecodeForParameter(1);\n    if ((((rangeX == null) || (rangeY == null)) || (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0)) || (Float.compare(rangeY.getMin(), rangeY.getMax()) == 0)) {\n        return Collections.emptyList();\n    }\n    int bitsPerFlag = getBitsPerFlag();\n    PDRange[] colRange = new PDRange[getNumberOfColorComponents()];\n    for (int i = 0; i < colRange.length; ++i) {\n        colRange[i] = getDecodeForParameter(2 + i);\n        if (colRange[i] == null) {\n            throw new IOException(\"Range missing in shading /Decode entry\");\n        }\n    }\n    List<Patch> list = new ArrayList<>();\n    long maxSrcCoord = ((long) (Math.pow(2, getBitsPerCoordinate()))) - 1;\n    long maxSrcColor = ((long) (Math.pow(2, getBitsPerComponent()))) - 1;\n    // MemoryCacheImageInputStream doesn't close the wrapped stream\n    try (InputStream imageStream = ((COSStream) (dict)).createInputStream()) {\n        try (ImageInputStream mciis = new MemoryCacheImageInputStream(imageStream)) {\n            Point2D[] implicitEdge = new Point2D[4];\n            float[][] implicitCornerColor = new float[2][colRange.length];\n            byte flag = 0;\n            try {\n                flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n            } catch (EOFException ex) {\n                LOG.error(ex);\n                return list;\n            }\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    boolean isFree = flag == 0;\n                    Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);\n                    if (current == null) {\n                        break;\n                    }\n                    list.add(current);\n                    flag = ((byte) (mciis.readBits(bitsPerFlag) & 3));\n                    switch (flag) {\n                        case 0 :\n                            break;\n                        case 1 :\n                            implicitEdge = current.getFlag1Edge();\n                            implicitCornerColor = current.getFlag1Color();\n                            break;\n                        case 2 :\n                            implicitEdge = current.getFlag2Edge();\n                            implicitCornerColor = current.getFlag2Color();\n                            break;\n                        case 3 :\n                            implicitEdge = current.getFlag3Edge();\n                            implicitCornerColor = current.getFlag3Color();\n                            break;\n                        default :\n                            LOG.warn(\"bad flag: \" + flag);\n                            break;\n                    }\n                } catch (EOFException ex) {\n                    eof = true;\n                }\n            } \n        }\n    }\n    return list;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.shadingFill",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.shadingFill", "org.apache.pdfbox.pdmodel.graphics.state.PDGraphicsState.getNonStrokingJavaComposite", "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.getInstance" ],
    "fullMethods" : [ "@Override\npublic void shadingFill(COSName shadingName) throws IOException {\n    if (!isContentRendered()) {\n        return;\n    }\n    PDShading shading = getResources().getShading(shadingName);\n    if (shading == null) {\n        LOG.error((\"shading \" + shadingName) + \" does not exist in resources dictionary\");\n        return;\n    }\n    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    Shape savedClip = graphics.getClip();\n    graphics.setClip(null);\n    lastClips = null;\n    // get the transformed BBox and intersect with current clipping path\n    // need to do it here and not in shading getRaster() because it may have been rotated\n    PDRectangle bbox = shading.getBBox();\n    Area area;\n    if (bbox != null) {\n        area = new Area(bbox.transform(ctm));\n        area.intersect(getGraphicsState().getCurrentClippingPath());\n    } else {\n        Rectangle2D bounds = shading.getBounds(new AffineTransform(), ctm);\n        if (bounds != null) {\n            bounds.add(new Point2D.Double(Math.floor(bounds.getMinX() - 1), Math.floor(bounds.getMinY() - 1)));\n            bounds.add(new Point2D.Double(Math.ceil(bounds.getMaxX() + 1), Math.ceil(bounds.getMaxY() + 1)));\n            area = new Area(bounds);\n            area.intersect(getGraphicsState().getCurrentClippingPath());\n        } else {\n            area = getGraphicsState().getCurrentClippingPath();\n        }\n    }\n    if (!area.isEmpty()) {\n        // creating Paint is sometimes a costly operation, so avoid if possible\n        Paint paint = shading.toPaint(ctm);\n        paint = applySoftMaskToPaint(paint, getGraphicsState().getSoftMask());\n        graphics.setPaint(paint);\n        graphics.fill(area);\n    }\n    graphics.setClip(savedClip);\n}", "public Composite getNonStrokingJavaComposite() {\n    return BlendComposite.getInstance(blendMode, ((float) (nonStrokingAlphaConstant)));\n}", "/**\n * Creates a blend composite\n *\n * @param blendMode\n * \t\tDesired blend mode\n * @param constantAlpha\n * \t\tConstant alpha, must be in the inclusive range\n * \t\t[0.0...1.0] or it will be clipped.\n * @return a blend composite.\n * @throws IllegalArgumentException\n * \t\tif blendMode is null.\n */\npublic static Composite getInstance(BlendMode blendMode, float constantAlpha) {\n    if (constantAlpha < 0) {\n        LOG.warn(\"using 0 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 0;\n    } else if (constantAlpha > 1) {\n        LOG.warn(\"using 1 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 1;\n    }\n    if (blendMode == null) {\n        throw new IllegalArgumentException(\"blendMode parameter cannot be null\");\n    }\n    if (blendMode == BlendMode.NORMAL) {\n        return AlphaComposite.getInstance(AlphaComposite.SRC_OVER, constantAlpha);\n    } else {\n        return new BlendComposite(blendMode, constantAlpha);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDStream.getDecodeParms",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDStream.getDecodeParms", "org.apache.pdfbox.pdmodel.common.PDStream.internalGetDecodeParams" ],
    "fullMethods" : [ "/**\n * Get the list of decode parameters. Each entry in the list will refer to\n * an entry in the filters list.\n *\n * @return The list of decode parameters.\n * @throws IOException\n * \t\tif there is an error retrieving the parameters.\n */\npublic List<Object> getDecodeParms() throws IOException {\n    // See PDF Ref 1.5 implementation note 7, /DP is sometimes used instead.\n    return internalGetDecodeParams(COSName.DECODE_PARMS, COSName.DP);\n}", "private List<Object> internalGetDecodeParams(COSName name1, COSName name2) throws IOException {\n    COSBase dp = stream.getDictionaryObject(name1, name2);\n    if (dp instanceof COSDictionary) {\n        Map<?, ?> map = COSDictionaryMap.convertBasicTypesToMap(((COSDictionary) (dp)));\n        return new COSArrayList<>(map, dp, stream, name1);\n    }\n    if (dp instanceof COSArray) {\n        COSArray array = ((COSArray) (dp));\n        List<Object> actuals = new ArrayList<>(array.size());\n        for (int i = 0; i < array.size(); i++) {\n            COSBase base = array.getObject(i);\n            if (base instanceof COSDictionary) {\n                actuals.add(COSDictionaryMap.convertBasicTypesToMap(((COSDictionary) (base))));\n            } else {\n                LOG.warn((\"Expected COSDictionary, got \" + base) + \", ignored\");\n            }\n        }\n        return new COSArrayList<>(actuals, array);\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.DictionaryEncoding.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.DictionaryEncoding.<init>" ],
    "fullMethods" : [ "/**\n * Creates a new DictionaryEncoding for a Type 3 font from a PDF.\n *\n * @param fontEncoding\n * \t\tThe Type 3 encoding dictionary.\n */\npublic DictionaryEncoding(COSDictionary fontEncoding) {\n    encoding = fontEncoding;\n    COSName name = encoding.getCOSName(COSName.BASE_ENCODING);\n    if (name != null) {\n        baseEncoding = Encoding.getInstance(name);// null when the name is invalid\n\n        if (baseEncoding != null) {\n            // PDFBOX-5963\n            // PDF Specification: \"Differences array shall specify the complete character\n            // encoding for this font\" but other viewers read it, thus we do too.\n            LOG.warn(\"/BaseEncoding in type 3 font\");\n            codeToName.putAll(baseEncoding.codeToName);\n            inverted.putAll(baseEncoding.inverted);\n        }\n    } else {\n        baseEncoding = null;\n    }\n    applyDifferences();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.<init>" ],
    "fullMethods" : [ "/**\n * Constructor.\n *\n * @param fontDictionary\n * \t\tthe corresponding dictionary\n * @throws IOException\n * \t\tit something went wrong\n */\npublic PDType1CFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    boolean fontIsDamaged = false;\n    CFFType1Font cffEmbedded = null;\n    PDFontDescriptor fd = getFontDescriptor();\n    if (fd != null) {\n        PDStream ff3Stream = fd.getFontFile3();\n        if (ff3Stream != null) {\n            try (RandomAccessRead randomAccessRead = ff3Stream.getCOSObject().createView()) {\n                if (randomAccessRead.length() == 0) {\n                    LOG.error(\"Invalid data for embedded Type1C font \" + getName());\n                } else {\n                    // note: this could be an OpenType file, fortunately CFFParser can handle that\n                    CFFParser cffParser = new CFFParser();\n                    CFFFont parsedCffFont = cffParser.parse(randomAccessRead).get(0);\n                    if (parsedCffFont instanceof CFFType1Font) {\n                        cffEmbedded = ((CFFType1Font) (parsedCffFont));\n                    } else {\n                        LOG.error(\"Expected CFFType1Font, got \" + parsedCffFont.getClass().getSimpleName());\n                        fontIsDamaged = true;\n                    }\n                }\n            } catch (IOException e) {\n                LOG.error(\"Can't read the embedded Type1C font \" + getName(), e);\n                fontIsDamaged = true;\n            }\n        }\n    }\n    isDamaged = fontIsDamaged;\n    cffFont = cffEmbedded;\n    if (cffFont != null) {\n        genericFont = cffFont;\n        isEmbedded = true;\n    } else {\n        String baseFont = getBaseFont();\n        FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(baseFont, fd);\n        genericFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + genericFont.getName()) + \" for \") + baseFont);\n        }\n        isEmbedded = false;\n    }\n    readEncoding();\n    fontMatrixTransform = getFontMatrix().createAffineTransform();\n    fontMatrixTransform.scale(1000, 1000);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDColor.<init>" ],
    "fullMethods" : [ "/**\n * Creates a PDColor containing the given color value.\n *\n * @param array\n * \t\ta COS array containing the color value\n * @param colorSpace\n * \t\tcolor space in which the color value is defined\n */\npublic PDColor(COSArray array, PDColorSpace colorSpace) {\n    if ((array.size() > 0) && (array.get(array.size() - 1) instanceof COSName)) {\n        // color components (optional), for the color of an uncoloured tiling pattern\n        components = new float[array.size() - 1];\n        initComponents(array);\n        // pattern name (required)\n        COSBase base = array.get(array.size() - 1);\n        if (base instanceof COSName) {\n            patternName = ((COSName) (base));\n        } else {\n            LOG.warn((\"pattern name in \" + array) + \" isn't a name, ignored\");\n            patternName = COSName.getPDFName(\"Unknown\");\n        }\n    } else {\n        // color components only\n        components = new float[array.size()];\n        initComponents(array);\n        patternName = null;\n    }\n    this.colorSpace = colorSpace;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getContentsForStreamParsing",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getContentsForStreamParsing" ],
    "fullMethods" : [ "@Override\npublic RandomAccessRead getContentsForStreamParsing() throws IOException {\n    // return a stream based reader if there is just one stream\n    COSStream contentStream = page.getCOSStream(COSName.CONTENTS);\n    if ((contentStream != null) && COSName.FLATE_DECODE.equals(contentStream.getFilters())) {\n        // for now only streams using a flate filter are supported\n        try {\n            FlateFilterDecoderStream decoderStream = new FlateFilterDecoderStream(contentStream.createRawInputStream());\n            return new NonSeekableRandomAccessReadInputStream(decoderStream);\n        } catch (IOException exception) {\n            LOG.warn(\"skipped malformed content stream\");\n            return new RandomAccessReadBuffer(DELIMITER);\n        }\n    }\n    return getContentsForRandomAccess();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getNumbers",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getNumbers" ],
    "fullMethods" : [ "/**\n * This will return a map of numbers on this level. The key will be a java.lang.Integer, the\n * value will depend on where this class is being used.\n *\n * @return A map of COS objects.\n * @throws IOException\n * \t\tIf there is a problem creating the values.\n */\npublic Map<Integer, COSObjectable> getNumbers() throws IOException {\n    Map<Integer, COSObjectable> indices = null;\n    COSArray numbersArray = node.getCOSArray(COSName.NUMS);\n    if (numbersArray != null) {\n        int size = numbersArray.size();\n        indices = new HashMap<>();\n        if ((size % 2) != 0) {\n            LOG.warn(\"Numbers array has odd size: \" + size);\n        }\n        for (int i = 0; (i + 1) < size; i += 2) {\n            COSBase base = numbersArray.getObject(i);\n            if (!(base instanceof COSInteger)) {\n                LOG.error(((\"page labels ignored, index \" + i) + \" should be a number, but is \") + base);\n                return null;\n            }\n            COSInteger key = ((COSInteger) (base));\n            COSBase cosValue = numbersArray.getObject(i + 1);\n            indices.put(key.intValue(), cosValue == null ? null : convertCOSToPD(cosValue));\n        }\n        indices = Collections.unmodifiableMap(indices);\n    }\n    return indices;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType0Font.readEncoding" ],
    "fullMethods" : [ "/**\n * Constructor for reading a Type0 font from a PDF file.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @throws IOException\n * \t\tif the descendant font is missing.\n */\npublic PDType0Font(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    gsubData = GsubData.NO_DATA_FOUND;\n    cmapLookup = null;\n    COSArray descendantFonts = dict.getCOSArray(COSName.DESCENDANT_FONTS);\n    if (descendantFonts == null) {\n        throw new IOException(\"Missing descendant font array\");\n    }\n    if (descendantFonts.size() == 0) {\n        throw new IOException(\"Descendant font array is empty\");\n    }\n    COSBase descendantFontDictBase = descendantFonts.getObject(0);\n    if (!(descendantFontDictBase instanceof COSDictionary)) {\n        throw new IOException(\"Missing descendant font dictionary\");\n    }\n    if (!COSName.FONT.equals(((COSDictionary) (descendantFontDictBase)).getCOSName(COSName.TYPE, COSName.FONT))) {\n        throw new IOException(\"Missing or wrong type in descendant font dictionary\");\n    }\n    descendantFont = PDFontFactory.createDescendantFont(((COSDictionary) (descendantFontDictBase)), this);\n    readEncoding();\n    fetchCMapUCS2();\n}", "/**\n * Reads the font's Encoding entry, which should be a CMap name/stream.\n */\nprivate void readEncoding() throws IOException {\n    COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);\n    if (encoding instanceof COSName) {\n        // predefined CMap\n        COSName encodingName = ((COSName) (encoding));\n        cMap = CMapManager.getPredefinedCMap(encodingName.getName());\n        isCMapPredefined = true;\n    } else if (encoding != null) {\n        cMap = readCMap(encoding);\n        if (cMap == null) {\n            throw new IOException(\"Missing required CMap\");\n        } else if (!cMap.hasCIDMappings()) {\n            LOG.warn(\"Invalid Encoding CMap in font \" + getName());\n        }\n    }\n    // check if the descendant font is CJK\n    PDCIDSystemInfo ros = descendantFont.getCIDSystemInfo();\n    if (ros != null) {\n        String ordering = ros.getOrdering();\n        isDescendantCJK = \"Adobe\".equals(ros.getRegistry()) && (((\"GB1\".equals(ordering) || \"CNS1\".equals(ordering)) || \"Japan1\".equals(ordering)) || \"Korea1\".equals(ordering));\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType0Font.loadVertical", "org.apache.pdfbox.pdmodel.font.PDType0Font.<init>", "org.apache.pdfbox.pdmodel.font.PDType0Font.readEncoding" ],
    "fullMethods" : [ "/**\n * Loads a TTF to be embedded into a document as a vertical Type 0 font.\n *\n * @param doc\n * \t\tThe PDF document that will hold the embedded font.\n * @param ttf\n * \t\tA TrueType font.\n * @param embedSubset\n * \t\tTrue if the font will be subset before embedding\n * @return A Type0 font with a CIDFontType2 descendant.\n * @throws IOException\n * \t\tIf there is an error reading the font stream.\n */\npublic static PDType0Font loadVertical(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException {\n    return new PDType0Font(doc, ttf, embedSubset, false, true);\n}", "/**\n * Private. Creates a new PDType0Font font for embedding.\n *\n * @param document\n * @param ttf\n * @param embedSubset\n * @param closeTTF\n * \t\twhether to close the ttf parameter after embedding. Must be true when the ttf\n * \t\tparameter was created in the load() method, false when the ttf parameter was passed to the\n * \t\tload() method.\n * @param vertical\n * \t\twhether to enable vertical substitutions.\n * @throws IOException\n */\nprivate PDType0Font(PDDocument document, TrueTypeFont ttf, boolean embedSubset, boolean closeTTF, boolean vertical) throws IOException {\n    if (vertical) {\n        ttf.enableVerticalSubstitutions();\n    }\n    gsubData = ttf.getGsubData();\n    cmapLookup = ttf.getUnicodeCmapLookup();\n    embedder = new PDCIDFontType2Embedder(document, dict, ttf, embedSubset, this, vertical);\n    descendantFont = embedder.getCIDFont();\n    readEncoding();\n    fetchCMapUCS2();\n    if (closeTTF) {\n        if (embedSubset) {\n            this.ttf = ttf;\n            document.registerTrueTypeFontForClosing(ttf);\n        } else {\n            // the TTF is fully loaded and it is safe to close the underlying data source\n            ttf.close();\n        }\n    }\n}", "/**\n * Reads the font's Encoding entry, which should be a CMap name/stream.\n */\nprivate void readEncoding() throws IOException {\n    COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);\n    if (encoding instanceof COSName) {\n        // predefined CMap\n        COSName encodingName = ((COSName) (encoding));\n        cMap = CMapManager.getPredefinedCMap(encodingName.getName());\n        isCMapPredefined = true;\n    } else if (encoding != null) {\n        cMap = readCMap(encoding);\n        if (cMap == null) {\n            throw new IOException(\"Missing required CMap\");\n        } else if (!cMap.hasCIDMappings()) {\n            LOG.warn(\"Invalid Encoding CMap in font \" + getName());\n        }\n    }\n    // check if the descendant font is CJK\n    PDCIDSystemInfo ros = descendantFont.getCIDSystemInfo();\n    if (ros != null) {\n        String ordering = ros.getOrdering();\n        isDescendantCJK = \"Adobe\".equals(ros.getRegistry()) && (((\"GB1\".equals(ordering) || \"CNS1\".equals(ordering)) || \"Japan1\".equals(ordering)) || \"Korea1\".equals(ordering));\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.printing.PDFPrintable.print",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.printing.PDFPrintable.print" ],
    "fullMethods" : [ "@Override\npublic int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n    if ((pageIndex < 0) || (pageIndex >= pageTree.getCount())) {\n        return NO_SUCH_PAGE;\n    }\n    try {\n        Graphics2D graphics2D = ((Graphics2D) (graphics));\n        // capture the DPI that will be used for rasterizing the image\n        // if rasterizing is specified\n        float rasterDpi = dpi;\n        if (rasterDpi == RASTERIZE_DPI_AUTO) {\n            rasterDpi = ((float) (graphics2D.getTransform().getScaleX())) * 72.0F;\n            LOG.debug(\"auto raster dpi: \" + rasterDpi);\n        }\n        PDPage page = pageTree.get(pageIndex);\n        PDRectangle cropBox = getRotatedCropBox(page);\n        // the imageable area is the area within the page margins\n        final double imageableWidth = pageFormat.getImageableWidth();\n        final double imageableHeight = pageFormat.getImageableHeight();\n        double scale = 1;\n        if (scaling != Scaling.ACTUAL_SIZE) {\n            // scale to fit\n            double scaleX = imageableWidth / cropBox.getWidth();\n            double scaleY = imageableHeight / cropBox.getHeight();\n            scale = Math.min(scaleX, scaleY);\n            // only shrink to fit when enabled\n            if ((scale > 1) && (scaling == Scaling.SHRINK_TO_FIT)) {\n                scale = 1;\n            }\n            // only stretch to fit when enabled\n            if ((scale < 1) && (scaling == Scaling.STRETCH_TO_FIT)) {\n                scale = 1;\n            }\n        }\n        // set the graphics origin to the origin of the imageable area (i.e the margins)\n        graphics2D.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n        // center on page\n        if (center) {\n            double dx = (imageableWidth - (cropBox.getWidth() * scale)) / 2;\n            double dy = (imageableHeight - (cropBox.getHeight() * scale)) / 2;\n            if ((dx >= 0) && (dy >= 0)) {\n                graphics2D.translate(dx, dy);\n            } else {\n                // PDFBOX-3117 and https://lists.apache.org/thread/12s9tc93ofgmjfq1dpqfps9p725l0wwr\n                LOG.warn((((\"Centering disabled because of negative translation value (\" + dx) + \",\") + dy) + \")\");\n            }\n        }\n        // rasterize to bitmap (optional)\n        Graphics2D printerGraphics = null;\n        BufferedImage image = null;\n        if ((dpi > 0) || (dpi == RASTERIZE_DPI_AUTO)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"dpi set to \" + rasterDpi);\n            }\n            float dpiScale = rasterDpi / 72;\n            image = new BufferedImage(((int) ((imageableWidth * dpiScale) / scale)), ((int) ((imageableHeight * dpiScale) / scale)), BufferedImage.TYPE_INT_ARGB);\n            printerGraphics = graphics2D;\n            graphics2D = image.createGraphics();\n            // rescale\n            printerGraphics.scale(scale / dpiScale, scale / dpiScale);\n            scale = dpiScale;\n        }\n        // draw to graphics using PDFRender\n        AffineTransform transform = graphics2D.getTransform();\n        graphics2D.setBackground(Color.WHITE);\n        renderer.setSubsamplingAllowed(subsamplingAllowed);\n        renderer.setRenderingHints(renderingHints);\n        renderer.renderPageToGraphics(pageIndex, graphics2D, ((float) (scale)), ((float) (scale)), RenderDestination.PRINT);\n        // draw crop box\n        if (showPageBorder) {\n            graphics2D.setTransform(transform);\n            graphics2D.setClip(0, 0, ((int) (imageableWidth)), ((int) (imageableHeight)));\n            graphics2D.scale(scale, scale);\n            graphics2D.setColor(Color.GRAY);\n            graphics2D.setStroke(new BasicStroke(0.5F));\n            graphics.drawRect(0, 0, ((int) (cropBox.getWidth())), ((int) (cropBox.getHeight())));\n        }\n        // draw rasterized bitmap (optional)\n        if (printerGraphics != null) {\n            printerGraphics.setBackground(Color.WHITE);\n            printerGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());\n            printerGraphics.drawImage(image, 0, 0, null);\n            graphics2D.dispose();\n        }\n        return PAGE_EXISTS;\n    } catch (IOException e) {\n        throw new PrinterIOException(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLinkAppearanceHandler.generateNormalAppearance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.annotation.handlers.PDLinkAppearanceHandler.generateNormalAppearance" ],
    "fullMethods" : [ "@Override\npublic void generateNormalAppearance() {\n    PDAnnotationLink annotation = ((PDAnnotationLink) (getAnnotation()));\n    PDRectangle rect = annotation.getRectangle();\n    if (rect == null) {\n        // 660402-p1-AnnotationEmptyRect.pdf has /Rect entry with 0 elements\n        return;\n    }\n    // Adobe doesn't generate an appearance for a link annotation\n    float lineWidth = getLineWidth();\n    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {\n        PDColor color = annotation.getColor();\n        if (color == null) {\n            // spec is unclear, but black is what Adobe does\n            color = new PDColor(new float[]{ 0 }, PDDeviceGray.INSTANCE);\n        }\n        boolean hasStroke = contentStream.setStrokingColorOnDemand(color);\n        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());\n        // Acrobat applies a padding to each side of the bbox so the line is completely within\n        // the bbox.\n        PDRectangle borderEdge = getPaddedRectangle(getRectangle(), lineWidth / 2);\n        float[] pathsArray = annotation.getQuadPoints();\n        if (pathsArray != null) {\n            // QuadPoints shall be ignored if any coordinate in the array lies outside\n            // the region specified by Rect.\n            for (int i = 0; i < (pathsArray.length / 2); ++i) {\n                if (!rect.contains(pathsArray[i * 2], pathsArray[(i * 2) + 1])) {\n                    LOG.warn((((((\"At least one /QuadPoints entry (\" + pathsArray[i * 2]) + \";\") + pathsArray[(i * 2) + 1]) + \") is outside of rectangle, \") + rect) + \", /QuadPoints are ignored and /Rect is used instead\");\n                    pathsArray = null;\n                    break;\n                }\n            }\n        }\n        if (pathsArray == null) {\n            // Convert rectangle coordinates as if it was a /QuadPoints entry\n            pathsArray = new float[8];\n            pathsArray[0] = borderEdge.getLowerLeftX();\n            pathsArray[1] = borderEdge.getLowerLeftY();\n            pathsArray[2] = borderEdge.getUpperRightX();\n            pathsArray[3] = borderEdge.getLowerLeftY();\n            pathsArray[4] = borderEdge.getUpperRightX();\n            pathsArray[5] = borderEdge.getUpperRightY();\n            pathsArray[6] = borderEdge.getLowerLeftX();\n            pathsArray[7] = borderEdge.getUpperRightY();\n        }\n        boolean underlined = false;\n        if (pathsArray.length >= 8) {\n            PDBorderStyleDictionary borderStyleDic = annotation.getBorderStyle();\n            if (borderStyleDic != null) {\n                underlined = PDBorderStyleDictionary.STYLE_UNDERLINE.equals(borderStyleDic.getStyle());\n            }\n        }\n        int of = 0;\n        while ((of + 7) < pathsArray.length) {\n            contentStream.moveTo(pathsArray[of], pathsArray[of + 1]);\n            contentStream.lineTo(pathsArray[of + 2], pathsArray[of + 3]);\n            if (!underlined) {\n                contentStream.lineTo(pathsArray[of + 4], pathsArray[of + 5]);\n                contentStream.lineTo(pathsArray[of + 6], pathsArray[of + 7]);\n                contentStream.closePath();\n            }\n            of += 8;\n        } \n        contentStream.drawShape(lineWidth, hasStroke, false);\n    } catch (IOException e) {\n        LOG.error(e);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.getInstance",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.blend.BlendComposite.getInstance" ],
    "fullMethods" : [ "/**\n * Creates a blend composite\n *\n * @param blendMode\n * \t\tDesired blend mode\n * @param constantAlpha\n * \t\tConstant alpha, must be in the inclusive range\n * \t\t[0.0...1.0] or it will be clipped.\n * @return a blend composite.\n * @throws IllegalArgumentException\n * \t\tif blendMode is null.\n */\npublic static Composite getInstance(BlendMode blendMode, float constantAlpha) {\n    if (constantAlpha < 0) {\n        LOG.warn(\"using 0 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 0;\n    } else if (constantAlpha > 1) {\n        LOG.warn(\"using 1 instead of incorrect Alpha \" + constantAlpha);\n        constantAlpha = 1;\n    }\n    if (blendMode == null) {\n        throw new IllegalArgumentException(\"blendMode parameter cannot be null\");\n    }\n    if (blendMode == BlendMode.NORMAL) {\n        return AlphaComposite.getInstance(AlphaComposite.SRC_OVER, constantAlpha);\n    } else {\n        return new BlendComposite(blendMode, constantAlpha);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.state.SetLineDashPattern.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.state.SetLineDashPattern.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws MissingOperandException {\n    if (arguments.size() < 2) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    COSBase base0 = arguments.get(0);\n    if (!(base0 instanceof COSArray)) {\n        return;\n    }\n    COSBase base1 = arguments.get(1);\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    COSArray dashArray = ((COSArray) (base0));\n    int dashPhase = ((COSNumber) (base1)).intValue();\n    for (COSBase base : dashArray) {\n        if (base instanceof COSNumber) {\n            COSNumber num = ((COSNumber) (base));\n            if (Float.compare(num.floatValue(), 0) != 0) {\n                break;\n            }\n        } else {\n            LOG.warn((\"dash array has non number element \" + base) + \", ignored\");\n            dashArray = new COSArray();\n            break;\n        }\n    }\n    getContext().setLineDashPattern(dashArray, dashPhase);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPage.getContentsForRandomAccess",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPage.getContentsForRandomAccess" ],
    "fullMethods" : [ "@Override\npublic RandomAccessRead getContentsForRandomAccess() throws IOException {\n    COSStream contentStream = page.getCOSStream(COSName.CONTENTS);\n    if (contentStream != null) {\n        try {\n            return contentStream.createView();\n        } catch (IOException exception) {\n            LOG.warn(\"skipped malformed content stream\");\n            return new RandomAccessReadBuffer(DELIMITER);\n        }\n    }\n    COSArray array = page.getCOSArray(COSName.CONTENTS);\n    if (array != null) {\n        List<COSStream> streams = // \n        // \n        // \n        // \n        array.toList().stream().map(o -> o instanceof COSObject ? ((COSObject) (o)).getObject() : o).filter(COSStream.class::isInstance).map(b -> ((COSStream) (b))).collect(Collectors.toList());\n        List<RandomAccessRead> inputStreams = new ArrayList<>();\n        streams.forEach(stream -> {\n            try {\n                inputStreams.add(stream.createView());\n                inputStreams.add(new RandomAccessReadBuffer(DELIMITER));\n            } catch (IOException exception) {\n                LOG.warn(\"malformed substream of content stream skipped\");\n            }\n        });\n        if (!inputStreams.isEmpty()) {\n            return new SequenceRandomAccessRead(inputStreams);\n        }\n    }\n    return new RandomAccessReadBuffer(new byte[0]);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.COSParser.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.COSParser.<init>", "org.apache.pdfbox.pdfparser.COSParser.init" ],
    "fullMethods" : [ "/**\n * Constructor for encrypted pdfs.\n *\n * @param source\n * \t\tinput representing the pdf.\n * @param password\n * \t\tpassword to be used for decryption.\n * @param keyStore\n * \t\tkey store to be used for decryption when using public key security\n * @param keyAlias\n * \t\talias to be used for decryption when using public key security\n * @param streamCacheCreateFunction\n * \t\ta function to create an instance of the stream cache\n * @throws IOException\n * \t\tif the source data could not be read\n */\npublic COSParser(RandomAccessRead source, String password, InputStream keyStore, String keyAlias, StreamCacheCreateFunction streamCacheCreateFunction) throws IOException {\n    super(source);\n    this.password = password;\n    this.keyAlias = keyAlias;\n    fileLen = source.length();\n    keyStoreInputStream = keyStore;\n    init(streamCacheCreateFunction);\n}", "private void init(StreamCacheCreateFunction streamCacheCreateFunction) {\n    String eofLookupRangeStr = System.getProperty(SYSPROP_EOFLOOKUPRANGE);\n    if (eofLookupRangeStr != null) {\n        try {\n            setEOFLookupRange(Integer.parseInt(eofLookupRangeStr));\n        } catch (NumberFormatException nfe) {\n            LOG.warn((((\"System property \" + SYSPROP_EOFLOOKUPRANGE) + \" does not contain an integer value, but: '\") + eofLookupRangeStr) + \"'\");\n        }\n    }\n    document = new COSDocument(streamCacheCreateFunction, this);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDButton.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances" ],
    "fullMethods" : [ "/**\n * Set the selected option given its index, and try to update the visual appearance.\n *\n * NOTE: this method is only usable if there are export values and used for\n * radio buttons with FLAG_RADIOS_IN_UNISON not set.\n *\n * @param index\n * \t\tindex of option to be selected\n * @throws IOException\n * \t\tif the value could not be set\n * @throws IllegalArgumentException\n * \t\tif the index provided is not a valid index.\n */\npublic void setValue(int index) throws IOException {\n    List<String> exportValues = getExportValues();\n    if ((exportValues.isEmpty() || (index < 0)) || (index >= exportValues.size())) {\n        throw new IllegalArgumentException(((((\"index '\" + index) + \"' is not a valid index for the field \") + getFullyQualifiedName()) + \", valid indices are from 0 to \") + (exportValues.size() - 1));\n    }\n    updateByValue(String.valueOf(index));\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.getNumberOfComponents",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.color.PDICCBased.getNumberOfComponents" ],
    "fullMethods" : [ "@Override\npublic int getNumberOfComponents() {\n    if (numberOfComponents < 0) {\n        numberOfComponents = stream.getCOSObject().getInt(COSName.N);\n        // PDFBOX-4801 correct wrong /N values\n        if (iccProfile != null) {\n            int numIccComponents = iccProfile.getNumComponents();\n            if (numIccComponents != numberOfComponents) {\n                LOG.warn((((\"Using \" + numIccComponents) + \" components from ICC profile info instead of \") + numberOfComponents) + \" components from /N entry\");\n                numberOfComponents = numIccComponents;\n            }\n        }\n    }\n    return numberOfComponents;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1Font.<init>" ],
    "fullMethods" : [ "/**\n * Creates a Type 1 standard 14 font for embedding.\n *\n * @param baseFont\n * \t\tOne of the standard 14 PostScript names, e.g. {@link FontName#HELVETICA_BOLD}.\n */\npublic PDType1Font(FontName baseFont) {\n    super(baseFont);\n    dict.setItem(COSName.SUBTYPE, COSName.TYPE1);\n    dict.setName(COSName.BASE_FONT, baseFont.getName());\n    switch (baseFont) {\n        case ZAPF_DINGBATS :\n            encoding = ZapfDingbatsEncoding.INSTANCE;\n            break;\n        case SYMBOL :\n            encoding = SymbolEncoding.INSTANCE;\n            break;\n        default :\n            encoding = WinAnsiEncoding.INSTANCE;\n            dict.setItem(COSName.ENCODING, COSName.WIN_ANSI_ENCODING);\n            break;\n    }\n    // todo: could load the PFB font here if we wanted to support Standard 14 embedding\n    type1font = null;\n    FontMapping<FontBoxFont> mapping = FontMappers.instance().getFontBoxFont(getBaseFont(), getFontDescriptor());\n    genericFont = mapping.getFont();\n    if (mapping.isFallback()) {\n        String fontName;\n        try {\n            fontName = genericFont.getName();\n        } catch (IOException e) {\n            LOG.debug(\"Couldn't get font name - setting to '?'\", e);\n            fontName = \"?\";\n        }\n        LOG.warn(((\"Using fallback font \" + fontName) + \" for base font \") + getBaseFont());\n    }\n    isEmbedded = false;\n    isDamaged = false;\n    fontMatrixTransform = new AffineTransform();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getResources",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3CharProc.getResources" ],
    "fullMethods" : [ "@Override\npublic PDResources getResources() {\n    if (charStream.containsKey(COSName.RESOURCES)) {\n        // PDFBOX-5294\n        LOG.warn(\"Using resources dictionary found in charproc entry\");\n        LOG.warn(\"This should have been in the font or in the page dictionary\");\n        return new PDResources(charStream.getCOSDictionary(COSName.RESOURCES));\n    }\n    return font.getResources();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType3Font.getBoundingBox",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType3Font.getBoundingBox", "org.apache.pdfbox.pdmodel.font.PDType3Font.generateBoundingBox" ],
    "fullMethods" : [ "@Override\npublic BoundingBox getBoundingBox() {\n    if (fontBBox == null) {\n        fontBBox = generateBoundingBox();\n    }\n    return fontBBox;\n}", "private BoundingBox generateBoundingBox() {\n    PDRectangle rect = getFontBBox();\n    if (rect == null) {\n        LOG.warn(\"FontBBox missing, returning empty rectangle\");\n        return new BoundingBox();\n    }\n    if (!isNonZeroBoundingBox(rect)) {\n        // Plan B: get the max bounding box of the glyphs\n        COSDictionary cp = getCharProcs();\n        if (cp != null) {\n            for (COSName name : cp.keySet()) {\n                COSStream typ3CharProcStream = cp.getCOSStream(name);\n                if (typ3CharProcStream != null) {\n                    PDType3CharProc charProc = new PDType3CharProc(this, typ3CharProcStream);\n                    try {\n                        PDRectangle glyphBBox = charProc.getGlyphBBox();\n                        if (glyphBBox == null) {\n                            continue;\n                        }\n                        rect.setLowerLeftX(Math.min(rect.getLowerLeftX(), glyphBBox.getLowerLeftX()));\n                        rect.setLowerLeftY(Math.min(rect.getLowerLeftY(), glyphBBox.getLowerLeftY()));\n                        rect.setUpperRightX(Math.max(rect.getUpperRightX(), glyphBBox.getUpperRightX()));\n                        rect.setUpperRightY(Math.max(rect.getUpperRightY(), glyphBBox.getUpperRightY()));\n                    } catch (IOException ex) {\n                        // ignore\n                        LOG.debug(\"error getting the glyph bounding box - font bounding box will be used\", ex);\n                    }\n                }\n            }\n        }\n    }\n    return new BoundingBox(rect.getLowerLeftX(), rect.getLowerLeftY(), rect.getUpperRightX(), rect.getUpperRightY());\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextString", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText" ],
    "fullMethods" : [ "/**\n * Called when a string of text is to be shown.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextString(byte[] string) throws IOException {\n    showText(string);\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.DCTFilter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.DCTFilter.decode" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException {\n    ImageReader reader = findRasterReader(\"JPEG\", \"a suitable JAI I/O image filter is not installed\");\n    try (ImageInputStream iis = ImageIO.createImageInputStream(encoded)) {\n        // skip one LF if there\n        if (iis.read() != 0xa) {\n            iis.seek(0);\n        }\n        reader.setInput(iis);\n        ImageReadParam irp = reader.getDefaultReadParam();\n        irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());\n        irp.setSourceRegion(options.getSourceRegion());\n        options.setFilterSubsampled(true);\n        Raster raster = readImageRaster(reader, irp);\n        // special handling for 4-component images\n        if (raster.getNumBands() == 4) {\n            // get APP14 marker\n            Integer transform;\n            try {\n                transform = getAdobeTransform(reader.getImageMetadata(0));\n            } catch (IIOException | NegativeArraySizeException e) {\n                // we really tried asking nicely, now we're using brute force.\n                LOG.debug(\"Couldn't read usÃ­ng getAdobeTransform() - using getAdobeTransformByBruteForce() as fallback\", e);\n                transform = getAdobeTransformByBruteForce(iis);\n            }\n            int colorTransform = (transform != null) ? transform : 0;\n            // 0 = Unknown (RGB or CMYK), 1 = YCbCr, 2 = YCCK\n            // https://exiftool.org/TagNames/JPEG.html#Adobe\n            switch (colorTransform) {\n                case 0 :\n                    // already CMYK\n                    break;\n                case 1 :\n                    LOG.warn(\"There is no 4 channel YCbCr, using YCCK\");\n                    // fallthrough\n                case 2 :\n                    raster = fromYCCKtoCMYK(raster);\n                    break;\n                default :\n                    throw new IllegalArgumentException(\"Unknown colorTransform\");\n            }\n        } else if (raster.getNumBands() == 3) {\n            // BGR to RGB\n            raster = fromBGRtoRGB(raster);\n        }\n        DataBufferByte dataBuffer = ((DataBufferByte) (raster.getDataBuffer()));\n        decoded.write(dataBuffer.getData());\n    } catch (CMMException ex) {\n        // PDFBOX-5732\n        throw new IOException(ex);\n    } finally {\n        reader.dispose();\n    }\n    return new DecodeResult(parameters);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.save",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.save" ],
    "fullMethods" : [ "/**\n * Save the document using the given compression.\n * <p>\n * Don't use the input file as target as this will produce a corrupted file.\n * <p>\n * If encryption has been activated (with {@link #protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy)\n * protect(ProtectionPolicy)}), do not use the document after saving because the contents are now encrypted.\n * The same applies if your file was created from parts of another file and that\n * one is to be used after saving.\n *\n * @param file\n * \t\tThe file to save as.\n * @param compressParameters\n * \t\tThe parameters for the document's compression.\n * @throws IOException\n * \t\tif the output could not be written\n */\npublic void save(File file, CompressParameters compressParameters) throws IOException {\n    if (file.exists() && (file.length() > 0)) {\n        LOG.warn((\"You are overwriting the existing file \" + file.getName()) + \", this will produce a corrupted file if you're also reading from it\");\n    }\n    try (BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(file))) {\n        save(bufferedOutputStream, compressParameters);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFObjectStreamParser.parseObject", "org.apache.pdfbox.pdfparser.BaseParser.parseDirObject" ],
    "fullMethods" : [ "/**\n * Search for/parse the object with the given object number. The stream is closed after parsing the object with the\n * given number.\n *\n * @param objectNumber\n * \t\tthe number of the object to b e parsed\n * @return the parsed object or null if the object with the given number can't be found\n * @throws IOException\n * \t\tif there is an error while parsing the stream\n */\npublic COSBase parseObject(long objectNumber) throws IOException {\n    COSBase streamObject = null;\n    try {\n        Integer objectOffset = privateReadObjectNumbers().get(objectNumber);\n        if (objectOffset != null) {\n            // jump to the offset of the first object\n            long currentPosition = source.getPosition();\n            if ((firstObject > 0) && (currentPosition < firstObject)) {\n                source.skip(firstObject - ((int) (currentPosition)));\n            }\n            // jump to the offset of the object to be parsed\n            source.skip(objectOffset);\n            streamObject = parseDirObject();\n            if (streamObject != null) {\n                streamObject.setDirect(false);\n            }\n        }\n    } finally {\n        source.close();\n        document = null;\n    }\n    return streamObject;\n}", "/**\n * This will parse a directory object from the stream.\n *\n * @return The parsed object.\n * @throws IOException\n * \t\tIf there is an error during parsing.\n */\nprotected COSBase parseDirObject() throws IOException {\n    try {\n        recursionDepth++;\n        if (recursionDepth > MAX_RECURSION_DEPTH) {\n            throw new IOException(MAX_RECUSRION_MSG);\n        }\n        skipSpaces();\n        char c = ((char) (source.peek()));\n        switch (c) {\n            case '<' :\n                // pull off first left bracket\n                source.read();\n                // check for second left bracket\n                c = ((char) (source.peek()));\n                source.rewind(1);\n                return c == '<' ? parseCOSDictionary(true) : parseCOSString();\n            case '[' :\n                // array\n                return parseCOSArray();\n            case '(' :\n                return parseCOSString();\n            case '/' :\n                // name\n                return parseCOSName();\n            case 'n' :\n                // null\n                readExpectedString(NULL, false);\n                return COSNull.NULL;\n            case 't' :\n                readExpectedString(TRUE, false);\n                return COSBoolean.TRUE;\n            case 'f' :\n                readExpectedString(FALSE, false);\n                return COSBoolean.FALSE;\n            case 'R' :\n                source.read();\n                return new COSObject(null);\n            case ((char) (-1)) :\n                return null;\n            default :\n                if (((Character.isDigit(c) || (c == '-')) || (c == '+')) || (c == '.')) {\n                    return parseCOSNumber();\n                }\n                // This is not suppose to happen, but we will allow for it\n                // so we are more compatible with POS writers that don't\n                // follow the spec\n                long startOffset = source.getPosition();\n                String badString = readString();\n                if (badString.isEmpty()) {\n                    int peek = source.peek();\n                    // we can end up in an infinite loop otherwise\n                    throw new IOException((((((((((((\"Unknown dir object c='\" + c) + \"' cInt=\") + ((int) (c))) + \" peek='\") + ((char) (peek))) + \"' peekInt=\") + peek) + \" at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                }\n                // if it's an endstream/endobj, we want to put it back so the caller will see it\n                if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {\n                    source.rewind(badString.getBytes(StandardCharsets.ISO_8859_1).length);\n                } else {\n                    LOG.warn((((((\"Skipped unexpected dir object = '\" + badString) + \"' at offset \") + source.getPosition()) + \" (start offset: \") + startOffset) + \")\");\n                    return this instanceof PDFStreamParser ? null : COSNull.NULL;\n                }\n        }\n        return null;\n    } finally {\n        recursionDepth--;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.isUserPassword56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeHash2A", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeHash2B", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Check if a plaintext password is the user password.\n *\n * @param password\n * \t\tThe plaintext password.\n * @param user\n * \t\tThe u entry of the encryption dictionary.\n * @param owner\n * \t\tThe o entry of the encryption dictionary.\n * @param permissions\n * \t\tThe permissions set in the PDF.\n * @param id\n * \t\tThe document id used for encryption.\n * @param encRevision\n * \t\tThe revision of the encryption algorithm.\n * @param keyLengthInBytes\n * \t\tThe length of the encryption key in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata.\n * @return true If the plaintext password is the user password.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\npublic boolean isUserPassword(byte[] password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException {\n    switch (encRevision) {\n        case REVISION_2 :\n        case REVISION_3 :\n        case REVISION_4 :\n            return isUserPassword234(password, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);\n        case REVISION_5 :\n        case REVISION_6 :\n            return isUserPassword56(password, user, encRevision);\n        default :\n            throw new IOException(\"Unknown Encryption Revision \" + encRevision);\n    }\n}", "private boolean isUserPassword56(byte[] password, byte[] user, int encRevision) throws IOException {\n    byte[] truncatedPassword = truncate127(password);\n    byte[] uHash = new byte[32];\n    byte[] uValidationSalt = new byte[8];\n    System.arraycopy(user, 0, uHash, 0, 32);\n    System.arraycopy(user, 32, uValidationSalt, 0, 8);\n    byte[] hash;\n    if (encRevision == REVISION_5) {\n        hash = computeSHA256(truncatedPassword, uValidationSalt, null);\n    } else {\n        hash = computeHash2A(truncatedPassword, uValidationSalt, null);\n    }\n    return MessageDigest.isEqual(hash, uHash);\n}", "// Algorithm 2.A from ISO 32000-1\nprivate byte[] computeHash2A(byte[] password, byte[] salt, byte[] u) throws IOException {\n    byte[] userKey = adjustUserKey(u);\n    byte[] truncatedPassword = truncate127(password);\n    byte[] input = concat(truncatedPassword, salt, userKey);\n    return computeHash2B(input, truncatedPassword, userKey);\n}", "// Algorithm 2.B from ISO 32000-2\nprivate static byte[] computeHash2B(byte[] input, byte[] password, byte[] userKey) throws IOException {\n    try {\n        MessageDigest md = MessageDigests.getSHA256();\n        byte[] k = md.digest(input);\n        byte[] e = null;\n        for (int round = 0; (round < 64) || ((e[e.length - 1] & 0xff) > (round - 32)); round++) {\n            byte[] k1;\n            if ((userKey != null) && (userKey.length >= 48)) {\n                k1 = new byte[64 * ((password.length + k.length) + 48)];\n            } else {\n                k1 = new byte[64 * (password.length + k.length)];\n            }\n            int pos = 0;\n            for (int i = 0; i < 64; i++) {\n                System.arraycopy(password, 0, k1, pos, password.length);\n                pos += password.length;\n                System.arraycopy(k, 0, k1, pos, k.length);\n                pos += k.length;\n                if ((userKey != null) && (userKey.length >= 48)) {\n                    System.arraycopy(userKey, 0, k1, pos, 48);\n                    pos += 48;\n                }\n            }\n            byte[] kFirst = new byte[16];\n            byte[] kSecond = new byte[16];\n            System.arraycopy(k, 0, kFirst, 0, 16);\n            System.arraycopy(k, 16, kSecond, 0, 16);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            SecretKeySpec keySpec = new SecretKeySpec(kFirst, \"AES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(kSecond);\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n            e = cipher.doFinal(k1);\n            byte[] eFirst = new byte[16];\n            System.arraycopy(e, 0, eFirst, 0, 16);\n            BigInteger bi = new BigInteger(1, eFirst);\n            BigInteger remainder = bi.mod(new BigInteger(\"3\"));\n            String nextHash = HASHES_2B[remainder.intValue()];\n            md = MessageDigest.getInstance(nextHash);\n            k = md.digest(e);\n        }\n        if (k.length > 32) {\n            byte[] kTrunc = new byte[32];\n            System.arraycopy(k, 0, kTrunc, 0, 32);\n            return kTrunc;\n        } else {\n            return k;\n        }\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getStencilImage",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.graphics.image.SampledImageReader.getStencilImage" ],
    "fullMethods" : [ "/**\n * Returns an ARGB image filled with the given paint and using the given image as a mask.\n *\n * @param paint\n * \t\tthe paint to fill the visible portions of the image with\n * @return a masked image filled with the given paint\n * @throws IOException\n * \t\tif the image cannot be read\n * @throws IllegalStateException\n * \t\tif the image is not a stencil.\n */\npublic static BufferedImage getStencilImage(PDImage pdImage, Paint paint) throws IOException {\n    int width = pdImage.getWidth();\n    int height = pdImage.getHeight();\n    // compose to ARGB\n    BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    Graphics2D g = masked.createGraphics();\n    g.setPaint(paint);\n    g.fillRect(0, 0, width, height);\n    g.dispose();\n    // set the alpha\n    WritableRaster raster = masked.getRaster();\n    final int[] transparent = new int[4];\n    // avoid getting a BufferedImage for the mask to lessen memory footprint.\n    // Such masks are always bpc=1 and have no colorspace, but have a decode.\n    // (see 8.9.6.2 Stencil Masking)\n    try (InputStream iis = pdImage.createInputStream()) {\n        final float[] decode = getDecodeArray(pdImage);\n        int value = (decode[0] < decode[1]) ? 1 : 0;\n        int rowLen = width / 8;\n        if ((width % 8) > 0) {\n            rowLen++;\n        }\n        byte[] buff = new byte[rowLen];\n        for (int y = 0; y < height; y++) {\n            int x = 0;\n            int readLen = ((int) (IOUtils.populateBuffer(iis, buff)));\n            for (int r = 0; (r < rowLen) && (r < readLen); r++) {\n                int byteValue = buff[r];\n                int mask = 128;\n                int shift = 7;\n                for (int i = 0; i < 8; i++) {\n                    int bit = (byteValue & mask) >> shift;\n                    mask >>= 1;\n                    --shift;\n                    if (bit == value) {\n                        raster.setPixel(x, y, transparent);\n                    }\n                    x++;\n                    if (x == width) {\n                        break;\n                    }\n                }\n            }\n            if (readLen != rowLen) {\n                LOG.warn(\"premature EOF, image will be incomplete\");\n                break;\n            }\n        }\n    }\n    return masked;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.cos.COSString.parseHex",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.cos.COSString.parseHex" ],
    "fullMethods" : [ "/**\n * This will create a COS string from a string of hex characters.\n *\n * @param hex\n * \t\tA hex string.\n * @return A cos string with the hex characters converted to their actual bytes.\n * @throws IOException\n * \t\tIf there is an error with the hex string.\n */\npublic static COSString parseHex(String hex) throws IOException {\n    // skip leading and trailing whitespace\n    int end = hex.length();\n    while ((end > 0) && Character.isWhitespace(hex.charAt(end - 1))) {\n        end--;\n    } \n    int start = 0;\n    while ((start < end) && Character.isWhitespace(hex.charAt(start))) {\n        start++;\n    } \n    int length = end - start;\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream((length + 1) / 2);\n    boolean isLengthUneven = (length % 2) != 0;\n    if (isLengthUneven) {\n        length--;\n    }\n    for (int i = 0; i < length; i += 2) {\n        int value = (16 * Hex.getHexValue(hex.charAt(i))) + Hex.getHexValue(hex.charAt(i + 1));\n        if (value >= 0) {\n            bytes.write(value);\n        } else if (FORCE_PARSING) {\n            LOG.warn(\"Encountered a malformed hex string\");\n            bytes.write('?');// todo: what does Acrobat do? Any example PDFs?\n\n        } else {\n            throw new IOException(\"Invalid hex string: \" + hex);\n        }\n    }\n    if (isLengthUneven) {\n        int value = 16 * Hex.getHexValue(hex.charAt(length));\n        if (value >= 0) {\n            bytes.write(value);\n        } else if (FORCE_PARSING) {\n            LOG.warn(\"Encountered a malformed hex string\");\n            bytes.write('?');// todo: what does Acrobat do? Any example PDFs?\n\n        } else {\n            throw new IOException(\"Invalid hex string: \" + hex);\n        }\n    }\n    return new COSString(bytes.toByteArray());\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDFontFactory.createFont" ],
    "fullMethods" : [ "/**\n * Creates a new PDFont instance with the appropriate subclass.\n *\n * @param dictionary\n * \t\ta font dictionary\n * @param resourceCache\n * \t\tresource cache, only useful for type 3 fonts, can be null\n * @return a PDFont instance, based on the SubType entry of the dictionary\n * @throws IOException\n * \t\tif something goes wrong\n */\npublic static PDFont createFont(COSDictionary dictionary, ResourceCache resourceCache) throws IOException {\n    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);\n    if (!COSName.FONT.equals(type)) {\n        LOG.error((\"Expected 'Font' dictionary but found '\" + type.getName()) + \"'\");\n    }\n    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);\n    if (COSName.TYPE1.equals(subType)) {\n        COSDictionary fd = dictionary.getCOSDictionary(COSName.FONT_DESC);\n        if ((fd != null) && fd.containsKey(COSName.FONT_FILE3)) {\n            return new PDType1CFont(dictionary);\n        }\n        return new PDType1Font(dictionary);\n    } else if (COSName.MM_TYPE1.equals(subType)) {\n        COSDictionary fd = dictionary.getCOSDictionary(COSName.FONT_DESC);\n        if ((fd != null) && fd.containsKey(COSName.FONT_FILE3)) {\n            return new PDType1CFont(dictionary);\n        }\n        return new PDMMType1Font(dictionary);\n    } else if (COSName.TRUE_TYPE.equals(subType)) {\n        return new PDTrueTypeFont(dictionary);\n    } else if (COSName.TYPE3.equals(subType)) {\n        return new PDType3Font(dictionary, resourceCache);\n    } else if (COSName.TYPE0.equals(subType)) {\n        COSDictionary fontDescriptor = getFontDescriptor(dictionary);\n        FontType fontTypeFromFont = getFontTypeFromFont(fontDescriptor, subType);\n        if (fontTypeFromFont != null) {\n            COSDictionary descendantFont = getDescendantFont(dictionary);\n            COSName descFontType = (descendantFont != null) ? descendantFont.getCOSName(COSName.SUBTYPE) : null;\n            if ((descFontType != null) && (!fontTypeFromFont.isCIDSubtype(descFontType))) {\n                fixType0Subtype(descendantFont, fontDescriptor, fontTypeFromFont.getSubtype());\n            }\n        }\n        return new PDType0Font(dictionary);\n    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {\n        throw new IOException(\"Type 0 descendant font not allowed\");\n    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {\n        throw new IOException(\"Type 2 descendant font not allowed\");\n    } else {\n        // assuming Type 1 font (see PDFBOX-1988) because it seems that Adobe Reader does this\n        // however, we may need more sophisticated logic perhaps looking at the FontFile\n        LOG.warn((\"Invalid font subtype '\" + subType) + \"'\");\n        return new PDType1Font(dictionary);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDPageContentStream.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDPageContentStream.<init>" ],
    "fullMethods" : [ "/**\n * Create a new PDPage content stream. This constructor overwrites all existing content streams\n * of this page.\n *\n * @param document\n * \t\tThe document the page is part of.\n * @param sourcePage\n * \t\tThe page to write the contents to.\n * @throws IOException\n * \t\tIf there is an error writing to the page contents.\n */\npublic PDPageContentStream(PDDocument document, PDPage sourcePage) throws IOException {\n    this(document, sourcePage, AppendMode.OVERWRITE, true, false);\n    if (sourcePageHadContents) {\n        LOG.warn(\"You are overwriting an existing content, you should use the append mode\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.operator.text.MoveText.process",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.operator.text.MoveText.process" ],
    "fullMethods" : [ "@Override\npublic void process(Operator operator, List<COSBase> arguments) throws MissingOperandException {\n    if (arguments.size() < 2) {\n        throw new MissingOperandException(operator, arguments);\n    }\n    PDFStreamEngine context = getContext();\n    Matrix textLineMatrix = context.getTextLineMatrix();\n    if (textLineMatrix == null) {\n        LOG.warn((\"TextLineMatrix is null, \" + getName()) + \" operator will be ignored\");\n        return;\n    }\n    COSBase base0 = arguments.get(0);\n    COSBase base1 = arguments.get(1);\n    if (!(base0 instanceof COSNumber)) {\n        return;\n    }\n    if (!(base1 instanceof COSNumber)) {\n        return;\n    }\n    COSNumber x = ((COSNumber) (base0));\n    COSNumber y = ((COSNumber) (base1));\n    Matrix matrix = new Matrix(1, 0, 0, 1, x.floatValue(), y.floatValue());\n    textLineMatrix.concatenate(matrix);\n    context.setTextMatrix(textLineMatrix.clone());\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances" ],
    "fullMethods" : [ "/**\n * Sets the value of this field to be the given signature.\n *\n * @param value\n * \t\tis the PDSignatureField\n * @throws IOException\n * \t\tif the new value could not be applied\n */\npublic void setValue(PDSignature value) throws IOException {\n    getCOSObject().setItem(COSName.V, value);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKey",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKey", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.computeEncryptedKeyRev56", "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.logIfStrongEncryptionMissing" ],
    "fullMethods" : [ "/**\n * Compute the encryption key.\n *\n * @param password\n * \t\tThe password to compute the encrypted key.\n * @param o\n * \t\tThe O entry of the encryption dictionary.\n * @param u\n * \t\tThe U entry of the encryption dictionary.\n * @param oe\n * \t\tThe OE entry of the encryption dictionary.\n * @param ue\n * \t\tThe UE entry of the encryption dictionary.\n * @param permissions\n * \t\tThe permissions for the document.\n * @param id\n * \t\tThe document id.\n * @param encRevision\n * \t\tThe revision of the encryption algorithm.\n * @param keyLengthInBytes\n * \t\tThe length of the encryption key in bytes.\n * @param encryptMetadata\n * \t\tThe encryption metadata\n * @param isOwnerPassword\n * \t\twhether the password given is the owner password (for revision 6)\n * @return The encrypted key bytes.\n * @throws IOException\n * \t\tIf there is an error with encryption.\n */\npublic byte[] computeEncryptedKey(byte[] password, byte[] o, byte[] u, byte[] oe, byte[] ue, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata, boolean isOwnerPassword) throws IOException {\n    if ((encRevision == REVISION_5) || (encRevision == REVISION_6)) {\n        return computeEncryptedKeyRev56(password, isOwnerPassword, o, u, oe, ue, encRevision);\n    } else {\n        return computeEncryptedKeyRev234(password, o, permissions, id, encryptMetadata, keyLengthInBytes, encRevision);\n    }\n}", "private byte[] computeEncryptedKeyRev56(byte[] password, boolean isOwnerPassword, byte[] o, byte[] u, byte[] oe, byte[] ue, int encRevision) throws IOException {\n    byte[] hash;\n    byte[] fileKeyEnc;\n    if (isOwnerPassword) {\n        if (oe == null) {\n            throw new IOException(\"/Encrypt/OE entry is missing\");\n        }\n        byte[] oKeySalt = new byte[8];\n        System.arraycopy(o, 40, oKeySalt, 0, 8);\n        if (encRevision == REVISION_5) {\n            hash = computeSHA256(password, oKeySalt, u);\n        } else {\n            hash = computeHash2A(password, oKeySalt, u);\n        }\n        fileKeyEnc = oe;\n    } else {\n        if (ue == null) {\n            throw new IOException(\"/Encrypt/UE entry is missing\");\n        }\n        byte[] uKeySalt = new byte[8];\n        System.arraycopy(u, 40, uKeySalt, 0, 8);\n        if (encRevision == REVISION_5) {\n            hash = computeSHA256(password, uKeySalt, null);\n        } else {\n            hash = computeHash2A(password, uKeySalt, null);\n        }\n        fileKeyEnc = ue;\n    }\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(hash, \"AES\"), new IvParameterSpec(new byte[16]));\n        return cipher.doFinal(fileKeyEnc);\n    } catch (GeneralSecurityException e) {\n        logIfStrongEncryptionMissing();\n        throw new IOException(e);\n    }\n}", "private static void logIfStrongEncryptionMissing() {\n    try {\n        if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE) {\n            LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        LOG.debug(\"AES Algorithm not available\", ex);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDNonTerminalField.getChildren",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDNonTerminalField.getChildren" ],
    "fullMethods" : [ "/**\n * Returns this field's children. These may be either terminal or non-terminal fields.\n *\n * @return the list of child fields. Be aware that this list is <i>not</i> backed by the\nchildren of the field, so adding or deleting has no effect on the PDF document until you call\n{@link #setChildren(java.util.List) setChildren()} with the modified list.\n */\npublic List<PDField> getChildren() {\n    // TODO: why not return a COSArrayList like in PDPage.getAnnotations() ?\n    List<PDField> children = new ArrayList<>();\n    COSArray kids = getCOSObject().getCOSArray(COSName.KIDS);\n    if (kids == null) {\n        return children;\n    }\n    for (int i = 0; i < kids.size(); i++) {\n        COSBase kid = kids.getObject(i);\n        if (kid instanceof COSDictionary) {\n            if (kid.getCOSObject() == this.getCOSObject()) {\n                LOG.warn(\"Child field is same object as parent\");\n                continue;\n            }\n            PDField field = PDField.fromDictionary(getAcroForm(), ((COSDictionary) (kid)), this);\n            if (field != null) {\n                children.add(field);\n            }\n        }\n    }\n    return children;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.setValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.form.PDTextField.setValue", "org.apache.pdfbox.pdmodel.interactive.form.PDTerminalField.applyChange", "org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField.constructAppearances" ],
    "fullMethods" : [ "/**\n * Set the plain text value of this field, and try to update the visual appearance.\n *\n * @param value\n * \t\tPlain text\n * @throws IOException\n * \t\tif the value could not be set\n */\n@Override\npublic void setValue(String value) throws IOException {\n    getCOSObject().setString(COSName.V, value);\n    applyChange();\n}", "/**\n * Applies a value change to the field. Generates appearances if required and raises events.\n *\n * @throws IOException\n * \t\tif the appearance couldn't be generated\n */\nprotected final void applyChange() throws IOException {\n    constructAppearances();\n    // if we supported JavaScript we would raise a field changed event here\n}", "@Override\nvoid constructAppearances() throws IOException {\n    PDAnnotationWidget widget = this.getWidgets().get(0);\n    if (widget != null) {\n        PDRectangle rectangle = widget.getRectangle();\n        // check if the signature is visible\n        if ((((rectangle == null) || ((Float.compare(rectangle.getHeight(), 0) == 0) && (Float.compare(rectangle.getWidth(), 0) == 0))) || widget.isNoView()) || widget.isHidden()) {\n            return;\n        }\n        // TODO: implement appearance generation for signatures (PDFBOX-3524)\n        LOG.warn(((\"Appearance generation for signature fields not implemented here. \" + \"You need to generate/update that manually, see the \") + \"CreateVisibleSignature*.java files in the examples subproject \") + \"of the source code download\");\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroup", "org.apache.pdfbox.rendering.PageDrawer.showTransparencyGroupOnGraphics", "org.apache.pdfbox.rendering.PageDrawer.TransparencyGroup.<init>", "org.apache.pdfbox.rendering.PageDrawer.TransparencyGroup.<init>" ],
    "fullMethods" : [ "@Override\npublic void showTransparencyGroup(PDTransparencyGroup form) throws IOException {\n    showTransparencyGroupOnGraphics(form, graphics);\n}", "/**\n * For advanced users, to extract the transparency group into a separate graphics device.\n *\n * @param form\n * \t\tthe transparency group to be extracted\n * @param graphics\n * \t\tthe target graphics device\n * @throws IOException\n * \t\tif the transparency group could not be extracted\n */\nprotected void showTransparencyGroupOnGraphics(PDTransparencyGroup form, Graphics2D graphics) throws IOException {\n    if (isHiddenOCG(form.getOptionalContent())) {\n        return;\n    }\n    if (!isContentRendered()) {\n        return;\n    }\n    TransparencyGroup group = new TransparencyGroup(form, false, getGraphicsState().getCurrentTransformationMatrix(), null);\n    BufferedImage image = group.getImage();\n    if (image == null) {\n        // image is empty, don't bother\n        return;\n    }\n    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n    setClip();\n    // both the DPI xform and the CTM were already applied to the group, so all we do\n    // here is draw it directly onto the Graphics2D device at the appropriate position\n    AffineTransform savedTransform = graphics.getTransform();\n    AffineTransform transform = new AffineTransform(xform);\n    transform.scale(1.0 / xformScalingFactorX, 1.0 / xformScalingFactorY);\n    graphics.setTransform(transform);\n    // adjust bbox (x,y) position at the initial scale + cropbox\n    PDRectangle bbox = group.getBBox();\n    float x = bbox.getLowerLeftX() - pageSize.getLowerLeftX();\n    float y = pageSize.getUpperRightY() - bbox.getUpperRightY();\n    if (flipTG) {\n        graphics.translate(0, image.getHeight());\n        graphics.scale(1, -1);\n    } else {\n        graphics.translate(x * xformScalingFactorX, y * xformScalingFactorY);\n    }\n    PDSoftMask softMask = getGraphicsState().getSoftMask();\n    if (softMask != null) {\n        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Float(0, 0, image.getWidth(), image.getHeight()));\n        awtPaint = applySoftMaskToPaint(awtPaint, softMask);\n        graphics.setPaint(awtPaint);\n        graphics.fill(new Rectangle2D.Float(0, 0, bbox.getWidth() * xformScalingFactorX, bbox.getHeight() * xformScalingFactorY));\n    } else {\n        try {\n            graphics.drawImage(image, null, null);\n        } catch (InternalError ie) {\n            LOG.error(\"Exception drawing image, see JDK-6689349, \" + \"try rendering into a BufferedImage instead\", ie);\n        }\n    }\n    graphics.setTransform(savedTransform);\n}", "/**\n * Creates a buffered image for a transparency group result.\n *\n * @param form\n * \t\tthe transparency group of the form or soft mask.\n * @param isSoftMask\n * \t\ttrue if this is a soft mask.\n * @param ctm\n * \t\tthe relevant current transformation matrix. For soft masks, this is the CTM at\n * \t\tthe time the soft mask is set (not at the time the soft mask is used for fill/stroke!),\n * \t\tfor forms, this is the CTM at the time the form is invoked.\n * @param backdropColor\n * \t\tthe color according to the /bc entry to be used for luminosity soft\n * \t\tmasks.\n * @throws IOException\n */\nprivate TransparencyGroup(PDTransparencyGroup form, boolean isSoftMask, Matrix ctm, PDColor backdropColor) throws IOException {\n    Graphics2D savedGraphics = graphics;\n    List<Path2D> savedLastClips = lastClips;\n    Shape savedInitialClip = initialClip;\n    // get the CTM x Form Matrix transform\n    Matrix transform = Matrix.concatenate(ctm, form.getMatrix());\n    // transform the bbox\n    PDRectangle formBBox = form.getBBox();\n    if (formBBox == null) {\n        // PDFBOX-5471\n        // check done here and not in caller to avoid getBBox() creating rectangle twice\n        LOG.warn(\"transparency group ignored because BBox is null\");\n        formBBox = new PDRectangle();\n    }\n    GeneralPath transformedBox = formBBox.transform(transform);\n    // clip the bbox to prevent giant bboxes from consuming all memory\n    Area transformed = new Area(transformedBox);\n    transformed.intersect(getGraphicsState().getCurrentClippingPath());\n    Rectangle2D clipRect = transformed.getBounds2D();\n    if (clipRect.isEmpty()) {\n        image = null;\n        bbox = null;\n        minX = 0;\n        minY = 0;\n        maxX = 0;\n        maxY = 0;\n        width = 0;\n        height = 0;\n        return;\n    }\n    this.bbox = new PDRectangle(((float) (clipRect.getX())), ((float) (clipRect.getY())), ((float) (clipRect.getWidth())), ((float) (clipRect.getHeight())));\n    // apply the underlying Graphics2D device's DPI transform\n    AffineTransform xformOriginal = xform;\n    xform = AffineTransform.getScaleInstance(xformScalingFactorX, xformScalingFactorY);\n    Rectangle2D bounds = xform.createTransformedShape(clipRect).getBounds2D();\n    minX = ((int) (Math.floor(bounds.getMinX())));\n    minY = ((int) (Math.floor(bounds.getMinY())));\n    maxX = ((int) (Math.floor(bounds.getMaxX()))) + 1;\n    maxY = ((int) (Math.floor(bounds.getMaxY()))) + 1;\n    width = maxX - minX;\n    height = maxY - minY;\n    // FIXME - color space\n    if (isGray(form.getGroup().getColorSpace(form.getResources()))) {\n        image = create2ByteGrayAlphaImage(width, height);\n    } else {\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n    boolean needsBackdrop = ((!isSoftMask) && (!form.getGroup().isIsolated())) && hasBlendMode(form, new HashSet<>());\n    BufferedImage backdropImage = null;\n    // Position of this group in parent group's coordinates\n    int backdropX = 0;\n    int backdropY = 0;\n    if (needsBackdrop) {\n        if (transparencyGroupStack.isEmpty()) {\n            // Use the current page as the parent group.\n            backdropImage = renderer.getPageImage();\n            if (backdropImage == null) {\n                needsBackdrop = false;\n            } else {\n                backdropX = minX;\n                backdropY = backdropImage.getHeight() - maxY;\n            }\n        } else {\n            TransparencyGroup parentGroup = transparencyGroupStack.peek();\n            backdropImage = parentGroup.image;\n            backdropX = minX - parentGroup.minX;\n            backdropY = parentGroup.maxY - maxY;\n        }\n    }\n    Graphics2D g = image.createGraphics();\n    if (needsBackdrop) {\n        // backdropImage must be included in group image but not in group alpha.\n        g.drawImage(backdropImage, 0, 0, width, height, backdropX, backdropY, backdropX + width, backdropY + height, null);\n        g = new GroupGraphics(image, g);\n    }\n    if (isSoftMask && (backdropColor != null)) {\n        // \"If the subtype is Luminosity, the transparency group XObject G shall be\n        // composited with a fully opaque backdrop whose colour is everywhere defined\n        // by the soft-mask dictionary's BC entry.\"\n        g.setBackground(new Color(backdropColor.toRGB()));\n        g.clearRect(0, 0, width, height);\n    }\n    // flip y-axis\n    g.translate(0, image.getHeight());\n    g.scale(1, -1);\n    boolean savedFlipTG = flipTG;\n    flipTG = false;\n    // apply device transform (DPI)\n    // the initial translation is ignored, because we're not writing into the initial graphics device\n    g.transform(xform);\n    PDRectangle pageSizeOriginal = pageSize;\n    pageSize = new PDRectangle(minX / xformScalingFactorX, minY / xformScalingFactorY, ((float) (bounds.getWidth() / xformScalingFactorX)), ((float) (bounds.getHeight() / xformScalingFactorY)));\n    int clipWindingRuleOriginal = clipWindingRule;\n    clipWindingRule = -1;\n    GeneralPath linePathOriginal = linePath;\n    linePath = new GeneralPath();\n    // adjust the origin\n    g.translate(-clipRect.getX(), -clipRect.getY());\n    graphics = g;\n    setRenderingHints();\n    try {\n        if (isSoftMask) {\n            processSoftMask(form);\n        } else {\n            transparencyGroupStack.push(this);\n            processTransparencyGroup(form);\n            if (!transparencyGroupStack.isEmpty()) {\n                transparencyGroupStack.pop();\n            }\n        }\n        if (needsBackdrop) {\n            ((GroupGraphics) (graphics)).removeBackdrop(backdropImage, backdropX, backdropY);\n        }\n    } finally {\n        flipTG = savedFlipTG;\n        lastClips = savedLastClips;\n        graphics.dispose();\n        graphics = savedGraphics;\n        initialClip = savedInitialClip;\n        clipWindingRule = clipWindingRuleOriginal;\n        linePath = linePathOriginal;\n        pageSize = pageSizeOriginal;\n        xform = xformOriginal;\n    }\n}", "/**\n * Creates a buffered image for a transparency group result.\n *\n * @param form\n * \t\tthe transparency group of the form or soft mask.\n * @param isSoftMask\n * \t\ttrue if this is a soft mask.\n * @param ctm\n * \t\tthe relevant current transformation matrix. For soft masks, this is the CTM at\n * \t\tthe time the soft mask is set (not at the time the soft mask is used for fill/stroke!),\n * \t\tfor forms, this is the CTM at the time the form is invoked.\n * @param backdropColor\n * \t\tthe color according to the /bc entry to be used for luminosity soft\n * \t\tmasks.\n * @throws IOException\n */\nprivate TransparencyGroup(PDTransparencyGroup form, boolean isSoftMask, Matrix ctm, PDColor backdropColor) throws IOException {\n    Graphics2D savedGraphics = graphics;\n    List<Path2D> savedLastClips = lastClips;\n    Shape savedInitialClip = initialClip;\n    // get the CTM x Form Matrix transform\n    Matrix transform = Matrix.concatenate(ctm, form.getMatrix());\n    // transform the bbox\n    PDRectangle formBBox = form.getBBox();\n    if (formBBox == null) {\n        // PDFBOX-5471\n        // check done here and not in caller to avoid getBBox() creating rectangle twice\n        LOG.warn(\"transparency group ignored because BBox is null\");\n        formBBox = new PDRectangle();\n    }\n    GeneralPath transformedBox = formBBox.transform(transform);\n    // clip the bbox to prevent giant bboxes from consuming all memory\n    Area transformed = new Area(transformedBox);\n    transformed.intersect(getGraphicsState().getCurrentClippingPath());\n    Rectangle2D clipRect = transformed.getBounds2D();\n    if (clipRect.isEmpty()) {\n        image = null;\n        bbox = null;\n        minX = 0;\n        minY = 0;\n        maxX = 0;\n        maxY = 0;\n        width = 0;\n        height = 0;\n        return;\n    }\n    this.bbox = new PDRectangle(((float) (clipRect.getX())), ((float) (clipRect.getY())), ((float) (clipRect.getWidth())), ((float) (clipRect.getHeight())));\n    // apply the underlying Graphics2D device's DPI transform\n    AffineTransform xformOriginal = xform;\n    xform = AffineTransform.getScaleInstance(xformScalingFactorX, xformScalingFactorY);\n    Rectangle2D bounds = xform.createTransformedShape(clipRect).getBounds2D();\n    minX = ((int) (Math.floor(bounds.getMinX())));\n    minY = ((int) (Math.floor(bounds.getMinY())));\n    maxX = ((int) (Math.floor(bounds.getMaxX()))) + 1;\n    maxY = ((int) (Math.floor(bounds.getMaxY()))) + 1;\n    width = maxX - minX;\n    height = maxY - minY;\n    // FIXME - color space\n    if (isGray(form.getGroup().getColorSpace(form.getResources()))) {\n        image = create2ByteGrayAlphaImage(width, height);\n    } else {\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    }\n    boolean needsBackdrop = ((!isSoftMask) && (!form.getGroup().isIsolated())) && hasBlendMode(form, new HashSet<>());\n    BufferedImage backdropImage = null;\n    // Position of this group in parent group's coordinates\n    int backdropX = 0;\n    int backdropY = 0;\n    if (needsBackdrop) {\n        if (transparencyGroupStack.isEmpty()) {\n            // Use the current page as the parent group.\n            backdropImage = renderer.getPageImage();\n            if (backdropImage == null) {\n                needsBackdrop = false;\n            } else {\n                backdropX = minX;\n                backdropY = backdropImage.getHeight() - maxY;\n            }\n        } else {\n            TransparencyGroup parentGroup = transparencyGroupStack.peek();\n            backdropImage = parentGroup.image;\n            backdropX = minX - parentGroup.minX;\n            backdropY = parentGroup.maxY - maxY;\n        }\n    }\n    Graphics2D g = image.createGraphics();\n    if (needsBackdrop) {\n        // backdropImage must be included in group image but not in group alpha.\n        g.drawImage(backdropImage, 0, 0, width, height, backdropX, backdropY, backdropX + width, backdropY + height, null);\n        g = new GroupGraphics(image, g);\n    }\n    if (isSoftMask && (backdropColor != null)) {\n        // \"If the subtype is Luminosity, the transparency group XObject G shall be\n        // composited with a fully opaque backdrop whose colour is everywhere defined\n        // by the soft-mask dictionary's BC entry.\"\n        g.setBackground(new Color(backdropColor.toRGB()));\n        g.clearRect(0, 0, width, height);\n    }\n    // flip y-axis\n    g.translate(0, image.getHeight());\n    g.scale(1, -1);\n    boolean savedFlipTG = flipTG;\n    flipTG = false;\n    // apply device transform (DPI)\n    // the initial translation is ignored, because we're not writing into the initial graphics device\n    g.transform(xform);\n    PDRectangle pageSizeOriginal = pageSize;\n    pageSize = new PDRectangle(minX / xformScalingFactorX, minY / xformScalingFactorY, ((float) (bounds.getWidth() / xformScalingFactorX)), ((float) (bounds.getHeight() / xformScalingFactorY)));\n    int clipWindingRuleOriginal = clipWindingRule;\n    clipWindingRule = -1;\n    GeneralPath linePathOriginal = linePath;\n    linePath = new GeneralPath();\n    // adjust the origin\n    g.translate(-clipRect.getX(), -clipRect.getY());\n    graphics = g;\n    setRenderingHints();\n    try {\n        if (isSoftMask) {\n            processSoftMask(form);\n        } else {\n            transparencyGroupStack.push(this);\n            processTransparencyGroup(form);\n            if (!transparencyGroupStack.isEmpty()) {\n                transparencyGroupStack.pop();\n            }\n        }\n        if (needsBackdrop) {\n            ((GroupGraphics) (graphics)).removeBackdrop(backdropImage, backdropX, backdropY);\n        }\n    } finally {\n        flipTG = savedFlipTG;\n        lastClips = savedLastClips;\n        graphics.dispose();\n        graphics = savedGraphics;\n        initialClip = savedInitialClip;\n        clipWindingRule = clipWindingRuleOriginal;\n        linePath = linePathOriginal;\n        pageSize = pageSizeOriginal;\n        xform = xformOriginal;\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.PDDocument.protect",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.PDDocument.protect" ],
    "fullMethods" : [ "/**\n * Protects the document with a protection policy. The document content will be really\n * encrypted when it will be saved. This method only marks the document for encryption. It also\n * calls {@link #setAllSecurityToBeRemoved(boolean)} with a false argument if it was set to true\n * previously and logs a warning.\n * <p>\n * Do not use the document after saving, because the structures are encrypted.\n * The same applies if your file was created from parts of another file and that\n * one is to be used after saving.\n *\n * @see org.apache.pdfbox.pdmodel.encryption.StandardProtectionPolicy\n * @see org.apache.pdfbox.pdmodel.encryption.PublicKeyProtectionPolicy\n * @param policy\n * \t\tThe protection policy.\n * @throws IOException\n * \t\tif there isn't any suitable security handler.\n */\npublic void protect(ProtectionPolicy policy) throws IOException {\n    if (isAllSecurityToBeRemoved()) {\n        LOG.warn(\"do not call setAllSecurityToBeRemoved(true) before calling protect(), \" + \"as protect() implies setAllSecurityToBeRemoved(false)\");\n        setAllSecurityToBeRemoved(false);\n    }\n    if (!isEncrypted()) {\n        encryption = new PDEncryption();\n    }\n    SecurityHandler<ProtectionPolicy> securityHandler = SecurityHandlerFactory.INSTANCE.newSecurityHandlerForPolicy(policy);\n    if (securityHandler == null) {\n        throw new IOException(\"No security handler for policy \" + policy);\n    }\n    getEncryption().setSecurityHandler(securityHandler);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.multipdf.LayerUtility.appendFormAsLayer",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.multipdf.LayerUtility.appendFormAsLayer" ],
    "fullMethods" : [ "/**\n * Places the given form over the existing content of the indicated page (like an overlay).\n * The form is enveloped in a marked content section to indicate that it's part of an\n * optional content group (OCG), here used as a layer. This optional group is returned and\n * can be enabled and disabled through methods on {@link PDOptionalContentProperties}.\n * <p>\n * You may want to call {@link #wrapInSaveRestore(PDPage) wrapInSaveRestore(PDPage)} before calling this method to make\n * sure that the graphics state is reset.\n *\n * @param targetPage\n * \t\tthe target page\n * @param form\n * \t\tthe form to place\n * @param transform\n * \t\tthe transformation matrix that controls the placement of your form. You'll\n * \t\tneed this if your page has a crop box different than the media box, or if these have negative\n * \t\tcoordinates, or if you want to scale or adjust your form.\n * @param layerName\n * \t\tthe name for the layer/OCG to produce\n * @return the optional content group that was generated for the form usage\n * @throws IOException\n * \t\tif an I/O error occurs\n */\npublic PDOptionalContentGroup appendFormAsLayer(PDPage targetPage, PDFormXObject form, AffineTransform transform, String layerName) throws IOException {\n    PDDocumentCatalog catalog = targetDoc.getDocumentCatalog();\n    PDOptionalContentProperties ocprops = catalog.getOCProperties();\n    if (ocprops == null) {\n        ocprops = new PDOptionalContentProperties();\n        catalog.setOCProperties(ocprops);\n    }\n    if (ocprops.hasGroup(layerName)) {\n        throw new IllegalArgumentException(\"Optional group (layer) already exists: \" + layerName);\n    }\n    PDRectangle cropBox = targetPage.getCropBox();\n    if (((cropBox.getLowerLeftX() < 0) || (cropBox.getLowerLeftY() < 0)) && transform.isIdentity()) {\n        // PDFBOX-4044\n        LOG.warn((\"Negative cropBox \" + cropBox) + \" and identity transform may make your form invisible\");\n    }\n    PDOptionalContentGroup layer = new PDOptionalContentGroup(layerName);\n    ocprops.addGroup(layer);\n    try (PDPageContentStream contentStream = new PDPageContentStream(targetDoc, targetPage, AppendMode.APPEND, !DEBUG)) {\n        contentStream.beginMarkedContent(COSName.OC, layer);\n        contentStream.saveGraphicsState();\n        contentStream.transform(new Matrix(transform));\n        contentStream.drawForm(form);\n        contentStream.restoreGraphicsState();\n        contentStream.endMarkedContent();\n    }\n    return layer;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.rendering.PageDrawer.strokePath",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.rendering.PageDrawer.strokePath", "org.apache.pdfbox.rendering.PageDrawer.getStroke" ],
    "fullMethods" : [ "@Override\npublic void strokePath() throws IOException {\n    if (isContentRendered()) {\n        graphics.setComposite(getGraphicsState().getStrokingJavaComposite());\n        graphics.setPaint(getStrokingPaint());\n        graphics.setStroke(getStroke());\n        setClip();\n        graphics.draw(linePath);\n    }\n    linePath.reset();\n}", "// create a new stroke based on the current CTM and the current stroke\nprivate Stroke getStroke() {\n    PDGraphicsState state = getGraphicsState();\n    // apply the CTM\n    float lineWidth = transformWidth(state.getLineWidth());\n    // minimum line width as used by Adobe Reader\n    if (lineWidth < 0.25) {\n        lineWidth = 0.25F;\n    }\n    PDLineDashPattern dashPattern = state.getLineDashPattern();\n    // PDFBOX-5168: show an all-zero dash array line invisible like Adobe does\n    // must do it here because getDashArray() sets minimum width because of JVM bugs\n    float[] dashArray = dashPattern.getDashArray();\n    if (isAllZeroDash(dashArray)) {\n        return (Shape p) -> new Area();\n    }\n    float phaseStart = dashPattern.getPhase();\n    dashArray = getDashArray(dashPattern);\n    phaseStart = transformWidth(phaseStart);\n    int lineCap = Math.min(2, Math.max(0, state.getLineCap()));// legal values 0..2\n\n    int lineJoin = Math.min(2, Math.max(0, state.getLineJoin()));\n    float miterLimit = state.getMiterLimit();\n    if (miterLimit < 1) {\n        LOG.warn((\"Miter limit must be >= 1, value \" + miterLimit) + \" is ignored\");\n        miterLimit = 10;\n    }\n    phaseStart = Math.min(phaseStart, Short.MAX_VALUE);// PDFBOX-5653: avoid jdk8 JVM freeze\n\n    return new BasicStroke(lineWidth, lineCap, lineJoin, miterLimit, dashArray, phaseStart);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareForDecryption",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.encryption.StandardSecurityHandler.prepareForDecryption" ],
    "fullMethods" : [ "/**\n * Prepares everything to decrypt the document.\n *\n * Only if decryption of single objects is needed this should be called.\n *\n * @param encryption\n * \t\tencryption dictionary\n * @param documentIDArray\n * \t\tdocument id\n * @param decryptionMaterial\n * \t\tInformation used to decrypt the document.\n * @throws InvalidPasswordException\n * \t\tIf the password is incorrect.\n * @throws IOException\n * \t\tIf there is an error accessing data.\n */\n@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException {\n    if (!(decryptionMaterial instanceof StandardDecryptionMaterial)) {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    // This is only used with security version 4 and 5.\n    if (encryption.getVersion() >= REVISION_4) {\n        setStreamFilterName(encryption.getStreamFilterName());\n        setStringFilterName(encryption.getStringFilterName());\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = ((StandardDecryptionMaterial) (decryptionMaterial));\n    String password = material.getPassword();\n    if (password == null) {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = (encryption.getVersion() == 1) ? 5 : encryption.getLength() / 8;\n    if ((encryption.getVersion() == REVISION_4) || (encryption.getVersion() == REVISION_5)) {\n        // detect whether AES encryption is used. This assumes that the encryption algo is\n        // stored in the PDCryptFilterDictionary\n        // However, crypt filters are used only when V is 4 or 5.\n        PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n        if (stdCryptFilterDictionary != null) {\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            if (COSName.AESV2.equals(cryptFilterMethod)) {\n                dicLength = 128 / 8;\n                setAES(true);\n                if (encryption.getCOSObject().containsKey(COSName.LENGTH)) {\n                    // PDFBOX-5345\n                    int newLength = encryption.getLength() / 8;\n                    if (newLength < dicLength) {\n                        LOG.warn((((\"Using \" + newLength) + \" bytes key length instead of \") + dicLength) + \" in AESV2 encryption?!\");\n                        dicLength = newLength;\n                    }\n                }\n            }\n            if (COSName.AESV3.equals(cryptFilterMethod)) {\n                dicLength = 256 / 8;\n                setAES(true);\n                if (encryption.getCOSObject().containsKey(COSName.LENGTH)) {\n                    // PDFBOX-5345\n                    int newLength = encryption.getLength() / 8;\n                    if (newLength < dicLength) {\n                        LOG.warn((((\"Using \" + newLength) + \" bytes key length instead of \") + dicLength) + \" in AESV3 encryption?!\");\n                        dicLength = newLength;\n                    }\n                }\n            }\n        }\n    }\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    // we need to know whether the meta data was encrypted for password calculation\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null;\n    byte[] oe = null;\n    Charset passwordCharset = StandardCharsets.ISO_8859_1;\n    if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n        passwordCharset = StandardCharsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    if (dicRevision == REVISION_6) {\n        password = SaslPrep.saslPrepQuery(password);// PDFBOX-4155\n\n    }\n    AccessPermission currentAccessPermission;\n    byte[] encryptedKey;\n    byte[] passwordBytes;\n    boolean isOwnerPassword;\n    if (isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n            passwordBytes = password.getBytes(passwordCharset);\n        } else {\n            passwordBytes = getUserPassword234(password.getBytes(passwordCharset), ownerKey, dicRevision, dicLength);\n        }\n        isOwnerPassword = true;\n    } else if (isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {\n        currentAccessPermission = new AccessPermission(dicPermissions);\n        currentAccessPermission.setReadOnly();\n        setCurrentAccessPermission(currentAccessPermission);\n        passwordBytes = password.getBytes(passwordCharset);\n        isOwnerPassword = false;\n    } else {\n        throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n    }\n    encryptedKey = computeEncryptedKey(passwordBytes, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, isOwnerPassword);\n    if ((dicRevision == REVISION_4) && (encryptedKey.length < 16)) {\n        LOG.info(\"PDFBOX-5955: padding RC4 key to length 16\");\n        encryptedKey = Arrays.copyOf(encryptedKey, 16);\n    }\n    setEncryptionKey(encryptedKey);\n    if ((dicRevision == REVISION_5) || (dicRevision == REVISION_6)) {\n        validatePerms(encryption, dicPermissions, encryptMetadata);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.toUnicode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.toUnicode" ],
    "fullMethods" : [ "/**\n * Returns the Unicode character sequence for the given glyph name, or null if there isn't any.\n *\n * @param name\n * \t\tPostScript glyph name\n * @return Unicode character(s), or null.\n */\npublic String toUnicode(String name) {\n    if (name == null) {\n        return null;\n    }\n    String unicode = nameToUnicode.get(name);\n    if (unicode != null) {\n        return unicode;\n    }\n    // separate read/write cache for thread safety\n    unicode = uniNameToUnicodeCache.get(name);\n    if (unicode == null) {\n        // test if we have a suffix and if so remove it\n        if (name.indexOf('.') > 0) {\n            unicode = toUnicode(name.substring(0, name.indexOf('.')));\n        } else if (((name.length() == 7) && name.startsWith(\"uni\")) || ((name.length() == 5) && name.startsWith(\"u\"))) {\n            // test for Unicode name in the format uniXXXX where X is hex\n            int start = (name.length() == 7) ? 3 : 1;\n            try {\n                int codePoint = Integer.parseInt(name.substring(start), 16);\n                if ((codePoint > 0xd7ff) && (codePoint < 0xe000)) {\n                    LOG.warn(\"Unicode character name with disallowed code area: \" + name);\n                } else {\n                    unicode = String.valueOf(((char) (codePoint)));\n                }\n            } catch (NumberFormatException nfe) {\n                LOG.warn(\"Not a number in Unicode character name: \" + name);\n            }\n        }\n        if (unicode != null) {\n            // null value not allowed in ConcurrentHashMap\n            uniNameToUnicodeCache.put(name, unicode);\n        }\n    }\n    return unicode;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.filter.JBIG2Filter.decode",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.filter.JBIG2Filter.decode" ],
    "fullMethods" : [ "@Override\npublic DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException {\n    ImageReader reader = findImageReader(\"JBIG2\", \"jbig2-imageio is not installed\");\n    if (reader.getClass().getName().contains(\"levigo\")) {\n        logLevigoDonated();\n    }\n    int bits = parameters.getInt(COSName.BITS_PER_COMPONENT, 1);\n    COSDictionary params = getDecodeParams(parameters, index);\n    ImageReadParam irp = reader.getDefaultReadParam();\n    irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());\n    irp.setSourceRegion(options.getSourceRegion());\n    options.setFilterSubsampled(true);\n    InputStream source = encoded;\n    if (params != null) {\n        COSStream globals = params.getCOSStream(COSName.JBIG2_GLOBALS);\n        if (globals != null) {\n            source = new SequenceInputStream(globals.createInputStream(), encoded);\n        }\n    }\n    try (ImageInputStream iis = ImageIO.createImageInputStream(source)) {\n        reader.setInput(iis);\n        BufferedImage image;\n        try {\n            image = reader.read(0, irp);\n        } catch (Exception e) {\n            // wrap and rethrow any exceptions\n            throw new IOException(\"Could not read JBIG2 image\", e);\n        }\n        // I am assuming since JBIG2 is always black and white\n        // depending on your renderer this might or might be needed\n        if (image.getColorModel().getPixelSize() != bits) {\n            if (bits != 1) {\n                LOG.warn(\"Attempting to handle a JBIG2 with more than 1-bit depth\");\n            }\n            BufferedImage packedImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);\n            Graphics graphics = packedImage.getGraphics();\n            graphics.drawImage(image, 0, 0, null);\n            graphics.dispose();\n            image = packedImage;\n        }\n        DataBuffer dBuf = image.getData().getDataBuffer();\n        if (dBuf.getDataType() == DataBuffer.TYPE_BYTE) {\n            decoded.write(((DataBufferByte) (dBuf)).getData());\n        } else {\n            throw new IOException(\"Unexpected image buffer type\");\n        }\n    } finally {\n        reader.dispose();\n    }\n    return new DecodeResult(parameters);\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNameTreeNode.getValue" ],
    "fullMethods" : [ "/**\n * The name to retrieve.\n *\n * @param name\n * \t\tThe name in the tree.\n * @return The value of the name in the tree.\n * @throws IOException\n * \t\tIf there is a problem creating the destinations.\n */\npublic T getValue(String name) throws IOException {\n    Map<String, T> names = getNames();\n    if (names != null) {\n        return names.get(name);\n    }\n    List<PDNameTreeNode<T>> kids = getKids();\n    if (kids != null) {\n        for (int i = 0; i < kids.size(); i++) {\n            PDNameTreeNode<T> childNode = kids.get(i);\n            String upperLimit = childNode.getUpperLimit();\n            String lowerLimit = childNode.getLowerLimit();\n            if ((((upperLimit == null) || (lowerLimit == null)) || (upperLimit.compareTo(lowerLimit) < 0)) || ((lowerLimit.compareTo(name) <= 0) && (upperLimit.compareTo(name) >= 0))) {\n                return childNode.getValue(name);\n            }\n        }\n    } else {\n        LOG.warn(\"NameTreeNode does not have \\\"names\\\" nor \\\"kids\\\" objects.\");\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.insertSiblingAfter",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem.insertSiblingAfter", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCountForAddedChild", "org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineNode.updateParentOpenCount" ],
    "fullMethods" : [ "/**\n * Insert a single sibling after this node.\n *\n * @param newSibling\n * \t\tThe item to insert.\n * @throws IllegalArgumentException\n * \t\tif the given sibling node is part of a list\n * \t\t(i.e. if it has a previous or a next sibling)\n */\npublic void insertSiblingAfter(PDOutlineItem newSibling) {\n    requireSingleNode(newSibling);\n    PDOutlineNode parent = getParent();\n    newSibling.setParent(parent);\n    PDOutlineItem next = getNextSibling();\n    setNextSibling(newSibling);\n    newSibling.setPreviousSibling(this);\n    if (next != null) {\n        newSibling.setNextSibling(next);\n        next.setPreviousSibling(newSibling);\n    } else if (parent != null) {\n        getParent().setLastChild(newSibling);\n    }\n    updateParentOpenCountForAddedChild(newSibling);\n}", "void updateParentOpenCountForAddedChild(PDOutlineItem newChild) {\n    int delta = 1;\n    if (newChild.isNodeOpen()) {\n        delta += newChild.getOpenCount();\n    }\n    newChild.updateParentOpenCount(delta);\n}", "/**\n * The count parameter needs to be updated when you add, remove, open or close outline items.\n *\n * @param delta\n * \t\tThe amount to update by.\n */\nvoid updateParentOpenCount(int delta) {\n    PDOutlineNode parent = getParent();\n    if (parent != null) {\n        if (getCOSObject() == parent.getCOSObject()) {\n            // PDFBOX-5939\n            LOG.warn(\"Outline parent points to itself\");\n            return;\n        }\n        if (parent.isNodeOpen()) {\n            parent.setOpenCount(parent.getOpenCount() + delta);\n            parent.updateParentOpenCount(delta);\n        } else {\n            parent.setOpenCount(parent.getOpenCount() - delta);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setXRef",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.XrefTrailerResolver.setXRef" ],
    "fullMethods" : [ "/**\n * Populate XRef HashMap of current XRef object.\n * Will add an Xreftable entry that maps ObjectKeys to byte offsets in the file.\n *\n * @param objKey\n * \t\tThe objkey, with id and gen numbers\n * @param offset\n * \t\tThe byte offset in this file\n */\npublic void setXRef(COSObjectKey objKey, long offset) {\n    if (curXrefTrailerObj == null) {\n        // should not happen...\n        LOG.warn((\"Cannot add XRef entry for '\" + objKey.getNumber()) + \"' because XRef start was not signalled.\");\n        return;\n    }\n    // PDFBOX-3506 check before adding to the map, to avoid entries from the table being\n    // overwritten by obsolete entries in hybrid files (/XRefStm entry)\n    if (!curXrefTrailerObj.xrefTable.containsKey(objKey)) {\n        curXrefTrailerObj.xrefTable.put(objKey, offset);\n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.contentstream.PDFStreamEngine.showTextStrings", "org.apache.pdfbox.contentstream.PDFStreamEngine.showText" ],
    "fullMethods" : [ "/**\n * Called when a string of text with spacing adjustments is to be shown.\n *\n * @param array\n * \t\tarray of encoded text strings and adjustments\n * @throws IOException\n * \t\tif there was an error showing the text\n */\npublic void showTextStrings(COSArray array) throws IOException {\n    PDTextState textState = getGraphicsState().getTextState();\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    PDFont font = textState.getFont();\n    boolean isVertical = false;\n    if (font != null) {\n        isVertical = font.isVertical();\n    }\n    for (COSBase obj : array) {\n        if (obj instanceof COSNumber) {\n            float tj = ((COSNumber) (obj)).floatValue();\n            // calculate the combined displacements\n            float tx;\n            float ty;\n            if (isVertical) {\n                tx = 0;\n                ty = ((-tj) / 1000) * fontSize;\n            } else {\n                tx = (((-tj) / 1000) * fontSize) * horizontalScaling;\n                ty = 0;\n            }\n            applyTextAdjustment(tx, ty);\n        } else if (obj instanceof COSString) {\n            byte[] string = ((COSString) (obj)).getBytes();\n            showText(string);\n        } else if (obj instanceof COSArray) {\n            LOG.error(\"Nested arrays are not allowed in an array for TJ operation: \" + obj);\n        } else {\n            LOG.error(((\"Unknown type \" + obj.getClass().getSimpleName()) + \" in array for TJ operation: \") + obj);\n        }\n    }\n}", "/**\n * Process text from the PDF Stream. You should override this method if you want to\n * perform an action when encoded text is being processed.\n *\n * @param string\n * \t\tthe encoded text\n * @throws IOException\n * \t\tif there is an error processing the string\n */\nprotected void showText(byte[] string) throws IOException {\n    PDGraphicsState state = getGraphicsState();\n    PDTextState textState = state.getTextState();\n    // get the current font\n    PDFont font = textState.getFont();\n    if (font == null) {\n        LOG.warn(\"No current font, will use default\");\n        font = getDefaultFont();\n    }\n    float fontSize = textState.getFontSize();\n    float horizontalScaling = textState.getHorizontalScaling() / 100.0F;\n    float charSpacing = textState.getCharacterSpacing();\n    // put the text state parameters into matrix form\n    Matrix parameters = // 0\n    // 0\n    new Matrix(fontSize * horizontalScaling, 0, 0, fontSize, 0, textState.getRise());// 1\n\n    Matrix textMatrix = state.getTextMatrix();\n    // read the stream until it is empty\n    InputStream in = new ByteArrayInputStream(string);\n    while (in.available() > 0) {\n        // decode a character\n        int before = in.available();\n        int code = font.readCode(in);\n        int codeLength = before - in.available();\n        // Word spacing shall be applied to every occurrence of the single-byte character code\n        // 32 in a string when using a simple font or a composite font that defines code 32 as\n        // a single-byte code.\n        float wordSpacing = 0;\n        if ((codeLength == 1) && (code == 32)) {\n            wordSpacing += textState.getWordSpacing();\n        }\n        // text rendering matrix (text space -> device space)\n        Matrix ctm = state.getCurrentTransformationMatrix();\n        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);\n        // get glyph's position vector if this is vertical text\n        // changes to vertical text should be tested with PDFBOX-2294 and PDFBOX-1422\n        if (font.isVertical()) {\n            // position vector, in text space\n            Vector v = font.getPositionVector(code);\n            // apply the position vector to the horizontal origin to get the vertical origin\n            textRenderingMatrix.translate(v);\n        }\n        // get glyph's horizontal and vertical displacements, in text space\n        Vector w = font.getDisplacement(code);\n        // process the decoded glyph\n        showGlyph(textRenderingMatrix, font, code, w);\n        // calculate the combined displacements\n        float tx;\n        float ty;\n        if (font.isVertical()) {\n            tx = 0;\n            ty = ((w.getY() * fontSize) + charSpacing) + wordSpacing;\n        } else {\n            tx = (((w.getX() * fontSize) + charSpacing) + wordSpacing) * horizontalScaling;\n            ty = 0;\n        }\n        // update the text matrix\n        textMatrix.translate(tx, ty);\n    } \n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDType1CFont.getStringWidth",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDType1CFont.getStringWidth" ],
    "fullMethods" : [ "@Override\npublic float getStringWidth(String string) throws IOException {\n    if (cffFont == null) {\n        LOG.warn(\"No embedded CFF font, returning 0\");\n        return 0;\n    }\n    float width = 0;\n    for (int i = 0; i < string.length(); i++) {\n        int codePoint = string.codePointAt(i);\n        String name = getGlyphList().codePointToName(codePoint);\n        if (!cffFont.hasGlyph(name)) {\n            throw new IllegalArgumentException(String.format(\"U+%04X ('%s') is not available in font %s\", codePoint, name, getName()));\n        }\n        width += cffFont.getType1CharString(name).getWidth();\n    }\n    return width;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getValue",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.common.PDNumberTreeNode.getValue" ],
    "fullMethods" : [ "/**\n * Returns the value corresponding to an index in the number tree.\n *\n * @param index\n * \t\tThe index in the number tree.\n * @return The value corresponding to the index.\n * @throws IOException\n * \t\tIf there is a problem creating the values.\n */\npublic Object getValue(Integer index) throws IOException {\n    Map<Integer, COSObjectable> numbers = getNumbers();\n    if (numbers != null) {\n        return numbers.get(index);\n    }\n    Object retval = null;\n    List<PDNumberTreeNode> kids = getKids();\n    if (kids != null) {\n        for (int i = 0; (i < kids.size()) && (retval == null); i++) {\n            PDNumberTreeNode childNode = kids.get(i);\n            if ((childNode.getLowerLimit().compareTo(index) <= 0) && (childNode.getUpperLimit().compareTo(index) >= 0)) {\n                retval = childNode.getValue(index);\n            }\n        }\n    } else {\n        LOG.warn(\"NumberTreeNode does not have \\\"nums\\\" nor \\\"kids\\\" objects.\");\n    }\n    return retval;\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.PDTrueTypeFont.<init>" ],
    "fullMethods" : [ "/**\n * Creates a new TrueType font from a Font dictionary.\n *\n * @param fontDictionary\n * \t\tThe font dictionary according to the PDF specification.\n * @throws IOException\n * \t\tif the font could not be created\n */\npublic PDTrueTypeFont(COSDictionary fontDictionary) throws IOException {\n    super(fontDictionary);\n    TrueTypeFont ttfFont = null;\n    boolean fontIsDamaged = false;\n    if (getFontDescriptor() != null) {\n        PDFontDescriptor fd = super.getFontDescriptor();\n        PDStream ff2Stream = fd.getFontFile2();\n        if (ff2Stream != null) {\n            RandomAccessRead view = null;\n            try {\n                view = ff2Stream.getCOSObject().createView();\n                // embedded\n                TTFParser ttfParser = getParser(view, true);\n                ttfFont = ttfParser.parse(view);\n                ttfFont.close();\n            } catch (IOException e) {\n                LOG.warn(\"Could not read embedded TTF for font \" + getBaseFont(), e);\n                fontIsDamaged = true;\n                IOUtils.closeQuietly(view);\n            }\n        }\n    }\n    isEmbedded = ttfFont != null;\n    isDamaged = fontIsDamaged;\n    // substitute\n    if (ttfFont == null) {\n        FontMapping<TrueTypeFont> mapping = FontMappers.instance().getTrueTypeFont(getBaseFont(), getFontDescriptor());\n        ttfFont = mapping.getFont();\n        if (mapping.isFallback()) {\n            LOG.warn(((\"Using fallback font \" + ttfFont) + \" for \") + getBaseFont());\n        }\n    }\n    otf = ((ttfFont instanceof OpenTypeFont) && ((OpenTypeFont) (ttfFont)).isSupportedOTF()) ? ((OpenTypeFont) (ttfFont)) : null;\n    ttf = ttfFont;\n    readEncoding();\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<init>",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.<init>", "org.apache.pdfbox.pdmodel.font.encoding.GlyphList.loadList" ],
    "fullMethods" : [ "/**\n * Creates a new GlyphList from a glyph list file.\n *\n * @param numberOfEntries\n * \t\tnumber of expected values used to preallocate the correct amount of memory\n * @param input\n * \t\tglyph list in Adobe format\n * @throws IOException\n * \t\tif the glyph list could not be read\n */\npublic GlyphList(InputStream input, int numberOfEntries) throws IOException {\n    nameToUnicode = new HashMap<>(numberOfEntries);\n    unicodeToName = new HashMap<>(numberOfEntries);\n    loadList(input);\n}", "private void loadList(InputStream input) throws IOException {\n    try (BufferedReader in = new BufferedReader(new InputStreamReader(input, StandardCharsets.ISO_8859_1))) {\n        while (in.ready()) {\n            String line = in.readLine();\n            if ((line != null) && (!line.startsWith(\"#\"))) {\n                String[] parts = line.split(\";\");\n                if (parts.length < 2) {\n                    throw new IOException(\"Invalid glyph list entry: \" + line);\n                }\n                String name = parts[0];\n                String[] unicodeList = parts[1].split(\" \");\n                int[] codePoints = new int[unicodeList.length];\n                int index = 0;\n                for (String hex : unicodeList) {\n                    codePoints[index++] = Integer.parseInt(hex, 16);\n                }\n                String string = new String(codePoints, 0, codePoints.length);\n                // forward mapping\n                String oldMapping = nameToUnicode.put(name, string);\n                if (oldMapping != null) {\n                    LOG.warn(((((\"duplicate value for \" + name) + \" -> \") + parts[1]) + \" \") + nameToUnicode.get(name));\n                }\n                // reverse mapping\n                // PDFBOX-3884: take the various standard encodings as canonical,\n                // e.g. tilde over ilde\n                final boolean forceOverride = (((WinAnsiEncoding.INSTANCE.contains(name) || MacRomanEncoding.INSTANCE.contains(name)) || MacExpertEncoding.INSTANCE.contains(name)) || SymbolEncoding.INSTANCE.contains(name)) || ZapfDingbatsEncoding.INSTANCE.contains(name);\n                if (forceOverride) {\n                    unicodeToName.put(string, name);\n                } else {\n                    unicodeToName.putIfAbsent(string, name);\n                }\n            }\n        } \n    }\n}" ]
  }, {
    "entryPoint" : "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken",
    "thirdPartyMethod" : "org.apache.commons.logging.Log.warn",
    "thirdPartyPackage" : "org.apache.commons.logging",
    "path" : [ "org.apache.pdfbox.pdfparser.PDFStreamParser.parseNextToken" ],
    "fullMethods" : [ "/**\n * This will parse the next token in the stream.\n *\n * @return The next token in the stream or null if there are no more tokens in the stream.\n * @throws IOException\n * \t\tIf an io error occurs while parsing the stream.\n */\npublic Object parseNextToken() throws IOException {\n    if (source.isClosed()) {\n        return null;\n    }\n    skipSpaces();\n    if (source.isEOF()) {\n        close();\n        return null;\n    }\n    char c = ((char) (source.peek()));\n    switch (c) {\n        case '<' :\n            // pull off first left bracket\n            source.read();\n            // check for second left bracket\n            c = ((char) (source.peek()));\n            // put back first bracket\n            source.rewind(1);\n            if (c == '<') {\n                try {\n                    return parseCOSDictionary(true);\n                } catch (IOException exception) {\n                    LOG.warn(\"Stop reading invalid dictionary from content stream at offset \" + source.getPosition());\n                    close();\n                    return null;\n                }\n            } else {\n                return parseCOSString();\n            }\n        case '[' :\n            // array\n            try {\n                return parseCOSArray();\n            } catch (IOException exception) {\n                LOG.warn(\"Stop reading invalid array from content stream at offset \" + source.getPosition());\n                close();\n                return null;\n            }\n        case '(' :\n            // string\n            return parseCOSString();\n        case '/' :\n            // name\n            return parseCOSName();\n        case 'n' :\n            // null\n            String nullString = readString();\n            if (nullString.equals(\"null\")) {\n                return COSNull.NULL;\n            } else {\n                return Operator.getOperator(nullString);\n            }\n        case 't' :\n        case 'f' :\n            String next = readString();\n            if (next.equals(\"true\")) {\n                return COSBoolean.TRUE;\n            } else if (next.equals(\"false\")) {\n                return COSBoolean.FALSE;\n            } else {\n                return Operator.getOperator(next);\n            }\n        case '0' :\n        case '1' :\n        case '2' :\n        case '3' :\n        case '4' :\n        case '5' :\n        case '6' :\n        case '7' :\n        case '8' :\n        case '9' :\n        case '-' :\n        case '+' :\n        case '.' :\n            /* We will be filling buf with the rest of the number.  Only\n            allow 1 \".\" and \"-\" and \"+\" at start of number.\n             */\n            StringBuilder buf = new StringBuilder();\n            buf.append(c);\n            source.read();\n            // Ignore double negative (this is consistent with Adobe Reader)\n            if ((c == '-') && (source.peek() == c)) {\n                source.read();\n            }\n            boolean dotNotRead = c != '.';\n            while ((Character.isDigit(c = ((char) (source.peek()))) || (dotNotRead && (c == '.'))) || (c == '-')) {\n                if (c != '-') {\n                    // PDFBOX-4064: ignore \"-\" in the middle of a number\n                    buf.append(c);\n                }\n                source.read();\n                if (dotNotRead && (c == '.')) {\n                    dotNotRead = false;\n                }\n            } \n            String s = buf.toString();\n            if (\"+\".equals(s)) {\n                // PDFBOX-5906\n                LOG.warn(\"isolated '+' is ignored\");\n                return COSNull.NULL;\n            }\n            return COSNumber.get(s);\n        case 'B' :\n            String nextOperator = readString();\n            Operator beginImageOP = Operator.getOperator(nextOperator);\n            if (nextOperator.equals(OperatorName.BEGIN_INLINE_IMAGE)) {\n                inlineImageDepth++;\n                if (inlineImageDepth > 1) {\n                    // PDFBOX-6038\n                    throw new IOException(((((\"Nested '\" + OperatorName.BEGIN_INLINE_IMAGE) + \"' operator not allowed at offset \") + source.getPosition()) + \", first: \") + inlineOffset);\n                } else {\n                    inlineOffset = source.getPosition();\n                }\n                COSDictionary imageParams = new COSDictionary();\n                beginImageOP.setImageParameters(imageParams);\n                Object nextToken = null;\n                while ((nextToken = parseNextToken()) instanceof COSName) {\n                    Object value = parseNextToken();\n                    if (!(value instanceof COSBase)) {\n                        LOG.warn(\"Unexpected token in inline image dictionary at offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                        break;\n                    }\n                    imageParams.setItem(((COSName) (nextToken)), ((COSBase) (value)));\n                } \n                // final token will be the image data, maybe??\n                if (nextToken instanceof Operator) {\n                    Operator imageData = ((Operator) (nextToken));\n                    if ((imageData.getImageData() == null) || (imageData.getImageData().length == 0)) {\n                        LOG.warn(\"empty inline image at stream offset \" + (source.isClosed() ? \"EOF\" : source.getPosition()));\n                    }\n                    beginImageOP.setImageData(imageData.getImageData());\n                    inlineImageDepth--;\n                } else {\n                    LOG.warn((((((\"nextToken \" + nextToken) + \" at position \") + (source.isClosed() ? \"EOF\" : source.getPosition())) + \", expected \") + OperatorName.BEGIN_INLINE_IMAGE_DATA) + \"?!\");\n                }\n            }\n            return beginImageOP;\n        case 'I' :\n            // Special case for ID operator\n            String id = Character.toString(((char) (source.read()))) + ((char) (source.read()));\n            if (!id.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA)) {\n                long currentPosition = source.getPosition();\n                close();\n                throw new IOException(((\"Error: Expected operator 'ID' actual='\" + id) + \"' at stream offset \") + currentPosition);\n            }\n            ByteArrayOutputStream imageData = new ByteArrayOutputStream();\n            // skip one line break (CR, LF or CRLF) or any one-byte whitespace\n            if ((!skipLinebreak()) && isWhitespace()) {\n                // pull off the whitespace character\n                source.read();\n            }\n            int lastByte = source.read();\n            int currentByte = source.read();\n            // PDF spec is kinda unclear about this. Should a whitespace\n            // always appear before EI? Not sure, so that we just read\n            // until EI<whitespace>.\n            // Be aware not all kind of whitespaces are allowed here. see PDFBOX-1561\n            while ((!((((lastByte == 'E') && (currentByte == 'I')) && hasNextSpaceOrReturn()) && hasNoFollowingBinData())) && (!isEOF())) {\n                imageData.write(lastByte);\n                lastByte = currentByte;\n                currentByte = source.read();\n            } \n            // the EI operator isn't unread, as it won't be processed anyway\n            Operator beginImageDataOP = Operator.getOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);\n            // save the image data to the operator, so that it can be accessed later\n            beginImageDataOP.setImageData(imageData.toByteArray());\n            return beginImageDataOP;\n        case ']' :\n            // some ']' around without its previous '['\n            // this means a PDF is somewhat corrupt but we will continue to parse.\n            source.read();\n            // must be a better solution than null...\n            return COSNull.NULL;\n        default :\n            // we must be an operator\n            String operator = readOperator().trim();\n            if (operator.length() > 0) {\n                return Operator.getOperator(operator);\n            }\n    }\n    return null;\n}" ]
  } ]
}